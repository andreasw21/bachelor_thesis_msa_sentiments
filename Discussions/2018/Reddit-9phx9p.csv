ID;Source;Creation Date;Content;Sentiment
9phx9p;Reddit;2018-10-19;Title:Microservices Are Something You Grow Into, Not Begin With, Content: https://nickjanetakis.com/blog/microservices-are-something-you-grow-into-not-begin-with;0

e825k7q;Reddit;2018-10-19 15:14:12;this assumes you don't know about microservice architectures before you begin. once you know how to make good judgment calls about architectural boundaries within a given technique or domain or both you can certainly begin with that technique.;0
e82h1jv;Reddit;2018-10-19 18:06:09;microservices solve an organizational problem not a technical one. if you don't have the organizational problem that they are meant to solve at scale you may find yourself crushed under the added complexity. you move to microservices because you are already splitting your application responsibilities up among multiple isolated teams and doing that in a monolith becomes a mess. so you breakup and isolate the problem domains into microservices to establish clear boundaries of responsibility. 90 of all articles comments decrying microservices as a fad etc. always fail to understand this or have only seen them applied in organizations without these problems and so think they aren't worth the cost. the extra costs of microservices balance against the challenges of managing a monolith in this organizational structure. when the balance tips it absolutely makes sense.;0
e8279xt;Reddit;2018-10-19 15:44:02;one of the biggest problems is monitoring. hell no. monitoring is easy compared to the actual issues you run into. logging monitoring and tracing are things you definitely need when running a microservice framework but these are all solved problems. elk or similar for logging prometheus pluggable in most frameworks for monitoring and tracing open tracing pluggable in most frameworks are freely available. the real problems with microservices is that that gravitate automatically towards becoming monoliths with all the drawbacks of monoliths hard to deploy and none of the benefits easy transaction guarantees reporting. done well microservices are a great way to decouple modules of your system making it easier to iterate but doing it well is incredibly hard. you start with service a who needs something from service b so they just call an api. service b needs something from c you just call an api. easy. c needs something from a you just all it. easy. only you just created a circular dependency making the system harder to deploy do i do a first or b or c?. if you end up doing what i describe above there's two options you recognise you're moving into the wrong direction and fix it by layering your architecture in the same way you'd layer a monolith by going for an event driven approach or pretend nothing is wrong because you're 'doing microservices' and end up in the same shit the majority of 'microservice architectures' end up with. all architecture of complex systems is hard. a microservice architecture is harder than a monolithic architecture. you just trade ease of design for easy of deployment and iteration times. whether that trade off is worth it really depends on the quality of your devs and architects.;0
e827rzq;Reddit;2018-10-19 15:52:07;i am going to have to disagree. serviceoriented architecture or more specifically microservices need to be developed from the get go in order to develop a maintainable system. switching over to it later is such a hassle and requires a ton of time.;0
e82mv6s;Reddit;2018-10-19 19:25:39;i think a rule worth sticking to a good architect leaves as many open doors as he can w his design. put another way when you make a design choice make the choice that leaves as many other choices open as possible. then as things change on the ground you can easily adapt by making choices that make the most sense given what you've learned. making heavily opinionated choices early on microservices application frameworks etc can work out well but often times leaves you w a very brittle application. this is my experience.;0
e82y2zc;Reddit;2018-10-19 22:01:01;everyone will think yeah but i'm different. microservices ahoy!;0
e831g4f;Reddit;2018-10-19 22:51:16;there is no microservices vs. monoliths issue. any wellthoughtout architecture will be a superposition of both of these things and going all in with one or the other doesn't make much sense. microservices is kind of like how you would abstract your code in a project into various modules expect you are abstracting actors in your network. sometimes you need to abstract out a component other times you don't. it depends on your exact usecase.;0
e83m6kc;Reddit;2018-10-20 04:53:48;i love this article for one e that helps quantify when you might want a micro service vs not but lets face it. you probably dont have 1000 developers working on a massive project with 10 years of history. many companies don't. we do. and if only we had a mere ten years of history. the important thing is to reduce the number of people who have to coordinate in order to make changes. and that's a tricky balance because at small scales monoliths are actually an optimization. i've seen some of our teams try to divide their work into 5 or more micro services all of which are under active development at all times. there's an overhead to each separate service you deploy. you can work to reduce the overhead but the overhead is there. if 8 people on a team are maintaining 5 microservices that's imposing a high overhead cost. if the team just talked together a bit more a monolith wouldn't have problems. and if it did maybe splitting it into two would make sense. this is related to the fact that it's often hard to determine the correct boundaries up front. if a change in requirements requires changes to five separate micro services that's not the correct division. it's hard to predict that i've seen complex designs go into production because they are abstract enough to suit all future needs and each future change actually required substantial design changes. so i agree with the article let experience guide the separation. don't split things until you start feeling pain.;0
e82drz7;Reddit;2018-10-19 17:20:18;microservices are a fad. anyone who went through the soa fad saw this coming. if an architect or a boss wants you to play with microservices you do so and put it on your resume to play the game. if you're doing your own project that you want to get done you do whatever works until it doesn't work then adapt. same as it's always been;0
e842ylg;Reddit;2018-10-20 12:49:57;implying that microservices are the result of some sort of design phase. in most shops they are cargo cult spaghetti code making calls across network boundaries and designed by devs with no understanding of the tradeoffs involved most microservice architectures are rife with race conditions and consistency problems and the reigning attitude is consistency is hard. let's go shopping. for small to medium projects i would take poorly designed monolith over poorly designed microservice architecture any day.;0
e827frq;Reddit;2018-10-19 15:46:36;to add to this it's possible to dismantle a monolith into microservices. hopefully you're using the strangler patternhttpsdocs.microsoft.comenusazurearchitecturepatternsstrangler instead of pretending a complete big bang rewrite is feasible. but even if you pull this off it's hard it's a very hard sell to the business. you will spend a lot of time rewriting as opposed to adding value.;0
e8415kz;Reddit;2018-10-20 11:41:31;post author here. the problem is you often can't set good architectural boundaries from the start because you don't know know the domain well enough on day 1. so with microservices from the start now you end up in a mess where a lot of your time is spent shuffling around boilerplate and changing your abstractions is very hard. day 1 which is usually the first few months of dev time is all about feeling things out. iteration should be fast and minimal effort. you work your way towards good abstractions based on experience instead of sitting there in your ivory tower trying to theory craft a solution before you even write 1 line of code.;0
e830vgd;Reddit;2018-10-19 22:42:41;microservices solve an organizational problem not a technical one. x200b i'm on a small 3 person team and disagree with this. we split job workers out into separate services from the api and it just makes sense. if the cpu spikes on a job server we know exactly what's taking up all the cpu time. if we need to scale up the job worker we can do that independently from the api servers. if one of the packages we're using has a memory leak that only affects that micro service instead of everything. you mentioned in another comment some of the drawbacks with microservices like figuring out how to do centralized logging and deployments. a paid service like datadog or loggly makes centralized logging so easy. if you've containerized one microservice and figured out how to deploy it it's simply a matter of copypasting the dockerfile add some env vars and a few more clicks to set it up in your favorite ci service circleci. i can get a new microservice up and running in an hour or two. i do agree that orchestration of deployments can be tricky but there are tools to help with that too.;0
e84o4t2;Reddit;2018-10-20 19:36:39;if i could give this 1000 i could microservices are solving an organization problem which is often when your company gets too large. this is why were i work currently zalando which has 3k developers iirc the company decided to move to microservices. the monoliths which we left behind were already approaching the million line source code barrier as well as compiling taking hours deployments happening once every 2 weeks and in some cases its gotten so bad that people can't even run the monolith locally.;0
e830ym5;Reddit;2018-10-19 22:43:59;i'd even go so far as to say that monitoring may be an advantage of microservices. yes there is more to do but because they are more granular there is more opportunity to do useful monitoring. let's say you're making a redditlike site. if the main page is slow and you have a monolithic architecture you don't necessarily know why. imagine instead you have a userprofileservice sortedarticlelistservice recentlyviewedlinksservice inboxservice and adservice. if you have separate monitoring set up for each one you can look at that and say oh look the time it takes for adservice to serve requests just rose from 50 milliseconds to 2500 milliseconds. you already have a general idea of where the problem is. on larger projects you can page the right team directly. on smaller ones the page has a more informative subject line. it's not just limited to specificity of performance problems. you can also be more proactive. suppose you have a monolithic architecture and a new release causes page loads to go from 1000 ms to 1100 ms. that might be a small enough increase that it gets ignored. maybe it is just several things that all add up and there's no easy way to do anything about it. but if adservice had always been at a steady 50 ms and jumps to 150 ms and it accounts for all the performance degradation then it's more obvious that something is not right. similar things apply for crashes excessive garbage collection or ram usage log storage space etc. with almost any value you might monitor it's helpful to have an extra parameter that gives you a rough idea of what part of the system it applies to.;0
e8404pz;Reddit;2018-10-20 11:02:38;to add to your point a lot of people think that making a distributed system is the same as making microservices. in reality microservices is all about loosely couple services. putting the network in the middle of your monolith will just create a distributed monolith the worse of both worlds.;0
e82q40u;Reddit;2018-10-19 20:09:44;you start with service a who needs something from service b so they just call an api. service b needs something from c you just call an api. easy. c needs something from a you just all it. easy. only you just created a circular dependency making the system harder to deploy do i do a first or b or c?. then you identify d which is a common base thing that a and b rely on that does not rely on a b or c. factor d into a new service point abc at it no more circle. then for extra credit you create a chart of your services arranged left to right and institute a rule that every service may only depend on things to its right. now you've established an architectural rule that eliminates cycles. for even more fun you define where your 'public' endpoints are and possibly write a boundary service that is the only allowed poc for your constellation. this part is useful if you're a small to medium sized team in a large org you've insulated everyone else from your internals and allowed yourself to refactor things without notifying everyone and their brother. this also works well if you start with m which is a monolithic thing containing abc and then split out sections of the code to microservices as needs arise. according to a lot of people in here m is faster to write in the first place.;0
e82bqid;Reddit;2018-10-19 16:51:16;the amount of cases where you can realize from the get go that you'll actually have any benefits whatsoever by using microservices is astoundingly low.;0
e82ggru;Reddit;2018-10-19 17:58:05;microservices are a fad. developers who say this are a fad. microservices are an architectural choice you can make. and like most choices there are drawbacks.;0
e83gltz;Reddit;2018-10-20 03:10:02;im sure for 99 of the implementations of microservices you are correct. i just wish the front end developer at work would shut up about them. yes you want to write some node.js thats great go apply for a job using mean stack and stop busting my arse.;0
e82arz1;Reddit;2018-10-19 16:37:29;i worked on a project where we switched everything over to microservices. it was nice to know that you could just spin up another instance when needed. but... we had 2 maybe 3 clients. we would never have to run more than one instance ever and everything ran on one server in the end anyway. moving everything over to the microservices took such a long time we had problems with dtos and automatic conversion which took a big chunk of processing time. there were so many communication and synchronization issues between the services i had to fix! i honestly think we could've finished a month earlier without the microservices and it would've worked just as well.;0
e85yw17;Reddit;2018-10-21 09:24:49;design obviously isn't bad. it's just that wrong design decisions can produce so much complexity that the end result is worse than basically having no design thought at all. all software production can be divided to essential complexity which is the fundamental stuff the program has to do in order to solve the task it's given and accidental complexity which is everything else. e.g. figuring out how to orchestrate your microservice deployments would fall into accidental complexity compared to having to just e.g. ship a single monolithic service if that'd be capable of doing all the same things. similarly running a service on a cluster is much harder than running it on a single machine so you'd want to avoid having to have a cluster of machines as long as possible. doing little to no futureproofing is also pretty smart because the future you're preparing for might never arrive. good software design or architecture i'd argue is mostly about minimizing the accidental complexity for as long as possible. however you will need some forethought about what things will look like down the road so that you can also avoid hitting design dead ends that would lead to expensive refactoring later. good design or architecture fundamentally depends on situation and there's no particular silver bullet. still i'd argue that at first you probably won't go wrong if you just kiss. i personally mostly do things with raw sql and httpjson endpoints that spew out exactly the data some particular view needs. you can imagine how boring my code is like it gets some parameters off http request fires off a single sql that can be tens of lines long then maps that automatically to some class that represents the fields returned via sql and that gets converted back to json. sometimes i even ask the database to convert directly to json and just write that json string out without even looking at it in server side code. mutations are similarly endpoints that exist to serve just that specific view they do all operations the button user pressed implies and it all gets done within a single http call and single transaction in a single database. it's basically designdictatedbyfunction approach but it's simple and predictable as heck so i find that it's easy to change and gets things done with minimum fuss.;0
e82ys41;Reddit;2018-10-19 22:11:16;a well made monolithic architecture i think this is possible but people often overlook that it requires somewhat more discipline. with microservices at least along whatever boundaries you've drawn things tend to stay more decoupled because coupling them is an uphill battle. you've built certain walls and it takes work to get over or through those walls so the path of least resistance is to do it some other way. sometimes a clean decoupled solution does exist and the existence of the walls pushes you toward finding it where you otherwise wouldn't have which is an obvious win. other times you may end up pushing back on a requirement on the grounds that microservices make it infeasible. but either way the general trend is toward keeping things separate because microservices change the economics. with monolithic architecture the same walls don't exist and it is more feasible to make connections between any two random things. that doesn't mean you have to. if maintaining a clean decoupled architecture is important to you you can still just make the choices not to connect pieces that shouldn't be connected even though there is no wall preventing you. and you will if you are willing and able to prioritize that. where this gets interesting is in teams. imho it's relatively easy to be a disciplined individual but it's harder to keep a team on track with clean code. either someone will not grasp the vision or someone won't care and it doesn't take much of this for things to drift gradually toward a messier architecture. the walls provide rigidity to the overall structure and resist this somewhat. since what i'm saying here nearly amounts to advocating for microservices i should be fair and note that if your team has too little discipline then with a microservices approach what you're going to end up with is a system that does have the walls but has no other structure. instead of one monolithic big ball of mud you'll end up with a set of n big balls of mud connected by welldefined interfaces. so it's not a silver bullet or anything.;0
e84hd7a;Reddit;2018-10-20 17:51:17;day 1 which is usually the first few months of dev time is all about feeling things out. iteration should be fast and minimal effort. x200b no disagreement there. x200b the problem is you often can't set good architectural boundaries from the start because you don't know know the domain well enough on day 1 x200b domain boundaries and architectural boundaries are different. depending on the industry and the maturity of the company it may take years to get domain boundaries right. you can't wait that long to get a good architecture. x200b so with microservices from the start now you end up in a mess where a lot of your time is spent shuffling around boilerplate and changing your abstractions is very hard. x200b this is where the problem lies emphasis mine x200b the problem isn't microservices. the problem is mvc and rest. mvc is an architecture. choosing the boundaries between your models is not an architectural decision it's a domain decision. if you're conflating the two you're going to have a bad time. the question isn't how to create the best abstractions for your domain using mvc the question is whether mvc is the correct abstraction for your application architecture and maybe more to the point whether the particular mvc framework you have chosen makes the right architectural decisions for you. applying the rest style necessitates that you have a representation of state of discrete entities. mvc necessitates that you have a model comprising discrete entities. if as you say on day 1 you don't know what the real boundaries are between entities in your domain why would you choose mvc and rest? and more to the point why would you blame a microservices architecture for your boilerplate shuffling and abstraction refactoring when what a microservices architecture provides you is smaller doses of complexity and decoupled execution? x200b during my day 1s i make architectural decisions without real understanding of the data domains. those architectural decisions tend to be about separating the user experience from the system defining ux state as separate and distinct from domain state establishing cqrs as the api style by defining usercallstoaction as the building block of the api do x. interrogate y. deciding on static frontend packages instead of streaming the frontend on demand ensuring layers don't leak by ensuring the core business logic can be run in multiple contexts http cli service worker avoiding early and complex virtualization strategies and ensuring seamless integration of packages written in multiple languages. the goal is rapid iteration that decouples architectural decisions from domain design decisions. moving between contexts encapsulating different data elements branching execution based on data and a host of other things that occur as your code base matures depends entirely on whether you've made good architectural decisions that keep your domain boundaries separate from your architectural boundaries. x200b granted i do a lot of faas so i have the advantage of a decoupled system right from the start but i believe many of the architectural decisions i make in faas can be applied in more traditional hah microservice architectures. x200b so yeah i guess what i'm saying is 1. don't conflate architecture with domain design 2. mvc and rest do more harm then good when you're trying to iterate fast and decoupled by nearly guaranteeing that your domain abstractions cross architectural boundaries and leak. 3. most frameworks make the architectural decisions for you so if you don't fully understand the way the framework is designed you're not really making architectural decisions you're making rad decisions. 4. if you're moving around boilerplate you've missed a major aspect of your architecture somewhere i'm sure there's more to say but i've said more than is polite already.;0
e82jlki;Reddit;2018-10-19 18:41:24;i think its fair to point out that the driver of both the organizational structure and the problems you mention is the scale of your application and user base. the larger that is the more these other problems pop up that you just don't have at smaller scales and that is where you get things like 1. who owns this or knows how this part works organizational restructuring into multiple integrated teams with isolated team leads pms qas etc. 2. working in a single project with multiple teams requires a dedicated team of people just handling servers and deployments dedicated dev ops. 3. complexity of deploys need for management over contracts between teams need to scale different parts of the system differently can't run the monolith on a single server anymore because its so big etc. microservices. 4. whole set of microservice problems like centralized logging ci integration versioning a host of other solutions the problem you usually see is people with teams of 10 20 people and one or two teams trying microservices and being crushed by the overhead of the extra management pieces don't have dedicated dev ops teams and just generally not being big enough to really have the problems that microservices solve and then writing it off as too complex because the scales haven't tipped yet for them. that doesn't mean you should start every project as microservices to start with because we'll get that big eventually and yes the transition to the architecture is time consuming expensive and complicated when you do get there... you really do have to have an organizational structure already that will support the added complexity microservices introduce but you do it because those are outweighed by the other problems you have by not doing it.;0
e836x0u;Reddit;2018-10-20 00:19:56;neat. hope that keeps scaling with you and your team. splitting off workers isn't really that out of the ordinary even for monoliths. its the cross cutting concerns and the number of nodes in your api graph that'll kill you in trying to manage everything... i'll recommend that you try and avoid going too wide with the stuff you split off right now though try and keep as much in the monolith as you can for now because if you go wide with the number of apps you have to manage the complexity and amount of time you have to spend managing things really does go up quickly. starting with the right tooling around ci is a good idea and will scale with you. if you can avoid 100 uptime promises until you scale out more thats a good idea too as deployment complexity will skyrocket as soon as thats a requirement. deployment as a distributed monolith where you deploy everything at once can work rather well to a certain scale but of course isn't what you want long term but will help sidestep the nontrivial issues of versioning bluegreen deployments contract deprecations schema transformations etc. i'm not trying to scare you sounds like you have a fairly normal start up going for now but going wide too fast and trying to adopt more of the microservices maturity model than you can feasibly support at your current scale are usually where you get these people writing blog posts about how we failed at microservices.;0
e82ht1p;Reddit;2018-10-19 18:16:40;you don't actually have to use http. you can do microservices with actual event sourcing like queuing. just saying.;0
e82hakj;Reddit;2018-10-19 18:09:36;what are you talking about? of course everything in architecture has good and bad. there were reasons it was put out into the world and got some hype. it has actively done good for some organizations projects. but if you don't think microservices arewere a fad you missed the last half decade in technologies bending over backwards to claim 'microservice' features gartner white papers and numerous blog posts and articles claiming the one true way to implement microservices.;0
e82i41k;Reddit;2018-10-19 18:20:54;premature optimization is the root of all evil you don't know what your bottlenecks will actually be until they've actually become bottlenecks. this is probably the most mised e in all of programming history. this e should not be taking out of context we should forget about small efficiencies say about 97 of the time premature optimization is the root of all evil. yet we should not pass up our opportunities in that critical 3. and it's important to understand he is talking about function level performance optimisations. not architectural decisions. it's a completely different subject. if you know that your are going to be creating a large complex system where you will have 10 teams working on it going for microservices from the start is in no way a wrong decision.;0
e83k624;Reddit;2018-10-20 04:16:14;if you have both split a monolith and combined microservices you will quickly realize that going too wide is much better than ending up with a monolith. most of the problems you mentioned have already be solved because of how popular soa and microservices have become.;0
e837duo;Reddit;2018-10-20 00:27:40;what makes you think those things don't exist in microservices? in microservices you replace spaghetti code with spaghetti code calls to deprecated and obsolete apis unknown webs of network calls that end up being way slower than other rpc mechanisms or library calls debugging weirdass networks issues having way more devops work to alter cluster configurations without accidentally bringing everything down. legacy code exists in every possible configuration and is mostly a matter of not paying for maintenance and refactorings. what you claim is a prime example of silver bullet thinking. microservices are useful for very specific purposes but they're not a better development practice by themselves at all.;0
e82hog2;Reddit;2018-10-19 18:14:56;a fad is something that is short lived. something that goes away. which is not what microservices are. you are even saying so yourself it has actively done good for some organizations projects. microservices are not some kind of golden hammer. but going in the opposite direction of microservices are the one true way is claiming microservices are a fad and is just as wrong. the truth is in the middle.;0
e845her;Reddit;2018-10-20 14:09:38;yeah i just tell the front end developer to shut up... no microservices for me... yay. the monkeys struggle to write a rest api as it is... god help them when i quit.;0
e82pdus;Reddit;2018-10-19 19:59:50;10 teams working on it? where is that? i think your advice about microservices applies to larger orgs but not to small startups.;0
e82p91w;Reddit;2018-10-19 19:58:02;so you're saying it's hard to split up a microservice but it's easy to split up a monolith? sincere question because that's what it sounds like. by the time your organisation becomes so large that splitting up a monolith is needed it will be too late to actually go and split it up within a few weeks. in a previous project we split up a microservice that needed splitting up. it was tiny compared to a monolith but it already took us almost two weeks.;0
e82dh8l;Reddit;2018-10-19 17:16:08;you can write spaghetti microservices too yes. that's literally what i described in the post you responded to i never said that microservices prevent you from creating a bad architecture. in some regards it makes it easier. what i have seen in monoliths is that often when there are problems is causes the entire monolith to not be releasable. with microservices it's easier to have the 'good' parts still deployable because it's much harder to cross boundaries where you should not. neither monoliths nor microservices are good or bad by design. but scaling a monolith to a large organisation with 10 teams working on the same 'system' while still deploying it every 2 weeks is very hard. if you on the other hand work with a team of 4 devs on a single application it's utter nonsense to create a microservice architecture.;0
e82ijaj;Reddit;2018-10-19 18:26:43;yeah it's a bit of a trick question. sorry. because you're not wrong but i've seen projects where they fell into the trap of creating one big orchestration service. now you have another monolith the bff patternhttpsnordicapis.combuildingabackendforfrontendshimforyourmicroservices is quite interesting here they are small orchestrators that live and die with the feature they orchestrate. they're tiny one of the few good applications for serverless imho. having a 'logic' or 'orchestration' layer is what i meant with the by layering your architecture in the same way you'd layer a monolith bit in my post. so i didn't miss it i just didn't mention it specifically.;0
e83abus;Reddit;2018-10-20 01:17:22;what makes you think those things don't exist in microservices? what makes you think i claimed those things don't exist? but they sure as hell as a lot simpler to do when you have things that exist independently from each other. in microservices you replace spaghetti code with spaghetti code calls to deprecated and obsolete apis first of all i'm not talking about spaghetti code. second of all your last bit is quite amusing... because calls to deprecated and obsolete apis is a strength that allows you to do zero down time as you version your apis so that older servers will still work as you iteratively upgrade each server one by one. unknown webs of network calls that end up being way slower than other rpc mechanisms or library calls you know you can create microservices with any rpc mechanism right? or did you forget what the r stands for? and speed is something i can tweak being able to more easily implement the features that i want is a much more important thing at design phase. debugging weirdass networks issues you're gonna be debugging weird ass network issues no matter what. having way more devops work to alter cluster configurations without accidentally bringing everything down. as opposed to the trivial devops work involved in making a monolith into something that's zdt durable and scalable? being able to configure services independently of each other is absolutely a benefit of microservices. if you make a mistake and bring down the service in a monolith you by definition bring everything down. if your microservice is actually more likely to bring everything down then there really isn't anything i can say other than... get better. legacy code exists in every possible configuration and is mostly a matter of not paying for maintenance and refactorings. there is a difference between legacy code in my codebase versus legacy code in another codebase. i assume you know what that difference is. what you claim is a prime example of silver bullet thinking. microservices are useful for very specific purposes but they're not a better development practice by themselves at all. i never claimed anything about a silver bullet. i'm claiming every project i've worked on needed features that are more easily done with microservices. you seem to be under the impression that zero down time scalability of nodes durability are mere attributes of better development practice. no they're metricsfeatures of your service that are much more easily improved with microservices than monoliths. i have no idea what you think a tirade on spaghetti code or whatever is relevant to that.;0
e82iwvt;Reddit;2018-10-19 18:31:57;our definitions are differing then. i'd call soa a fad. it had lots of consulting dollars thrown at it and ran its course. businesses are still getting rto on that today but nothing like it was. microservices are similar. lots of hype and consulting dollars. i don't personally believe it'll be the thing most businesses are striving for in their architecture 35 years from now.;0
e82nxp5;Reddit;2018-10-19 19:40:11;that's a nice e but it applies to systems not architectural styles. microservice architectures generally start simple too.;0
e82plkf;Reddit;2018-10-19 20:02:46;the person i responded to was making a general remark not specific to small or large companies and that's what i replied to. i went more in depth in another commenthttpsold.reddit.comrprogrammingcomments9phx9pmicroservicesaresomethingyougrowintonote8279xt i'm definitely not saying a small startup should go for microservices. people abusing that e is just a bit of a pet peeve of mine. it gets thrown around a lot often by people who don't want to bother actually designing stuff beforehand.;0
e83iwhj;Reddit;2018-10-20 03:52:34;small startups can benefit from microservices as well. nothing like having to scale your entire application when you could just have to scale that one small microservice.;0
e82qbjg;Reddit;2018-10-19 20:12:34;saying it's hard to split up a microservice but it's easy to split up a monolith? sincere question because that's what it sounds like. exactly. it is easy in the sense that you have already identified interface boundaries that are actually causing problems and you have been able to understand where the difficulties will lie in defining the domains for a service. doing this beforehand will get you in a ton of trouble later on when trying to handle highperformance requests distributed transactions etc. by the time your organisation becomes so large that splitting up a monolith is needed it will be too late to actually go and split it up within a few weeks. who says this takes just a few weeks and that that's bad? you don't immediately go and break an app into a half dozen apps. you do it piecemeal you make the necessary infrastructure adjustments and you do it as needed because breaking things up for the sake of breaking things up is idiotic.;0
e84jnv0;Reddit;2018-10-20 18:27:41;you fundmental error in this entire conversation is that you think it's easier to implement features in microservices. this is absolutely wrong. doing anything in microservices is harder than a monolith. you exacerbate the difficulties by having everything in distributed systems. you don't distribute your systems unless you need to because there is always additional conceptual overhead. maintaining multiple versions of apis is pita. doing distributed migrations is a pita. by comparison migration of monoliths is in general really straightforward and requires substantially less planning overhead. and sorry but network calls don't hold a candle to a good db that does joins transaction control and maintains consistency. these are all really difficult things to get right with microservices and the pattern does not offer any straightforward way to ameliorate them.;0
e82jml0;Reddit;2018-10-19 18:41:47;i'd call soa a fad. and with all due respect you'd be just as wrong. soa was a response to horrible monolithic architectures that didn't scale with organisations. parts of them worked well. parts especially tying everything together with expensive enterprise service busses didn't. microservices are just an evolution of the good bits separating functionalities into separate applications without the bad bits. the next evolution is already there serverless basically just micromicroservices where you don't manage the server yourself anymore. these evolutions don't mean that the previous version is outdated. monoliths are viable for many companies. so are microservices. serverless has benefits in some areas problems in others. like programming languages they're just architectural styles and you need to find whatever fits best.;0
e86tsd3;Reddit;2018-10-21 20:20:09;this is absolutely wrong. doing anything in microservices is harder than a monolith. you exacerbate the difficulties by having everything in distributed systems. lol. i like how you think i haven't tried both. but if you think you know so much please how would you implement zero down time scalability of nodes and resiliency tolerant of node failures and fast disaster recovery with a monolith. i'm pretty sure any answer you give would result in something that completely fails any architecture interview but hey surprise me. i recently implemented something using the actor model that was insanely fault tolerant and scalable and it was easy. but hey what do i know.;0
e8350p2;Reddit;2018-10-19 23:47:53;that's exactly where this goes wrong. everyone pretends it's really easy to write a great modular monolith. then if it's so easy why doesn't it just work? why are all monoliths these monsters who turn into complete steaming piles of shit that people are completely unable to reason about? maybe because you don't work with disciplined staff or make time for refactorings because this is not the case with teams that occasionally do spring cleaning. and honestly if you need microservices because your team is so incompetent that they can't be arsed to put things in the right place in the codebase... a microservice isn't going to help.;0
e892qq8;Reddit;2018-10-22 21:00:47;you use a load balancer and replicate the same process across a constellation of servers and when you upgrade your servers and you need to migrate that db what happens? oh wait you're a monolith so you have to take the whole system down for that migration. and if you somehow manage to find a way to not take down the system for the upgrade you're required to leaving some nodes up and servicing at all times so by definition you have server out there existing at the same time but with different versions at which point you have to handle the case of deprecated api endpoint no matter what. and even if you replicate the same process across multiple servers since you're a monolith you're either all connecting to the same db at which point it's not particularly scalable or you have to deal with synchronizing multiple dbs at which point you might as well do microservices. the fact that you think scalability just spin up more nodes! really exposes your naivety. if you don't design your system to be horizontally scalable then it won't be. and if you use a sane app server with multithreaded request handling then a request will crash gracefully and not take the entire server with it. i like how you think just being multithreaded will make you crash gracefully. say someone on your team commits a change that silently leaks threads and doesn't free them. or it leaks memory and slowly pushes your system towards oom. what happens now? think being multithreaded will save your entire server? no your entire monolith goes down. fun times isn't it? or how about just a simple hardware outage. one instance of hardware outage on a monolith is enough to take it out as opposed to... you guessed it. node failure is immaterial of app architecture. that this needs to be explained means you're not the expert you claim to be. being able to resilient to node failure is definitely not immaterial of app architecture. the fact that you don't realize this indicates you'd probably fail every architecture interview i know of. resilient the system stays responsive in the face of failure. this applies not only to highlyavailable missioncritical systems any system that is not resilient will be unresponsive after a failure. resilience is achieved by replication containment isolation and delegation. failures are contained within each component isolating components from each other and thereby ensuring that parts of the system can fail and recover without compromising the system as a whole. recovery of each component is delegated to another external component and highavailability is ensured by replication where necessary. the client of a component is not burdened with handling its failures.https guess what really pairs with replication containment isolation and delegation? man your answers is the stuff i get from clueless new grads who have no idea what being fault tolerant actually means. this is seriously disappointing.;0
e82m7pk;Reddit;2018-10-19 19:16:58;to this day i still believe that only ides could write wsdls. half the time anyone who touched a wsdl might break its interoperability which was its entire selling point. it didn't matter that .net or java had bugs in its implementation if you couldn't practically make it work it was as good as it theoretically not working. that entire spec was a nightmare. the schema part of wsdls was excellent i used to be on board with this. i was really confused when i was first introduced to jsonrest web services. why wouldn't you want to publish and enforce the correct implementation of your service? since then i've come around to the idea that culture is more important than contracts. bad interfaces can happen anywhere but reinforcing any interface with a schema makes it exponentially more difficult to make changes to that functionality. if your culture already supports documentation tests and standards about how to write an api then having a schema becomes a formality and bit of rigidity in the entire process. if your culture allows for 3 different ways to write a simple crud service then any schema you write is still going to be a pain for the client. wssecurity shudder..... i mean i was down with the idea that wsdl could theoretically support all sorts of plugins like global transactions across services. i haven't really seen a good way to orchestrate global transactions in microservices. but putting any plugin into wsdl was summoning the demogorgon to your project;0
e893clq;Reddit;2018-10-22 21:09:05;and when you upgrade your servers and you need to migrate that db what happens? oh wait you're a monolith so you have to take the whole system down for that migration. hi there's this scheme where you do data model migrations piecemeal where you can gracefully migrate data. this applies so any sort of service anyway the same that it applies to multiple concurrent versions of apis. dude we've been doing this for 30 years. this has not really been a substantial issue for anyone who knows to make fields nullable or nonnullable. and it still applies to data migrations in servicebased architectures because guess what they store data too. and even if you replicate the same process across multiple servers since you're a monolith you're either all connecting to the same db at which point it's not particularly scalable or you have to deal with synchronizing multiple dbs at which point you might as well do microservices. some of us need actual high performance. 99 of applications are well served by a large multiterabyte postgres instance. i've been running oracle rac instances connected to hundreds of clients without issue for 15 years. i like how you think just being multithreaded will make you crash gracefully. say someone on your team commits a change that silently leaks threads and doesn't free them. or it leaks memory and slowly pushes your system towards oom. what happens now? think being multithreaded will save your entire server? no your entire monolith goes down. fun times isn't it? hi this has not been a problem with most app servers since forever. monitoring automatic restarting and health checks have existed for decades. why do you think this shit was created with microservices? i've been doing this stuff professionally for decades and have worked with dinosaurs who have considered all these solved problems for quite a while. that you're ignorant of these processes or think that microservices have invented these solutions still means you don't know what you're talking about.;0
e89647t;Reddit;2018-10-22 21:44:41;hi there's this scheme where you do data model migrations piecemeal where you can gracefully migrate data. this applies so any sort of service anyway the same that it applies to multiple concurrent versions of apis. and what happens if a user tries to modify the data at the same moment that you're gracefully migrating it? see you really have no idea what zero down time actually means. dude we've been doing this for 30 years. this has not really been a substantial issue for anyone who knows to make fields nullable or nonnullable. and it still applies to data migrations in servicebased architectures because guess what they store data too. i'm not talking about whether or not to make fields nullable it's about how to make the system stay up while you're upgrading it. the fact that you think it's about db schemas indicates you've never actually done a zdt system. and here's the thing about microservices... they enable systems that are easier to upgrade piecemeal no need to take down the whole system for a small change to have stateless services that can be swapped out at will and support deprecated calls so that the things needed for zdt are almost gotten for free. some of us need actual high performance. 99 of applications are well served by a large multiterabyte postgres instance. i've been running oracle rac instances connected to hundreds of clients without issue for 15 years. that's not what you said you claimed the only thing you needed to be scalable is to just add a few extra servers and use a load balancer not performance. i find it funny that when exposed about how you have no idea what you're talking about you fall back to well they don't need to be that scalable! hi this has not been a problem with most app servers since forever. monitoring automatic restarting and health checks have existed for decades. why do you think this shit was created with microservices? jesus this is starting to get depressing. the whole point is that with monoliths what happens when your system automatically restarts? oh yeah service outage that's what happens. you entire server goes down for a while because one thing made a mistake. you think that i'm talking about the concept of automatic restarts. no i'm saying that if a microservice crashes and you restart it nothing else goes down but that service so most things are still operational you usually have multiple instances of it running anyways so the impact is minimal and it's fast to restart because it's tiny. i can't believe i had to spell that out for you. i've been doing this stuff professionally for decades and have worked with dinosaurs who have considered all these solved problems for quite a while. maybe you shouldn't learn from dinosaurs whose knowledge should be extinct by now. that you're ignorant of these processes or think that microservices have invented these solutions still means you don't know what you're talking about. you don't know what scalability zdt or resilience actually means and you see yourself fit to lecture me? you still don't know what i'm actually talking about. you're under the impression that i'm claiming that microservices invented monitoring or some shit. no i'm saying that these solutions work much better in microservicelike systems.;0
e89815p;Reddit;2018-10-22 22:09:18;and what happens if a user tries to modify the data at the same moment that you're gracefully migrating it? oh i'm sorry i didn't know a microservice has anything to do with transaction control in databases. it's 2018 postgres support serializable writes. and here's the thing about microservices... they enable systems that are easier to upgrade piecemeal no need to take down the whole system for a small change to have stateless services that can be swapped out at will and support deprecated calls so that the things needed for zdt are almost gotten for free. it is absolutely trivial to run concurrent updates in code if you know how to use feature flags we've been doing it for ages. that's not what you said you claimed the only thing you needed to be scalable is to just add a few extra servers and use a load balancer not performance. for the vast majority of things that is exactly what you need. the whole point is that with monoliths what happens when your system automatically restarts? oh yeah service outage that's what happens. you entire server goes down for a while because one thing made a mistake. hi you run multiple concurrent instances of the same app code and you're not constrainted from doing graduale releases. you don't have service outages. are you really that dense? where did they teach you that gradual releases or failovers are just for microservices? maybe you shouldn't learn from dinosaurs whose knowledge should be extinct by now. oh you mean the dinosaurs that had the vm operating system on os360 running selfhealing systems and virtualization 40 years ago over which regular x86 systems are just catching up to today? man you really need to read the manual of an as400 or sometime. none of this shit is new.;0
e89ted9;Reddit;2018-10-23 03:35:25;oh i'm sorry i didn't know a microservice has anything to do with transaction control in databases. it's 2018 postgres support serializable writes. you really don't get it. the point isn't about transaction control it's about how long the user is waiting until they're able to use your service again. how long is the db locked for? if the migration hits a snag how long does it take to roll it back or fix it? and how much of your system do you need to take down while fixing it? you don't even recognize what the problem actually is. the crux of the matter is that to really deliver zdt you'd want a system that has 2 versions live at the same time and you redirect requests incrementally to the newer version which means supporting deprecated apis and a system to synchronize the data changes between both eventually. and if something does fail only take down the service that does depend on it. guess what delivers that basically for free? if you had built it with microservices to begin with. which is the whole fucking point. it is absolutely trivial to run concurrent updates in code if you know how to use feature flags we've been doing it for ages. lol i like how you rant about deprecated apis but now you praise feature flags which is literally deprecated code that you let live in your codebase. either you just googled it or you're a huge ass hypocrite. yes feature flags are great but they really have no relevance to what i'm talking about independent updates to each service and limiting failure to those services. for the vast majority of things that is exactly what you need. and the vast majority of monoliths are not horizontally scalable so that won't help the vast majority of cases that need it. hi you run multiple concurrent instances of the same app code and you're not constrainted from doing graduale releases. you don't have service outages. lol. you should take a look at how the architecture of your precious rac looks and how they architected the database to be highly available the truly highly available modes for example. redo logs mirroring snapshots etc just to handle using multiple dbs at the same time. if you think the only needed to make your application highly available is to simply spin up more instances of it you truly haven't learned shit. when you actually get to build a real product that is actually resilient if ever you'd realize that you have to deal with things that are actually hard to synchronize across multiple instances. are you really that dense? where did they teach you that gradual releases or failovers are just for microservices? where did they teach you that monoliths are trivially horizontally scalable? you're like a 1st year undergrad exclaiming to the world why don't we just give this program more threads? it's so easy and it'll automatically make n times more resilient! oh you mean the dinosaurs that had the vm operating system on os360 running selfhealing systems and virtualization 40 years ago over which regular x86 systems are just catching up to today? oh yes i'm sure that their solutions from the preinternet age totally didn't need to evolve with the times. man you really need to read the manual of an as400 or sometime. none of this shit is new. maybe you need to actually read some modern architecture books and see how much you look like an old man yelling at the moon. when you first write a single threaded application do you just spin it up on 10 different threads and expect it to just scale 10x? of course not you have to architect it carefully to make it useful in a multithreaded environment. but apparently to you it's just trivial to make a monolith and then just deploy 10 nodes of it and it'll just work. laughable what a schoolboy view of the world. when you realize that haha i'm just gonna deploy this thing on multiple machines and it'll just work actually has some strong complications and you have to do some work to handle them you'd realize that you'd be well on your way to separating out services. but i think i got what i needed out of this you don't seem to know much at all about architecture and you don't seem to even able to ask the right questions. i suggest you read books like reactive design patternshttps to actually get educated because i don't have the time to teach you more about it. sorry.;0
