ID;Source;Creation Date;Content;Sentiment
16200007;HackerNews;2018-01-21;Title:The Death of Microservice Madness in 2018, Content: http://www.dwmkerr.com/the-death-of-microservice-madness-in-2018/;0

16238424;HackerNews;2018-01-26;but how is the data shared? e.g. when you sign up you store your data. but to edit it or to just display it you need to access it again but that data only belongs to the signup microservice...?;0
16218767;HackerNews;2018-01-24;it's fascinating to me that people don't point out that you can get many of the benefits of microservices with all your code in a monolith indeed all in a single runtime. of the 4 benefits he lists 1 independent development 2 independent deployment 3 independent scalability 4 reusability you can mostly get 24 by deploying your monolith to different server pools that are deployed and routed to independently.microservices get to be necessary for large dev teams but probably a lot later than most teams think.;0
16216223;HackerNews;2018-01-23;i'm well aware of that. this type of coordination is much easier than producing a new build in a complex corporate environment. the delivery of microservice is limited in most cases to the change in environment inventory file and integration testing. the delivery of the build requires source code management you'll need to push the dependency change in the right branch probably full application sqa cycle to make sure there's no side effects e.g. due to transitive dependency update and only then deployment and integration testing.;0
16210898;HackerNews;2018-01-23;my experience in attempting to build a monolithand oh i triedwas that it's basically impossible.forget embedding elasticsearch for the purpose of running it inside your monlith just the transport layer drivers supposing you're not using drivers that work over http basically add all of elasticsearch onto your classpath. good luck building your monolith after that. and that's true for so many things you'd want to use. if you want to build a monolith you basically can't have any dependencies. or be very experienced in dependency management.this is why i have a microservice that fronts all my elasticsearch queries. its artifact has the elasticsearch drivers all other microservices that need access data from elasticsearch talk to this service over grpc. any time i want to upgrade elasticsearch or change something about a query i only need to do it in one spot. it's great.;0
16210226;HackerNews;2018-01-23;i'm gonna just be honest here and say that i don't really know the difference between microservices and serviceoriented architecture except for the notion that microservices implies breaking up your services before they get too big and hairy which kind of seems obvious.the impression i get and this could be totally wrong is that the difference is how the services relate to each other.in this post's example 5 of the 6 microservices look like something that would be exposed to the user in some way. i would call this a microservice architecture they're networked together in a way where no one thing orchestrates the others. they likely all touch the same data storage but the overall structure is mostly flat.in a serviceoriented architecture there'd be a treelike or graphlike hierarchy. to an end user it would look monolithic but the monolith would behind the scenes delegate to the userfacing services such as upload and download. upload and download would then use the transcode service as appropriate. but the important part is that this would all be one way transcode isn't allowed to contact upload or download just return the result to whatever called it.;0
16208347;HackerNews;2018-01-22;completely agree.i mostly tell my people we aren't going to do that yet or possibly ever but keep in mind that we might have to if we ever win the user growth hockeystick graph lottery so when choosing between options of how to architect things prefer very narrow focus that could be pulled apart into microservices more easily if practicali've also been known to stand up duplicated instances on a monolith with path routing on the load balancer as a pretend microservices scaling or upgrade trick.;0
16207467;HackerNews;2018-01-22;i'm gonna just be honest here and say that i don't really know the difference between microservices and serviceoriented architecture except for the notion that microservices implies breaking up your services before they get too big and hairy which kind of seems obvious.if some companies go completely nuts and deploy 5 microservices per developer then yes that is madness. if all of those microservices are restjson microservices that's madness squared because you're wasting half your time in serializationdeserialization. if you're managing all of this stuff with kubernetes because it's trendy rather than because it's actually necessary for your use case then you're probably making a bad call.but ultimately services give development teams ownership over features in a complete endtoend way that is fundamentally impossible with monoliths once you're past a certain size.;0
16207257;HackerNews;2018-01-22;i get both why people downvoted you and why people defended you.one developer can certainly be responsible for coding many microservices and even maintaining them depending on the scope number of users etc.sometimes people might even rotate with a core architect coordinating how they all interact and if they are consistent with each other.discussing about microservices can be very confusing if people are thinking about different things and as always when there's a good idea implemented in a specific context and people who don't use it get exposed to it as a silver bullet we'll end up with a huge backlash like in this article.;0
16206635;HackerNews;2018-01-22;also there is a nice place ibetweeni microservices and a monolith;0
16206099;HackerNews;2018-01-22;message queues streaming services specialized dbs etc have no intrinsic properties making them cloudprovider capabilities.all of these cloudprovider capabilities are just normal software that you can run on your own hardware. in one or two cases the software was first exposed via a particular provider's platform but similar and very likely superior software that accomplishes the same goals is now available for selfhosting dynamo cassandra or riak for example. that's about as strong as the connection gets.it doesn't follow that microservices and cloudnative apps hang together because the cloud provider charges you a lot of money to access their redis server when you could run your own redis server.;0
16205344;HackerNews;2018-01-22;it's the ensuring that the library got everywhere it needed to go and that the new release of the other users of that library didn't introduce any bugs.and guess what you have to do the same thing with microservices. you must ensure that all its clients are pointing to the correct version and you must ensure that the new version didn't add any bugs in the clients.adaptations for new service versions will also get into the release queue and can also get blocked by other stuff.;0
16204697;HackerNews;2018-01-22;i don't think microservices are loved by developers so much because they are technically superior but because they allow for quickersafer decisionmaking on management level just like agile development imho only helps traineedevs but shines in providing clear communication strategies between management and developers read keeps mgmt off dev's back for at leat 6h a day.abstractly spoken i don't care whether you call fx directly via ipc rpc or as a microservice. in my preferred programming languages there is not much of a difference anyway.;0
16204692;HackerNews;2018-01-22;appears to be hip to bash microservices now. we have some very clear reasons that keep us on the service oriented path. scaling based on very disparate resource requirements across our api security isolation of critical backend infrastructure language requirements and dependency management accommodating different skills and groups of skills across our organization;0
16204520;HackerNews;2018-01-22;that's harder scheduling not easier. with a monolith you just give it all the resources and threads will use resources as is necessary. after that it's a matter of load balancing appropriately.the key was with bin packing. if you just give it all the resources then you're not bin packing and you're barely scheduling. at that point your scheduler is only capable of scheduling based on cpu and io usage and not for example based on ram. that last one is tricky because most runtime environments won't return memory to the operating system e.g. free won't munmap and we're currently in the middle of a ram shortage. your machines will almost always have a different shape from your processes it's just something you have to live with.a bin packing scheduler is not useful for all companies and all services. it depends on the size of your resource footprint with very large services benefiting the most.so microservices give you better scheduling in the sense that you can use fewer machines to run the same set of services. however this is not important to everyone.this stuff is built into e.g. kubernetes so it is actually quite easy. you just can't do it with monoliths.;0
16204518;HackerNews;2018-01-22;that's absolutely true but it's not specific to microservices. the pendulum could very well swing back the other wayi've come to view microservices in the context of conway's law. if you have a team of developers working on a project who don't like to communicate or work with each other do not understand version control and all have different programming styles and technology choices the only feasible architecture is one service per person.i have no trouble believing that this is what's really behind netflix's adoption of microservices. from what i've heard it's a sociopathogenic work culture and if i worked there i would probably want to just disappear from everybody too.;0
16204338;HackerNews;2018-01-22;all software is modular whether those modules are individual functions or separate processes called over the network. like i said the computer doesn't care so it's really up to the dev team and organization to divide functionality as they see fit.there's no inherent infinite scale that magically shows up proper architecture and design does that. microservices again just goes back to being a rather badly defined description of a certain way of deployment. every time i've seen these used in smaller companies there's no benefit over just having separate assemblies talking in the same process instead.;0
16204337;HackerNews;2018-01-22;better scheduling. a service made of microservices is easier to schedule using bin packing. low priority components can be deprioritized by the scheduler very easily. this is important for services with large resource footprints.that's harder scheduling not easier. with a monolith you just give it all the resources and threads will use resources as is necessary. after that it's a matter of load balancing appropriately.;0
16204210;HackerNews;2018-01-22;i've been working on a number of microservice projects and have found them to at times be wonderful at times frustrating. all in all i think it's just a case of ymmv that with or without can be fine as long as the decision making is sane;0
16204164;HackerNews;2018-01-22;yep there is no real one size fits all to microservices;0
16204044;HackerNews;2018-01-22;yes i agree. my concern is more that microservices as a subcategory of soa are a fad that few people will care about or use 1020 years from now. most services probably don't ever go beyond monolith the rest move to soa and probably a minuscule minority actually needs microservices.;0
16203979;HackerNews;2018-01-22;you icouldi. in this particular case if memory serves we had an existing set of endpoints functioning but people deemed it in need of rewrite to node because 'microservice'. instead of putting the code we had behind proxy then migrating we had to start over. because 'scale' and 'microservice'. and 'lambda'.also the same team spent several hours in meetings deciding whether or not to allow email signup or facebook signup or both or neither in the mobile app. then had the same discussionsarguments a few weeks later when a couple new people joined the team.i realize i sound a bit bitter. i got pushback because i'd used the 'microservice api' in a we don't like that language. consuming the api which i'd understood to be part of the reason of having a central api vs just hitting db tables directly by anything that wasn't also node was outside the groupthink and caused problems.i left the project.they've got their microservice architecture but no userbase yet? to be concerned about scaling issues.i understand it's reasonable to be concerned about potential scaling problems the teamproject spent far too much time chasing architectural perfection and really... 'shiny new stuff' vs executing a marketing plan. it's easier for a group that is techfolkheavy to focus on that i get it. but it didn't solve any problems at hand. but when the mythical 2 million users in an hour problem happens it'll probably hold up unless it doesn't.;0
16203834;HackerNews;2018-01-22;services consuming other services sounds like recipe for spaghetti.can we extend that logic to classes or interfaces? accessing data operations through a wellestablished api is generally seen as a good thing and is the exact cure for spaghetti...service apis also entail load balancing and decoupled deployments so they eliminate unclear architecture that arises at the app level when trying to tune the whole for individual components. particularly when a shared component exist across multiple systems.for a generalized microservices architecture layering is a bit of a misnomer as everything is loosely in the same 'service' layer... i'd also point out that in ntiered applications application services or domain services calling other services at the same layer is seen as the solely approved channel for reuse not an antipattern.;0
16203818;HackerNews;2018-01-22;you'd be surprised. with a microservice you still need to coordinate the release with other consumers of it.;0
16203787;HackerNews;2018-01-22;idk if azure functions count or notazure functions are technically a serverless product but using them as y'all intended to is a textbook definition of a microservice;0
16203776;HackerNews;2018-01-22;microservice architectures are a subcategory of soa.many of the same reasons to use them apply to both but with a finer granularity on what is being hosted where and how it is scaling with microservices. scaling a service with multiple facets going through it gets tricky hence a desire for a more appropriate modularity.placing services in the cloud kinda papers over why microservices and cloudnative apps hang together so tightly... leveraging cloudprovider capabilities message queues streaming services specialized dbs etc often introduces new kinds of scaling new requirements and new deployment needs at the icomponent leveli. particularly if you're working in multiple clouds or a hybrid environment or with teams in different organizations... tech stacks might diverge at the component level developer competencies diverge maintenance routines and monitoring and the rest of it too.a thin service wrapper in front of dynamodb is gonna have a different scalability story than a doitall service on a vm that can also write to dynamodb. especially if the service is used by multiple apps or customers in addition to apps. for a saas outfit that can be make or break.;0
16203745;HackerNews;2018-01-22;sounds like they don't understand why it's called a microservice to begin with. they're not supposed to be solutions an entire piece of software just dedicated bits at least that's what i'd figure with a name such as micro. when we adopted microservices at my job idk if azure functions count or not we did it because we had 1 task we needed taken out of our main application for performance concerns iandi because we knew it would involve way more work to implement .net framework codebase being ported to .net core which meant the dependencies from .net framework did not work anymore in .net core but we eventually turned it into a webapi instead due to limitations of azure functions for what we wanted to do process imagery of sorts.;0
16203704;HackerNews;2018-01-22;hey daveno problem. there was a ton of good stuff in there! i saved it to refer back to it later. as a tech coach i teach good programming skills which mostly ends up being tdd and other good coding skills for oop folks. but i've become a huge pure fp fan over the past decade learning it all on my own just by struggling through it.so as a coach i'm seeing more and more of these microservice train wrecks. i'm also seeing a ton of people who don't understand microservices come online and bitch about how they don't work.wlaschin's book goes into building a pure fp system from the topdown something i never considered doing i've never coached or worked in a large pure fp shop. of course if you build it out that way it really doesn't matter how you splice up the code or where it goes. you can do monolith serverless microservices whatever.i liked the process described in the book a lot. it describes to me how you can have 50 people and 100 microservices and make it all work. although everything you point out is still an issue many of the pure fp techniques mitigate them. feels a lot like bduf though which kinda bugs me.i sat down with uncle bob last month and spend a week showing him f. tdd didn't seem to work that well but maybe i missed it. there's just nothing to test in simple transforms and you want to keep using simple transforms as much as you can. i think we need to evolve a tddlike process for growing systems in pure fp from the groundup. i'll probably cogitate on this for a few years and end up writing something. if you know of any good resources please send them my way!;0
16203693;HackerNews;2018-01-22;if that was the case then it wouldn't be anything specific to microservices.;0
16203688;HackerNews;2018-01-22;it's not the number of people that are micro it's the scope of the service... so what is the right level of manpower for a scoped service with unspecified operational demands? unknowable.the definition isn't small teams per se it's a small area of responsibility with singular focus. a lego block instead of duplo. that lends itself very well to small teams but you could reasonably have 100 people working on a service and call it micro.reason being if those 100 people weren't working on their scoped 'microservice' they would be part of a much much much larger pool working on the shared 'product' 'platform' or 'service' that contains that exact same functionality only without the clarityscalability of application boundaries surrounding the individual service components.that's not to say microservices are ideal just that the size of micro is highly relative to ongoing operations.;0
16203664;HackerNews;2018-01-22;i don't think you should always go with a microservice approach first but you should always separate different domainsfeatures into well defined modulesprojects even within a monolith.there have been plenty of times where i've taken a project out of a monolith and created a separate shippable package to be consumed by another monolith in a separate repo.there were also occasions where i had to rip out a feature in a monolithic api that either needed to scale independently or be released independently and then just created a facade in the originally api that proxies the microservice.;0
16203645;HackerNews;2018-01-22;micro in this case relates to the services iscopei not its operational footprint.so if netflix has a user logon service and a payment processing service used across their clients clients you might be looking at a couple of microservices with ihundredsi of related employees. imagine services for googles search autocomplete ml or analytics...as the article states the micro aspect is mostly in terms of deployment responsibility freeing those 101000 employees from thinking about the totality of googlesnetflixes' operations before rolling out a patch;0
16203619;HackerNews;2018-01-22;those growth points and their associated market knowledge and budgetary constraints would become perfect transition points into a friendlier architecture for the team... plan for change moreso than trying to plan against change.decomposing and fragmenting an established service into smaller clones of itself should be reasonably straightforward. in most languages with a component story ie java library reuse across microservices should make your service architecture orthogonal to your application logic. this kind of approach also eases a lot of pain of crossservice issues.;0
16203597;HackerNews;2018-01-22;it has nothing to do with the resilience of cloud providers. if the cloud providers were resilient then you wouldn't need all of the wonderful scheduling tooling from stuff like kubernetes to deal with unstable individual machines. you can also certainly have a microservice architecture without running anything on the cloud at all.microservices make it possible to simply deal with unstable environments. cattle not pets.;0
16203574;HackerNews;2018-01-22;i'm the dev lead for a largish company with a small development shop 49 people contractors come and go. i went for a microservice like hub and spoke model where a bunch of small services integrate with a central mongo database where all of the crud is managed via an api and validation is done via the api. also cross cutting concerns like configuration a wrapper around consul logging structured logging via serilog and job scheduling nomad is done via a common package.i chose this approach because the developers who were already there were relatively new to c and i knew we were going to have to ramp up contractors relatively fast.our dev ops process revolves around creating build and release processes by simply cloning an existing build and release pipeline in visual studio team services the hosted version of team foundation services and changing a variable. every service is a separate repo. each dev is responsible for releasing their own service.the advantages1. all green field development for a new dev. they always start with an empty repo when creating a new service.2. maintenance is easier. you know going in all you have to do is use a few documented postman calls to run your program if you need to make changes. also it's easy to see what the program does and if you make a mistake it doesn't affect too many other people if you keep the interface the same.3. the release process is fast. once we get the necessary approvals we can log on to vsts from anywhere and press a button.4. bad code doesn't infest the entire system. the permanent junior employees are getting better by the month and we are all learning what works and doesn't work as we build out the system. each service is taking our lessons learned into account. we aren't forced to keep living with bad decisions we made earlier and building on top of it.a microservice strategy only works if you have the support system around it.in our case an easy to use continuous integration continuous deployment system vsts easy configuration consul service discovery and recovery consul with watches automated unit and integration tests a method to standardize cross cutting concernsand finally hashicorp's nomad has been a god send for orchestration. our services are really just a bunch of apps. nomad works with shell scripts batch files docker containers and raw executables. it was much easier to set up and configure than kubernetes.;0
16203521;HackerNews;2018-01-22;crossbar.io is currently an interesting approach imo.it does have a single point of failure that is also a bottleneck the router and it's a lot of work to load balance failover it.but other than that it provides a fantastic way to make microservices anything is a client of the crossbar router. your server code is a client. the db can be a client. the web page js code is a client. and they all talk to each others. a client can expose any function to be called remotely by giving it a name. another client can call this function by simply providing the name. clients don't need to know each others. routed rpc completly decoupled the clients from each others. a client can subscribe to a topic at any time and be notified when anothe client publishes a message on that topic. quick easy and powerful pubsub with wildcard. a client can be written in js node and browser python c java php etc. clients from other languages can talk to each others transparently. they all just receive jsonmsgpackwhatever and error are propagated and turn into the native language error handling mechanisme transparently. the api is pretty simple. if you tried soap or corba before this is way way way simpler. it feels more like using redis. it uses websockets which mean it works anywhere http works. including a web page or behind a nat or with tls. everything is async. the router handles 6000 msg s to 1000 clients on a small raspberry pi. the router can act as a process manager and even a static wsgi web server. you can load balance any clients hot swap them ban them get meta event about the whole system etc. you can asign clients permissions authentications etc. sessions are attached to each connexion so clients knows what other clients can do.;0
16203474;HackerNews;2018-01-22;you don't need microservices to fix that you need ci and maybe some release processes for your libraries.there will come a point where you can't scale a monolith sure but that point is thousands rather than hundreds of engineers.;0
16203459;HackerNews;2018-01-22;do you legit think that people are all just doing this as a fad?yes. that's been my experience. the idea that the existing code base could have problems shouldn't be a surprise to anyone. amazon almost fell over because of their code base. twitter too.most organisations aren't amazon. most organisations aren't twitter. and even these webscale organisations aren't as allin as the microservice advocates. i worked at last.fm for a time and while we did many things that could be classed as microservices from a certain perspective we didn't blindly microservice all the things microservices as mass delusion discounts a lot of people who are really thinking hard about how to handle the pros and the cons of things.most fads start from a core of sensible design. the web really did revolutionise commerce but many x but on the web companies of the late '90s really were dumb.;0
16203433;HackerNews;2018-01-22;here's my experience. some features are extremely good as microservices. and i wanted to use it. but i don't. why?1. setting up a microservices architecture itself is a convoluted process. if you're not a netflix or amazon that will run hundreds of microservices the upfront cost and time is not at all worth it. i would rather just run an app on digitalocean.2. if i decided to bypass step 1 and just use existing vendors like aws google microsoft etc. first i don't feel good about it because i know it's in each vendor's best interest to implement lockin which conflicts with my own interest.3. lastly none of the existing cloud function vendors have good user experience. aws lambda google cloud functions etc. all require you to go through all the authentication related stuff before running a simple function not to mention all the constraints that come with function based paradigm. again definitely not worth it unless you're trying to run hundreds of these functions.i think part 3 is critical because i was willing to ignore part 1 and 2 as long as i could get my function up and running really easily. but none of the vendors make it easy. sure there are frameworks that let you do that like apex and serverless but those also require setup. i would rather just run a digitalocean server for 5 which by the way can run multiple of those services as a regular server without me having to spend time dealing with the complexities of function servers.i thought about how this could be improved. sure there can be some heroku for functions saas but nobody is excited about building saas startups nowadays because they know they can't compete with large vendors in the very long run. unless you're comfortable with just building a lifestyle business which is totally fine but i personally won't rely on a lifestyle business saasthe only way this can be improved is if each root vendors like amazon ms and google actually implemented better ui but none of them are really focused on this since the reason they're doing this business in the first place is not for consumers but to make sure they have leverage in this space. if aws dominated 90 of this market the rest of the companies will be in a great risk in the long run;0
16203432;HackerNews;2018-01-22;while i'm not arguing with you i have had a different experience working with developers and microservices perhaps because the teams have been more seasonedexperienced and there is more of a collaborative environment.i found that a lot of the time developers start moving towards microservices when they find that a monolithic app becomes too difficult to work on. for example multiple teams working on the same codebase will often have accidental code conflicts. plus scaling a monolithic app because one part of it is under load isn't always cost effective or logical. so teams will start to break off components into microservices to make development easier and less painful. naturally this has to be weighed up as microservices bring a different set of challenges 'gotchas' etc etc but in my experience the teams have done a proper job discussing the pros and cons.;0
16203329;HackerNews;2018-01-22;it's much harder to deploy a library fix to production producing a new build of integrated app in large team is a big deal than a microservice.;0
16203310;HackerNews;2018-01-22;yes we do. the ecosystem is great and microservice architecture may be manageable even in small teams but it's always a process that defines the success. from my own experience the biggest technical problem of microservices in java can be the performance of the whole system in a monolith there's much less logging and state management no network latencies and mismatching parallelism settings. discovery auth messaging configuration management etc are solved.;0
16203260;HackerNews;2018-01-22;one thing ive noticed with microservices is the business rules duplication. everyone tries to solve their problem so the same rules start popping up ofc implemented differently and mostly unknowingly in all these microservices. the problems start when the business requirements change and you need to change all microservices.;0
16203252;HackerNews;2018-01-22;this is a well thought out and well reasoned article.it resonates on many of the pain points of microservices. i also nearly broke out laughing at his definition of microservice madness netflix are great at devops. netfix do microservices. therefore if i do microservices i am great at devops.because it is so hilariously accurate it's almost painful.i do want to point out something the author implies which is that there iarei benefits to microservices as a pattern...and as a pattern it is likely here to stay. it's an advanced pattern that comes with tradeoffs and complexity increases on the ops side. in the best case you're trading developer complexity for operational complexity and perhaps also getting better reliability but this is not a guarantee.additionally projects like kubernetes istio and envoy are all tools aimed at making certain operational complexities of microservices easier...so the operational trade offs are likely to change dramatically this year.but in the end we can all still hope that madness dies in 2018 though.;0
16203231;HackerNews;2018-01-22;because i find debating about the pro's and con's about microservices somewhat cumbersome i tried to let the code speak and record a screencast series on exactly this topics. because i feel that especially in the java world microservices are an utter abomination most of the time. comments more than welcome!;0
16203184;HackerNews;2018-01-22;microservices is a backend service pattern. mvc model view controller is a frontend pattern to enforce separation between data ui and interaction logic.;0
16203163;HackerNews;2018-01-22;what we need is a polyglot paas that's only runs microservices lambda is the closest to that ideal right now.;0
16203099;HackerNews;2018-01-22;what i love about some microservice iimplementationsi so not microservices in general is that people use fast and scalable data platforms to analyze data in microseconds but then slap a rest api in front of them ideally with slow authentication and logging and ideally in a different availability zone so instead of waiting 20 ms for your metric you get it in 3 seconds.i love without es microservices for their isolation principle people can kill offrewrite parts of the system without affecting other parts written possibly in a whole different language etc. but lets not abuse it. if you put every tiny function behind an api what you'll get is a slow and unmaintainable mess.;0
16203085;HackerNews;2018-01-22;we are such a totalitarian part of the species. someone writes about microservices and my next project i'm building services for each feature because some manager heard it increases reliability. the fact is its always science. if you don't want your inconsistent dataset from somewhere else in the corporation taking down your application then chunk a part of the application into your own container to manage calls rather than allowing the event loop to block up. it doesn't have to be 'micro' it has to exist for some reason if not it is just your developers trying to be cool.;0
16203056;HackerNews;2018-01-22;they're only following their incentives.what's gonna look better on a devs cv 'spent a year maintaining a crud monolith app' vs 'spent a year breaking monolith into microservices with shiny language x to boot'.we can be a very fashion and buzzword driven industry sometimes.edit this perverse incentive goes all they way to the top through to cto level. sometimes i wonder if businesses understand just how much money and effort is wasted on pointless rewrites that make life harder for everyone.;0
16203030;HackerNews;2018-01-22;microservice is certainly a buzzword but it's not just serviceoriented architecture. mircoservice architecture is modular design with all the advantages of effectively infinite scale incredibly flexible orchestration and the resilience provided by the public cloud providers. it has it's own set of challenges and it isn't the right solution for every problem. but it can be fantastic when used properly. i've written plenty of well performing api endpoints in microservices and i've also done a fair bit of business process automation with them.;0
16202972;HackerNews;2018-01-22;i use microservices and i experienced many venefits. more in general it follows unix phylosophy.;0
16202840;HackerNews;2018-01-22;i suppose it depends if those 10 people are purely developers or include the other teams you'd need monitoring devops etc. for a critical highperformance microservice i can easily see it needing the involvement of 2 devs at least one senior product owner project manager qa devops monitoring etc.;0
16202552;HackerNews;2018-01-22;there is no such thing as microservices it's just services otherwise known as a serviceoriented architecture soa. a service is a logical grouping of functionality as it makes sense in your business domain. a small service for a large company can be bigger than the entire product of a startup there is no standard unit of measure.computers also don't care how code is deployed and different services can be bounded by classes or namespaces or assemblies or packages or processes or completely separate apis reached over the internet on the other side of the planet.microservices can perhaps be defined as more of a deployment model but even then it's 99 about the team and organization structure. as companies get larger there is a trend towards smaller teams in charge of separate functionalities that create deploy and operate their own service. this can be effective in managing complexity and creating efficiency although definitely not absolutely necessary.all that being said outside of the major software companies i have seen exactly 0 uses of microservices where the benefits were worth the effort if any benefits even appeared at all.;0
16202462;HackerNews;2018-01-22;decoupling codeinfrastructure is not a bad practice. as it so often turns out to be microservicesmonoliths mean different things to different people and your mileage may vary. difficulties may be introduced going either way.choosing the right tool for the job is difficult there are many variables at play. there's a lot of value to people sharing their perspectivesexperience about these issues. at the same time i think the overall discussion shouldn't be so dichotomous.;0
16202459;HackerNews;2018-01-22;good quality code can increase the chance of meeting deadlines but working long hours can also increase the chance of meeting deadlines.no that's not true except in a very superficial sense. yes long hours can increase the chance of meeting deadlines... but often it doesn't or more precisely it only works if the code quality is decent.code quality is not about following whatever patterns are en vogue today or using the latest dev language. it is mostly about simplicity dealing with few things at a time and making those things explicit. if you need to understand the entire solution and the entire domain model and all the edge cases before making the tiniest of modifications long hours are not going to help you.to go back to microservices many companies claim to build microservices but actually build a distributed monolith. this doesn't help productivity it actively harms it.;0
16202441;HackerNews;2018-01-22;not the op but also having worked on multimillion user apps off the top of my head zero downtime deployments small failure domains if you make a bad update to a service only related functionality suffers the rest keeps working frequent small deployments like several times a day easy and quick integration testing cause you only have to test the functionality of one service not the whole system easier debugging cause if one functionality isn't working it's easy to analyze only the logs of the service responsible for that functionality and optionally move to others later having identified some part of the cause. also every microservice is a new clean slate you can quickly learn from your mistakes and try out new approaches. not diametrically different but you have the ability to iterate moreedit another one is that if you keep the microservices actually small and well described by an api you can easily quickly and safely heavily refactorrewrite old services.;0
16202283;HackerNews;2018-01-22;the author omitted an important one microservices are the new source of spaghetti code.when trying to implement as multiple microservices something that should actually be a single servicei.e. the ms's are not useful as independent unitsanswering a single api request is an amazing mess of distributed calls all over the place and unnecessary serializationdeserialization of queries.;0
16202212;HackerNews;2018-01-22;they can manage those teams by writing libraries no need for microservices.;0
16202185;HackerNews;2018-01-22;if you can't debug one and only one microservice at a time then it's not really a microservice.it depends on what you want to debug. it is like unit test vs integration test. if you are finding a bug related to integration between multiple services you definitely need to debug on multiple services.;0
16202061;HackerNews;2018-01-22;the ops cost of inoti using microservices is a lot higher than you'd think too. at some point when you have hundreds of engineers and your monolith is compiled together from libraries written by a dozen different teams and you have to try and make one heroic release per week except half the time it fails and you have to go back and fix it and absolutely no one in the company can ship a new feature because you're blocked.;0
16202008;HackerNews;2018-01-22;thats how i meant it that the advantage of microservices is bite size pieces of work so 10 people on the same service sounds like theyd step on each others toes. i run a bunch of services but theyre each debugged enough to be fairly low maintenance and small enough that the edges are well defined.its 8 or so but its possible for me to handle it all. if we add features theyre going to be new services so adding big features to the services i manage is unlikely. it is more likely that i get a new service on my plate in 6 months time than getting additional members of the engineering team to work on already completed services.im obviously not entirely alone... ill ask for help if i need it and i help out with other peoples stuff too but i am primarily in charge of them and i am responsible for keeping everything working well.;0
16201954;HackerNews;2018-01-22;my two cents would be that tooling makes all the difference with microservices especially in terms of developer productivity. having tooling which allows me to test changes to a microservice locally and easily is a huge win and without that tooling microservice development becomes much more difficult. making it easy to test a service locally including its network interactions lets me be more confident that my code will work in production and reduces a lot of the cognitive overhead of developing one component among thousands.;0
16201949;HackerNews;2018-01-22;i think that it is accurate to say that in a system composed of microservices a microservice should not effect the state of other microservices in the system other than by consuming them.whether it should iconsumei other microservices is less clear and gets into the choreography vs. orchestration issue choreography provides lower coupling but may be less scalable.;0
16201941;HackerNews;2018-01-22;the scope of a microservice is commonly a bounded context in ddd. so depending upon the problem you might be talking about a lot of code.;0
16201924;HackerNews;2018-01-22;i feel like several of the purported benefits of microservices could be realized in a monolith as well.independent development just stick to your own part of the app.reusability write a libraryisolated deployments and deployment velocity i suppose not isolated but theres no reason you can't achieve great velocity with a monolith.a less often cited advantage that i do think has a lot of merrit is the ability to choose different languages and tools for different problem domains.;0
16201898;HackerNews;2018-01-22;in fact if you have stateless services then i'd be inclined to consider skipping microservices altogether and consider using a serverless model.what? isn't a serverless model necessarily a microservices solution?;0
16201883;HackerNews;2018-01-22;do you legit think that people are all just doing this as a fad?as you say there are a lot of pros and cons to any architecture or paradigm which is why we're still talking about it and saying things like right tool for the job and not just using the one true methodtm.i legit think that a lot of people using the new hotness as a form of cargo cult programming with no understanding of the methods they're considering or how they apply to the problems they're trying to solve.it's not just microservices that are improperly applied. i've been in the industry long enough to see dozens of languages technologies paradigms processes and everything else hailed as the second coming of christ and applied inappropriately all over the place until the shinyness wore off.and i mean... when we start talking about developing for amazon scale we're already talking about situations that don't apply to 99 of developers. not a great argument that their cases aren't inappropriate applications of the pattern.;0
16201835;HackerNews;2018-01-22;wrt 2. data isolation argument.it is not clear to me why data isolation is your view is exclusive to microservices.i have build non trival rbacabac authorization platforms using pdp and embedeabble pep and did not find that it was useful by micro services only. and i did not feel that it can only be called via 'micro service' pipeline.in a way the authorization is a separate service yes but it should be offering an embeddable pep policy enforcement point that one can embed link or call outofprocess if needed from pretty much anywhere monolith or any runtime component.authorization decisions require very very low latency as you are authorizing pretty much every data or function interaction.in fact for data interaction authorization engines offer sqlrewritingfiltering so that the actual 'enforcement' happens at the layer of database you are using not even at the layer of the component that's accessing the data.;0
16201794;HackerNews;2018-01-22;i think these are appealing for 2 reasons1. there is a believe that component isolation taken to extreme by microservices enables better productivity of the development department.that is more features more prototypes more people can be moved in and out a given role. so that those 5 crusty programmers are not a bottleneck for the 'next great idea' that a product manager or cio reads up on.2. there is a constant battle for the crown of i am modern eg data science micro services big data that is going on in every development or technology organization. where the closer you are in your 'vision' to google or netflix the more 'modern' you are.the rest of the folks is 'legacy'. so you get budgets you get to hire you get to 'lead'. microservices is the enabler to help to win this battle although probably for a short term.i personally do not believe that microservices bring anything new compared to previously used methods of runtime modularization i do not think they replace the standards like corba although i think they will end up eventually replicating it with better thought out standards and tools.;0
16201747;HackerNews;2018-01-22;i mean there's no reason you can't do that i think that's a fine approach personally. i'm not really sure you gain much from focusing on developing tons of microservices at that point though. in general it's going to add complexity to your project and at the end of the day you're still deploying it as one big single service so i'm not really sure you gain much from the added complexity. that said i'm not really huge on microservices to being with so i may not be the best one to talk to about them;0
16201713;HackerNews;2018-01-22;microservices bring more advantages for management than technical people. easier to manage smaller team easier to hire we can hire good people with different skillset easier to scale and so on...;0
16201705;HackerNews;2018-01-22;microservices in practice are like polyglot throwing away type safety for no good reason. this shit needs to stop.;0
16201671;HackerNews;2018-01-22;they haven't hit the proverbial nail with the hammer they've hit the railroad spike with a sledge imo it's 100 about your environment and the demands and obligations your development team has against it's own obligations to deliver. i'm not going to say microservices are the cornucopia smoking gun or even smoldering slingshot but much of the dissent in this thread seems predicated on the idea that they are the end result and not merely an optional path to take for desired outcomes of deliverability.;0
16201652;HackerNews;2018-01-22;a little over two years ago my little team of three gasp! succumbed to the allure of microservices. after six months of writing custom solutions for problems i'd created i bagged it. the one upside of our microservice architecture was how simple it was to consolidate back into a single app. only took a couple months. i believe the theoretical benefits of microservices namely hard domain boundaries remain compelling but geez i also learned its benefits are extremely circumstantial.;0
16201638;HackerNews;2018-01-22;just for the record i'm one of the people who thought that putting a corba orb inside gnome was a ifantastici idea. we're all young once!microservices are just another way for us to do premature subsystem decomposition because we ialwaysi think that we can build components with stable apis that will be small clean and reusable. it's even more fun to put that subsystem into a different process because who doesn't like a little bit of extra latency in their processing? i jest but it's not such a silly idea. by making sure everything is in another processes and using the most inefficient ipc system available tcpip you ensure that nobody is going to do stupid things similar to what people tend to do with threads. the multiprocessing aspect appeals to people because it helps them break down the problem into isolated chunks and reason about them.the key here though is to realise that you almost never need multiprocessing. the design challenge is actually the same whether you isolate your processing in different processes or not. however it's imuchi easier to refactor your code when you haven't put road blocks in your path first. if you are doing that then it is easy to extract the functionality into a separate process if you need to or even a thread if you happen to work in an os that thinks that thread processing should be more efficient than process processing.in short don't practice i must protect myself from the stupid programmers programming and instead concentrate on writing good code with your coworkers.;0
16201615;HackerNews;2018-01-22;when i see a team of 7 deciding to go with microservices for a new project i know they're gonna be in for a world of unnecessary pain.faced this a couple of years ago and i was the lone dissenting voice suggesting this was not going to go well. then i learned that microservice in reality just meant everything was going to be one nodejs process running endpoints with ios and android clients hitting it which... didn't really fit my understanding of microservice that's just service.;0
16201613;HackerNews;2018-01-22;i think my point was misunderstood probably because i did a poor job of explaining it as i was cramming a hamburger in my facehole and watching the pats win the afc i think in many cases microservice architectures appeal to engineering organizations with poor communication and cooperation skills where developers desire to be strongly independent because of the lack of management creating a cooperative and coordinated dev and work environment. i think that's actually saying something very similar to the conway law idea brought up by the other poster.;0
16201586;HackerNews;2018-01-22;the big benefit of microservices is being able to easily reason about or scale services but adding dependencies usually sacrifices those benefits.thank you that makes sense.;0
16201572;HackerNews;2018-01-22;i think the context is pretty clear microservices.if it takes 10 people to manage one service it is not a microservice by definition. it is more like a 10xmicroservice or a macroservice.;0
16201493;HackerNews;2018-01-22;background ive been on good and bad projects that used microservices and good and bad monolithic projects.the madness is going away but the microservices are staying. there are some rationales for microservices that are conspicuously missing.1. fault isolation. transcoder stuck in a crash loop? upload service using too much ram? with microservices you don't even really have to figure out what's going on you can often just roll back the affected component.2. data isolation. only certain privileged components can access certain types of data. using a separate service for handling authentication is the classic example.3. better scheduling. a service made of microservices is easier to schedule using bin packing. low priority components can be deprioritized by the scheduler very easily. this is important for services with large resource footprints.the criticisms remind me of the problems with objectoriented programming. in some sense the transition is similar objects are selfcontained code and data with references to other objects. the 90s saw an explosion of bad oo design and cargo cult architectures. it wasn't a problem with oo design itself. eventually people figured out how to do it well. you don't have to make everything an object any more than you have to make everything a microservice.;0
16201475;HackerNews;2018-01-22;that is nice in theory and i agree it should be done wherever possible but lot of the time business logic will require immediate synchronous response to be returned as a next step in workflow will execute different branch of logic based on conditionresult returned from previous microservice and the frontend consumer app will need immediate confirmation about whether action succeeded.even in such cases you might want to move bulk of processing to asynchronous queue based system but part of the logic might need to be executed synchronously authorise credit card payment you can process the payment asynchronously later perhaps in bulk cron jobs like apple itunes does it but initial authorisation which decides whether purchase is successful must be synchronous.;0
16201474;HackerNews;2018-01-22;well a library deploying it into its own space so that it doesn't bring down your main app due to compute time.the operational part of microservices can end up being pretty important in these cases;0
16201467;HackerNews;2018-01-22;but that is ridiculous. fiddling with database flags is silly i agree but inserting and updating database is a completely normal side effect of most business logic. so if your microservice handles any kind of ordinary feature of your business solution it will almost definitely have side effects because it will write to database. there might be services which just do some computation in memory and return result to you but i think those will be a small minority most of your services dealing with features such as payment subscriptions identity etc just some examples will have useful side effects.;0
16201451;HackerNews;2018-01-22;do you legit think that people are all just doing this as a fad?there's legitimate arguments for looking at these patterns the big one being isolation of concerns. the biggest counterargument is that the ops cost is much higher than assumed of course.the idea that the existing code base could have problems shouldn't be a surprise to anyone. amazon almost fell over because of their code base. twitter too. and its not even not doing it right but simply that scales change. or patterns change.and in new companies it could be that people don't get it.microservices as mass delusion discounts a lot of people who are really thinking hard about how to handle the pros and the cons of things.;0
16201442;HackerNews;2018-01-22;this i can entirely agree with framing my point around conway's law works well and i think i can reframe my question as is the expression of conway's law a management failure or is it the misstructuring of the organization causing the expression to be harmful?the parent post i was replying to seemed to simplify things down to let your developers communicate and they'll build a more coupled system that works instead of a morass of microservices that don't. that's another thing that looks good on paper but doesn't scale at least in my experience.;0
16201375;HackerNews;2018-01-22;those of us who have been around since the 80s90s are astonished by the low productivity of today's programmers.if it takes 1 person to run 1 microservice we are all doomed.;0
16201353;HackerNews;2018-01-22;they were having performance problems and needed to migrate to microservices. they developed 12 seperate applications all in the same repo deployed independently it's own jvm.9 times out of 10 it's because developers don't know how to properly design and index the underlying rdbms. i've noticed there is a severe lack of knowledge of that for the average developer.;0
16201333;HackerNews;2018-01-22;i think another important cause of microservice is politicswhen every department wants the easiest job with max outcome and the boss decides to split the cake equally then an easy job x can be cut into n services which are usually named micro resulting in a huge project of complexity xnn for each team.;0
16201318;HackerNews;2018-01-22;microservice architectures usually represent a management failure because they usually don't work well in the real world. it's easy to concoct a paperonly theoretical version of an idealized microservice architecture since you can gloss over all the realworld details and practicalities. mapping that theory into the real physical world is a whole different ball game.conway's law might as well be renamed the law of microservices. per wikipedia 0 it states organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations.microservices are on a tear because they make a perfect cover for the blatant and bare expression of unbridled conway's law.such unbridled expression is much easier in the course of greenfield development because it lets the core team of 23 people per service go about their development work without consulting anyone external. it lets them throw away any overriding convention or cultural concerns and it avoids the difficulties of crossgroup coordination. but it leads to a completely unmaintainable wreck when things transition into production.this is not to say that ino onei will have a successful microservice deployment or that it's always a bad choice but it usually goes way off the rails.0;0
16201295;HackerNews;2018-01-22;microservices as a mechanism for mainly code organization are just a bad idea. build a wellorganized monolith first structure your code as inprocess services so that you can factor those pieces out individually in the future.i see smaller teams heaping in tons of complexity for no real gain and actual measurable cost.;0
16201276;HackerNews;2018-01-22;i found out recently that people too often think about microservices in context of broader solution like it would be one app just scattered around. i did that mistake in the past either. the longer i work with microservices the clearer it is to me that teams implementing them should forget about the big product just focus on the service as it would be product itself. assume that anyone can use it for any purpose they like as long as they stick to the contract that is and you'll be fine.i tend to have two layers of design now. one big picture which treats services anonymously. just black boxes that respond to input. the goal here is to build solution like kids are building stuff from building blocks.other layer depicts services as separate beings. they treat all their clients anonymously. they have a contract to fulfill and whomever plays by the rules can be served all right. they should be treated as completely separate projects have their own backlog release strategies etc.now if you would have a product that utilize certain data would you allow some anonymous guy from the internet tap to it directly? no need to answer i guess.edit typo;0
16201253;HackerNews;2018-01-22;the monolith first approach has always served me well. nascent projects benefit from portability because they need higher amounts of flux. as they mature let's assume they grow in scale and integrations and somewhere along the line it becomes sensible to break off pieces into services.to me the big benefit of microservices is scaling out components into flexible independent release cadences but the trouble comes with employing them too early.;0
16201220;HackerNews;2018-01-22;putting the i back in microservices;0
16201211;HackerNews;2018-01-22;the key to microservices is a framework and tooling around them to make them work for you. release management authnauthz compilation composition service lookup etc. should all be outofthebox before microservices should ever be considered. otherwise the on gains you get in modularity turn into on fml.;0
16201194;HackerNews;2018-01-22;i prefer that the advice not to be dogmatic about saying no but rather to be wary of the costs. the big benefit of microservices is being able to easily reason about or scale services but adding dependencies usually sacrifices those benefits. ive seen that done poorly in the various iterations of this cycle and the worst failure modes mean that debugging requires you to understand how to get amp interpret state from many locations making even simple problems challenging.that might mean that you still take that cost willingly but engineer in the extra tooling to make things easier to manage i.e. simplifying tracing load or errors across service boundaries back to the source but it might also be a cue for you raise to reconsider whether the service divisions are in the right place or whether all of the services are appropriately sized. if you find yourself needed distributed transactions retries etc. thats often a good time to pause and reconsider.;0
16201150;HackerNews;2018-01-22;looks like microservices have rounded the peak of inflated expectations and heading into the trough of disillusionment;0
16201124;HackerNews;2018-01-22;why is scaling independently a pro? i've heard that argument before and never understood it.if i have one api that is low throughput and one that is high say requires 2 and 20 nodes respectively then you need 22 nodes whether they are two independent microservices or a monolith. i'd think the monolith would actually be easier to manage as you don't have to worry about how to divvy up the resources. all 22 nodes run the same code. sure you could do the same with a k8s cluster autoscaling i assume but still i don't see how this makes anything strictly easier than a monolith scaling. if anything it seems like one more thing to worry about.but i've heard the argument multiple times so wonder if i'm missing something.;0
16201122;HackerNews;2018-01-22;why was this downvoted? i think this is a valid argument. there are plenty of small teams or individuals who have been managing a bunch of small services. before this was called microservices.;0
16201094;HackerNews;2018-01-22;i'm thinking this concept improperly conflates synchronous requests with eventuallyconsistent asynchrony.no you definitely don't want microservices making synchronous requests to other microservices and depending on them that way.but it still may be necessary for your services to depend on each other and that's where you can allow that communication through asynchronous eventually consistent communication. actor communications queue submissionconsumption caching etc.;0
16201081;HackerNews;2018-01-22;in my opinion only the extremely good developers seem to comprehend that they are almost always writing what will be considered the technical debt of 5 years from now when paradigms shift again.i've also seen really bad developers with that attitude it's all crap so just ship whatever already.the good developers write code that can be replaced rewritten or rescaled later. though charitably both monolithic service and microservice people are trying to do exactly that. it's just what sort of scale they're thinking about and what part of the software development lifecycle they think will be especially difficult going forward.;0
16201067;HackerNews;2018-01-22;i tend to think that the job of invoking the services lies within a gateway. for example you can have a microservice for recipes but a web gateway that know all of the various integrations necessary to generate a page. so the web gateway is essentially a monolith.if and when you need to support mobile devices independently of your web ui you can have a mobile gateway. same idea. this gateway is optimized to know how to handle mobile traffic realities like smaller download sizes etc.;0
16201058;HackerNews;2018-01-22;well you don't want to call a processor intensive task with a library. a separate service for these types of tasks is a better architecture.although i'm not sure whether or not a task queue architecture with separate server workers executing code passed over from a central monolithic app server is still considered a microservice architecture.;0
16201042;HackerNews;2018-01-22;to put it in an even less flattening way the real problem are developers not the paradigm. your company's code will be as good as your developers are regardless of the paradigm.microservices will not help you if your developers have the same level of skill and foresight as whoever wrote the monolith which is probably true if those devs were selected by the same hiring process that your company has today subject to the same organizational effectiveness etc.;0
16201032;HackerNews;2018-01-22;is this truly a management failure?if a few things are true i could see this as a win i can isolate my developers from outside interests using microservices. my developers are more effective in each dimension quality retentionhappiness velocity because they are isolated from outside interests. my software is easier to operate and more reliable because it is a microservice.if any of these three things aren't true then i agree. but i'm not sure that a communication culture can scale to a large organization and i'd like to see a truly large company 1000 developers successfully doing so. i've seen more success come from separation of concerns and welldeployed microservices seem to be fairly effective to this end.;0
16200956;HackerNews;2018-01-22;it's not exclusive to inheritance though. there are lots of times that the original principal decides that he could have done it better and winds up in exactly the same place. it could be progress too if it trades on set of failure modes for another that is less severe or less frequent.this is why a team needs access to good architect who's seen the paradigms shift or even cycle. you're almost never starting from scratch so you really need someone who's able to incorporate better or more suitable tech without throwing out the baby.if you're microservicesbased that last part is easier even if it falls into one of the described pitfalls e.g. systemofsystems.;0
16200916;HackerNews;2018-01-22;i really think microservices are a process win not a technical win. it's easier and better to have 5 teams of 10 managing 5 services. then having one team of 50 managing a one super service.when i see a team of 7 deciding to go with microservices for a new project i know they're gonna be in for a world of unnecessary pain.;0
16200912;HackerNews;2018-01-22;at my workplace the idea is distort disparage or destroy applications and replace with spring boot thingie. voila now we have a 'next generation platform' based on microservices.;0
16200910;HackerNews;2018-01-22;why can't you build a microservice that does a handshake with an api gateway to authenticate a user? when doing microservices you have to have a sane auth strategy and that generally means you encapsulate authenticationauthorization in a service that your gateway will talk to.;0
16200908;HackerNews;2018-01-22;microservices as the m in mvc?;0
16200899;HackerNews;2018-01-22;i agree mostly. a black box can have internal state but it should not have shared state with another black box defeats the purpose calling it a black box. if two black boxes microservices shared state then we'd need to think of the composite as a single black box.if two black boxes directly contact each other then that also defeats the purpose. microservices are not appealing unless talk via message queues. the whole point of microservices was to handle scale independently for independent functions.where do you suggest storing that state if it needs to be persistent? the definition of microservices should not assume anything about how long i need to track my data. if two of your microservices are touching the same database fields then that's the implementor's mistake.;0
16200882;HackerNews;2018-01-22;great article but i'd like to dispute one point a new version of the subscriptions service may store data in the subscriptions database in a different shape. if you are running both services in parallel you are running the system with two schemas at once.microservices should manage their own separate data stores and communicate with others through a welldefined api. only then services can evolve independently and each team is free to change the internals including schema migrations without coordinating with everybody else.multiple services sharing the same database is the perfect example of the monolith in disguise antipattern mentioned in the article with all of the costs of microservices but few benefits.;0
16200867;HackerNews;2018-01-22;microservices with a share datasource are just a service oriented architecture circa 2005. you might have a variety of middle tier services deployed in their own boxes or at the very least java service containers but ultimately talking to some giant oracle db behind it. microservices that share a database are not deployed into a container running jboss and instead use something more languageagnostic but it's ultimately the same thing. all you have to do is e the many criticisms of that era when any significant db change was either impossible or required dozens of teams to change things in unison.the best imagery i know for this picture is a twoheaded ogre. it might have multiple heads but one digestive system. doesn't matter which head is doing the eating ultimately you have the same shit. i've head semi famous people talk about this in conferences but few articles.;0
16200843;HackerNews;2018-01-22;im confused. if a microservice doesnt call the api of any other microservices then when is sending the requests to any of them?a large purpose of service oriented architecture is encapsulation. if no other microservices can make requests to your microservice then you really havent encapsulated much.;0
16200842;HackerNews;2018-01-22;i recently had a similar experience our product at work is a monolith not in the greatest shape as it has technical debt which we inherited and our product is usually used condescendingly when talking to other teams working on different products. to our surprise when we started testing it with cloud deployments it was really lightweight compared to just one of the 25 java microservices from the other teams.their microservices suffered from the same jvm overhead and to remedy this they are joining their functionalities together initially they had 3040.;0
16200801;HackerNews;2018-01-22;modifying data in a database is a side effect. since you brought up the wikipedia definition here it is in computer science a function or expression is said to have a side effect if it modifies some state outside its scope or has an observable interaction with its calling functions or the outside world besides returning a value. for example a particular function might modify a global variable or static variable modify one of its arguments raise an exception write data to a display or file read data or call other sideeffecting functions.note write data to a display or file. i think we agree that writing to a database falls under this definition hence using terms like side effecting when talking about microservices is misleading.;0
16200756;HackerNews;2018-01-22;a side effect is iby definitioni some mutation that's out of the scope of the function if the purpose of the microservice is to put stuff in a database then by definition it's not a side effect. switching a flag on top of doing some work on the other hand e.g. flip processed to true in a global database iisi a side effect.;0
16200733;HackerNews;2018-01-22;aren't you talking about pure functions more applicable to serverless than the commonly accepted use of microservices?;0
16200732;HackerNews;2018-01-22;i think it has to do with control. i've written microservices and microservices tooling now for a long time... so long when i started we were just calling it something like isolatedresponsibility soa and we didn't have a fancy buzzword.developers want to iowni their thing. microserivces desire springs up because of a lack of communication culture and desire for siloification in a companies organization to keep various interests from bothering the developers. those almost always point to a failure of management in my mind rather than a technical failure.;0
16200726;HackerNews;2018-01-22;i do have a case of monolithsindisguiseitis.i just wish someone with street cred or with a famous recognizable name i could use for appeal to authority could create a simple post saying hey if you have a shared data store that all services depend on and are accessing directly you are not doing microservices. and you also don't have microservices if you have to update everything in one go as part of a release.that way i could circulate it throughout the company and maybe get the point across. i've tried to argue unsuccessfully. after all we are doing k8s so we have microservices each is a pod duh! no you have a monolith which happens to be running as multiple containers...;0
16200710;HackerNews;2018-01-22;nice article but i'd point out two things1. 'death' is a bit too extreme. i think everybody is excited at first and tries to find an excuse to use microservices. we're assisting to a decline in that initial push that's all.2. i think the point about transactions is fair as well as the expertise and team concerns but the rest are mostly it's too hard and complex. it'll get better with time. i think that being a bit uncomfortable as a dev is not too bad that's what we're here for assuming there's a real need of course.;0
16200703;HackerNews;2018-01-22;i think microservices is so appealing because so many developers ilovei the idea of tearing down the old written 12 months ago crusty using a language they don't likeisn't in vogue and bloated using a patternmodel they don't agree with monolith and turning it into a swarm of microservices.as an infrastructure guy the pattern i've seen time and time again is developers thinking the previous generation had no idea what they were doing and they'll do it iwayi better. they usually nail the first 80 then hit a new edge case not well handled by their architecturemodel but was by the old system andor start adding swathes of new features during the rewrite.in my opinion only the extremely good developers seem to comprehend that they are almost always writing what will be considered the technical debt of 5 years from now when paradigms shift again.;0
16200689;HackerNews;2018-01-22;a microservice imo should just be a simple black box that takes in some input and returns some outputi am not quite sure what you mean. a microservice with rest api that has post method is not a microservice?;0
16200670;HackerNews;2018-01-22;will someone enlighten me as to why a microservice should have no dependent services? seems reasonable to me.;0
16200624;HackerNews;2018-01-22;that's plainly wrong. i get the gist of what you are saying and i more or less agree with it but you expressed it poorly.i'm not sure what you think side effects are but i'm using the standard computer science definition you can look up on wikipedia. if you have a microservice that modifies e.g. some hidden state it's a disaster waiting to happen. having imultiplei microservices that have database sideeffects will almost always end up with a race condition somewhere. have fun debugging that.;0
16200623;HackerNews;2018-01-22;or chaos or madness or bedlam.most people have enough trouble getting three methods in the same file to use the same argument semantics. every service is an adventure unto itself.we have a couple services that use something in the vein of graphql but some of the fields are calculated from other fields. if you have the derived field but not the source field you get garbage output iand they dont see the problem with thisi;0
16200611;HackerNews;2018-01-22;a microservice should generally not have side effects.that's plainly wrong. i get the gist of what you are saying and i more or less agree with it but you expressed it poorly.having api dependencies is not an issue. as long as the microservices don't touch each others data and only communicate with each other through their api boundaries microservices can and should build on top of each other.in fact that's one of the core promises of the open source microservices architecture we are building .i think your bad experiences are due to microservice apps which are unnecessarily fragmented into a lot of services. sometimes even when you respect service boundaries that can be a problem when you have to release a bunch of services to ship a feature that's a sign that you have a distributed monolith on your hands.i like to think of services even my services as third party ones i can't touch. when i view them this way the urge to tailor them to the current feature i'm hacking on lessens and i identify the correct microservice the given modification belongs to easier.;0
16200588;HackerNews;2018-01-21;in proper microservices architecture only a single application access the db. other apps get the data via an api call. thus you can drop the column maybe it's derived data and still keep the api interface.in the end it's mostly about enforcing contracts and making devops simpler.;0
16200541;HackerNews;2018-01-21;that's not a pure microservices approach since you are sharing state the database. it means that any development which changes or is impacted by a change in the db has to be coordinated between teams.the microservice approach is to have each service have its own database mysql or schema postgresql.another solution is the use of a modular architecture where separate modules are each responsible for their database tables' schema. tables are not shared across modules accessing data from a table requires calling its module's api.each module can be developed independently and combined into one large service or several smaller services. it's helpful to be able to separate modules into their own service for load balancing and optimization while having all modules in the same service eases administration of the system.from previous experience you start by lumping all modules together then use monitoring software i.e. elk stack collectdgrafana you decide where to split into services. because the reality is you'll not really know where to split until you are running in production.this is the approach of django for example and works quite well for large projects.;0
16200497;HackerNews;2018-01-21;once when starting a new gig i inherited a microservices architecture.they were having performance problems and needed to migrate to microservices. they developed 12 seperate applications all in the same repo deployed independently it's own jvm. of course if you were using microservices you needed docker as well so they had also developed a giant docker container containing all 12 microservices which they deployed to a single host all managed by supervisord. of course since they had 12 different jvm applications the services needed a host with at least 9gib of ram so they used a larger instance. everything was provisioned manually by the way because there was no service discovery or container orchestration just a docker container running on a host an upgrade from running the production processes in a tmux instance. what they really had was a giant monolithic application with a complicated deployment process and an insane jvm overhead.moving to the larger instance likely solved the performance issues. in place they now had multiple over provisioned instances for ha and combined with other questionable decisions were paying 100kyear for a web backend that did no more than 50 requestsminute at peak. but hey at least they were doing real devops like netflix.for me i've become a bit more aware of cargo cult development. i can't say i'm completely immune to cargo cult driven development either i once rewrote an entire angular application in react because angular is dead so it really opened my eyes how i could also implement solutions without truly understanding why they are useful.;0
16200492;HackerNews;2018-01-21;by most definitions of microservices i've heard there's a 1many relationship between microservicesdatastores. multiple microservices can't talk to the same database. for example while monolithic applications prefer a single logical database for persistant data enterprises often prefer a single database across a range of applications... microservices prefer letting each service manage its own database either different instances of the same database technology or entirely different database systems not to say that pattern can't be successfully implemented just that it wouldn't be considered microservices. it sounds like you're describing a threetier architecture;0
16200488;HackerNews;2018-01-21;a microservice imo should just be a simple black box that takes in some input and returns some output sometimes asynchronously. no sideeffects necessary. no fiddling with database flags or global state and definitely no hitting iotheri microservices. see cryologic's post for a good example. this means that you simply ican'ti build some things using microservices like logging in a user and you'd be right.;0
16200484;HackerNews;2018-01-21;at the very least each service should own its area of concern which means only one application should ieveri write to the underlying structures and those structures should support that application alone. what happens if you have an app that needs a certain setting on the database but you can't restart to make it effective because 9 other apps are using the same db?it's hard enough to coordinate this kind of maintenance when there is only one oltpstyle user of the database. if you get a lot of interdependent units where app a needs to read table b and app c needs to write to table d it's nigh impossible to do it without global downtime.microservices require a large amount of control and discipline to implement properly. in almost all cases a straightup monolith ends up being much saner. microservices are often seen as a license to run hog wild and disregard everything outside of one's immediate area of concern team. this is convenient at the time because of conway's law but it is terrible for longterm maintenance overall consistency and employee sanity.;0
16200452;HackerNews;2018-01-21;a microservice should generally not have side effectsi gotta ask how is this realistic? a salient feature of most of the software i've worked on is that it has useful side effects.;0
16200439;HackerNews;2018-01-21;if multiple services are coupled to the same database schema then any changes to the schema must be coordinated between all services so you've got something of a distributed monolith instead of a set of independent microservices.this might be fine and maybe it could even be a good choice in your situation but i would probably avoid the added complexity.;0
16200423;HackerNews;2018-01-21;shared mysql dbthis is already a smell. usually microservices don't need to access global state.;0
16200419;HackerNews;2018-01-21;biggest issue with microservices microservices can be monoliths in disguise i'd omit the icani and say i99 of the time arei.it's not a microservice if you have api dependencies. it's probably not a microservice if you access a global data store. a microservice should generally inoti have side effects. microservices are supposed to be great not just because of the ease of deployment but it's also supposed to make debugging easier. if you can't debug ionei and only one microservice at a time then it's not really a microservice.a lot of engineers think that just having a bunch of api endpoints written by different teams is a microservice architecture but they could't be more wrong.;0
16200417;HackerNews;2018-01-21;i think that sounds like a bad idea. i could see pain arising from the shared usage of the database e.g. during migrations or heavy usage. i'm not really sure what the benefit is either each team will likely want to be the owner of their own database anyway.if you're talking about the separate microservices using the same tables in the database that's probably an even worse idea. either your services are way too tightly coupled or shouldn't have been split into separate services in the first place.;0
16200415;HackerNews;2018-01-21;agree with the author that microservices are harder to operate in certain aspects. for example latency tracing with microservices is harder when you have many services to check latency through what service call caused the latency. doing error tracing with microservices is also harder because now you have to follow a web request through many different microservices. microservices in some cases may have worse performance than a monolith. with microservices data no longer does in local memory or local cache you have to traverse the network through an api calls to fetch data. imagine that you have a monolith that can look up data in a hash table that is one memorycache access versus a micro service network call. in the micro service you have to make a network call for a memory lookup. a memory access may take between 0.5ns100ns versus a network call may take 10000ns. that microservices may be between 20000 times to a 100 times slower accessing remote memory in another microservice than accessing it locally in the same monoliths memory. thus one could argue that in some cases performance are worse with microservices than a monolith. you can still scale stateless monoliths buy putting a load balancer in front of the monolith. there is also increased overhead of running microservices instead of having one java processnodejs process for a monolith you may have several hundred nodejs processes microservices running in docker containers. each nodejs process takes memory for nodejs itself. an important aspect of microservices which are good is that they allow a part of the system to be restarted independently instead of restarting a whole monolith. . sometimes you may want to rewrite a component that is also much easier to rewrite with micro services. compare a mainframe from the 60s80s running a monotlith without unit testing integration testing versus modern micro services with testing. replacing parts or the whole main frame monolith will be very very scary.latency numbers every programmer should know however i would argue microservices has been done before the idea is not new. microservices is a realization of the same principle as that of unixlinux. this is called the unix philosophy write one program that do one thing well. make the output of one program the input of the other one.microservices are not a new idea its the reimplementation of the unix philosophy for the web.the unix philosophy make each program do one thing well. to do a new job build afresh rather than complicate old programs by adding new features. compare with microservice definition by wikipedia the services are small finegrained to perform a single function.improving reliaility with recursive reboots microservices on kubernetes are at least implementing micro reboots in case of component failure. like most tech micro services probably follow the hype cycle;0
16200412;HackerNews;2018-01-21;that sounds like the integration database pattern and it's generally not considered serviceoriented of which microservices is a subset.;0
16200390;HackerNews;2018-01-21;i have recently been thinking about doing microservices by simply having a shared mysql db that all modules connect to.so for example one developer can create the backend and one developer can create the frontend. the codebases can be completely independent. one could use phplaravel and the other one phpsymfony for example.frontend and backend would live on their own servers. and simply having the ip login and pw of the shared db set in their project.what do you guys think about such an approach?;0
16200375;HackerNews;2018-01-21;best use i've found for microservices is highly isolated and welldefined stateless functions which make a significant read compute intense change to some data and drop it somewhere else e.g. image compression.now you can use this microservice anywhere and just change a few params in how you call it and you have avatars thumbnails etc.;0
16200325;HackerNews;2018-01-21;this is the 9th time it's been posted;0
16200269;HackerNews;2018-01-21;broadly speaking microservices make small limited changesupdate less complex and large sweeping changesupdates more complex.this is why generalizations like larger established organizations which make mostly relative small changes should lean more to microservices than smaller younger organizations which make mostly relatively large changes hold true.;0
