ID;Source;Creation Date;Content;Sentiment
18255110;HackerNews;2018-10-19;Title:Microservices Are Something You Grow Into, Not Begin With, Content: https://nickjanetakis.com/blog/microservices-are-something-you-grow-into-not-begin-with;0

18275969;HackerNews;2018-10-22;3. docker and kubernetes add a lot of overhead.that depends on the application.but docker adding overhead? everywhere i introduced docker to devs productivity went up not down once a good way of working was presented to them. no 10 devs using some different versions of the same database engine no more rogue gmail accounts for 'testing purposes' by showing them mailhog updating the backend service became as much as a 'git pull' and 'dockercompose up' for the frontend devs instead of in the best scenario killing their vagrant vm and reinstalling it or worst case a 3page installationconfiguration document to follow on a fresh vm and the list goes on... sure there is some overhead involved people need to learn a new tool and have a bit more feeling with how software is deployed but from an infra pov that's a good thing.kubernetes? yes that adds a ton of overhead certainly initially. few really need it but if you move from a monolithic app into a more microservice based architecture for scalability issues something like k8s is a godsend. what i do notice however is that once teams are accustomed to a workflow involving it after building a large application they actually enjoy it and also start using it for smallerones. architecturewise it's easy to go overboard with the microservices splitting things up simply because they're 'cleaner' but that's something you should resist.but as you say for smaller web apps microservices make no sense...;0
18265623;HackerNews;2018-10-20;the comment was arguing the use of microservices is far more common than the need for microservices.in rereading the parent comment several times now and taking some time to reflect on it i find that i am not able to agree with this interpretation of it.as i understand it the parent comment is taking issue with any type of reaction to a monolith in the direction of switching to microservices as a tactic to get rid of the blockage and tech debt. the comment does allow that some cases may support the use of microservices but this secondary comment is so at odds with the sanctimonious tone sardonically criticizing people who want to migrate to soa from a monolith that i just do not find that phrasing to contribute much to my understanding of the comment. it seems clear to me that the comment means to harshly denigrate the idea of wanting to switch to soa as a solution strategy in those cases and the concession that sometimes it might be the right thing to do is tacked on not really related to everything else.i accept that we might just agree to disagree on the interpretation but i still feel comfortable that my original interpretation is the most consistent with the available text of the comment and the context of it.;0
18264471;HackerNews;2018-10-20;the comment was arguing the use of microservices is far more common than the need for microservices. and based on your description it sounds like you guys were one of the few that had a need for microservices.;0
18262823;HackerNews;2018-10-20;some amazon teams have multiple services of varying sizesyes. i'm not saying that is 1 team runs only 1 service but with microservices people tend to refer to much smaller daemons.;0
18261777;HackerNews;2018-10-20;i dont see how you get that at all. the comment starts out expressly criticizing when organizations consider migrating to microservices from existing monolith projects.;0
18261062;HackerNews;2018-10-20;yeah i definitely agree with these points. and i think quite a few of them come down to one simple thingthere's a huge disconnect between what many developers wish they were doing and what many developers are doing. they wish they were at googlefacebookamazonwhatever working on some complex greenfield project that'll change the world they're instead working on crud apps for corporate clients agencies and businesses with far less technical needs.so their obsession with using microservices and modern javascript frameworks and complicated build processes and what not for everything comes down to them trying to turn b into a even if the actual solutions they need don't actually require any of that complexity.;0
18260447;HackerNews;2018-10-20;as people already said there is little point on talking about hypotheticals since those properties are inherent...but there are tools that can distribute a program over a network and let your functions run at any node with the right capabilities just like the network allowing if it was local.this is another point that the microservices pushers miss. it's a solved problem and can be done in a much better way than what they push around.;0
18259665;HackerNews;2018-10-19;you have a problem. you decide to use regular expressions to solve it. now you have two problems.you have a problem. you decide to use microservices to solve it. now you have ten problems.;0
18259126;HackerNews;2018-10-19;yeah he wrote that iafteri he realized that the microservice movement he spawned had gone nuts.;0
18258894;HackerNews;2018-10-19;i am just starting to develop web apps. is jamstack lambda functions aws lambda a good place to start with?since lambda functions are similar to microservices i am now confused if i should stick to simpler backends or full stack instead of jamstack.;0
18258613;HackerNews;2018-10-19;i don't like the phrase microservice because it now has a certain amount of baggage similar to service oriented architecture which it was meant to be somewhat of a counterpoint to. whereas the issue with soa was its association with malignedfeared technologies soap wsdls corba the issue with microservices is the implied granularity. soa was a good idea but people particularly in startups don't want to say they're doing soa because it has oldschool corporate connotations. on the other hand the granularity of microservices seems too extreme for what most products would actually need but the concept is associated with more modern technologies which are attractive to developers like grpc or avro or kubernetes or even something as simple as http. so i would say the most pragmatic approach for a greenfield web product rather than a corporate it integration is have a fairly standard core probably a rest api a serverside mvc framework or a graphql backend if you're nasty and factor out services that make sense to the team maybe a service that handles push notifications or a service that does image processing or a service that is the secret sauce of your product because they need to scale independently or handle asynccomputational tasks that should have dedicated resources or they pull from a data source that is orthogonal to the rest of the system. you need to strike a balance between micro and service.there is this idea that you either have microservices or you have a monolith while its really more of a gradient. i guess what i'm advocating for is modern serviceoriented architecture or chunky services vs microservices reasonably sized wellconsidered services that use modern technologies for interservice communication.;0
18258518;HackerNews;2018-10-19;whats fun about microservices? i find them annoying but a necessary evil depending on context.;0
18258244;HackerNews;2018-10-19;you're blurring the lines a bit between the true definition of microservices eg no shared schema data structures etc and just a sensible deployment architecture. if their runtime state is independent then there is nothing stopping you taking your monolithic code base and deploying it n times for as many independent end points as you want. that way service a crashing is never going to bring down service b but they can still share code and data structures.the real question is do they have shared runtime state? if they don't you can do the above but if they do moving to microservices won't make that go away it might even make it harder to deal with.;0
18258193;HackerNews;2018-10-19;i have a islightlyi different opinion. start with a mostly monolith sure that makes sense. but also start off with just ionei separate microservice for something important. it's important that you establish good patterns for integrating services in to your codebase early on. its really easy to write a monolith without any thought of external service abstraction which makes it way harder to do down the road if you decide you need to.;0
18258080;HackerNews;2018-10-19;when making generic rules one should provide a lot of context. i have found that a fairly large rearchitecture is needed to move from a monolithic product to something with microservices. it is not something to grow into that way.and the technical reasons to move will be mostly for fault tolerance and resiliency you dont want your whole service to go down because a small widget failed somewhere. of course this does not come for free.basically its not that one is better than the other for all cases. this is a case where people should consider many things including nontechnical aspects before making sweeping statements or decisions.;0
18257995;HackerNews;2018-10-19;a syntax error should never make it production if you have even half decent infrastructure... in a monolith or a micro service.and if your microservice get to production with a syntax error do you really think the whole ecosystem is somehow more healthy? not unless you wrote a ton of horrible defensive code with and retries and http errortimeout catching code every time this service is called...;0
18257890;HackerNews;2018-10-19;i disagree. you can have fast delivery with monoliths ime microservices provide better separation of concerns which one the benefits could be faster delivery.however your end user doesnt interact with microservices they interact with a product. microservices suggested as a delivery silver bullet tend to be ways managers try and mask the fact that they are trying to hire 9 women to make a baby in one month.;0
18257842;HackerNews;2018-10-19;the newish argument for microservices is that they enable compositionality so wouldn't that same hypothetical apply? i.e. some 10xer is short on time and glues a bunch of microservices together and now you have the same problem but worse because there's no ide allowing you to trace the code?;0
18257833;HackerNews;2018-10-19;in my experience microservices have been prescribed as a sales bullet point instead of a software architecture decision.every time it's resulted in insane low traffic bottlenecks all over the place as services chatter away or separately need to look at he same file data so all request a copy etc.any architecture has tradeoffs and it's poor form to pick one before you've even described what the software is for.;0
18257823;HackerNews;2018-10-19;business is pressuring tech teams to deliver faster and they cannot so they blame current system derogatory name monoliththey are not wrong though monoliths cannot give you fast delivery. fast delivery implies at least expressive dynamically typed languages with some resilience to bugs which in turn requires limiting the scope of bugs and therefore decoupling and isolating everything as much as possible. this is very different architecture from monoliths. microservices are a first step there but of course not a substitute for lightweight isolated processes and supervision trees. still monoliths are definitely bad choices in every way possible if you can split them into isolated services.;0
18257779;HackerNews;2018-10-19;isn't the argument that is being made that you did things exactly right. that microservices are a great architecture to migrate to when you feel the need. but aren't a great to start a project.;0
18257711;HackerNews;2018-10-19;if it only forces clean boundaries then i agree you shouldnt be using microservices. the main benefits of microservices are things like fault isolation and better security since you can run different components with different privileges.;0
18257706;HackerNews;2018-10-19;as you correctly point out microservices ! soa. so a critique of microservices doesn't imply a critique of soa.;0
18257634;HackerNews;2018-10-19;i once worked with a team that wanted to use microservices because they felt like a monolith approach for their webapp wouldn't support their user base long term.they had 400 users serving roughly 40 requests per second. their database was small enough to fit into ram on my cell phone.i'm sure there are 100 valid reasons for billion dollar corporations to use microservices. but most of the uses of it that i've experienced personally were not ireallyi warranted for any technical reason and were usually some combination of nontechnonproduct problems bleeding into the codebase. whether that's inexperience mismanagement communication issues lack of leadership political strife tacit permission to silo oneself off developer boredom or whatever.;0
18257373;HackerNews;2018-10-19;this article and articles like it presume some magical workforce you can hire that will transform or organically evolve your application into a microservice ecosystem. but the fact is that people who know how to execute a microservice architecture muchless willing to work on your particular budding application are few and far between. so if you dont know how to build microservices it seems really hard to start with microservices by factoring a live running application while you are also simultaneously trying to keep that application up and functioning and feature developing in order to monetize it. wow does that sounds difficult.so it makes more sense to me to build out from microservesthey can be embedded in one jvm or whateverso you know how to organically evolve and can focus on monetizing your application.;0
18257294;HackerNews;2018-10-19;there is a lot of tooling for getting started with microservices nowadays.;0
18257044;HackerNews;2018-10-19;my problems with microservices irl1. sharing models the models can be moved out to another repository or a nuget package but guess what happens when you have to modify them? inevitably devs duplicate models.2. debugging across five different code bases have fun changing all the environment variables to point to your local every time or running five different applications at the same time for local development.3. docker and kubernetes add a lot of overhead.4. multiple frontend apps combined into one coherent site always leads to routing problems...and token management problems.5. web components cause bloat by pulling in web component scripts and the fact that each web component needs to fit the style of the whole site. since shadow dom is isolated each component pulls in styles again slow. again debugging and checking in web component code is a pain.6. finally siloing is inevitable.imo this doesn't make sense at all for a smaller web app.;0
18257030;HackerNews;2018-10-19;thanks for the clarification but it doesn't negate my point. it supports the idea that scaling is a lousy motivation for my team to adopt microservices.;0
18256952;HackerNews;2018-10-19;i would just like to add that i consider there to be two types of microservices one is developer focused which is what most people are talking about when they say the word but the other is operations focused which is some sysadmins have finally been embracing.when it comes to the sysadmin version since you may be wondering it mostly means decoupling entangled services into seperate less centralized bins bringing more resilency and quicker diagnosis timeframes when problems occur.;0
18256924;HackerNews;2018-10-19;a simple syntax error in a monolith means the whole monolith is crashed. bug anywhere in the monolith could mean border effect in the rest of the code anywhere. with microservices you guaranty isolation so a bug in one microservice won't have impact on the rest of the api;0
18256864;HackerNews;2018-10-19;reality is also confusing.people can see that in a one day hackathon the same bunch of people can produce more stuff than they do in a year otherwise. why? are they lazy? did they use better tools?my niece shelly added address book integration to her hobby app in an afternoon while drunk. whytf are we 640 man hours deep into identity architecture coordination meetings?!! just do with shelly did!those things don't make total sense even to even the saltiest of developers. they know to expect it but can't understand it. neither can i honestly. it's not surprising this gets so many people.a lot of the hairy abstract rabbit holes we climb into whether organisation like agile or architectural like microservices are an attempt to solve the 1001006 wtf! problem.;0
18256793;HackerNews;2018-10-19;i am in the middle of implementing a pocmvp of a greenfield micro services architecture that i was assigned to do at work.my background is more monolithic and some soa so i have had to adapt my thinking to try to make this work.i am an open minded architect and always willing to explore what the good and bad takeaways are from a given approach.i think that microservice architecture gives us a chance to think about what would happen if we thought of an ecosystem of applications fully decomposed into a fabric of services.the first and hardest thing i have encountered so far was trying to understand the right decomposition into ideal smaller units something that is nearly impossible without understanding the requirements in full up front. i am not sure you can easily identify your servicedomain contexts and boundaries a la ddd perfectly enough when you are doing agile development and the microservice architecture is intended to be used by many applications.however there is a caveat if you build modules to be smaller it is easier to reason about what each one does by itself. so that part actually fits in with agile well.also if you for a minute imagine that network machine boundaries didnt have implications latency retries etc. and were as reliable as service calls and if you imagine that we had reliable distributed two phase commit it can be done but all subsystems involved have to understand transactions and someone has to coordinate it... i at least can start to see a picture that works.i believe microservice as simply to be an old idea build in a modular small form in a new light and i think it is part of us trying to evolve our system development and architecture further.dont look at microservice as a panacea nor fad. look at the problems it raises as opportunities to improve the problems it highlights and then suddenly all of this might make sense as a scaled up architecture that can start small and scale smoothly to big in the future.i believe its all part of the same journey we all have been on developing systems that go from local to global and maybe someday beyond.;0
18256586;HackerNews;2018-10-19;the term used before microservices got trendy was serviceoriented architecture or soa.so this isn't exactly a new idea.;0
18256581;HackerNews;2018-10-19;business is pressuring tech teams to deliver faster and they cannot so they blame current systemand are very often right about it. delivering monoliths can require such amount of bureaucracy and needless coordination that it slows everything down. i've seen it. inexperienced developers proposing microservices because they think it sounds much more fun than working on the system as it is currently designed.it doesn't matter who proposes something if its good idea do it. and in my experience it is indeed more fun in addition to other benefits. technology does not solve these problems.using microservices is a matter of organisation it has nothing to do with technology. it is nontechnical solution for nontechnical problem. any effect it may have on a technology is secondary to main goal. in the end it's absolutely the case that a movement to microservices is something that should be evolutionarynothing you said before contradicts that. and in direct need to technical requirementshow people are organized is not a technical requirement. for nearly every company out there a horizontallyscaled monolith will be much simpler to maintain and extend than some web of servicesto maintain yes. to develop often not.;0
18256579;HackerNews;2018-10-19;to be fair here is a direct e from the parenti»in the end it's absolutely the case that a movement to microservices is something that should be evolutionary and in direct need to technical requirements.«ii would argue that what you did is exactly that. perhaps with the caveat that it should have been done earlier.i'm not reading tha parent arguing that one should stick with a monorepomonolith until the end of time but rather providing a few thoughts around what might cause a push in applying microservices incorrectly.;0
18256575;HackerNews;2018-10-19;last few teams i've worked with microservices has come up multiple times and in at least 2 cases parties indicated that this was something they wanted to learn and that was part of the motivation. it wasn't part of the justification for microservices scaling and uptime and robust were thrown around but some of the private justification was i want to learn this stuff. not saying everyone has that motivation but it's contributed to my lack of enthusiasm. that and the relatively huge amount of cognitive overhead required for what turns out to be usually relatively benefit.;0
18256543;HackerNews;2018-10-19;this sounds sanctimonious and rife with the exact same inexperience and overly brittle purist attitudes you are criticizing.it really is true that huge monolith legacy systems might prevent dev teams focused on product growth from even being capable of doing their jobs let alone meeting aggressive deadlines.it doesnt always mean microservices or heavy rearchitecture is the right choice but sometimes it absolutely is.the places where ive seen the most value to pivoting away from existing monoliths often have benefited a lot from microservices.i was part of a group that split a huge tangled mess of search engine and image processing services in a monorepo into separate smaller web services and by further separating them into distinct repos per project we could migrate things to new versions convert some legacy java services into python to take advantage of machine learning tools that fundamentally do not exist in jvm languages all in more careful isolated ways that monorepo tooling just simply doesnt support and lots of other things that would not have been possible if we tried to steadily change portions while preserving their cointegration in a single large project that attempted to support modularization in ways that were simply just bad.your language seems to betray the fact that you personally associate the entire concept of microservices with being intrinsically dogmatic.typically only dogmatic people feel that way in my experience. but either way theres nothing inherently dogmatic about a microservices approach.;0
18256363;HackerNews;2018-10-19;although the evidence is sparse i feel that you shouldn't start with microservices unless you have reasonable experience of building a microservices system in the team.;0
18256355;HackerNews;2018-10-19;in theory translating an interfacebased monolith to a soa should be straightforward dropin some replacement classes for your services and you're good to go.in practice it's not as simple as that. serialization across service boundaries requires a bit of thought invoking a method via a local call stack can accidentally cause a blowout on an soa service buffer. network timeouts suddenly become a thing. latency might be an issue.of course these aren't critical obstacles and i agree that the architecture should look very similar no matter whether it's a monolith or microservice. but designing one from the ground up would look a bit different.;0
18256237;HackerNews;2018-10-19;you should always start with domain specific microservices. those microservices shouldnt be out of process services necessarily. they can just as easily be in process domain services in a monolith that are only accessed via an interface where each module is treated as a black box.;0
18256225;HackerNews;2018-10-19;fwiw as a developer on the firefox accounts team i strongly endorse the sentiment of this article. we've occasionally found ourselves merging microservices back together because the abstraction boundaries we designed upfront weren't working out in practice...;0
18256212;HackerNews;2018-10-19;microservices are a cult but soa is amazon's conerstone. most services are the right size to fit a team so not micro and implement separation of concerns.random link;0
18256202;HackerNews;2018-10-19;isn't separation of concerns addressed by modularization? of course using microservices is one kind modularization.;0
18256193;HackerNews;2018-10-19;iit's hard to turn a monolith architecture into a architecture with microservices.iits only hard if your monolith wasnt designed properly. in c parlance...1. from day one create your monolith with different domain specific projects where the functionality is exposed as an interface.2. all consumers of each service use a dependency injection framework to map the interface to the service not http service in process domain servicemodulenamespace.3. when you need to separate out a module to a separate service its easy to split that specific module into a separate service by putting an http front end on it. if you integrate swagger into your api there are tools to automatically create proxy classes for your client.4. your proxy client can implement the same interface the interface from step 1. just change your di appropriately.5. if you have modules that are shared between the monolith and new microservice create a package and a private package repo.;0
18256162;HackerNews;2018-10-19;but microservices are also about coupling just have a selfcontained service that does one thing.what stops you from creating a module inside a monolith with an interface that provides a selfcontained service that does one thing?;0
18256125;HackerNews;2018-10-19;they're subject to a clear limit though. the more micro you make your services the less they resemble operational units and the more they resemble primitives from which your actual system is built sort of like an innerplatform effect. and then you have to debug interactions between microservices with all the overhead that entails.;0
18256018;HackerNews;2018-10-19;isolated changes aren't a myth. faang and others leverage the isolation brought by service separation every day. for very large services a monolith makes it difficult to test services independently.i personally don't like the word microservices since it implies that services have to be micro. for the last few years i have worked on service oriented systems where the individual components are sometimes pretty big one could say almost monolithic .splitting a monolith into separate services exacts an operational price. engineers should be honest in assessing whether it's worth it. sometimes it is sometimes it isn't.;0
18255948;HackerNews;2018-10-19;mostly agree in full. but i think it's worth noting that microservices or any technology for the matter cannot fix a dysfunctional organization that's not clear about it's current and future business needs.does it fail sometimes? sure. but more often than not projects go sideways at the leadership team i.e. all stakeholders not just it level. blaming it is a convenient narrative.;0
18255935;HackerNews;2018-10-19;you really can get all the benefits of popular architectures without going off the rails!don't start out with a di framework use poor man's di ie 'passing stuff in'.don't start out with microservices use poor man's di ban all public staticglobal variables and segregate code into separate processes with public 'interfaces' but don't use actual interfaces until you actually need them! 1 interface per class is an antipattern!. these can all run in an async process pool you build which can monitor bottlenecks when you get to that point. you can then years later easily break an internal service into a microservice when the trade off makes sense.i'm obviously static typingoop focused but there's a version of this which applies to any paradigm.;0
18255915;HackerNews;2018-10-19;interesting that the article mentions shopify supporting over 600000 users with a rails monolith.at my day job one of the justifications for us adopting microservices is that we want to horizontally scale.we have fewer than 8000 users.hubris eh?;0
18255900;HackerNews;2018-10-19;i don't believe it os reasonable to portray microservices as the result of incompetence and blameshifting.microservices are actually a very basic and fundamental principle of software engineering separation of concerns. if your system is extensive enough so that it covers multiple independent concerns and your team is large and already organized into teams focused on each concerns then it makes technical and organizational sense to divide the project into independent services.;0
18255837;HackerNews;2018-10-19;this is a great list. i've been reflecting on this drive for microservices in early stage companies for the last four years and you hit all the major points.one additional one i'll add is the marketing objectives of containerization and infrastructure companies.and a good time to resurface martin fowler's monolith first;0
18255796;HackerNews;2018-10-19;bottom line is that it's all a case by case basis. however i'll always warn against slicing microservices too thin. each slice is a moving part outside of the machine and therefore brings in additional risk. i recently refactoredrewrote a monolithic project into a few fairly chunky services. each one is sliced by a broad context. the only reason i did it was because the monolithic app required separate physical deployments per client due to data sharing restrictions and the service model i won't call it micro allows sharing of the data i'm able and should share between them. perhaps we need a name for the model in between monolithic and microservices. maybe macro services?;0
18255656;HackerNews;2018-10-19;not if you know how to architect one properly.how is a small microservice with one purpose different from a class module with one purpose?;0
18255577;HackerNews;2018-10-19;imho the monoliths vs microservices debate is akin to monorepos vs multirepos they are both strategies used to share work when your organization grows. both can work well depending on your tooling and organization.but do not forget that those abstractions layers you add while very useful say for release velocity might also be a direct application of conway's law which means that refactoring some code might sometime require refactoring your organization so if you lack the ability to do that incrementally you might converge to an ossified system that stops evolving.;0
18255564;HackerNews;2018-10-19;it occurred to me a couple years ago when designing my deployment architecture that the majority of the complexity was just this. instead of letting linkersmodule systems do the work i was doing all that stuff first by hand and then basically writing my own form of linking logic to solve a problem we created ourselves. reminded me of when i read about the old ways people used to link code by hand...and yes we were definitely cargoculting...microservices were totally unnecessary for us. the only positive result is that it forced clean boundaries but those could just as well have been forced by thoughtful architectural design anyway.;0
18255549;HackerNews;2018-10-19;having worked in a payments company where slas can be very demandingwe broke our monolith server into microservices and realized that we broke in to too many pieces as our slas broke. every microservice you add to your usecase adds a small but fixed costand finally decided to convert some microservices into libraries to save milliseconds and bring down our 95th percentile i completely agree with the premise of the article.never start with microservice start with monolith with enough flexibility and inbuilt abstractions which can allow you to replace an abstraction with a monolith.;0
18255545;HackerNews;2018-10-19;this can sometimes be worthwhile in a corporate environment even if technically it makes things harder because it solves a major political communication problem.however for the expense of dealing with the complications of an additional network boundary to worthwhile some of the following must hold you need architect who has an overview of the whole system creates abstractions that make sense and puts the api boundaries in the correct place avoiding the tightly coupled microservices antipattern. you need good devops people who can track problems that span service boundaries. this is the one area where the company can't skimp i.e. no outsourcing of this position. without these people you get an epic political clusterfuck where everybody ends up blaming the other team for their problems. the two services need to be built by two teams which for whatever reason cannot be relied upon to communicate or work effectively with one another different orgs different country different company maybe. the two teams possibly use different programming languages.i believe these reasons are probably the reason why it worked wonders for martin fowler. then startups read his blog and decided that every team needed to build 15 microservices and the whole world went crazy thanks martin.;0
18255528;HackerNews;2018-10-19;microservices test driven development agile 4gl and so on. it's all the same thing a technique that is applicable some of the time but not all of the time that ends up getting a bad rap because the people promoting them tend to come from the theoretical side of the street and they see the subject matter as their new revenue stream. they will then promote it to be used even when it isn't applicable.a web based service can be as messy or as clean as you want no matter whether the underlying architecture is a monolith or a bunch of microservices. i don't like the 'micro' in microservices to begin with to break up a large and complex problem into multiple smaller problems that are each simple to solve is a core principle of programming. if you take that to an extreme you end up with services that do almost nothing and then you have a communications problem or at least you will have one in most environments you are likely to encounter. if you glue everything together in on giant hairball you don't have the comms overhead but you have a cognitive overhead in trying to understand it all.like with everything else there is a happy medium services that are easy to understand because they do not have horizontal ties to other parts of larger whole enough isolation to help you with debugging not so much isolation that you end up doing remote requests for data that should have been nearby.everything in moderation.as an illustration of 'microservices' done well i worked the last time i had an honest job as a programmer on a message switch for kvsa a company that brokers shipping capacity. super interesting job even more interesting architecture. right from day one contrary to the article title! it was decided the system was too complex to tackle as a monolith. the reliability demands and the latency requirements led to the base system being built on top of qnx a soft real time unix like operating system with a micro kernel. since in a microkernel environment message passing and service oriented architectures go handinhand the technique percolated through to the application level which ended up being a series of queues and 'admins' qnx parlance for a daemon or a service handling the inputs from these queues and effecting transformations on those inputs resulting in new outputs or side effects such as a fax or a telex being sent. the system worked flawlessly had a very high degree of redundancy built in and it most likely would have never made it to production if it weren't designed like this from day 1. for that particular use case it was ideal. in 1993 if you're wondering whether microservices are something new you have your answer.;0
18255517;HackerNews;2018-10-19;you can just as easily create an unmaintainable spaghetti mess of microservices. isolation is defined by good architecture microservice or monolith is just how it gets executed.;0
18255500;HackerNews;2018-10-19;most of the time i've found a push to microservices within an organization to be due to some combination of1 business is pressuring tech teams to deliver faster and they cannot so they blame current system derogatory name monolith and present microservices as solution. note this is the same tired argument from years ago when people would refer to legacy systemslegacy code as the reason for not being able to deliver.2 inexperienced developers proposing microservices because they think it sounds much more fun than working on the system as it is currently designed.3 technical people trying to avoid addressing the lack of communication and leadership in the organization by implementing technical solutions. this is common in the case where tech teams end up trying to do microservices as a way to reduce merge conflicts or other such difficulties that are ultimately a problem of human interaction and lack of leadership. technology does not solve these problems.4 inexperienced developers not understanding the immense costs of coordinationoperationsadministration that come along with a microservices architecture.5 some people read about microservices on the engineering blog of one of the major tech companies and those people are unaware that such blogs are a recruiting tool of said company. many most? of those posts are specifically designed to be interesting and present the company as doing groundbreaking stuff in order to increase inbound applicant demand and fill seats. those posts should not be construed as architectural advice or best practices.in the end it's absolutely the case that a movement to microservices is something that should be evolutionary and in direct need to technical requirements. for nearly every company out there a horizontallyscaled monolith will be much simpler to maintain and extend than some web of services each of which can be horizontally scaled on their own.i also wrote as a way to communicate some of this including some thoughts on when and how to structure a codebase monolith and when it might make sense to start moving towards microservices etc. there are cases where it's reasonable even advisable to move towards microservices but they are rare.;0
18255491;HackerNews;2018-10-19;there are many ways to slice an apple.sometimes it is a good idea to build something as microservices but you just have taken the wrong approach and therefore it is a pain in the ii. so slicing it a different way might still be a microservice architecture but feel much better.recently i thought about setting up a firefox sync server. the first bumper was when i learnt that the sync server has a dependency on the accounts server... but the fullfeatured accounts server in turn consists of a bunch of services of its own 1 fxacontentserver fxaprofileserver fxaauthserver fxaoauthserver browseridverifier fxaauthdbmysqlafter seeing that i decided to tackle that project another day.for mozilla that architecture might be perfect but for most people who just want to run a separate server for lt10 people that architecture is just a burden.1;0
18255379;HackerNews;2018-10-19;just like you have tests between monolith modules you can have integration tests between microservices;0
18255338;HackerNews;2018-10-19;i agree that microservices is the new must have technology but actually it isn't a great deal different from a monolith. the monolith can have separation between services and still requires interfaces to work between them.as others have said microservices bring a lot of baggage that you might never have seen before i.e. big learning curve and the myth of isolated changes is just that a myth. unless it is some low level thing you cannot change it without impacting other services and this is no different than a monolith.like the article yesterday about oop the same principles exist to write a good application whatever you use to do it.;0
18255335;HackerNews;2018-10-19;the argument here is that microservices are another level of code reuse with their own encapsulation.but microservices are also about coupling just have a selfcontained service that does one thing.;0
18255325;HackerNews;2018-10-19;and then another downstream microservice fails when you deploy your change into a running environment because you lack the integration testing capabilities of a monolith.it's true you achieve higher isolation with microservices but you also lose points in other areas. and you can get lost in your haystack of microservices just as easily as in your typical monolith;0
18255311;HackerNews;2018-10-19;though keep in mind that in microservice world suddenly you have dozen of problems you would never face in monolith world. you are forced to implement a good orchestration deployment segregate data between services and other stuff. it's all fun but takes time to dive into that and build the right process. for sure it is nice and sound once it's built but you might simply lose track of your primary product if you're solo project dev;0
18255309;HackerNews;2018-10-19;i grew out of microservices because it felt like i was doing the same boilerplate rest service over and over.so i made a modular rest api service that could load plugins. the plugins can contain anything from simple endpoints to database schemas with sqlalchemy. all this is loaded into the main app at runtime.so the main app can handle authentication against ldap for example while all the various deployed microservices can have their own roles.;0
18255290;HackerNews;2018-10-19;what i love about monolith is coherence and forcing you to do things well from the beginning. microservice mesh tend to become horrible to maintain after a few years when no one really measure which components will be impacted by a single change. on the opposite change one small 50 line function and your ide will happily show you all the calls to that specific function.;0
18255277;HackerNews;2018-10-19;what i love about microservices is isolation and forcing you to do thing well from the beginning. monoliths tend to become horrible to maintain after few years. on the opposite change one small 50 lines microservice is a lot less risky!;0
