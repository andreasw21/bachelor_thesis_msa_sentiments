ID;Source;Creation Date;Content;Sentiment
29999191;HackerNews;2022-01-19;Title:Starting with microservices, Content: https://arnoldgalovics.com/truth-about-microservices/;0

30017370;HackerNews;2022-01-21;in reality it worked each service only talked to the next so in that sense it was okay. but each service was its own binary running in its own container someone went to a conference and heard that s3 was made up of 500 microservices to they decided we needed as many microservices as possible. the bit where it didn't work so well was making changes and testing those changes the original developers hacked it together then didn't want to touch it after that so there was no dev environment just staging environments to hijack and no functionale2e tests.;0
30013896;HackerNews;2022-01-20;one problem i've never seen mentioned regarding microservices is what happens when the organization that produced them has moved from growing to stagnation and finally into decline. if microservices ship the orgchart what happens when that organization fails to attract engineers?i worked for a company that microserviced themselves into a pit. we had a huge layoff which completely killed the morale of the remaining engineering staff. over the next 3 years more and more engineers left and the company refused to replace them. what started out as teams 5 people responsible for 3 microservices ended up as teams of 3 people responsible for 6 microservices.it was kind of cool to be responsible for more architecture and see how it all fit together but the sad reality was that too many of the microservices that had been stood up were stitching together disparate data from other microservices to then perform what a single sql query against a rdbms was doing.;0
30013156;HackerNews;2022-01-20;there are plenty of monoliths that scale in terms of number of contributors and organizational changes. for example the linux kernel. i've worked on massive monoliths that were 20 years old and changed hands and org structures tons of times and nobody ever thought this needs to be microservices! microservices are not the only way to modularize code.nobody said that it was the only way to modularize code.however but to be frank most of those require greater discipline than most of the engineering teams going to microservices have. these teams don't do a great job at microservices but probably would do a worse job with a monolith. also there is tons of bikeshedding with regard to http. which http method do you use? how do you structure your paths? what does the body of the request look like? how to we translate failures into the various http error codes? do you send a 200 or a 201 status for this particular request? i could go on and on... even among well established http apis there are differences.you can bike shed anything that's why it's called bikeshedding. referring to nobody being able to contribute to the design review of a nuclear reactor so the committee just fights over the color of the bikeshed. that being said the state space of an http api is strictly smaller than a local library's api and you can generally expect backend engineers to at least know what complete the state space of options looks like and what the tradeoffs are. this is very much a double edged sword. i've seen this happen and people just tend to avoid services in languagesframeworks that they don't know. and even if they don't avoid them they are less productive in them. we have a critical services written in rust and one guy at the company knows rust. we have 2 services written in a particular java reactive framework which only a few people know how to use. any newcomers to these services have to spend a lot of time learning a new thing.the other end i've seen is that having the whole org on one tech stack is a single organizational point of failure. it's not an issue for smaller orgs but if you have more than say 200 devs working on the same product you want a little experimentation and a lower barrier to new technology. if something is abandoned you can simply replace it since it's not your literal entire stack. and forcing your devs to be polylingual i've found makes them better in all of the language they use even their primary language.;0
30009410;HackerNews;2022-01-20;we've been doing this too for some logical services. for example we might have a service which has a rest api and but also needs to do long running processing in response to requests via said rest api. the code for both lives in one repo and can share code data structure definitions databases etc. one container is made but we deploy it twice with different args. one is set to run the rest apiand the other runs the processing. both are closely related but in the cloud we can scale and monitor them separately. it gives a lot of the benefits of standard microservices with much less of the code and repo level screwing around. it relaxes the general microservices approach that one service one git repo one database one container one deployment in gcpetc.;0
30008779;HackerNews;2022-01-20;is it not better to debug one microservice than the whole monolith?as long as your bug is well behaved and decided to keep itself into a single microservice... and you somehow know what microservice it is then yes it's much easier.;0
30008464;HackerNews;2022-01-20;it's in fact exactly in horizontal scalability that it becomes important to have control over exactly what resources you need to scale let's take a typical monolith. you'll be serving endpoints that are cpu intensive are memory intensive are io intensivethey are almost always heavy on some part but not all. and definitely they are not uniformly all relying on the same amount of resources.now you scale out horizontally adding instances of the same size because each of these monolithic instances need to be capable of serving the entire domain without impacting tail latencies. some part of your application becoming more resource intensive? you'll be bumping up the sizes of the entire monolith because you are essentially needing to do the equivalent of provisioning for peak load.contrast this with microservices which i'm not arguing are a silver bullet you can run your memory intensive part of memory optimized instances and run your compute intensive parts on compute optimized instances.that's the part about scalability.now the more interesting part for me personally is ireliabilityi. you are decreasing your blast radius of a bad componentthreadprocess taking down your entire monolith service and instead compartmentalizing it into limited subparts of your entire api or application.finally as you mentioned microservices do help guide you towards better choices when it comes to structuring your data. you can do this with monoliths as well and should but it doesn't come naturally and having a single data store is the main reason i see teams run into scalability issues addition some thing i don't see many people talk about is the ability to address techdebt in microservices. my experience has been that it is an enormous benefit to have made you domain smaller for when it comes to making changes that require sweeping across the whole codebase. examples include upgrading language versions e.g. scala 2 3 haskell 8.10 9.2 upgrading frameworks introducing stricter compilation checks e.g. typescript and strict true.these easily end up being either insurmountable or yearlong projects in a monolith where it's very hard to incrementally benefit from the work because they are often by nature all or nothing changes.;0
30008049;HackerNews;2022-01-20;there are plenty of monoliths that scale in terms of number of contributors and organizational changes. for example the linux kernel. i've worked on massive monoliths that were 20 years old and changed hands and org structures tons of times and nobody ever thought this needs to be microservices!microservices are not the only way to modularize code.also there is tons of bikeshedding with regard to http. which http method do you use? how do you structure your paths? what does the body of the request look like? how to we translate failures into the various http error codes? do you send a 200 or a 201 status for this particular request? i could go on and on... even among well established http apis there are differences. letting technology choices drift on a per team basis is kind of nice to allow experimentation with different technologies without having to get the whole org onboard.this is very much a double edged sword. i've seen this happen and people just tend to avoid services in languagesframeworks that they don't know. and even if they don't avoid them they are less productive in them. we have a critical services written in rust and one guy at the company knows rust. we have 2 services written in a particular java reactive framework which only a few people know how to use. any newcomers to these services have to spend a lot of time learning a new thing.;0
30007491;HackerNews;2022-01-20;isn't 5 just... microservices in a monorepo?;0
30006774;HackerNews;2022-01-20;gutfeeling microservicesi'm in this comment and i don't like it.my current team has this pattern. i think we've ended up with two core services with a fairly thin channel between them but a constellation of tightlycoupled peripheral services around each core.to be honest it works pretty well. it wasn't intentional and it grew in exactly the haphazard way you describe. but it's not a disaster or at least doesn't feel like one.maybe we should rebrand this as natural microservices?;0
30006633;HackerNews;2022-01-20;gutfeeling microservices is a fantastic definition thanks for that.;0
30006313;HackerNews;2022-01-20;thats not true. people in industry commonly refer to the consequence of their misguided decision to embark on a microservices adventure as a distributed monolith.;0
30005951;HackerNews;2022-01-20;i'm guessing more than a few here have seen and been burned by colleagues jumping on the microservice bandwagon plenty of developers think microservices good regardless of how the system is architected.;0
30005820;HackerNews;2022-01-20;you know what's underrated and underused? encapsulation and common sense. you can't just do microservices for sake of microservices but if you see that one of domains in your monolith is growing faster than others it might be good idea to split it to microservices. every decision has to be reasoned by something. if you don't know or you haven't done basic designing like event storming then you should start with monolith because it's easier to take step back.choosing architecture has to be conscious not based on trends or beliefs. even small app can be easy to mantain and develop in miroservices manner if you know why you decided to split it up. don't do or don't stop doing this because you read some comments on hacker news or reddit;0
30005624;HackerNews;2022-01-20;ive coined the term microlith but im probably not the only one and it may not be what youre thinking of. i wrote about it in the new edition of my book and also discussed it here;0
30004780;HackerNews;2022-01-20;the nice thing about microservices is that you don't need iron discipline to maintain modular boundaries instead its just how things work.i like to analogize it to assembly vs structured programming languages or c vs java you can write the same programs in either you can write bugs in either but there are whole classes of pitfalls that get erased by moving from one language to another.;0
30004543;HackerNews;2022-01-20;is it not better to debug one microservice than the whole monolith? easy to run locally easy to reproduce errors etc. my last two weeks was working in such an environment hunting a production bug. debugging it was a pleasure. clear interfaces etc. of course when a small feature requires changing 34 microservices the pleasure is definitely less dit's much easier to test them in separation also. deployments are low risk not much need for coordination with other teams etc.there are components that have a heavier load so we run more of those. not really a big difference compared to simply running a few more monoliths and configuring them to only handle certain requests... but that's already a given here.i don't have strong opinions either way. teamscompanies should do what works for them and they should spend some time on improving it so they can be more effective. because most peopleteamscompanies have a good enough complacency inertiabias. and most solutions work in both setups. eg. making builds fast requires a divide and conquer strategy anyway. do you build modulespackages separately and link them in the end? do you build containers separately? same thing. do whatever works.;0
30003780;HackerNews;2022-01-20;this cycle of having a few years where the costs of an approach aren't acknowledged to a few years where the benefits aren't acknowledged is very lame.well said. i do sympathize with some of the criticisms but only insofar as people who didn't have experience with microservices get sold on a lot of hype the tradeoffs aren't made clear and they get burned. the cycle seems to be this is the silver bullet for programming complexity! for a few years followed by a few years of this isn't a silver bullet! before the next big thing tm comes along and the cycle starts over.;0
30003611;HackerNews;2022-01-20;if microservices were a bad idea we wouldn't all be running gnu herd right now.;0
30003580;HackerNews;2022-01-20;microservices mix several different needs scalability function decomposition and team structure. if you want them all you might want microservices but there are better alternatives when you only want one or two of them.people have different opinions on microservices because microservices is great when done right but can easily screw things up if people don't split the bounded contexts carefully. it's also more expensive to correct these mistakes because there are apis between them instead of just code so many projects would live on with them painfully forever.;0
30002685;HackerNews;2022-01-20;what part of microservices says things must be separated by way of an arbitrary wire protocol?that's not a requirement cf. erlangotp.but to qualify as a microservice you need it decoupled enough that you can independently deploy andor restart individual services. pretty sure that's a minimum to call yourself microservicebased and hard to do by just using classes in c or something.arguably you should also have quite a bit of control over dependencies and their versions. if your service isn't ready for python3 it can keep using python2 or whatever. taking this to the extreme would generally mean a black box that serializes everything over a network so that any service can be implemented on any stack. i'm not sure that's fundamental to the idea of microservices though.;0
30002436;HackerNews;2022-01-20;even with language modularisation you lose the ability to provision modules independently if they are bundled together in a single service.microservices and monoliths are opposing extremes on a scale. there is a range somewhere in the middle which is entirely sensible.i feel like i've found my greatest success with my service abstractions by separating things out based on resource and availability needs of the functionality.;0
30002315;HackerNews;2022-01-20;more smaller microservices bring along a combinatorial explosion of failure scenarios.;0
30002181;HackerNews;2022-01-20;that's exactly what i'm doing for my almost fulltime sideproject.while we do microservices at work distrubited team and conway's law does make sense it doesn't make sense for me personally. so i applied all ddd logic and implemented it in my app.in dotnet there is a useful feature where functionality from referenced projects is included in your main webapp. which makes everything pretty clean.i use application logic over 2 gateways. where a gateway is a dummy solution that contains swagger global things for that project eg. auth verification and uses the controllerslogic from the referenced projects. spa angular that contains a ocelot gateway on the same domain no cors issues apigateway contains all the backend api logic and custom integrations with partners. shopgateway is included in the frontend. frontend the shop itselve. currently in the process of making this dbless everything over api messages or using the gateway. the gateway is currently a referenced project see up so everything is pretty fastin the meantime i can make reasonable quick adjustments and the logic is really flexible.overview of the solution note db migration from 1 project to this is not complete yet . but it's one of the bigger shifts and i'm already 90 finished before i can start the actual shift to martendb from ef dapper if you want a quick summary on the logic behind ddd would be the answer.;0
30001980;HackerNews;2022-01-20;yeah the biggest problem that people get into with microservices is that they allow the communication structure to dictate the app structure. a monolith gives you some refactorability because you can run what would have been integration tests locally as you massage your module boundaries to match the problem that you're solving. so a monolith can become a clean monolith and then a clean monolith can maybe become microservices if you need the scale attributes.the basic problem is that before you know where the module boundary is you cannot have a clear module boundary. so three popular approaches emergea ddd milliservices. basically define the different sorts of users come up with a clustering of the different sorts of people that you think will be using your app. people are considered to be in the same cluster if they use the same jargon to refer to things or different clusters if they both use some word but they both mean subtly different things by it.b gutfeeling microservices that become feature microservices. i should probably have an auth service i don't know what it does but i'm going to be doing auth so that's probably a service. i need to import a git library to contact github probably there should be a git service that handles all communication to github or other git repos. each of these things exposes some swaggeropenapi docs maybe we should have a docs service? that sort of thing. the danger is that the things that are easy to break off are usually not the core competency of the product and so there emerges some sort of core services one or two big honkers that basically are monoliths. people are aware that they aren't supposed to keep adding to the core services and so new services emerge named after feature requests hello sharing service hello wallet service. except the core usually is tightly coupled to these new feature services and they all kind of connect to each other. the idea of splitting the core services into other services to fit the newfound module boundaries becomes complicated by all these ties to nearby features you are not actually loosely coupled because you do rpcs and you probably code in the expectation of success into these rpcs like method calls.c every noun becomes a nanoservice. this is a service that watches just one or two tables or nosql document types or what have you and exposes a crud api for that noun plus a couple auxiliary verbs to do actual business needs with those nouns. so if you were implementing git there would be a file service a tree service a branch service a commit service probably a working tree service... but you just have to know that logs and rebases and cherrypicks live in commitservice while diffing for some reason lives in treeservice and adding a file to your working tree requires first creating it in fileservice and then handing that link off to the workingtreeservice which will make needed calls to treeservice creating your own tree is exposed via treeservice's crud but the developers tell you that down that road there be dragons and you should not have been messing with that.any of these three can be successful but only insofar as you can create new module boundaries and move module boundaries and test to make sure that your users will not notice any performance regressions. of them i would only recommend option a because it gives a really nice place for these tests to live and an intuition that each test should document a user journey for the system.;0
30001930;HackerNews;2022-01-20;ive done monoliths and microservices. having a monolithic codebase with many entry points is my preferred.;0
30001904;HackerNews;2022-01-20;im going to be the contrarian in this discussion. i think microservices are awesome and ive deployed architectures in anger in both java and go. 100 would and will do it again.most of the problems people are talking about seem to be around using microservices inappropriately without sufficient preparation or when an application is not complex enough to benefit from it.microservices are not a panacea any more than any other architecture. properly implemented they have significant strengths vs monoliths but require experience to get right.properly implemented monoliths built by experienced developers are likely to strongly resemble microservices but without some of the advantages that i enjoy.as others have said its not all or nothing one or the other but i dont get the hate for microservices here.;0
30001903;HackerNews;2022-01-20;yes but microservices maximize cloud vendors' revenue compared to monoliths.;0
30001898;HackerNews;2022-01-20;need ultra stable? more and smaller microservices usually better.i don't think i agree with this statement. more and smaller also means potentially more routing and communication paths thus increased latency and complexity.;0
30001892;HackerNews;2022-01-20;the example given of adding new instances of a session service that consumes from a kafka topic is completely wrong.kafka producers use a partition key of your choice so the userloggedinevent and useractivityevent that relate to the same userid will always be written to same partition. this is how horizontal scaling of kafka consumers works without ordering problems. anyone that isn't aware of this has very limited experience with kafka and eventdriven microservices.i respect the author's attempt to give some balance but i think some parts aren't well informed.it's important to understand the benefits of microservices and the costs. small focused projects have small fast test suites can be wholly owned and developed by a single team amongst many can be released and deployed without fear of breaking unrelated features across a vast platform can be retired easily when obsolete. they also introduce the complexity of communication across many systems to complete an endtoend journey and require incredibly careful design and carefully chosen boundaries and responsibilities if you want to allow each one to evolve independently. this takes time and experience and many organisations get themselves into a big mess with no governance consistency or cohesion across a confusing sea of services and teams.there's no free lunch but let's get beyond fashiondriven lurching from one extreme to another. this cycle of having a few years where the costs of an approach aren't acknowledged to a few years where the benefits aren't acknowledged is very lame.;0
30001798;HackerNews;2022-01-20;companies that arent b2d have a hard time with monolithic architecture. they simply have too many disparate needs teams vendors and timelines to try to force everyone to share a codebase unit of deployment and set of endpoints. the supply side and demand side of any business has vastly different objectives slas and priorities. should we have to wait two weeks to deploy a minor patch to the purchase order portal because there is a risky ecommerce deployment that needs to be finalized first? do we need to scale up the web servers to batch process some nightly data?surely there are excesses in the realm of microservice architecture every library is a microservice is advice ive read in the past. service discovery routing isnt easy. naming things is hard.personally i prefer the term service and try to make no prescriptions as to what size it will end up being.;0
30001789;HackerNews;2022-01-20;spot on. microservices is a way of scaling ipeoplei. there are other ways of scaling systems.i would suggest that http not be the goto mechanism for communicating between microservices. each should be able to operate to some degree without hard dependencies. if you build using microservices with rpc over http or whathaveyou replacing function calls you've done it wrong. you can usually tell if your 'bounded context' is of the form nounservice or adjectivenounservice. usually the context boundary should be a process workflow kind that serves a user type. reliable oneway async datastreams are more useful for keeping microservices fed with the information it needs and it can decide how to utilize that information in a way that makes sense for that service. if you have core 'source of truth' services used by many others you have a distributed monolith.;0
30001780;HackerNews;2022-01-20;microservices are all about starting and never about finishing.;0
30001649;HackerNews;2022-01-19;pretty sure microservices will be remembered as a horribly convoluted stop gap once we have better language modularization.they encourage modular patterns which is usually good but all that plumbing will eventually become unnecessary. i cant help but remember building 6 versions of each class in the old ejb days whenever i hear microservices hype.;0
30001648;HackerNews;2022-01-19;building ok but for testing or debugging microservices aren't really an alternative. just like scalability they add no new capability here. the most they can do is adapt better to some set of procedures than a monolith.for deploying they are nothing but a very large hindrance.;0
30001625;HackerNews;2022-01-19;starting a greenfield project with microservices is easy.that's an overstatement if i've ever heard one. staring a greenfield project with microservices is a nightmare. in a greenfield monolith you can code and deploy your dependencies together. in greenfield microservices? oh right. set them all up for deployment figure out netwroking and access between them any change requires the fixtestdeploy dance etc.;0
30001589;HackerNews;2022-01-19;ive never been part of a monolith that used a di framework but ive seen quite a few monoliths fail as in the project becomes too convoluted and iteration slows to a crawl until the project is canceled or effectively rewritten and i certainly believe that one important reason microservices do well is that they enforce the modularity that you describe. that said a lot of critics of microservices describe similar issues of indiscernible chaos so either ive been very fortunate or microservice critics are gaslighting us.;0
30001553;HackerNews;2022-01-19;we passed right by this mode of operation while migrating from microservicesmonolith. everything is a separate process but running on the same box. ran that way for quite some time. we pulled services into the main process onebyone. it went about as smoothly as one could have hoped for.;0
30001526;HackerNews;2022-01-19;we have a big codebase where i work and its written as a set of micro services. im a bit of a noob but i thought that micro services were always containerized. turns out we dont do that and it all runs in a very bespoke and poorly documented vm. now can we call this a microservices based architecture? i feel like we cannot it feels like worst of both worlds;0
30001521;HackerNews;2022-01-19;lifecycle management is also a big part of it i think.my search engine is a hybrid architecture with some monoliths and some microservices. index 5 minute start time and uses 60 of system ram. search server query parser etc. 30 second start time due to having to load a bunch of term frequency data low resources ephemeral state assistant server dictionary lookups spell checks etc. fast start medium resources stateless crawler only runs sometimes high resources statefull archive server fast start low resources ephemeral state public api gateway 5 second start time low resources ephemeral state a few othersa lot of the ways it's divided is along the lines of minimizing disruption when deploying changes. i don't have the server resources to run secondary instances of any of these so i'm working with what i've got. if i patch the crawler i don't want the search function to go down. if i patch the search function i don't want to have to wait 5 minutes to restart the index.it would certainly be cleaner to say break apart the index service in terms of design as it does several disparate things but those things have a resource synergy which means i can't not without buying another server and running a small 100 gbe network between them. seems silly for a living room operation.;0
30001498;HackerNews;2022-01-19;architecture astronauts ilovei microservices.i'm watching a government customer take simple cohesive systems developed by a small team 45 people and isplit it upi into tiny little pieces scattered across different hosting platforms and even clouds.why?because it's fun for the architects and pads out their resume.just now i'm watching a digital interactions project that will have dozens of components across two clouds including multiple etl steps. in all seriousness half of that could be replaced by a idatabase indexi and the other half with a trigger.they're seriously going to deploy clusters of stuff on kubernetes for 100 mb of data to make sure it scales... to 200 mb. maybe. eventually.what kills me is that now that they've made the decision to overengineer the thing my consultancy firm can't bid on the tender because we don't have the appropriate experience building overengineered monstrosities!the simple and effective solutions to problems we've delivered in the past are idisqualifyingi us from work.you guessed it my next project will be an architect's wet dream and will be over engineered just so that we can say on tender applications that yes we have the relevant experience.gotta play the game by the rules...;0
30001394;HackerNews;2022-01-19;pretty clearly the pros and cons come down to the application and necessary stability. need ultra stable? more and smaller microservices usually better. need fairly stable? bigger services is fine. need it to work generally? build it however you can.;0
30001328;HackerNews;2022-01-19;there's something to be said about the benefits of having a serialization boundary between parts of the code that's a natural consequence of microservices but it's something that could be employed in a monolith just as well. then if at any point you actually need to split out a module into its own process or machine it would be trivial to do.;0
30001319;HackerNews;2022-01-19;i notice there's a lot of comments here saying this exact same thing and it's also what seems most sensible to me. yet microservices are getting all the hype. should be hype a thorough modular design more?;0
30001312;HackerNews;2022-01-19;sure but i think the point is that it's unlikely the bottleneck will be in the web server but in whatever database you're using for your logins. just because you have a single program it doesn't mean it is required to use a single database.but even if the webserver is the problem it feels unlikely that you'll end up saving much in infrastructure cost by scaling just the login service rather than just deploying more copies of your webserver.not saying it is impossible but it's unlikely for that to be a good justification to adopt microservices. i'm not saying that there aren't good reasons to use microservices but i agree that scalability is not a good selling point. i'd actually argue that it's harder to build scalable microservices than monoliths.;0
30001285;HackerNews;2022-01-19;i've come to the conclusion that microservices as usually implemented are simply a conway's law concern.we haven't had a great track record defining the semantics of component boundaries but http is both simple enough that it constricts code flow in a particular way leaving a lot of misunderstandings and bike shedding discussions off of the table and is the ligua franca for external services owned by other orgs so your engineers can be universally expected to understand those semantics. there is a nice decoupling of letting teams make technology choices though. letting that drift on a per team basis is kind of nice to allow experimentation with different technologies without having to get the whole org onboard.maybe i need to go on the talk giving consultant circuit reselling a restricted view of di as hybrid service architecture! write your code as microservices but devops can colocate your apps in the same process if that's more efficient! lolzit's also quite a nerd trap as we developers love to separate components into as small of boxes as possible but just like i've seen super deep object hierarchies that didn't gain you anything at the end of the day it's easy to fall into the trap of spinning every tiny bit of code into its own service.i'm creating my own backend arch right now from scratch and really trying to look at each network traversal from a what does drawing this boundary actually get me perspective. and i'm only splitting that out because the third party protocol being implemented is inherently separate services in an interesting way.;0
30001046;HackerNews;2022-01-19;it seems over time some nuance has been lost in translation on this. microservices weren't 'more scalable' than monoliths they were 'more appropriately scalable'. in other words you could scale parts independently and shape your infrastructure more effectively for your workload. e.g. if your bottleneck is logins you scale the loginservice and don't need extra copies of the appointmentservice running to keep up.;0
30000782;HackerNews;2022-01-19;i have done the full theme park ride on monolithmicroservicesmonolith. both have ups and downs.the most important thing i learned is that microservices in absolutely no way necessitates bullshit spread across multiple cloud vendors and other scenarios involving more than 1 computer. what part of microservices says things imusti be separated by way of an arbitrary wire protocol?we now have a monolith process that is comprised of many microservices class files each of which is responsible for its own database business logic types etc. these services are able to communicate amongst themselves using the simple path of direct method invocation.if you are looking to scale up your capacity or even make things more resilient microservices vs monolith is really not the conversation you need to be having. if you are trying to better organize your codebase you might be in the right place but you also need to be super careful with how you proceed.we wasted a solid 3 years trying to make microservices solve all of our problems. looking back we spent more time worrying about trying to put humpty dumpty back together again with json apis and other technological duct tape than what our customers were complaining about.;0
30000604;HackerNews;2022-01-19;haha i was thinking the same thing. the code base of my startup is a monolith but in reality its a fork on request webserver sending messages to a collection of genservers actings as services.in essence creating a microservice with elixir is about the same amount of effort as adding a controller in rails.;0
30000596;HackerNews;2022-01-19;this is exactly what shopify does with their monolithic rails app 1. i worked at a company with 200 engineers that used the same general architecture and i really enjoyed it. we got a lot of the benefits clear interfaces teams able to work on their system without having to understand the whole platform build optimization etc without any of the operational headaches that come with microservices.1;0
30000595;HackerNews;2022-01-19;i wouldn't blame badly implemented di for all the problems of monoliths.i think the real main issue is lack of discipline when dividing the application into modules.spaghetti is basically defined as an application where real modularisation does not exist and everything talks to everything.it is much easier to work with an application when you can abstract parts of it when you are solving your problem. you effectively work on much smaller part of the application.spaghetti you effectively have to take into account possibility of the piece of code you look at interacting with any other piece of code in the application.well modularised application you only need to take into account the contents of your current module and the interface of the other modules you are using.one reason why microservices sort of work when done well is because they force people to think about apis and how those services talk to each other.in most cases you could just put these microservices as modules in a monolithic application and expend the effort on ensuring apis and application structure.i have successfully rolled back couple microservice initiatives by integrating services into monoliths. this usually results in the team getting back a lot of their time because their environment suddenly became much simpler. less applications to manage less network communication less possible ways for things to break less frameworks less resources needed to run the application less processes like processes around deployment release management etc. less boilerplate code and so on. the list is very long.of course when you work on a large monolith vs a lot of small microservices it is now important to be able to structure your applications. but there is also an opportunity for improvement.;0
30000577;HackerNews;2022-01-19;i never got the scalability argument of microservices. you can trivially deploy multiple instances of your monolithic web application chances are youre already doing so by running multiple workersthreads in your application server. spreading that to other machines is trivial.the real issue is in scaling the data store. microservices typically work around that problem by each having their own separate database but nothing prevents your monolith from also talking to different dbs.;0
30000453;HackerNews;2022-01-19;indeed the principal seems to often be forgotten. the why of monolith vs citadel vs microservices is ignored by some people.this results in k8sdrivendevelopment instead of microservices.;0
30000267;HackerNews;2022-01-19;this is what i do in practice. i've seen it called a distributed monolith.one of the good reasons to spend time with erlang or elixir is it'll iforcei you to learn how to write your programs with a variety of actors. actors are generally easy cut points for turning into microservices if necessary. as with many programming languages i appreciate not being iforcedi to use that paradigm everywhere but it's great to be forced to do it for a while to learn how so you can more comfortably adapt the paradigm elsewhere. my go code is not 100 split into actors everywhere but it definitely has actors embedded into it where useful and even on my small team i can cite multiple cases where actors got pulled out into microservices. it wasn't trivial but it was relatively easy.;0
30000174;HackerNews;2022-01-19;do you know what kind of software has an absurd level of horizontal scalability by default? web servers.the idea of splitting your web servers into multitiered web servers for scalability is well weird. yet somehow it's the main reason people keep pushing it. even this article repeats this.there's nothing on microservices that adds scalability. they make it convenient to deal with data partitioning but it's an ergonomics change not one of capability.;0
30000161;HackerNews;2022-01-19;in my opinion implementing strong interfaces and good modularization is something that we should talk about more than doing microservices.this is my position as well. strong interfaces good logical separation of function under the covers etc. should allow splitting off things at whatever level of micro you prefer.;0
30000041;HackerNews;2022-01-19;in my opinion implementing strong interfaces and good modularization is something that we should talk about more than doing microservices. in the end it might be easy to rip of a microservice when needed if the code is well structured.;0
30000025;HackerNews;2022-01-19;maybe it's just the activation energy. until you have the setup for making a microservice you're kinda limited to a monolith. once you pay the setup cost though making incrementally more services is trivial so you end up on the other end of the spectrum.;0
29999982;HackerNews;2022-01-19;i agree but the trend still seems to prefer one or the other and that's why it's so important to talk about the potential downsides instead of closing our eyes and saying everything is gonna be better if we do microservices.;0
29999872;HackerNews;2022-01-19;i don't understand why people treat microservices or monoliths as either or. if i find my various projects using the same functionality over and over then i'll split that off as a microservice to serve my monolith projects of various sizes.it's like functions don't turn code into a function until you need it in three different places.;0
