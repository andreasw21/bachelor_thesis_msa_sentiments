ID;Source;Creation Date;Content;Sentiment
32250722;HackerNews;2022-07-27;Title:You Don't Need Microservices, Content: https://medium.com/@msaspence/you-dont-need-microservices-2ad8508b9e27;0

32324945;HackerNews;2022-08-03;i can believe that monoliths have a lower theoretical icomplexity floori than microservice architectures but i don't think any shops are coming close to that theoretical complexity floor irrespective of their architecture so we need to think about the iactual practical complexityi of applications in each architecture.specifically i think the strong boundaries between components better facilitates maintainabilityas with dynamic typing the absence of rails allows people to more easily make bad decisions. in the case of monoliths this usually looks like an inexperienced developer especially at the bequest of an unscrupulous manager who swears that we will definitely not do this again and will fix in a subsequent release taking a dependency on another system's private internals. in other words i assert that given a good architect and an average team a microservice architecture will be less complex than a monolith despite marshaling data over a network. in order to have a wellengineered monolith you need good architects iandi a good team no unscrupulous managers who are empowered to compromise the architecture in the name of expedience. no guaranteed data consistency no global commit guaranteesyou don't get these for free with monoliths either. i've seen a lot of monoliths choc full of race conditions which don't manifest during development small contrived test cases running on unburdened systems. paradoxically because microservices have to marshal data over a network these consistency issues are more likely to appear. moreover people who work on microservices are more likely to think about race conditions precisely because the system is distributed indeed the architects think about this stuff when they lay out the interfaces.;0
32324785;HackerNews;2022-08-02;this is not inherently true. whether it's true or not is down to your implementation. you can most certainly have reliability and security problems while doing microservices.obviously i didn't claim you cannot have reliability or security problems while doing microservices.;0
32285485;HackerNews;2022-07-30;it's also worth noting that microservices are more secure and reliable as well since there's no vulnerable component that has access to all of the secrets nor a bunch of components that ought to be noncritical but actually are critical because anything can bring down the entire application for all other components e.g. someone makes a sync call in some leaf component that breaks the event loop for the whole application with failures cascading across your replicasthis is not inherently true. whether it's true or not is down to your implementation. you can most certainly have reliability and security problems while doing microservices.;0
32279889;HackerNews;2022-07-29;this is probably true if you have good engineering discipline in the monolith case such that your team adheres to good architecture. in the microservices case as long as your architect is competent you can draw sane lines between components and it's dramatically harder for idgaf managers and developers to violate them. everywhere i've worked the microservices approach ends up being considerably simpler precisely because it makes it difficult to do things that are probably bad ideas in the first place it's the same concept with static typing by the waya sufficiently smart team may not need explicit types but in practice most teams aren't sufficiently smart and the types function as rails to keep people from doing dumb things. every place i've worked the network and complexity overheads are paid for many times over by the simplicity and performance of preventing people from doing dumb things.it's also worth noting that microservices are more secure and reliable as well since there's no vulnerable component that has access to all of the secrets nor a bunch of components that ought to be noncritical but actually are critical because anything can bring down the entire application for all other components e.g. someone makes a sync call in some leaf component that breaks the event loop for the whole application with failures cascading across your replicas.;0
32272760;HackerNews;2022-07-29;composing libraries offers some of the advantages of microservices but not all of them. for example a vulnerable library still has access to all of the secrets used by any other library whereas a vulnerable microservice will only yield the secrets it needs. similarly a critical bug in one library can bring the whole process down even if the library itself is a noncritical componenta critical bug in a microservice will only tank that service and maybe services that depend on it if they dont degrade gracefully. notably linux and windows spend tremendous energy making sure these vulnerabilities and bugs dont slip through!;0
32272449;HackerNews;2022-07-29;i think the critical aspect of whether or not you need them and hence whether or not they represent a good set of tradeoffs is on what dimensions are you optimizing for.my previous employer was a small engineering org of around 40 engineers with a monolith of below average quality trying to go in a microservices direction and not really having that pan out a great deal due to being unable to spare the engineering bandwidth to invest enough in managing the complexity while still having to deal with the monolith.my current employer is an engineering org of around 4000 engineers that one two headed monolith that makes up the original product web app api share some code and are monoliths in their own right and also very successfully uses microservices for everything else and there is a lot of them.at my previous employer dealing with the monolith was fine even though the code was rather horrid and we would release twice a week. the microservices i wound up buildingworking on there were not worth the overhead complexity added at all and we would have been far far far better off investing in cleaning up the monolith to make it safereasier to work in.at my current employer dealing with the monolith is not fine. you have to book releases in a calendar it's scary it's giant and despite multiple releases of it per day there are so many other teams that book releases for it that you have to queue up to get your turn and it's done that way for safety. yes we also use feature flagging too. it's also vastly more difficult to knowfind who you have to communicate with about changes to the monoliths because unlike a tiny engineering org that information simply doesn't fit in your head. here the microservices we own are awesome in comparison. they are small code bases that are easy to reason about our organization invested a massive amount in the technical maturity needed to operate maintain and be able to handle the complexity and we have continuous deployment pipelines that mean we can safely release multiple times per day and when prs are merged they are shipped all the way through to production in around 15 minutes.so when you say more complex and slower you have to ask yourself than what? there is no one is better than the other there is only every tool is the right tool for some job and every tool is also the wrong tool for almost any other job it was not designed for and your job is to understand exactly what tool your specific situation actually calls for.this is why i like modular monoliths as a starting point as they're essentially a multitool. a halfway compromise which is not as easy to use as a fullblown dedicated tool but is versatile enough that if it's the only tool you have and you have no idea what job you're going to need to do then you've probably made an adequate choice regardless of what the situation calls for in the end. and if you outgrow your multitool you can much more easily swap it out for a set of it's dedicated equivalents.;0
32272161;HackerNews;2022-07-29;nothing magically makes microservices good or bad. nothing magically makes monoliths good or bad. it all depends on how good the developers are. however it is objectively a fact that microservides are inherently more complex than monoliths. you basically take a monolith and iaddi encodedecoding network latency delays no global commits potential timing issues partlyfailed system scenarios new types of distributed error conditions etc. to the mix. so there is zero upside to using microservices imho.;0
32272137;HackerNews;2022-07-29;microservices can most definitely be tightly coupled. the same way that most oop code i have seen is a spiderweb of tight dependencies. i ibeti that code you think is loosely coupled probably isn't. most developers have no clue what loosely coupled actually means.;0
32272104;HackerNews;2022-07-29;everything you claim is unproven and pure speculation. however what iisi proven to be true is that thousands of developers all over the world can effectively work on massive monoliths like linux and windows without using microservices.;0
32272092;HackerNews;2022-07-29;what problems are solved better with microservices? serious question.;0
32272085;HackerNews;2022-07-29;nope. 95 of saas products out there use monoliths not microservices. for igoodi reasons.;0
32272071;HackerNews;2022-07-29;thousands of developers use ilibrariesi and not microservices to implement linux and windows. if they can do it so can you. so no that is not correct.;0
32272053;HackerNews;2022-07-29;jane street using monoliths to manage bn of trades a day and millions of transactions per second. so nothing you say makes microservices necessary.;0
32272020;HackerNews;2022-07-29;you mean a client server system? that is not microservices.;0
32271934;HackerNews;2022-07-29;yep because it is true. microservices is just the latest silver bullet that inexperienced developers think will save themselves from doing bad work. the reality is that microservices is inherently more complex than monoliths. so the more you can discourage developers from making that mistake the better.;0
32271902;HackerNews;2022-07-29;that sounds like a true scotsman argument. the fact is that microservices are inherently and objectively more complex than monoliths. so if you can't build a well engineered monolith then you are pretty much guaranteed to build an even worse microservices system because you now have the added encodingdecoding network hops latency and timing issues no guaranteed data consistency no global commit guarantees etc. etc. etc.;0
32271878;HackerNews;2022-07-29;100 agree. you can write bad code using both monoliths and microservices. however microservices are inherently more complex iandi slower than monoliths because of the added encodingdecoding and network overhead.;0
32271847;HackerNews;2022-07-29;nothing stops microservices from having the same problems. plus all the extra problems you get with distributed systems timing issues logical dependencies etc.;0
32266812;HackerNews;2022-07-28;simple example.you have an app and just 3 microservices web recommendation engine payment gatwaythis means that the team that handles recommendation engine can deploy as fast as they want while the payment gateway which is brittle and mission critical stays put.if you have just a monolith then everytime the recommendation engine is tuned the payment gateway code is also redeployed with possible downtime contrived example but just to give you the idea;0
32266320;HackerNews;2022-07-28;i agree that it only really makes sense to consider when you have runtime concerns around performance that justify the added complexity. i posted that in a comment elsewhere. however i think the benefit to modularity can be significant sometimes. separating something into libraries is an exercise in organizational discipline and in my experience it often fails. an inviolable boundary can be valuable for orgs who struggle with that sort of thing.that said even small apps virtually always have hot regions. typically those can be ignored until big scale without impacting the users but that doesn't mean it's efficient to do so.i would also definitely push back on the idea that a monolith is inherently more computeenergy efficient. i'm not sure how you arrived at that conclusion but it doesn't take much in the way of efficiency gained from individually scaling services to make up for the tiny additional costs of your orchestrationcommunication.personally i'm a monolith guy. i think the discipline required to build and release a good monolith is typically easier than the difficulty of maintaining services. i would rarely recommend a microservice architecture. but i don't think it's in anyone's best interests to just pretend that the benefits of microservices don't exist.;0
32263530;HackerNews;2022-07-28;why do you feel this is relevant let alone detrimental to the idea of microservices? it looks to me that it's one of the primary positive traits.i did explain at the end of the sentence why it was relevant because rewriting in js would have also meant switching to a completely new language. which the team as a whole had less experience with and which would have made it a complete rewrite without being able to reuse anything. this statement makes no sense at all.i'm sorry you didn't understand it. if you asked a clarifying question i may have been able to explain. you stated the legacy codebase was crapno i said one team member stated that the code base was crap. i didn't say it was crap. i didn't evaluate it because i don't know and don't like php and because i didn't have to work with it anyway. the other two team members said the code was of acceptable quality for them to work on. and that a team member took up to himself to do the strangler's vine thing and gradually peel responsibilities out of the monolith. what leads you to believe this is stupid?because this is not what was going to happen and because they had been working on the thing for about 2 years back then without releasing it and because their planned release would have been in about 2 months. it's almost never about only the technology these products and services iservei a business purpose or provide value through other means. if it didn't matter you can of course take all the time in the world start over 10 times just to come up with what you think the best solution is for the problem. it's totally fine this is the artistic approach. if you follow the engineering approach then you have to factor in the time and the investment too. because in that case you have to deliver ivaluei.regarding peeling away gradually this wasn't really what i said. the person pushing for the microservices solution said they needed to irewritei. so stop the world rebuild the thing without having a working system during that period. because they didn't have a working system to start with.;0
32263182;HackerNews;2022-07-28;my 2c is that an experience architect would know that it would be ideal if they could do this and be right but in practice they aren't likely to get those boundaries correct upfront and it takes time and experience working in the domain to see what those boundaries truly ought to be. also it's perfectly possible for monolithic applications to enforce boundaries as strict as microservices do via a modular monolith approach where the domain contracts are marked as public but all the domain logic is marked as internal and a framework of sorts enforces that each module only has access to either it's own schema in a shared database or it's own separate database.these days i think that's actually where everything should start off. with a good implementation of this you can transition relatively painlessly to a distributed system and in the initial phases the simplicity of the buildtestdeploy cycle massively lowers the overhead compared to a microservices approach while the strong isolation of domain logic gives you the ability to reason about changes to your domain not affecting other areas of the system.having worked in both small companies with terrible monoliths small companies with terrible microservices big companies with terrible monoliths and big companies with semidecent microservices and then implementing a modular monolith myself i've seen enough to know that it's a solid solid starting point. most companies are pretty small and the difference between an engineering org of 40 engineers trying microservices vs an engineering org of 4000 engineers doing microservices is on such a different level that people who haven't experienced both likely can't appreciate the data point that they're missing.i love the strong isolation that microservices provide and they can be super beneficial but done at the wrong scale the wrong level of technical maturity or the wrong time and they're a huge drag. by the same token a monolith that grows too large for too long is equally a drag but it's one that's exponentially more tolerable in an engineering org of 40 engineers than it is an engineering org of 4000 engineers. the key thing isn't which architecture you pick it's the ability to be able to transition and adapt at the right point in time. modular monoliths buy you this opportunity at a fraction of the price and for much less risk.;0
32263062;HackerNews;2022-07-28;it turns out the secret is just not writing crappy software and having crappy processes. it turns out the caveat is that the conditional probability of those two things is vanishingly small so regardless of monolith or microservices most devs are exposed to crappy stuff and because their sample sizes are tiny they assume well we just did it wrong when in fact they did it average and average is crappy for any and all architectures.;0
32261587;HackerNews;2022-07-28;when i'm forced to work with a monolith that has 4000 source files and takes a few minutes to even start up and has about 20 configuration files that all need to be setup properly for it to even start i wish for microservices.when i'm forced to work with microservices that need skaffold and helm charts just to run locally but with the configuration in the monorepo being kind of mismanaged and strewn around a bunch of folders with no documentation in addition to debugging in the ide not working because nobody set it all up i wish for monoliths.really you can have good monolithic systems and you can have good microservices as well in addition to something in the middle actually the first blog post that i wrote the casual language probably shows its age.but there can also be plenty of poorly developed projects with either. it just so happens that people hate monoliths more in the mainstream culture because most of the older and worse projects out there were monolithic much like many hate java and other languages because of being exposed to bad legacy projects written in them just wait for 510 years and people's disposition towards both monoliths and microservices will even out the advantages and disadvantages of either will become clearly recognized and the hype will shift towards something like serverless. much like now we know the advantages and disadvantages of languages withwithout gc as well as higherlower abtraction levels pretty well consider python vs rust for example.maybe things will slow down a bit because kubernetes will also become a bit easier to use possibly thanks to projects like k3s k0s portainer and rancher.;0
32261447;HackerNews;2022-07-28;really? youve never seen an overengineered microservices design that could be a much simpler express app?;0
32260907;HackerNews;2022-07-28;it's a fascinating set of priories that lead to these policies.we trust you enough to run your code in production but we can't let you read another team's code because you might steal it. yes the odds that anyone wants to steal the code for this mundane microservice are staggeringly low... and yes you're going to be less productive and more prone to serious bugs by being in the dark but that's your problem.;0
32260171;HackerNews;2022-07-28;at a multibillion dollar company local development is impossible staging doesn't exist most stack traces from production are truncated because the log aggregator cannot handle log entries as large as java stack traces and most of the work involves migrating from talking to the database to talking to a microservice that exposes a single table of the database. what are joins?at another company that was acquired by amazon the user service team so again this is a microservice that exposes a single table of a database this time with a twopizza team dedicated entirely to that microservice told us that we couldn't just query the user service when we wanted to render a page containing a username given a user id because that was too many queries. product demands from a vp dictated that we didn't have time to set up our own caching layer for their service is this the responsibility of every team other than theirs? so we shipped the feature with the usernames saved in our own db and now when users change their usernames the old name will appear in the pages for our feature depending on when the pages were created.;0
32259361;HackerNews;2022-07-28;you have a problem. so you choose microservices. now you have n distributed problems and a system that is k times slower. well done.;0
32259290;HackerNews;2022-07-28;on the contrary. using libraries with clearly defined interfaces makes it ieasieri to combine those libraries into a single executable reducing deployment and debugging complexity. it also dramatically improves performance given the lack of intermediate encodingdecoding protocol code and tcpudp hops. experienced seasoned architects knows this and work hard to remove unnecessary distributed complexity from systems they design. while beginner experts always pick the most complex solution for the job at hand. the iworsti spaghetti code i have ever seen in my 30 year career is a 20 years old microservices architecture. so i cant wait to read the future we had a problem so we chose microservices. now we have n distributed problems k impossible to debug obscure timing issues articles.;0
32259207;HackerNews;2022-07-28;on the contrary. an experienced architect defines the boundaries and then the microservice architecture enforced them in a way that a monolithic architecture cannot.;0
32259135;HackerNews;2022-07-28;i dont know if you will need microservices or not. i can tell you that many developers and teams will do microservices poorly and will not get an advantage out of it and will have an even more complex ball of mud to maintain.;0
32259102;HackerNews;2022-07-28;a friend of mine is working on a 20 years old microservices application. it is literally the worst piece of garbage system i have ever heard about. i am sure my friend would have ilovedi for it to be a monolith instead of 50 services with massively complicated distributed dependencies and timing issues.;0
32258919;HackerNews;2022-07-28;you do need microservices because when when parts of you system are badly written or the requirements change etc etc..you can just shoot a couple of the offending microservices dead and replace them with better implemented versions.assuming there are at least 6 developers;0
32258127;HackerNews;2022-07-28;if it was a monolith i would have access to the same codebase so i could just go look at stuff in the code?versus microservices where i might not have permissions to look at their repos.;0
32257493;HackerNews;2022-07-27;i... the monolith they had was php just to add to the fun so switching over would mean switching languages too.iwhy do you feel this is relevant let alone detrimental to the idea of microservices? it looks to me that it's one of the primary positive traits. ithe guy he was a smart and motivated chap even started implementing one service in his free time ... which somehow screwed up the monotlith and made it start crashing.ithis statement makes no sense at all. iobviously it was a 100 stupid idea ...ii saw no stupid idea in any of your statements.you stated the legacy codebase was crap and that a team member took up to himself to do the strangler's vine thing and gradually peel responsibilities out of the monolith. what leads you to believe this is stupid?;0
32257390;HackerNews;2022-07-27;isame. i keep hearing that people have had bad experiences with microservices but i'm not sure what those bad experiences are. i certainly don't relate to them.ilikewise. when i see people complaining about microservices more often what i see is actually poorly thoughtthrough strawmen aimed at distributed systems which boil down to having to do network requests is bad.i wonder why attacking the microservices buzzword gets these people on rage mode but the sight of a web app calling a dozen apis somehow doesn't make them bat an eye.;0
32257336;HackerNews;2022-07-27;i wish these services were a monolith so there was any amount of discoverability at allwhy do you conflate microservices with discoverability? what's wrong with simply calling a web service? ... and i don't have to beg for time from busy people on other teams to help me use their undocumented apisand you believe that the same hypothetical team you claim doesn't document their api would all of a sudden documented all its internal?;0
32254689;HackerNews;2022-07-27;it still depends on the organization size or the size of the user base or the complexity of the product. so you may only have experience with services where it was the right choice.i did see two instances where it wasn't. i mainly work withfor small companies startups. in one instance i was called in as a tech leadexpert for a small startup having a kind of a productsoftware crisis. they've been working on their service for a year or too yes way too long and 23 months before the planned release at some random conference slush tnw or whatnot one of the developers figured out that the whole codebase was a piece of shit and there was no way they could be ready in time but they should rewrite it as a collection of node microservices and that could work. the monolith they had was php just to add to the fun so switching over would mean switching languages too.the guy he was a smart and motivated chap even started implementing one service in his free time the user registrationuser handling i think the least important and least complex one of course which somehow screwed up the monotlith and made it start crashing. or so they said i don't know what was up with that.obviously it was a 100 stupid idea and we went on with fixing their development process starting to do scrum and teaching the stakeholders that they need to stop phoning the developers directly and asking for features fixes introducing automated testing etc. oh and it was a team of 22.5 people. with the group manager doing some backend work too but also managing another totally unrelated project for another client.the other one was a bit different story where i just shared my insights over a call. a guy i've known took over a project that was built by a small team 25 people can't remember for a startup and wanted some external opinion for himself and the founder. that one was built as a set of microservices but they did have all kinds of stability issues. the idea was that it had to be veryverysuper scalable. because you know you launch and they will come and there's nothing worse than not being able to handle the load. except there is they had been building the thing for over 2 years back then.it was an online medical consultation solution you describe your problem pick a doctor do a f2f call and pay by the time. the funny thing is that i've built a very similar system as a startup cofounder 34 years earlier for psychology consultation with the help of 2 other guys who didn't even work full time one of them came after the first one quit. the mvp was up in i think 2 maybe 3 months. ours was a monolithish thing and theirs definitely looked better maybe scaled better and would have been cheaper to operate at scale we used an external service for the video calls. but ours was a iloti cheaper to build and launch and we could test validate our solution a iloti earlier with real customers.if it worked out we could have started breaking it down into multiple services asifwhen needed.;0
32254576;HackerNews;2022-07-27;i feel like http is too heavyweight for microservices. for monoliths it's great. and the only way to proceed in your case is to convert microservices into minimonoliths. particularly the authentication side which needs to be revalidated with every request.grpc might be better but supposedly so was soap corba dcom xmlrpc and finally rest.;0
32254276;HackerNews;2022-07-27;which is a good thing since microservices were iwayi overhyped from the beginning. now bashing too hard wouldn't be good either but fortunately the organizations that need it will be technologically mature enough to be able to ignore the current hype.whereas when microservices were overhyped they were introduced into orgscompanies that didn't have the brain powerexperience to implement these properly or just to be able to say an informed inoi.;0
32253987;HackerNews;2022-07-27;i just read yesterday that not only does my blog need microservices it needs microfrontends.;0
32253540;HackerNews;2022-07-27;where you can get a whole bunch of likes by saying microservices bad amirite?!okay.;0
32253092;HackerNews;2022-07-27;i implore you to watch the incessant and regular posts on hn claiming that microservices are the future for everyone and everything and then be there to tell them you've seen this before. my guess is you won't be as leadfooted in those cases. the idea that if you write an article or an opinion and have to do an hour of research to see if its been covered before is a high level of micromanagement that you just aren't ever going to see i'm sorry. it's super unrealistic to expect that.;0
32253049;HackerNews;2022-07-27;microservices suck when you need to make a process faster so you run a profiler and figure out that 90 of the workload is handling the http requests between the services.;0
32252624;HackerNews;2022-07-27;you might misunderstand the point here.it's about how to keep the velocity without firing junior dev without removing bad code from the production system.so microservice is a leadership tool to manage it. keep it in control.;0
32252481;HackerNews;2022-07-27;i think there's a lot of historical accident involved. personally my experience of the two terms was that i heard about services aka soa first and it meant a topdown global architecture where the pieces were composed in elaborate cumbersome ways service buses orchestrators complicated xmlbased technologies service discovery remote transactions all that fancy stuff that many people tried and few people ever got working correctly. people were talking about integrating a new service to your architecture by dragging and dropping widgets in an orchestration dashboard generated from xml descriptors published by the services and it was the kind of thing that blew your mind for a few seconds until you realized it was obviously never going to work.then i heard about microservices and the people using that term were talking about json and http and dns stuff you could actually imagine working and then you tried it and you actually could get it working with almost no effort which was mindblowing in a different and better way.that difference was a historical accident based on where those terms were in the hype cycle. now a lot of definitions of microservices describe architectures that are almost as elaborate as the old soa ideas i was exposed to and people have the same reaction i did to services back then. and now it's the supposed microservices experts who will tell you that if you did anything simple enough that you actually got it working in less than six months with less than fifty people then you did it wrong and doomed your company. the hype cycle has made a complete turn.;0
32252413;HackerNews;2022-07-27;some people will make an incoherent mess out of anything.a garbled knot of interdependent microservices with timing issues bad extensibility and unpredictable flow.an ornate matroyshka set of wrapper functions calling each other spreading over multiple directories making any modification a large error prone effort.event systems probably multiple without any real difference between just a function call other than your debugger getting very confused by it.database schemas with table names that exude the narcissism of small differences with nitpicky rules that make it explode if any flexibility is demandedaws bill that's 10x more than any reasonable expectation given the problem set.an object oriented design that looks like some kind of fetishized exercise of every feature possible where defects cascade to action at a distance and unintended consequences with tight coupling that can't be extricated leading to a rewrite just like it did last timethey are the people who create the waterfall of dozens of levels of div tags for no functional reason other than to accommodate their incompetencythey are the ones that want to pollute your entire day with needless meetings over irrelevant things that will not be acted upon.of course there's no useful comments or tests or documentation. the git comment messages are single words like fix and rewrite. there's no versions in the deploy or a reasonable approach to logging that allows a successful audit and the thing is too state dependent to reproduce bugs.then there's dependencies loads of them just picked seemingly at random written by people who think like them with the same disregard for documentation compatibility or testing. but they have very pretty websites which says they're painless simple and easy so i guess it's all ok right?the problem with microservices is the same problem with anything else and changing paradigms won't fix it. the approach needs to change not the technique. it's a different kind of budo.;0
32252398;HackerNews;2022-07-27;id argue thats being contrarian taking an opposing stance just for attention seeking.this is more like the trough of disillusionment on the hype cycle. youve suffered so much at the hands of microservices you want to convince everyone else not to use them. lots of others have suffered similarly so thanks to confirmation bias your post gets lots of likes based on the sentiment.;0
32252384;HackerNews;2022-07-27;that doesn't seem advisable. maybe you should try microservices instead?;0
32252243;HackerNews;2022-07-27;code quality is only one reason to use microservices deployment frequency is another you want people to be able to deploy their service without needing to coordinate with every other service in the system.moreover code quality isn't just encumbered by junior devsin fact in my experience it's more often managers pressuring developers to take shortcuts e.g. taking a dependency on another system's private internals in the name of expedience while swearing up and down that we will totally clean it up in a future iteration or other organizational hurdles that make it difficultimpossible to fix it the right way so shortcuts are taken instead with microservices the organization ihasi to confront those issues they can't be easily papered over by bypassing official interfaces.another reason to prefer microservices is securitynot putting every secret in a single process's memory space is a great way to minimize blast radius if a service is compromised.ianotheri reason is reliabilityif one system has a catastrophic failure mode it won't take out all other systems. of course if the failing system is a core service then it may not matter but at least you're not bringing everything down when some service on the architectural periphery goes haywire.;0
32252178;HackerNews;2022-07-27;a crypto exchange has bragged about having 30ish microservices per engineer. it's pretty wild.;0
32252122;HackerNews;2022-07-27;nothing in the article is fresh news. sam newman made many of these same points himself in his 2015 book on microservices.the article does not discuss why engineering teams ignore that advice.companies see microservices as a silver bullet for solving complexity. inexperienced engineers attracted to shiny things jump on the bandwagon. vendors sell tooling to deal with the new complexity. but in that case if it wasnt microservices it would be oop fp spas rpc rdbms nosql etc. the problem is the hype cycle. overuse of microservices is only a symptom.;0
32252118;HackerNews;2022-07-27;i've never found deployments to be an issue. any team can trigger an entire redeploy of the app.one could argue that this is inefficient w.r.t. compute costs but i think its orders of magnitude cheaper than the cost of the cognitive overhead of orchestrating microservices.obviously there is a scale at which this doesn't work anymore but i've worked on huge code bases with big teams and am yet to witness this...;0
32252095;HackerNews;2022-07-27;it's not a service for every db activity this is a fundamental misunderstanding about what microservices are how to use them etc so of course you're going to have a bad time with them.;0
32252047;HackerNews;2022-07-27;yes we have a term for that technical debts!the reality is like this you have a critical system that ran for ages and now what will you do to scale the features ? by allowingteaching junior devs to understand how to contribute to the codebase ?there's a simpler way to do that efficiently extract a subdomain into its own microservice and you control the interface. then even that microservice has bad code quality tech debt your business is still running fine!problem solved.;0
32252009;HackerNews;2022-07-27;same. i keep hearing that people have had bad experiences with microservices but i'm not sure what those bad experiences are. i certainly don't relate to them. we had a monolith and it devolved into a messmanagers would insist on people taking dependencies on stuff they didn't own in the name of expedience yeah we'll totally circle back and do it the right way lol. microservices kept things neat by making dumb things hard. we were also able to deploy individual services much more frequently without needing to coordinate with a bunch of other teams and builds tests etc were much faster helping shorten our iteration loops.local development environments were a bit more tedious in certain cases but that was the only issue i recall.;0
32252006;HackerNews;2022-07-27;a service around every single table in a database with an absolutely ridiculous spaghetti of interprocess communication to tie it all togetherfor what it's worth i suddenly feel a lot better about my employer's architecture. but we still call them microservices because language.;0
32252004;HackerNews;2022-07-27;the same advantages can be achieved by separating things into libraries or discrete packages.microservices just takes that and spreads it around a k8s cluster using grpc or restful json or some other rpc bus for all the various modules to talk to each other consuming far more compute resources and helping increase atmospheric co2 and make cloud vendors rich. why is calling a library running in a separate task possibly on a separate cpu via grpc a better approach to code modularity?the ionly timei this makes sense is when you are 1 totally huge and 2 have specific hot regions of your service that you want to autoscale relative to the rest of the service.incremental upgrades can be achieved by just incrementally cycling your service no microservices needed. doing so when only some modules change can be achieved with ci without the crazy runtime overhead.;0
32251992;HackerNews;2022-07-27;most of the real world microservices usage outside of faang has been to legitimize polyglot development a net negative for most organizations and the to create heretofore unseen levels of conway's law. a microservice per person? sure why not?it's madness. the solution is to avoid the polyglot issue by fiat and to ensure that there is some actual planning and rationale around when it makes sense to add a service. most groups i've talked to don't even have a good answer to why is this in a separate service from that? when asked and i've talked to a lot of them.;0
32251946;HackerNews;2022-07-27;microservices are very much not a fad and they aren't even that new of a concept. they have just gotten more attention recently and have probably been overadopted a little bit.in the right circumstances a microservices architecture can absolutely boost developer velocity. you can reduce developmentmental model complexity reduce blocking internal dependencies increase performance of tooling and deployment and allow more consistent and less risky deployments. there are certainly costs infrastructural complexity a new network boundary between services increased risk of techincalproduct drift.for orgs where the benefits outweigh the costs due to scaleorg structureperf concernsetc it can be an enormous win for velocity. for other orgs it can be a huge velocity killer. it just depends.;0
32251921;HackerNews;2022-07-27;move stuff around and complexity will magically go away fallacythis is a great description of microservices;0
32251866;HackerNews;2022-07-27;i've seen the degenerate states of both extremes a monolith with too many engineers contributing no continuous deployment but rather release day which was a shitshow said day was an extensive process where hundreds of engineers anybody who was on git blame had to be online and sitting by for four hours while it rolled the release team often had to handrevert bad patches bullying of engineers who broke the build reached levels that would raise hr eyebrows there were still often rollbacks and site breakages. microservice hell there were often 23 apis for the same service platform engineering for the protobuf rpc generation had to support five different languages security auditing was nphard every team had its own release process services that were still highly used were deprecated and left languishing for years until somebody took up the mantle and released their own parallel service that did nearly the same thing but with a different api so now other services had to use both etc.but that wouldn't happen at mycompany we know the pitfalls and we'd never be that bad at engineering! sure...sure. that's what these companies said to themselves too;0
32251858;HackerNews;2022-07-27;i love the idea of managing junior level programmers who don't know how to make loosely coupling architecture as describing engineering leadership regardless of how cynical it is.i do question how microservices manage that though? tightly coupled microservices ie the distributed monolith are a still real danger for teams that don't have enough engineers that know know how to make loosely coupling architecture;0
32251840;HackerNews;2022-07-27;they're irrationally thrown up there as a silver bullet and people are heavily criticised when people suggest nonmonolithmicroservice alternatives.;0
32251829;HackerNews;2022-07-27;you got to love the balant disregard for alternative architectures where this article has to advocate for monoliths again.you can isolate pieces of your architecture and simplify them. a lot of issues with microservices inside the system not user facing comes from the expectations of what the microservice deals with the enforced boundry of the microservice intention of it and the fact that anyone can connect to it.think about streaming data systems. these allow for multiple components connecting to durable queues with maintence polices that will process data and pass it along. this is more for data that may take longer and shouldn't be done in the same request.slight personal rant the crap that i've seen people expect of microservices to do in a request is excessive. if you're doing more than taking a request readingwritting into a database.. you're doing too much and your performance is terrible additionally there is very little consideration about what happens when a microservice performs badly.;0
32251805;HackerNews;2022-07-27;as someone who has built a monolith fullstack literally everything from mysql to phpnode.js to the web to cordova platform at i can still tell you that microservices are great. but the average person isn't going to finetune all those microservices. they need to install something that just works out of the box. an expert can be hired to finetune some parts of the stack e.g. add a cdn or varnish cache and not others. the layers e.g. database file system already are separated and cloud services like amazon can even scale them automatically e.g. aurora or lambda.the main problem isn't microservices it's control and interoperability. facebook decides it wants to turn into tiktok? too bad for all its users it'll happen. relax breathe we hear you is what zuck said to all his outraged users after the first big rollout of newsfeed. then a lot of scandals later beacon etc. they are still at it. google sunset reader just like that. people are hoping that elon musk adds a feature to twitter. this is crazy.host stuff yourself and not in the cloud. and for that we need people to be able to just install something like a wordpress 5 min install on a hosting company.i don't want to make this comment long so anyone who wants to read the full thesis can see it here;0
32251791;HackerNews;2022-07-27;firmly disagree. microservices get you very little in terms of code quality enforcement past what you would get with a well modularized monolith and they introduce a lot of code quality amp architectural pitfalls. i think going microservices to enforce boundaries and decoupling is a very bad idea that will create far more trouble than its worth. i'd be a iloti more scared of my junior devs committing code to microservices than to a decently organized monolith.i would only seriously consider a move to microservices for deploymentperf reasons.;0
32251742;HackerNews;2022-07-27;this doesn't cover independent deployments.microservices allow team a to deploy their component while team b are just writing code. then team b deploys their own component and while team a is at the bar.;0
32251720;HackerNews;2022-07-27;when i see a service around every single table in a database with an absolutely ridiculous spaghetti of interprocess communication to tie it all together it usually is because someone took the 'services' pattern a bit too far and in that case 'microservices' is a proper moniker. and for erlang based systems it usually is also appropriate. if there are fewer than 10 or so services usually they are not 'microservices' but just services.;0
32251677;HackerNews;2022-07-27;this reminds me a lot of conway's law any organization that designs a system defined broadly will produce a design whose structure is a copy of the organization's communication structure.if we apply this law backwards microservices reflect an organizational structure with many teams working on different things so they'd make more sense in that context rather than within a small team.;0
32251660;HackerNews;2022-07-27;id argue bashing microsevices is more in vogue than microservices themselves. theyve reached that point on the hype cycle where you can get a whole bunch of likes by saying microservices bad amirite?!;0
32251612;HackerNews;2022-07-27;ive worked for decades now as both a developer and an sre and have never once thought either man i wish these microservices were monolithic nor man this monolith is so great im glad its not a collection of microservices. these kinds of articles seem to be written for people who work in environments ive never even heard of let alone experienced.;0
32251578;HackerNews;2022-07-27;i find it pretty entertaining how the word microservices got to mean what we used to mean by services or web services. it has not referred to size in the npm leftpad sense at all for a long time now.i feel that the battle is lost at this point kind of like the battle for the meaning of hacker.;0
32251553;HackerNews;2022-07-27;for the bulk of the smaller companies the monolith is an iexcellenti choice. for a smaller number of them decomposition of that monolith into a few lt 10 and usually lt 5 services makes good sense. typically the kind of project you are working on will suggest nice 'cut here' lines and if it does not then you're going to have to be a bit more creative. you could try going by entities or by processes or by large chunks of the project accessed by different people.and then there are projects that grow way beyond the point where even that will keep them manageable in which case microservices may well make sense. but the number of companies faced with challenges at that level is quite small relative to the total and the chances that you find yourself in one of those if you don't have a few hundred coworkers as developer is very small.;0
32251420;HackerNews;2022-07-27;i'd love to see more of these you don't need microservices' type of articles be more prescriptive on when you might need them. 20 product scrum teams? 10 different team? certain functional team separate like you have a data infra team search payment processing?i always can't help but to think most of these articles are written by engineers working at 30 people startups or something. and there's definitely a lot of orgsize and structure between the startup and a faangsized tech giant.;0
32251412;HackerNews;2022-07-27;isn't the devil in the details? some problems are solved better as microservices. some problems are solved better as monoliths. ultimately it is the lack of maintaining the solution we choose that leads to the grass is greener fad chase.;0
32251389;HackerNews;2022-07-27;or do the whole redeployment all the time and you'll see the risk of doing so was psychological or a few better tests away.i work in a 150 yo company where change is ... well not welcome. when we said we could try to release without schedule several times a week whenever we want just because we finished one thing at a time you should have seen their looks. we have 100 microservices doing low latency trading in 13 stock exchanges in heavily regulated asia trading bn a day it kinda has to work day after day and the risk of deploying the whole think more than once a quarter was terrifying.well a few better tests and a bit of bravery and now i just do the full redeployment whenever i want. some teeth are still grinding but what can i say we still banking lol and now when we find a bug we don't wait for months to fix it.;0
32251326;HackerNews;2022-07-27;fault isolation the ability for a single feature of your application to go down without taking the rest down with it is a big bonus of a properly designed microservices architecture.yes but it also comes with a cost. microservices might still fail in a cascade manner and bringing such system up under significant load is even more challenging.;0
32251318;HackerNews;2022-07-27;one of the benefits of being in this industry for a while is that you learn to spot and avoid fads. you even learn classes of fads.microservices instantly looked like a fad. two classes of fad apply. one is a move stuff around and complexity will magically go away fallacy fad. the other is a way to promote vendor lockin or higher cost fad.other major classes of fads are consultant self promotion fads reinvention fads of all kinds in which devs speed run the history of some aspect of computing to arrive at the same place magic pixie dust fads where sprinkling some buzzword on things makes everything better management methodology panacea fads etc.avoiding fads is a superpower. it tends to save a whole lot of money and wasted time.the test of whether something is a fad is whether it reduces incidental complexity enables something categorically new or genuinely boosts developer velocity.incidental complexity is the complexity that creeps into our designs that is inoti essential to the problem but an artifact of how we got there or some prior limitation in how things are done. a genuine innovation will make incidental complexity actually go away but inoti by pretending that essential complexity doesn't exist.a categorically new thing would be e.g. deep learning or an actually practical and useful provablysafe language rust.boosting developer velocity means actually speeding up time to ship without doing so by adding a ton of technical debt or making the product suck.if something doesn't do at least one of those things well it's a fad.;0
32251223;HackerNews;2022-07-27;microservice is to manage junior level programmers who don't know how to make loosely coupling architecture. that's it. because your job is to manage low quality code produced by junior devs you need to use microservice to prevent bad code to break the monothlic.edit for more context this opinion is more about the art of developer management not much about infra security scalability stuff;0
32251220;HackerNews;2022-07-27;this can be accomplished using a modular monorepo. different teams simply manage different directories or modules of the same repo.breaking up an app into microservices is total overkill in this instance...;0
32251183;HackerNews;2022-07-27;the article represents a reasonable position.monolith is an unfortunate term by which everyone seems to mean something different. so is any application whose parts do not communicate via network interfaces a monolith? is an application where the majority of the function calls are not realized as a series of network transactions like corba at that time a less good application than one where different classes and modules on the same machine communicate directly with each other?we should stop using the term nor assigning blanket value attributes to it. monolyth is not the antonym to microservices as suggested by the article. from a certain distance every system looks like a monolith that has more to do with the viewer than the system.;0
32251171;HackerNews;2022-07-27;microservices are a great way to promote cloud vendors' offerings and complicate it life with overengineered standards like kubernetes.big corp wins while their customers create devops and other buzzword teams and the majority of it world loses the capability to actually administer systems and becomes users addicted to everchanging vendor offerings that complicate learning useful stuff outside.;0
32251158;HackerNews;2022-07-27;strong agree. the need to transition to microservices will sneak up on an organization and that's okay. it's surprising how much life you can squeeze out of a monolith.;0
32251156;HackerNews;2022-07-27;i wrote a library 1 for laravel that lets you put a kind of microservice iinsidei of your monolith.it lets you develop deploy and execute aws lambda functions from your laravel application.the theory here is that sometimes you need some other languageinfrastructure beyond what you're comfortable devopsing yourself and lambda is actually quite good at providing you with an entire stack of stuff you don't have to own.so if you need a single node python or ruby function you can put just that part on lambda and still call it from laravel as if it were a native php function. no api gateway or anything to muck about with either.is it a true microservice? not really although who knows what that actually means. it does allow you to take advantage of isomei parts of microservices without the pain though!1;0
32251118;HackerNews;2022-07-27;modularize your monolithit is true that probably any monolith can be break down into components that won't prevent the full redeployment and all the risks that it brings though.i think in reality no one needs microservices or monolith for that matter. you would pick the poison that adjust the best to your needs.;0
32251103;HackerNews;2022-07-27;that makes a lot of sense when you have real team and most importantly process boundaries. isolate the code and deployment aligned with your team and process boundaries.but if you're a company of 1020 people all pretty much working on the same code? microservices just adds complexity and overhead. deployment telemetry documentation version synchronization tracing everything becomes more complex when you start creating boundaries between sub parts of your system.for me microservices are about boundaries. the question is what benefit that boundary provides for the team. for large companies where there are many discrete teams following different processes and release cadences microservices might be worth the overhead. for small companies it is wasted effort.;0
32251083;HackerNews;2022-07-27;yea. imo microservices are usually more of an organizational solution than a technical solution;0
32251080;HackerNews;2022-07-27;while i agree that there are definitely some cautionary tales regarding microservices consistent and autonomous delivery across many teams with a complex monolith is equally if not more difficult than some of the cons that come with microservices.i don't think the answer is as easy as you don't need microservices. i think the answer is you can effectively use both.;0
32251005;HackerNews;2022-07-27;aren't microservices nice because they allow you to have different teams own different parts of the code and minimize the communication overhead?;0
32250723;HackerNews;2022-07-27;why the monolith should remain the default choice for new small and mediumsized engineering teams. considering how we can leverage the monolith to realize the benefits that microservices claim for themselves.;0
