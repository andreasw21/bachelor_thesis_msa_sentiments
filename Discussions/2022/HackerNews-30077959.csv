ID;Source;Creation Date;Content;Sentiment
30077959;HackerNews;2022-01-25;Title:Why our team cancelled our move to microservices, Content: https://steven-lemon182.medium.com/why-our-team-cancelled-our-move-to-microservices-8fd87898d952;0

30109818;HackerNews;2022-01-28;it's solvable with appropriate tooling. i.e. you can store api definitions in a separate repository and make the services or cicd check api usage is valid at build time. makes sense though it feels somewhat like reinventing the wheel samecodebase tooling are generally easier and faster to use. what do you mean by that? data and workflow have to be unified across the company's products to provide the user with a seamless experience. as above to me this seems may contradict some components of microservices like splitting the database since one ends up with the same constraints synchronization shared schema while complicating the orchestration since now crosssystem integration is needed.sure something like reddit or hn can break the unified experience but any important or productivity system will greatly suffer from such fragmentation. i assume it can be achieved with microservices but it seems somewhat harder.;0
30097073;HackerNews;2022-01-27;well the parent talked about not joining across services. then there are hard limits to how small you can make them.and what need to join with what is something that can change.so if you make services very small and no joins across services you get a lot of copies of the same data everywhere...and if you make the services too small you have just moved the exact patterns you would have inside a monolith to into your apis..how can that be easier?you say downsides of monoliths but monoliths isn't a homogenous thing they come in all shapes and varieties. so does microservices.myself i happen to have experienced microservices systems that are a real mess and pretty clean monolith designs. consider for instance an event sourced service where every endpoint a reads events from database b if business rules allows involving possibly external calls writes an event to the database. no crud. this pattern keeps every handlerbusiness rule reasonably isolated from other and it doesn't matter if it runs in 1 or 10 services...;0
30093907;HackerNews;2022-01-27;it seems to me that you are comparing apples and oranges. if your code has no relevant state or coupling a pure function. sure you can look at it in isolation. you could do the same in a monolith.i've worked on plenty of monoliths with async style code and have found the stack traces to be plenty helpful. it's never been an issue. at least in javascript you retain all relevant scoped data and can dump it all if you like. debugging gets much more interesting when there are no obvious such errors yet error conditions are present.i'm still not seeing any equivalent microservice tooling.;0
30093038;HackerNews;2022-01-26;i'm not saying you ihavei to use microservices to solve these problems just that they are potential reasons why you might want to even with a small team of developers. i would also argue that if you're deploying the same codebase in two different places and having it execute completely different code paths you're effectively running two separate services. whether or not you decide to deploy a bunch of dead code i.e. the parts of your monolith that belong to the service running on the other cluster along with them doesn't change how they logically interact.;0
30091565;HackerNews;2022-01-26;microservices and spas are to me in the same category of things we do because it is fun rather than because the business will take any benefit out of it.the amount of effort wasted is just not worth it in 90 of the cases.;0
30091312;HackerNews;2022-01-26;if i'm in java javascript or python and there is a code fault the system provides me a stack trace of the call structure that lead to the error. if i catch the error i can output more related data as i deem necessary. this comes effectively out of the box.sure if you are not writing a program using eventdriven async style. every monolith i've worked with has been in async style pretty much.with global state in the monolith this can become quite difficult to reason about. by contrast with microservices you can analyze the service as performing a small function with a single input and output without global state dependencies. this can be easier to debug.;0
30089909;HackerNews;2022-01-26;the problem is in the hype.for example the tradeoff between centralized and distributed has been taken mostly informally by big institutions for years. it´s not possible for a large bank with multiple overlapping domains hundreds or thousands of dev tems some of them outsourcedoffshored to have all of it´s code in a single repo or a single executable. and not all of it´s applications have the same requirements technical scale etc either.soa came to aid in this case by putting a common integration pattern between the interested parts.but at some point the idea was hyped and even small teams with no diverse technical or scale problems started doing simple backends using full blown distributed systems without reason.basically if you don´t have problems of scale domain technical or people related going microservices first is probably not granted.;0
30088481;HackerNews;2022-01-26;i can certainly see how this happens. points to how poorly all the chatter about microservices obscures important points. this post itself doesn't strongly enough highlight that 12 developers is a fullstop no microservices decision point.or to phrase it differently it's like a horror film where a smallskinny person goes into a dark unknown basement by themselves. sure there's a story to be had but the important bits to know come before the decision. i suppose it could be useful how to best defend oneself in a rare situation but avoiding it altogether is better if easy to learn.;0
30088161;HackerNews;2022-01-26;if i'm in java javascript or python and there is a code fault the system provides me a stack trace of the call structure that lead to the error. if i catch the error i can output more related data as i deem necessary. this comes effectively out of the box.how do i do a similar stack trace in microservices to understand the path that led to this state? i've used microservices at a couple of companies and their methods were effectively look at the request id and trace it through this mass of log files for each microservice we are running. it was terrible and could take hours to compile the same information.what tooling exists to solve this problem with microservices? genuinely want to know.;0
30087141;HackerNews;2022-01-26;i claimed that we should secure secrets and prevent attackers from executing routines that they shouldn't have permissions to execute.while this is obviously a noble goal you mentioned restricting employee access to secrets in relation to restricting employee access to code as well. to me this is throwing the baby out with the bathwater. we can obviously make things harder for attackers by making things harder for everyone but to carry it out even farther we may as well make the code fully immutable since then an attacker wouldnt be able to do anything to it then. if you disagree with this then surely you must agree that theres a balance to be found and it depends on the needs of the organization? i mentioned that profitable organizations often secure their applicationswell i never made the argument against securing applications but assuming you meant that they use microservices thats great although unfortunately it doesnt mean anything about the overall appropriateness of microservices. profitable companies are known for moving so slowly they are unable to adapt to anything even when it means their existence is at stake and also for blindly following the path laid out for them by laws shareholders stakeholders etc. almost as an automaton without brains. so this supporting point isnt hugely convincing.if your point is that in a very specific set of cases microservices are appropriate then we are in agreement. however this wasnt the tone generated by the comments i was replying to.;0
30086889;HackerNews;2022-01-26;you're reading too closely and judging instead of looking at the discussion from an objective standpoint and simply seeking clarity and working towards truthi think you're projecting here. perhaps we can stick to the actual discussion instead of speculating on my motivationsas though you can understand someone's inner workings from half a dozen internet comments .anyway we're no longer talking about microservices or monoliths so it would seem this thread has run its course. enjoy your day!;0
30086813;HackerNews;2022-01-26;let's stay focused. there are so many implicit assumptions you're taking as granted i'm starting to doubt this is even an argument in good faith.i share your doubts that this is a good faith argument in particular you keep responding to arguments that i patently didn't make for one code is not secret.i didn't claim code was secret i claimed that we should secure secrets and prevent attackers from executing routines that they shouldn't have permissions to execute. secondly when was this discussion scoped to profitable organizations?i didn't scope the conversation to profitable organizations i mentioned that profitable organizations often secure their applications. i'm giving you an example and you bizarrely think i'm limiting the conversation ionlyi to that example. you do the same thing here as well and suggest that ii'mi the one who isn't focused this argument weakens the entire stance because it shifts the goalpost from this thing is good to this thing is legally required.again i give in some cases security is even required and you take it as we're no longer talking about other reasons for which security is beneficial.honestly the monolith vs microservice question is interesting but it's inoti interesting to debate someone who is bent on responding to arguments i clearly didn't make. whether you're being obtuse on purpose or by accident this conversation has become dull and i'm ducking out of it.;0
30085135;HackerNews;2022-01-26;yes and i have to consult with other teams when versioning i don't just go welp here's the next version i created and deployed without asking anyone because that's what the ibm microservices manifesto 2006 suggested and some random guy on hn insinuated i'm causing undue friction if i work with you guys;0
30083831;HackerNews;2022-01-26;as soon as you start dealing in packages of code1 theres no longer a meaningful boundary between your services instead the boundary is completely arbitrary and each service becomes a microservice in name only.while this sounds very radical to me at least i mostly understand how you've come to this conclusion. obviously just one package is going to lead to further complexities down the line and perhaps many more packages than that.perhaps a dedicated microservice for this piece of business logic would be better as you suggested.;0
30081992;HackerNews;2022-01-26;for anyone with a monolith considering microservices that 25 of total is 33 more work than the monolith.but if 33 more work isn't enough we can things in languages with undefined behaviour like javascript and also use lots of different languages in the services so out support gets more complex!jokes aside the saving grace is t25 sounds like empirical observation so it probably an all up figure so probably includes the large amounts of bikeshedding that often accompanies a microservices implementation.;0
30081835;HackerNews;2022-01-26;they only communicate through welldefined apis and there's a rule that crosscontext api calls can only happen in the anticorruption layer we use a tool to check it at build time.what i meant by intertwined maybe a wrong word i'm not a native speaker1 there's a lot of datalogic dependency between the contexts i.e. a context in its operation depends on n other contexts although we at least disallow circular references it's unfortunately dictated by business rules and i'd like to see contexts to be more isolated and selfcontained. some can say that if a change in the requirements requires to change many contexts at once maybe it's one fat context after all and they may be right but we enjoy the current modularization effort one big fat module would be far less manageable for us.2 there're occurrences of temporal coupling there are synchronous operations that spawn several contexts with a lot of data flowing back and forthnow it's easier to manage it in a monolith in the same process because1 there are no network trips back and forth in case of complex operations with a lot of data2 no retry logic in case of network connectivity issues3 db connectionslocks and other inmemory structures can be reused4 same codebase so easier to reason aboutmicroservices require more care and more complex solutions1 distributed transactions are hard2 eventual consistency is hard3 the idiom db per microservice makes managing the infrastructure harder4 deployment is harder if you have changes in several related contexts there's only 1 deployment in the monolith as opposed to n deployments of microservices5 you have to manage different codebasesrepos can't see the whole picture6 you have to defend against network connectivity issues microservice unavailability etc.7 debugging is harder you can't just step into another microservice like you do with inmemory modules8 new devs need to be taught all thatthe list can go on and on. so we don't try to make all our modulescontexts into microservices just because we like microservices we have to substantiate a move to a microservice with proof that it will make developmentscalability easier for us and that the advantages outweigh the disadvantages.;0
30081716;HackerNews;2022-01-26;ftr... a desktop emulator was a reference to something like wamp or xampp... on which a monolith can be run developed upon and even tested entirely independent of any host or vm infrastructure.i'm not back pedaling you're reading too closely and judging instead of looking at the discussion from an objective standpoint and simply seeking clarity and working towards truth. here's what i posted in this same thread even before my post in this branch by winternett 6 hours ago parent context prev next on why our team cancelled our move to microservicesa size 20 shoe is better for a large foot... but not better for a size 15 or size 10 foot. saying microservices are better is the same as me saying a size 20 shoe is better than any other shoe... for everyone.it's not a viable statement in any use case except for people with size 20 feet.the business need is what determines the solution necessary.;0
30081186;HackerNews;2022-01-26;as with all architectural patterns there are tradeoffs. microservices for one thing are not functions. granularity is an important concern.a ddd approach up front will help with granularity.the other leg is serverless support. without that you are stuck with maintaining infrastructure in tandem with all the other considerations which takes a lot a specialists lots of engineers.definitely a game of scale and not for small organizations.however if scale is the key ingredient for success and the value proposition is based on scale then this kind of architecture is worth looking at.that said all shops are not netflix or aws...;0
30080937;HackerNews;2022-01-26;fine until one of the microservices needs an update with new features new api because something has changed and suddenly...1. rightyou only depend on other teams iwhen you need toi2. even in this case you just version your api deploy your new version at your leisure and incrementally move people over to the new version while deprecating the old version. are containers not a de facto platform?not in any interesting or meaningful sense. containers are precisely the technology that allow you to pack up and go to a different orchestrator or cloud provider. note that the original concern was being locked into a cloud provider or paaswhat does it mean to be locked into containers? who has ever been locked into containers? here's a moderately complete list of products. how many are paytoplay?you're conflating a lot of things. first of all containers aren't micro services or vice versa. containers are just an interface for processes and they enable things like orchestrators. containers versus ltwhatever is orthogonal to micro services vs monoliths. secondly there's nothing about paying for something that implies more lockin. whether you're paying or not it's a lot easier to transition between platforms with micro services than with a monolith micro services can move incrementally while a monolith has to move all at once or be painstakingly broken into micro services. all you're really doing with containers is creating a metamonolithwith the enormous caveat that imicroservicesi can be deployed independently and even on different platforms and use different technologies... which is to say microservices are nothing like monoliths. this makes sense at global scale where you're drowning in income and need to handle all kinds of everything for verylargenumber customers.it makes sense if you have more than a few teams. it's complete madness for a small startup that doesn't even have a proven market yet.there are degrees between small startup without a market and global scale drowning in income. but yes i agree that microservices aren't a good fit for the very earliest smallestscale companies.;0
30080656;HackerNews;2022-01-26;i have a very strong objection to this line of thinking.effective use of microservices depends upon a strong meaningful boundary between the services and that boundary should be business driven not code driven. as soon as you start dealing in packages of code1 theres no longer a meaningful boundary between your services instead the boundary is completely arbitrary and each service becomes a microservice in name only.if every microservice knows about the business logic for generating basket prices whether the code comes from a package or not you no longer have microservices you have a lot of monoliths.i joined a company that did this and it was one of my worst experiences as a software engineer i would never recommend it.1 specifically packages containing business logic. packages containing functionality for crossservice communication etc. are very reasonable.;0
30080543;HackerNews;2022-01-26;or moved into its own microservice and then rpc'd to from those other services. but yeah.;0
30080515;HackerNews;2022-01-26;the post is very explicitly coming from a perspective of we didn't know what we were getting ourselves into. the story begins iafteri the decision to move to microservices was made and the backstory of the decision isn't dwelt on beyond allusions to topdown pressure from management.the important lessons here are on how they recognized the mistake before they had fully committed. having worked on a team with a similar story it all rings iveryi true.;0
30080505;HackerNews;2022-01-26;because we couldnt isolate any of our services properly this was going to mean that we would be left with a significant amount of duplication. for example we identified one particularly complicated and essential piece of business logic that would have to be copypasted and maintained across 4 of the planned microservices.wouldn't this piece of business logic be best placed in an importable module? then that module would be imported by those 4 microservices and problem solved ...? i don't really understand this argument.;0
30080435;HackerNews;2022-01-26;isn't the point of making services as small as possible so that you can easily shift boundaries? isn't ddd a common companion of microservices all about iconstantly shiftingi business domains?we've gotten boundaries wrong tons of times. we change them which includes a migration script to move historical data from one service to another if possible. yes it's work but it's not any more work than having everything crammed into the same monolith and having to deal with all the downsides therein.;0
30080421;HackerNews;2022-01-26;many monoliths can be run on something as simple as a desktop emulator. they don't generally rely on cloud either.microservices are distributed across a cloud host platform because they are each updated and maintained by different teams. my use of the term distributed means that if aws east has your db instance and your web server is stored in an entirely different region you app goes down anyway but your frontend team can maybe still deploy updates... which is not really a dramatically productive gain for a customer running a restaurant web site.... on the other hand if you're running a massive video streaming site it might be a good thing to base it on micro service architecture. each use case is different.i'm resisting the pressure to be drawn into a debate about which one is better that's not what i'm out to do... what determines which solution is better is the business case it seeks to resolve. neither is inferior or more obsolete the two ideals both can and often do run on identicalsimilar code bases... it's the configuration and potential usesapplicationbenefits that differ.;0
30080394;HackerNews;2022-01-26;that buyers often are properly warned about their inability to easily migrate if they invest in platformspecific microservices too heavily.;0
30080361;HackerNews;2022-01-26;it really doesnt seem like they are confusing microservices im not sure what makes you think that.;0
30080322;HackerNews;2022-01-26;the debate about microservices and monoliths are really about valuing consistency of tooling over best tool for the job. microservices tend to emphasize allowing a developer to use whatever tools services and languages they want to implement a service. we define the input to the service and the output from the service but little in between. the consistency is in the interfaces between the services how each service is built can be totally different. monoliths emphasize consistency of tooling and language across services so there are fewer tools fewer things to know to operate and develop the application.you know what? you can totally screw up both architectures you can have cost overruns and you can fail to scale. neither microservices or monoliths are going to make you succeed of fail.the real question is where do you want to put the consistency? is that the right way to do it for your app? can your team maintain and keep building or is maintenance going to blow you up?;0
30080286;HackerNews;2022-01-26;we have approximately 12 developers spread across 2 feature teams and a support team.i started work at amazon in 2001 when they were near the beginning of the transition to microservices. i think they had a couple thousand software developers at that time.;0
30080262;HackerNews;2022-01-26;individual teams cant deploy their code without coordinating with every other team which yields long user feedback loops and a bunch of other knockon effectsfine until one of the microservices needs an update with new features new api because something has changed and suddenly...the whole purpose of containers is to decouple the application from the platform.are containers not a de facto platform?literally laughing out loud at the idea that marketing people are behind microservices.here's a moderately complete list of products. how many are paytoplay? all you're really doing with containers is creating a metamonolith running on external hardware with custom automation managed by an ever so handy third party software product. also running on external hardware. all of which you're paying for.you can also diy and not pay. in theory. but really...?this makes sense at global scale where you're drowning in income and need to handle all kinds of everything for verylargenumber customers.it's complete madness for a small startup that doesn't even have a proven market yet.;0
30080237;HackerNews;2022-01-26;here at google one of our most popular microservices frameworks enables microservices to be assembled into servers. if one microservice calls another one in the same assembly it won't touch the network and is quite optimized. there's no reason that microservices have to all run in separate binaries but when it's useful it can be done easily enough without having to change your code.;0
30080228;HackerNews;2022-01-26;what were we trying to achieve again?this is the main takeaway here. if you have a problem and think microservices might be a good way to solve it and possibly worth the effort then go ahead and investigate. but without a clear problem and plausible solution involving ms it's going to be a big waste of time.;0
30080191;HackerNews;2022-01-26;that's what makes the whole idea of microservices seems weird to me. if a functionality has merit on its own e.g. an authentication service then it will naturally fall outside of the main application. if a service is tightly coupled to other parts of the app then microservices seems like intentionally hindering yourself the coupling remains as evident by the need for backward compatibility but now we it's harder to keep everything aligned due to the extra separation e.g. different code bases multiple databases no static validation of remote interfaces etc..the point of organizations and products is to work as a itightly coordinated machinei. the decoupling that microservices create seems opposite to that goal.happy to hear different perspectives.;0
30080187;HackerNews;2022-01-26;its pretty straightforward. in a monolith everything is in the same memory space so the payment system credentials and routines are available to the whole monolith. in a microservice architecture one service cant access the memory or routines of other services.;0
30080138;HackerNews;2022-01-26;not everything is a conspiracy. sometimes its just useful to have a word to describe a particular architecture. in this particular case monolith isnt even disparaging so if big microservices were trying to disparage monolithic architectures why wouldnt they use a term with a negative connotation?this isn't the reality on the ground. where i currently work monolith is absolutely used as a pejorative by those advocating for microservices.;0
30080121;HackerNews;2022-01-26;the 1 reason to split your serving architecture into microservices is that your application can't fit in 1 server's memory.if your application fits in 1 server you have a choice otherwise you don't.if your application can't fit in 1 server and you can't split it up you have to refactor so it can.if you can't refactor your application to have isolated domains aka your domain is so complex it must take up an entire server you have a serious problem.clustered applications are unavoidable.;0
30080032;HackerNews;2022-01-26;they are so old buddy actually. splitting monolith into servicesnot always been micro is a natural evolution for any software.microservice isn't really about that it's a marketing paradigm that is here to serve the paid tools not really the architecture it is exactly like serverless it's not an architecture it's a really about promoting paid platforms.the parent is 100 right about their point about marketing buzzwords because that's really all what it is all about.;0
30079985;HackerNews;2022-01-26;youre confusing microservices with dependencies on a particular platform presumably cloud providers. microservices arent more likely to have these dependencies as monoliths are often also deployed on cloud providers and assume a particular database etc.anyway if youre dealing with microservices lockin isnt a real problemyou just move one service over to your new platform at a time. good luck doing that with your monolith iwithout decomposing it into servicesi and frankly if you icani feasibly decompose your monolith into services your architecture is probably cleaner than 95 of monoliths out there.;0
30079971;HackerNews;2022-01-26;salutes go out to the folks who can handle microservices because they have always been a pain in the ass for me. the world needs more libraries not services;0
30079964;HackerNews;2022-01-26;its been mentioned elsewhere in this thread but the lack of microservices doesnt imply a global shared state. theres a big difference between a large service that has well isolated modules and a large service where all the state is contained in one struct for example. i feel this issue is pitched as a false dichotomy.;0
30079936;HackerNews;2022-01-26;the operations needed to keep a large monolith buildable when a lot of different teams work on it are also highly complex and increase in complexity relative to the number of contributors to the codebase. it becomes a massive coordination problem at scale.microservices decouple teams so they can get their work done without stepping on each other's toes.;0
30079892;HackerNews;2022-01-26;this is agreeably congruent with my original statementthe main problem i have with microservice marketingit is often promoted to clients that do not have applications that are large or critical enough to warrant leveraging them.that buyers often are properly warned about their inability to easily migrate if they invest in platformspecific microservices too heavily.and clients are often not aware of the operational costs that can rise over time for each component of the distributed architecture.monolithic solutions have also not stagnated... they can be run in distributed methods they can leverage microservices in parts they can also leverage containers they are far from obsolescence because they are using the same languages that microservice architectures use just with less distribution overall.the term monolithic is often used to indicate that lessdistributed solutions are somehow out of date obsolete and not innovating inaccurately when the real story is that the business case usually dictates which solution will fit best.;0
30079886;HackerNews;2022-01-26;ithat's why i don't buy into buzz words at all.iclearly you do because this is mostly nonsense driven by your knee jerk reaction to microservices. very little youve written here is substantive. its all emotional appeal covering ignorance. iif it's not broken don't fix it... ibut it iisi broken. engineers often experience significant pain from monoliths so they look for a solution. they often also experience significant pain from microservices so the pendulum returns. hopefully during all of this we learn enough that at least some pain is reduced whether we land on microservices or monoliths or hybrid solutions. iwe need to stop disparaging and focus on what worksihere i agree. focus on what works and stop engaging in low value attacks on solutions that clearly work for some. ithe more we allow marketing minds to take control of our it decisionsiwhat marketing minds are making decisions about service architecture? this seems like an imaginary issue.;0
30079817;HackerNews;2022-01-26;microservice architecture isn't better.monoliths aren't better.because the whole idea of better makes absolutely no sense without context. sometimes microservices are better in a certain context. sometimes a monolith is better in a different context. and sometimes one or the other is better but inot by enough of a margin to care abouti.it's the oldest cliche in the book but one that this industry seems to hate with a passion pick the right tool for the job.sadly in our world the received wisdom sometimes seems to be use the newest shiniest most hyped tool that is what everyone is talking about.;0
30079816;HackerNews;2022-01-26;this. and now microservices is a rallying cry to avoid any kind of architecture organizing.because the broke you know isn't called broke.;0
30079768;HackerNews;2022-01-26;microservices probably do increase the overall amount of complexity in a sense but the iideai is to trade a little bit of complexity in order to decouple teams. i.e. each team can own its service from soup to nuts without having to coordinate with a bunch of other teams. to put it differently theres a small increase in technical complexity in exchange for a significant decrease in organizational complexity. that said if you go out of your way to retain that organizational complexity e.g. by dividing your services in a way that doesnt resemble your org chart then youre going to have a bad time with microservices. similarly if you idont havei organizational complexity e.g. you only have one or two teams then microservices are probably the wrong way to go.;0
30079722;HackerNews;2022-01-26;youre confusing microservices and distributed architecture with depending on specific cloud provider services. microservices dont have to depend on any cloud services at all and monoliths can and often do! use cloud services.;0
30079703;HackerNews;2022-01-26;my team built an application using a multiple not so well thought out microservices and it ended up creating a lot of unnecessary maintenance and complexity and has been a long term pain. i wish we had just built within a single service.but my company split out a much older larger monolith over many years into separate services with clear ownership across a variety of teams. this has been a huge benefit coming from clear ownership api boundaries and separation of concerns.so neither monolith or microservices are a clear winner. it depends on context. an easy litmus test imo is that a single dev team will get little to no benefit from managing many microservices but a company scale problem will get a lot of benefit from having each team manage and deal with an independent service.;0
30079698;HackerNews;2022-01-26;the op was pretty explicitly arguing in favor of monolithic architecture. the term monolith was devised by people who wanted to brand microservices as newer and superior. it's almost as if in order to succeed these days you need to discredit and disparage your competition rather than simply having a better product and that's why i don't buy into buzz words at all.;0
30079693;HackerNews;2022-01-26;theres nothing new about marketing your product and make no mistake that dynamodb and route53 are iproductsi. those names appeal to non technical product owners that then force adoption onto development teamsroute 53 is a pun on the dns portnot exactly common knowledge among nontechnical product owners. anyway dynamodb and route 53 succeed on merit. there are certainly better examples of shitty technologies that win on marketing or other nontechnical considerations. e.g. oracle anything of course oracle arent know for being purveyors of microservices.;0
30079683;HackerNews;2022-01-26;monolith almost sounds cool to me. to be honest.i remember hearing a story from a person inside said company about a reasonably sized company with a 2 really 1 man dev team they contract for most of their needs and how excited the company was to move their internal stuff to microservices and off a monolith.he looked at me like i was insane when i said a monolith would work better for them.;0
30079637;HackerNews;2022-01-26;thats exactly what big microservices wants you to think.;0
30079609;HackerNews;2022-01-26;monoliths are pretty great and there are tons of valid criticisms of microservices however this comment managed to steer clear of all of them. the term monolith was devised by people who wanted to brand microservices as newer and superior.not everything is a conspiracy. sometimes its just useful to have a word to describe a particular architecture. in this particular case monolith isnt even disparaging so if big microservices were trying to disparage monolithic architectures why wouldnt they use a term with a negative connotation? if it's not broken don't fix it... microservices are relatively new and unproven.the microservices people would argue that monoliths iarei broken for many use cases. in particular individual teams cant deploy their code without coordinating with every other team which yields long user feedback loops and a bunch of other knockon effects. microservices exist to support nimble organizations by helping to remove technical coupling between teams. this is all 101level stuff but the microservices critics always ignore it in their criticism. microservice architecture is also inherently designed to lock a customer into very specific tools that make future migration to any other platform a very costly decision in most cases... thereby locking a customer into platformspecific dependency.i dont think you could be more incorrect . microservices are almost universally built atop containers and the whole purpose of containers is to idecouplei the application from the platform. we have also seen enough failures and pain points within microservice and even cloud architectures over the past two years alone to raise questions about whether or not it it indeed a better solution.microservices are typically more robust than monoliths if only because components are isolateda failure in a superficial component doesnt bring the whole app down. moreover monoliths are ilessi secure as well because theres no way to regulate permissions iwithini the processanything one component can do the whole system can do. the more we allow marketing minds to take control of our it decisions over reasonable technical mindsliterally laughing out loud at the idea that marketing people are behind microservices.;0
30079520;HackerNews;2022-01-26;well if the problem domain and scope is veryvery well defined developing a service as microservice is good better than monolith. i can't imagine google map api to be developed inside the monolith app instead of running as their own service.the problem that many developers fall on is sometimes some problem domains feel like they're well separated. however in practice those domains are tightly coupled into each other that merging them together is better.;0
30079406;HackerNews;2022-01-26;we have a hybrid model modular monolith microservices. it has worked well so far.the core of the product is found in the monolith. we use bounded contexts modular monolith with strictly separated concerns. there are no immediate plans to split the core into microservices unless absolutely necessary because the logic between modules is too intertwined and coupled. splitting the core into microservices would overcomplicate everything for us and the performance would suffer.as for microservices we usually use them for1 critical infrastructure which needs to be fast and scalable for example the auth service2 isolated helper services for example a service which allows to integrate with thirdparty platforms3 isolated featuresproducts which minimally interact with the rest of the system for example we have an optional feature which shares the ui with the rest of the application and uses some of its data but ultimately it's a product of its own it's developed separately with its own codebase and integrated into the monolithso i think it's a false dichotomy that you either have a monolith or microservices. you can use both they can complement each other.;0
30079398;HackerNews;2022-01-26;from what i gather microservices architecture works in a large enough organization where there are enough teams to manage each individual microservice. if your business logic allows for nicely isolated modules which can almost act as separate products that each individual team builds and then the rest of organization dogfoods then sure. but if there's a single underlying dependency that won't work. if there're complex interdependencies it won't work as nicely. if you have a small team it won't work. if requirements frequently change it won't work.ultimately works well if you have something very high scale with enduring set of requirements.;0
30079394;HackerNews;2022-01-26;my experience was mostly at small companies with dedicated ops personnel and in government. i worked with a large number of teams that had been chartered with implementing microservices within government agencies and every single one of them was told what stack they were going to use either by agency leadership or by infosec personnel.there was slightly more freedom of choice when i was at aws but compliance requirements and tooling support basically strongly encouraged everyone to adopt a standardized stack.all of which is to say i get that what you're describing is in theory what microservices are supposed to allow but i have yet to see it actually work that way in practice.;0
30079338;HackerNews;2022-01-25;i don't remember the hard numbers but on average each service at netflix was maintained by about 4 people but there were outliers in both directions. sometimes there were four or five services maintained by one person and sometimes there was one service backed by a team of 25.the other important number was that about 25 of engineering was dedicated to building the tools to manage the microservices. we didn't work on customer facing software the other engineers were our customers. and i found that number to be pretty consistent amongst any company that was fully invested into microservices.;0
30079325;HackerNews;2022-01-25;microservices does not mean kubernetes. the idea that to properly implement microservices you need to set up a k8s cluster and hire 5 devops guys that keep it running is just flatout wrong.you dont need to use kubernetes but i strongly believe its the best choice if youre not using faas. if you pick nomad or bare vms youll spend a lot of your time building a framework to deploymonitornetworkconfigure etc your services whereas kubernetes has sane defaults for all of thesethat said you should use managed kubernetes and not deploy it from scratch;0
30079290;HackerNews;2022-01-25;some perspective from netflix. around 10k employees 1 could not find how many are working with software more that 1000 microservices 2.the second article also provides some insight to the services. those make sense for me they truly sound like independent relatively large pieces of software. not like loginservice type of things you sometimes see.few examples 1create a main menu list of movies 2determine your subscription status to provide content relevant to that subscription tier 3use your watch history to recommend videos you may like1 2;0
30079239;HackerNews;2022-01-25;one of the questions i like asking developer pals is what ratio their company has between engineers and servicesdeployable units. anybody reading this care to share?for me that number says a lot more about the daytoday life of devs than the microservices vs monolith label does.;0
30079234;HackerNews;2022-01-25;doesn't a function only have so many inputs and outputs too? scope capturingglobal variables aside.sure and a microservices architecture to me implies a larger movement towards functionesque idemopotency analyzability and away from global state.to me monolithic architecture implies global shared state that is difficult to reason about.;0
30079221;HackerNews;2022-01-25;microservices make sense in some scenarios.i work at a large retail company with who knows how many developers. we have different teams for payment promotions product search account shipping and more. all of them working on a single codebase with coordinated deployments would be a nightmare.previously i joined a startup previous coworkers of mine a developer and a business guy. the developer drank the microservices koolaid and came up with in theory super scalable solutions and like a dozen of microservices. it was difficult to keep things in mind the tech stack was way too complicated for two developers. it was also less performant and more costly. the added complexity was totally unnecessary especially because we never got neither tons of users nor more developers. the business guy trusted the developer so the company never worked enough on their product and usp. i guess the developer just didn't want to accept that the fancy tech solutions won't bring success.yet another time we were a small team 5ish devs product owner and a designer. we started with a monolith and we paid attention to software design and moved quickly.also for some reason it's often overlooked that you can make your monolith modular and design it so that when the day comes you can split it up into smaller services. you don't need to start with microservices you can start with a monolith and figure out later how to split it up if necessary.microservices and monoliths have their place you just need to know when to use which.;0
30079183;HackerNews;2022-01-25;it's almost as if in order to succeed these days you need to discredit and disparage your competition rather than simply having a better product and that's why i don't buy into buzz words at all.meh. in order to sound smart on hn it's easiest to point at something and call it hype. microservices are relatively new and unprovensoa is old as fuck. microservices are also fairly old but especially when you consider they're really just soa dogma. microservice architecture is also inherently designed to lock a customer into very specific tools that make future migration to any other platform a very costly decision in most cases...no? not at all. instead of being charged for one single server annually on microservices you can be charged for many individual components that run your app independently and when usage skyrockets it's a sticker shock that you can only stop by going offline.alternatively phrased if you only use one service you only pay for it not for the whole suite of features you don't need or want. we have also seen enough failures and pain points within microservice and even cloud architectures over the past two years alone to raise questions about whether or not it it indeed a better solution.and plenty of success stories. we need to stop disparaging traditional noncloud hosting and solutions that aren't obsolete at all in this manner and focus on what works what is secure and what is cost effective in order to stay sustainable into the future.microservices work are secure and are cost effective.honestly your post contains no useful information and is satirically close to a return to traditional family values! speech.;0
30079157;HackerNews;2022-01-25;the real problem in monolithic codebases isn't that it's large and needs to be separated it's that the pieces are logically coupled. microservices force you into separation but do not force decoupling.;0
30079109;HackerNews;2022-01-25;their architecture didn't provide any clear boundaries to be sufficient for microservices however that isn't the case for many medium to larger sized projects.by the way just because there's still quite a bit of coupling between services doesn't mean there aren't clear boundaries microservices can communicate with one another all the time and still be justified in being decoupledthere isn't an absolute answer to monolith vs microservices it depends case by case.instagram was built using django and i'm unsure of ig's architecture today but it remained monolithic for a very long time at least till late 2019 and if that architecture sufficed for instagram i'm sure it would suffice for many other projects.however still it's not a this or that as many of the comments here would seemingly imply again it's heavily dependent on the case.;0
30079108;HackerNews;2022-01-25;i'm not speaking from experience here but it seems like rather than moving to a microservices architecture it would perhaps be better to think more in terms of splitting out specific functionality x into an independently deployable and hostable service which should alleviate the specific problem y that we've been experiencing due to their being too closely coupled and if there are no obvious x and y then maybe the monolith is fine?;0
30079098;HackerNews;2022-01-25;the term monolith was devised by people who wanted to brand microservices as newer and superior.i am interested in hearing more history on this;0
30079088;HackerNews;2022-01-25;also this independent deployability is simply not a feature of microservices. it is a feature of any iwell architectedi code base.i've always worked on monoliths and i've almost never needed to coordinate a release with anyone. i just merge my branch and deploy. github and shopify talk about merging and deploying monoliths hundreds of times per day without coordination.the case where you would need to coordinate a release in a monolith is exactly the same case where you would need to coordinate a release in microservice app. that's the case where your change depends on someone else releasing their change first. it doesn't matter if their change is in a different service or just in a different module or set of modules in the same application.now most application are inoti well architected micorservices or monoliths. in the case of a poorly architected app deploying a monolith is much easier anyway. just merge all that spaghetti and push one button vs trying to coordinate the releases of 15 tangled microservices in the proper order.;0
30079086;HackerNews;2022-01-25;most of the conversation so far has focused on the development benefits of microservices decoupling deployments less coordination between teams etc. small teams don't really have this problem but there are other benefits to microservices. one of the biggest is scaling heterogeneous compute resources.suppose for example your webapp backend has to do some very expensive ml gpu processing for 1 of your incoming traffic. if you deploy your backend as a monolith every single one of your backend nodes has to be an expensive gpu node and as your normal traffic increases you have to scale using gpu nodes regardless of whether you actually need more gpu compute power for your ml traffic.if you instead deploy the ml logic as a separate service it can be hosted on gpu nodes while the rest of your logic is hosted on much cheaper regular compute nodes and both can be scaled separately.availability is another good example. suppose you have some api endpoints that are both far more compute intensive than the rest of your app but also less essential. if you deploy these as a separate service a traffic surge to the expensive endpoints will slow them down due to resource starvation at least until autoscaling catches up but the rest of your app will be unaffected.;0
30079074;HackerNews;2022-01-25;exactly.microservices can solve for some problems eg scaling infrastructure in a nonuniform manner or scaling development velocity nonuniformly across many teams.but there are also tons of other ways to solve these problems. the mistake is in assuming that you need microservices to do x without really critically thinking about what is actually stoping you from having x right now.the move to microservices or any similar kind of rewrite efforts should be undertaken only when it's painfully obvious that it's needed.;0
30079056;HackerNews;2022-01-25;microservice architecture is also inherently designed to lock a customer into very specific tools that make future migration to any other platform a very costly decision in most cases... thereby locking a customer into platformspecific dependencycan you elaborate on this? examples? thanks!!;0
30079028;HackerNews;2022-01-25;most comments about this assumes a poorly designed monolith and a well designed set of microservices. a microservices architecture can be a rats nest too.i guess what it means is that even if you can build a well modularized system it will only stay well modularized if you use a network call to enforce it. well at least for most companies.conceptually there's nothing keeping you from designing your codebase to work as both microservices or direct calls. i've certainly done it before each service defined a java interface and codegen could hook that up as either a direct call or to route over some kind of layer.;0
30079005;HackerNews;2022-01-25;just last week i found an interesting and unexpected for me advantage of microservices. we have two monoliths written in different stacksframeworks and developed by different departments. monolith 1 is being split into microservices we already have around 20 microservices. monolith 2 kind of lags behind and there are certain problems that they encountered which are already solved in one of the microservices split from monolith 1. the solution i came up with is to simply reuse the microservice from monolith 1 in monolith 2 the service is isolated and selfcontained so it doesn't care who uses it. i found it to be a rather elegant and simple solution for cases when you want to reuse an implementation but can't package it into a library because clients have different stacks.;0
30078984;HackerNews;2022-01-25;i agree that microservices shift complexity but i'm not sure that this inherently results in an overall increase in complexity. for example using highly automated ops tools like autoscaling and load balancing can enable smooth handling of problems that can be challenging to handle in code.;0
30078959;HackerNews;2022-01-25;do you have an auth service that does not do api? does your api ask the auth rather than reaching into the auth table to see who is authorized? when you send an email do you do it inline or do you trigger a push to a queue with separate workers? does your externally accessible api talk to internal services using a predefined protocol rather than reaching directly into a database?congratulations you have micro services!as someone who have driven the migration from a monolith just set environment variables and magically the same codebase becomes auth notifications workers web and api and the same codebase reaches into every single database and talks to every single service into micro services because a simple features were taking months to implement i can confidently say that even today in 2022 an average organization does not have the tooling or the team to do a monolith. monolith is a cargo cult. break stuff into an digestable chunks externalize your own internal libraries if they are shared version the interfaces and stop worrying about microservice complexities.;0
30078956;HackerNews;2022-01-25;a few points i'd like to make1. you can't migrate to microservices from a monolith. this is an architectural decision that is made early on. what migrating means here is rebuilding. interestingly migrating from microservices to a monolith is actually much more viable and often times just means stick everything on one box and talk through function calls or ipc or something instead of http. don't believe me? see this e the only ways we could break down our monolith meant that implementing a standard feature would involve updating multiple microservices at the same time. having each feature requiring different combinations of microservices prevented any microservice from being owned by a single team.once something is built as one thing you can't really easily take it apart into many things.2. microservices does inoti mean kubernetes. the idea that to properly implement microservices you need to set up a k8s cluster and hire 5 devops guys that keep it running is just flatout wrong.3. microservices are antifragile to use a talebian term. so i think that this paragraph is actually incorrect this uncertainty made creating microservices more fraught as we couldnt predict what new links would pop up even in the short term.a microservice is way easier to change again if designed properly than a huge app that shares state all over the place.4. what's the point here? it seems like the decision was hasty and predictably a waste of time. any ctoarchitecttech lead worth his or her salt would've said this is a bad idea to begin with.;0
30078950;HackerNews;2022-01-25;because the team might already be comfortable working in that way? because certain parts of the application might require specialised implementations and very natural lines of separation fall out?im in a team of 4 and the few apis we expose would be considered microservices. we did that because it was easiest and fastest for us to build and maintain and the features we provide were all quite distinct.;0
30078921;HackerNews;2022-01-25;we have approximately 12 developers spread across 2 feature teams and a support team.if i were consulting for this company i would have told them to stop right there microservices are probably not for them. unless you build from the start for microservices on something like aws lambda doing with such a small team would be really hard.and as they eventually discovered a lot of unnecessary overhead for such a small team.;0
30078871;HackerNews;2022-01-25;its about trade offs i think.monolith can microservices are so often presented as x is better than y but it should be which is more applicable for the team size product and operational concerns.monoliths are a great choice for certain team sizes and applications want stricter isolation and blastradius between different teams and products and need to scale different things differently? micro services are probably a better choice.;0
30078867;HackerNews;2022-01-25;recently our development team had a small break in our feature delivery schedule. technical leadership decided that this time would be best spent splitting our monolithic architecture into microservices.maybe redesigning the architecture of the product just because there is time vs. there is a pain pointproblem that needs solving is already a red flag. in this context it feels like micro services was a hammer looking for a nail and they had no such nail.edit typo;0
30078847;HackerNews;2022-01-25;just picked a bad service boundary well that's the thing isn't it. if you always pick the right boundary up front something that is perfect both now and also anticipates any kind of future crazy feature request if you can pull that off i'd say ianyi architecture will work well.but most people get boundaries wrong some times. sometimes very badly wrong. sometimes the boundaries are historical set by product owners without technical input set by junior developer set by superficial attributes and sometimes even the most experienced developerarchitect just does a mistake.and the whole point of not doing microservices is you don't have a huge investment in your boundaries it's more feasible to change them once you inevitably now and then realize you got them wrong.;0
30078833;HackerNews;2022-01-25;i always start with a monolith while keeping microservices in mind. have clear communication boundaries avoid shared state as much as possible consider asynchronous and parallel processing needs etc.actor systems are a natural fit for this eventual decoupling. what starts as a simple actor w a mailbox can eventually grow to a standalone rest service with minimal headache in architectural refactoring.;0
30078765;HackerNews;2022-01-25;i don't think it was splitting monolith it was more like connecting separate applications.like you had a payroll in your enterprise of 1000 employees and you needed that same data in 5 applications in 3 different departments. so you would wrap payroll into a service and have that data accessible in multiple places.i think that is still a valid approach to build monolith app and use multiple services if they are internal apps.for customer facing and quickly changing stuff you might want to add microservices to be able to build new features quickly when ideally microservice should have its own database with what it needs to operate.;0
30078746;HackerNews;2022-01-25;why would you consider microservices if you are only 12 developers?;0
30078739;HackerNews;2022-01-25;it was soa service oriented architecture where you would split them up that predates microservices by quite a bit. i remember doing that in the early 2000s.what i think he is saying is that microservices people pitch their service against monolith as better but monolith hasn't been in vogue for 20 years. i saw the same tactic with scrum people pitching against waterfall which hadn't been in vogue for quite a while either.;0
30078722;HackerNews;2022-01-25;microservices shift complexity from code to operations microservices don't remove complexity they spread it wider making the whole more complex.;0
30078720;HackerNews;2022-01-25;this is just arguing over the service boundary definition and not the architecture. there are multiple comments here trying to differentiate between a service and a microservice which seems like a fools errand to me.;0
30078719;HackerNews;2022-01-25;monolith vs microservice is not a dichotomy it's a spectrum as it is with so many other things. individual microservices can still become monolithy and become responsible for doing a lot of things tm.that being said the biggest hurdle in a rearchitecture project like this is usually in the n1 n2 stage and n2 n5 is a lot easier once you add service 2 you learn how to set up telemetry permissions billingchargeback alerting etc. the next few are just repeating the same process.;0
30078714;HackerNews;2022-01-25;something like microsoft does with the their interfacesthey have multiple versions of calls. the older one function as before and never change. want different behavior here is yourinterfacev1 yourinterfacev2 etc.you still alert team about new functionality but they're free to consume it at their own pace. this of course involves a boatload of design and planning.i am in general against microservices and consider those as the last resort when nothing else works. to me a microservice is mostly my monolith interacting with another monolith.when monolith becomes big enough that it needs 2 teams i usually handle it by each team releasing their part as a library that still gets linked into the same monolith. that is my version of microservice when the only reason for it to exist is to have two or more independent teams.;0
30078682;HackerNews;2022-01-25;that is how you get to it.if you are noname rapper you start dissing bigger guys so they diss you back and you get notoriety because someone noticed you.as a politician you have to say others are the worst and broke everything but you have plan to fix everything that is broken now.in the end all the swearing is posturing and all great plans turn out not possible in reality.while yes you can do nice stuff with microservices it is not a silver bullet.;0
30078665;HackerNews;2022-01-25;microservices allow your team to have control over the full stack they require to deliver a feature.this is honestly pretty rare at least in my experience. what i have seen is that organizations will buy in to the microservices hype then dictate to their teams what stacks deployment paradigms etc. sometimes even down to the sprint cadence are acceptable.;0
30078635;HackerNews;2022-01-25;i think many microservice implementations are more complex than necessary but i also am extremely skeptical of someones competence if the database is on the same compute instance as everything else;0
30078587;HackerNews;2022-01-25;that's why finding the right boundaries between services yes services microservices is a harmful buzzword is important so that you minimise having to communicate and coordinate with other teams.;0
30078586;HackerNews;2022-01-25;microservices are relatively new and unproven.they are so old buddy actually. splitting monolith into servicesnot always been micro is a natural evolution for any software.;0
30078571;HackerNews;2022-01-25;i know its not a catch all. but more often than i would like to admit they bring simplicity and reduce complexity. the more i develop software the less i can stomach monoliths running on some big server. the other day i was considering deploying an mvp i have written on django and instead just ripped it apart and pushed the pieces into their own seperate lambdas. deploying some monolith api like that was nerve wrecking updates are the blast radius is higher and the composability of components is easier with smaller microservices.;0
30078539;HackerNews;2022-01-25;a size 20 shoe is better for a large foot... but not better for a size 15 or size 10 foot.saying microservices are better is the same as me saying a size 20 shoe is better than any other shoe... for everyone.it's not a viable statement in any use case except for people with size 20 feet.the business need is what determines the solution necessary.;0
30078533;HackerNews;2022-01-25;i think that moving a monolith to a microservices architecture is only justified if the organization size is large enough so there are different business teamsdepartments. in that scenario each teamdepartment will own a microservice and this will speed up the development on each team. still every time there is a change in any microservice api that will require coordination. for a small company12 developers i can't see the benefit.;0
30078529;HackerNews;2022-01-25;microservices had been sold to us as the ideal architectural for perhaps a year now. when he learn that there is no ideal architectural in software?;0
30078510;HackerNews;2022-01-25;the term monolith was devised by people who wanted to brand microservices as newer and superior.it's almost as if in order to succeed these days you need to discredit and disparage your competition rather than simply having a better product and that's why i don't buy into buzz words at all.if it's not broken don't fix it... microservices are relatively new and unproven. the way the world has rushed to dive into microservice infrastructure only highlights reckless spending and waste that is characteristic of overpriced goods and high taxes that are constantly in turn thrust upon us as consumers.microservice architecture is also inherently designed to lock a customer into very specific tools that make future migration to any other platform a very costly decision in most cases... thereby locking a customer into platformspecific dependency. microservices architecture also introduces the ability for providers to charge for each specific service as a utility... instead of being charged for one single server annually on microservices you can be charged for many individual components that run your app independently and when usage skyrockets it's a sticker shock that you can only stop by going offline.we have also seen enough failures and pain points within microservice and even cloud architectures over the past two years alone to raise questions about whether or not it it indeed a better solution.we need to stop disparaging traditional noncloud hosting and solutions that aren't obsolete at all in this manner and focus on what works what is secure and what is cost effective in order to stay sustainable into the future.the more we allow marketing minds to take control of our it decisions over reasonable technical minds the more costly it will be to us all over time no matter what salary we make. bog tech firms will hate me for saying this but any human in the chain can tell that reckless drive for weakvulnerablecostlyand overcomplex it solutions cannot be sustained as a viable longterm business sales strategy anyway.;0
30078501;HackerNews;2022-01-25;it took me a while to accept that microservices are better. not in every case but in a surprising number of cases. they really shine when combined with serverless computing. clear seperation of code by a networking call is the next logical step in the encapsulation principle of object oriented programming. we hide the implementation details and only expose an interface which creates seperation and forces us to stop sphagetti logic. microservices are the enxt step in that design pattern and only with the improvement in container technology and cloud computing has this become achievable in the sense of there not being so much operations and complexity overhead.;0
30078405;HackerNews;2022-01-25;a benefit of microservices is that each team can be responsible for releasing their services independently and without coordination with other teams.sounds almost sarcastic. how do you deliver api changes without alerting other teams?;0
