ID;Source;Creation Date;Content;Sentiment
30758723;HackerNews;2022-03-21;Title:Microservices: Why Are We Doing This?, Content: https://michaeldehaan.substack.com/p/microservices-why-are-we-doing-this;0

30800006;HackerNews;2022-03-25;well you have an api for libraries as well and an even stronger one because you can have type guarantees which you can't do with json you can use grpc etc but people usually don't.with libraries it's easier than with microservices because i can scan all the dependency files of all projects and immediately see which project relies on what library which is much harder to do with microservices as a library author.with those two things and the fact that you can just keep using an older library version if you need to whereas you can't easily keep using an older microservice version if it's been upgraded i think libraries have lots of advantages in this.;0
30799701;HackerNews;2022-03-25;in my experience for regular libraries you usually want to pin version ranges and not always use the latest of every library. but when the main business logic and a whole team is dedicated to one of the service libraries whose responsibility is it to make sure that the version stays up to date across other service libraries? do you leave it up to the main host app? do you allow a multitude of service library versions? do you skip versioning all together? in microservices you have an opaque facade in the form of an api that makes this a nonissue. perhaps you'd want some simulacrum of this in the form of ipc between service libraries?do you use some sort of contract based testing between service libraries? put all integration testing in the host application?it's not obvious to me what the best approach would be.;0
30775673;HackerNews;2022-03-23;regarding why you got the downvotes i have a guess have you maybe considered not ... usually gets followed by something that's transparently stupid or incompetent or otherwise undesirable in the given context. for example have you considered not publicly yelling at your coworkers? obviously that's not what you were saying but it may have read like it.it's a fantastic indirect way of telling someone they did something stupid. and because stupid actions map so well onto their doers it's also a fantastic way to insult people.as an aside this sort of indirection asking a question to assert something it's not peculiar to english but it's suuper common in englishlanguage expressions which is in fact due to the habitual indirection of the english at least according to a linguistics professor i once had.the kicker is because it's an ironic construction its likely going to require more effort to process the presence of irony means that what is actually meant by the speaker is not encoded literally but rather must be interpreted derived from what was said and irony and other ways of flouting literal language yields a disjunction x y z. it puts the listener into a role where their recognition of intent and ability to joke around are tested and the correct interpretation is up in the air. so while it's possible to say this expression to a friend when they screw up have you considered not showing up to work drunk? it's also a great way to make an enemy have you considered not being a fuckup that nobody likes?. same construction. in fact this later example is especially sinister because any answer you give just makes you assert what you're being slandered with. no i haven't considered not being a fuckup? yes i did in fact consider not being a fuckup? you get the idea. it can be wielded in a very mean way.and your comment wasn't intended this way at all and in fact it's obvious when you read it that straight talk and no irony is meant but it shares enough of the signification with the ironic phrase that it sets off alarm bells. especially in an online reply to someone where trolling is sport! the context is working against you here.and the context is the first tool we have when interpreting communication because it's already available to our cognition before we receive any given message. and brains are energy misers using heuristics to filter shit out that doesn't look like a good reward for the necessary energy expenditure.so i bet that the downvoters saw 1 a short comment and short is by the way much more likely to be low effort and unconstructive and 2 all the native speakers' downvoting brains instantly recognized the same construction as the ironic idiom talked about above and then they instantly said fuck it this person is being a dick without even really reading it. since irony unless its expected requires more processing effort both in detecting whether irony is present and what the ironic speaker means just to get to the point where you can start assessing the semantic content these two things were enough to justify jumping the interpretive gun. i wouldn't be surprised if your question was flagged by most native speakers brains asshole detection systems. and so the actual substance of your question which processed in its entirety have indicated that you were asking a bona fide relevant even microservicesessential question got booted out. and then the overzealous downvoters succumbed to the urge to smash the downvote button without a second thought and never looked back.i found myself in the same place actually thinking they're being a dick then moving on. probably took less than a second. often when people in online conversations say why the downvotes? they're trolls acting in bad faith which pisses me off because i always go reread what they wrote. so i did. you weren't calling anyone stupid! still i had to stare at it a bit before i realized it was an unintentional collision with the syntax of sarcasm. maybe like if i wrote was hast du denn? and really truly meant what do you have? instead of what's wrong with you? if you don't recognize it for what it is it might look like an honest question which expects an honest answer.oh. another thing to consider after a while spent in any given semiotic context our cognition adjusts and those cognitive heuristics that reject hard things become even lazier. our pattern of behavior when reading on screens starts with reading but then it turns to skimming and scanning if given long enough. i'd bet money that if your brief but bona fide contribution had been one of the first comments your downvote percentage would be a lot lower. halfway down a long page the skippers are skipping and the downvoters downvoting. that doesn't mean that they intended to or are even aware of the switch in reading modes. at the top of the page information is still shiny and new and worth interpreting speculating on the speaker and their intentions etc. after a while nobody gives any comment a second chance.anyway i don't get to revisit all the shit i learned at university enough so it felt good to write all that. are you still here? maybe everyone's already moved the fuck on. brain got bored? would serve me right ha! so here i go back to my job where instead of working in cognitive linguistics text semiotics pragmatics philosophy of language etc. i'm writing boringass javascript all day for an application ... being built on microservices.;0
30771854;HackerNews;2022-03-22;above all i'm saying that sentences like microservices are better monoliths are better 42 services are the best are all stupid without context.what your business does how many people you have 3 or 10k what kind of roles and seniority you have how long you're in the project 3 months in or 10 years in how crystalized architecture is at what scale you operate how does performance landscape looks like what kind of predeployment quality assurance policies are dictated by the business are offline upgrades allowed or we're operating in 24h which direction system is evolving where are gaps scalability quality... etc are all necessary to determine correct answer.building website for local tennis club will require different approaches than developing high frequency trading exchange and both will be different from approaches for system to show 1bn people one advert or the other.seeing world as hotdog and nothotdog microservices vs monoliths makes infantile conversations. there is nothing inherently wrong with microservices monoliths or any of approaches to manage complexity ie refactoring code to a shared functions encapsulating into classes or a typed object encapsulating into a modules simply arranging code into better directory structures flattening naming things better changing crosssections ie. by behavior instead of physicalish classes and objects extracting code to packageslibraries inside monorepo or its own repository ie. open sourcing nonbusiness specific generic projects or rely on 3rd party packagelibrary extracting into dedicated threads processes actorssupervisors etc. extracting to service in monorepo or dedicated repository or creating internal team to black box it and communicate via api specs or use 3rd party service...bonus points for removing code deleting services removing nonsensical layers of complexity simplifying unifying etc.etc;0
30770339;HackerNews;2022-03-22;i see. i guess i've been lucky enough to be on teams that haven't thought of microservices that way.;0
30770273;HackerNews;2022-03-22;i dont understand why i got the downvotesi was taught that sharing code between services should only be done in circumstances in which there is already a strong connection between them for example by being owned by the same team.in the organization where i initial learned how to deal with microservices even direct calls via http between services was a nogo and only used in rare circumstances and if then only temporary.i am not sure if this is the way to do it since i have a sample size of one but we had about 500 services to manage and in the end it worked okay and i never saw something you described. thats why i wanted to know if you have considered just not sharing code.;0
30766430;HackerNews;2022-03-22;ruby and ruby on rails is definitely still here! i'm currently job searching specifically for fullstack roles including rails and i'm at least finding some success but i do find many of the jstsmicroservices roles you describe as well.there are many companies still successfully using rails don't lose hope!;0
30766336;HackerNews;2022-03-22;yes obviously there are use cases where microservices is a better architecture but the point is it's very rare and most teamscompanies never need it because it would complicate their life unnecessarily.;0
30766224;HackerNews;2022-03-22;i was fortunate to have a similar experience early on. that being said i still firmly believe there are cases where microservices are appropriate such as when you married to a specialized framework that only supports python 3.5 but you want to use modern tooling for everything else as much as possible;0
30766060;HackerNews;2022-03-22;to some extent i think monolith is actually changing connotation as people realize that microservices are not a silver bullet. for example shopify calls their system a modular monolith;0
30765904;HackerNews;2022-03-22;agreed! i think a wellstructured monolith is what most projects call for.what i don't want is for people to buy the microservices hype so thoroughly that they start thinking microservices just means wellarchitected system.;0
30765894;HackerNews;2022-03-22;the main benefit of microservices there is that they can be independently deployed. if you have libs into a monolith you have to redeploy the entire thing which may involve coordination.i still mostly prefer the libs monolith approach though.;0
30765036;HackerNews;2022-03-22;i dont actually think this is where it comes from necessarily. in my experience most of this comes from the engineers themselves. usually business just wants a crud app but the engineers want a distributed cloud microservice extravaganza partly to keep themselves entertained and partly to pad their resumes.but you dont get upvotes for saying this on hn.;0
30764936;HackerNews;2022-03-22;the attitude. the micro of microservices belies a religious zeal that more and smaller services is an unmitigated awesome thing and we should always strive for more of it. services is for people who think it is a necessary evil to be deployed under the right circumstances.;0
30764794;HackerNews;2022-03-22;at what size does a microservice become a service?there is no answer to that because microservice is a meaningless buzzword at first place like cloud no code or serverless. these are mostly marketing concerns not engineering concerns. marketing has taken over web development.;0
30763294;HackerNews;2022-03-22;i'm just leaving my first job because among other things i really start dreading adding business features to a 20 year old huge monolith riddled with terrible code and even more terrible oop inheritance roller coasters of madness up down up up down up down ... who thinks this has anything to do with good abstraction wtf? it certainly doesn't help that the company has a it always worked so we will never change kind of attitude towards absolutely everything.currently i couldn't be more excited to start my new position in which i'll be responsible for speed reliability amp security of millions of cloud transactions in a microservice backend.that being said let's see how i feel in 6 months. experience need to be made by oneself.;0
30763257;HackerNews;2022-03-22;if a repo needs to be broken up for performance or organisational reasons is there really a reason to prefer to integrate the parts as microservices rather than as libraries?;0
30763188;HackerNews;2022-03-22;microservices why are we doing this?1. because many developers have no idea that it is possible to produce a local imodulari application.2. plumbing technologies and deployment pipelines have become more important than a business problem domain.;0
30763184;HackerNews;2022-03-22;which is actually much better than a distributed monolith random microservices thrown together just because it ticks some boxes on managements resumes;0
30763073;HackerNews;2022-03-22;i think one mistake is using the term monolithic in comparison to microservices. to a whole new generation of programmers and a fair proportion of older ones also it has a negative meaning somewhere approaching a huge and growing mess of smelly unstructured nonmodular code. it is a negative term iinventedi to compare against the glory that be microservices.i prefer to use the term local modular application in lieu of anything better?;0
30763007;HackerNews;2022-03-22;likely faster less flaky less complicated setup and higher coverage than the integration test suite of a set of microservices.;0
30762742;HackerNews;2022-03-22;do we have to release often? no we do not because the release process almost never changes and there are so few components.this is nonsequitur release frequency is not dictated by release process although it is affected by it but by business requirements.we never really had monoliths before in development that i experienced.good for the op i guess. i currently involved in development of 3 monolith services. all are 67 years behind on the framework they were based on and making any sweeping refactorings is cost prohibitive and tantamount to a full rewrite. were they architected as microservices which entails not just code but infra major refactorings would've been on the table.code review policy feelings doesn't make a lot of sense to me either. company's policy is all code goes through review. how one feels about it is not relevant it's a part of one's job. microservices or not code gets reviewed.;0
30762575;HackerNews;2022-03-22;if you have a single deployment unit you have a monolith regardless of how that deployment unit is structured on the inside. there's a lot of fuzziness about what microservices means but isomei degree of independent deployability is pretty nonnegotiable.;0
30762525;HackerNews;2022-03-22;in my experience 95 of the people advocating microservices can't properly explain acid. not to mention advanced concurrency concepts like mvcc.regarding division of work those advocates seem to have forgotten that libraries exists.or that you can deploy a monolith and still scale endpoints independently.microservices might be a good fit for tiny fraction of real world scenarios.;0
30762524;HackerNews;2022-03-22;before we invented terms like microservices and service meshes and even saas and paas the phenomenon was just called dazzling them with bullshit.tony hoare used his turing award speech to state the following microservices were meant to be simple encapsulation but if you create enough crosslinks in a network of very simple services then rather than removing the weight you've just pushed it out of the nodes and into the edges. and since those edges don't exist when the system is at rest they are dead awful to analyze and reason about. there are no obvious deficiencies.;0
30762462;HackerNews;2022-03-22;this is actually why i think we need more cloud and not less. the problem is poorly designed code not monolith or microservice.for example validationservice as described above could be replaced with openpolicyagent and would scale much better.that said i could see someone pointing at openpolicyagent and asking why they didnt separate distributed updates from the policy spec as two distinct projects this way you could reuse parts of opa to distribute config files or feature flags. you can now too but it requires the extra hop of compiling a function to answer.come to think of it distributed state updating is roughly the same general problem that kubernetes operator pattern solves.another way of putting it we have cloud primitives but not enough of them maybe or they arent well enough explained to make the choices or restrictions of different architectures a bit more obvious? i especially look forward to a future when we get design systems for the programming we do with business logic in the cloud.im overemphasizing cloud here. i mean code you dont directly have to maintain and write regardless of where it runs or who wrote it.;0
30762401;HackerNews;2022-03-22;to people from the world of smaller companies microservices means creating a lot of json graphql services and trying to make them talk to each other reliably.people from big companies are also doing microservices but they don't necessarily call it that. they use typed interprocess communication technology such as protocol buffer thrift etc and work in a monorepo with statically typed languages. this makes things much more likely to work.i suspect that in general smaller companies doing microservices should move in the direction of what the bigger companies are doing.;0
30762314;HackerNews;2022-03-22;going from working at a company with an engineering team of 40 odd engineers to a company with thousands of engineers where the small company was trying to move towards microservices and it was just really slowing us down and the large company was in a hybrid mode of still having a couple of monoliths and a lot of microservices i could definitely appreciate that there is very much a scale at which it absolutely makes sense for the engineering organisation to use microservice and very much is a scale below which it's fairly counterproductive.;0
30762289;HackerNews;2022-03-22;my advice would be to carefully construct an explanations of the scenarios when microservices do apply and then explain why you are not currently in that situation. i tried that once. didn't work. end result was just pure pain.;0
30762270;HackerNews;2022-03-22;this article fails to mention anything about team size which should be the first criteria for any decision about microservices in es because it's just new terminology someone made up because serviceoriented architecture wasn't cool anymore and they had to prove how original and modern their thinking was. half of the engineering orgs chasing this fad are lt50 people and have absolutely no reason to be adding the overhead of an soa. the rules of thumb should be if you have more than 1 service per 4 engineers it's too many and if your total engineering org size is not big enough to support a dedicated infra team of 4 engineers working fulltime on tools just to support the other teams then you're not big enough.overcomplicating things to pad your resume might get you into faang but it won't make you a good engineer or a good entrepreneur. the sign of a truly senior engineer is one who knows how to keep things as simple as possible to solve real problems while maximizing power to weight ratio of their code. the resumedrivendevelopment antipattern is pretending that the problems facing 1000 or 10000 person orgs are your problems. those large companies got to where they are by solving the problems in front of them and you won't get to that scale if you don't do the same.;0
30762262;HackerNews;2022-03-22;i worked at a place that had a microservice for validations. you made a request with the item singular to be validated and the rule to validate it by. the most common validations were things like is this value greater than 15 or are these values equal.nobody else saw the problem here. establishing a http connection serializing a json document deseralizing it on the other side then doing 14 15 anyway before going back the way it came. lighting up a hundred thousand lines of code vs one.this was done as it iterated over large files millions of items millions of requests.they were genuinely confused why it was slow.;0
30762251;HackerNews;2022-03-22;is it a common thing for proper microservices to have microservices retrieve data from other services via apis?i've worked on microservices systems before that do this. they were mostly shit.the system i'm working on at the moment has each service subscribe to events and maintain its own database. the only comms is via events. it works pretty well and everything really is nicely separated but it feels a bit haphazard.;0
30762216;HackerNews;2022-03-22;i do not have a problem with a a product being implemented as microservices if1. the microservice platform itself is mature and stable. see vmware tanzu. 2. the devs implement traceability. see correlationid 3. there is good crosstraining between the dev and sre teams.actually. all 3 apply to monoliths too.;0
30762192;HackerNews;2022-03-22;i used to be afraid of that but i've found that it is possible to solve this problem with code ownership rules in github.which sometimes you also need even when using microservices if you use a monorepo for example;0
30762177;HackerNews;2022-03-22;it is definitely possible to reap a lot of those things with monoliths. separating internal code using libraries as the sibling poster said using different server clusters to serve different routes deploying those clusters independently if possible using multiple databases separating the applications in different areas maintained by different teams. the one thing microservices can do that monoliths can't however is allowing as many different languages.;0
30762108;HackerNews;2022-03-22;work at a bank. microservices have allowed replacement as tech preferences or performance requirements have changed. i havent always liked the changes but they were enabled by the architecture. can shift one service at a time run both leave some services alone no dependency.note lots of systems lots of technologies from sap to rust. not all microservice by a long shot but those have worked pretty well.;0
30762060;HackerNews;2022-03-22;right but some of those desirable system properties are much easier and lower friction in microservices.and others in monoliths.each has its pros and cons.;0
30762040;HackerNews;2022-03-22;this is the comment i was looking for. microservices as fashion is often a bad idea. as with any architecture decision you cant just choose something that other people have called a best practice and pretend you did your due diligence unless you understand why it is a best practice and know how it applies to your particular situation.;0
30762010;HackerNews;2022-03-22;my advice would be to carefully construct an explanations of the scenarios when microservices do apply and then explain why you are not currently in that situation. the best microservice examples i've ever found were for the addition of features to legacy systems the ability to write minor additional things in alternate languages and most critically when the original code base couldn't be changed or was lost and yet more functionality was required. there are valid reasons to add ia microservicei there are probably not good reasons to take a normal code base made by a modern company and completely shift to only microservices.;0
30761978;HackerNews;2022-03-22;meh i think its propaganda from major cloud providers. its hard to do microservices well without all their tools which is;0
30761927;HackerNews;2022-03-22;microservices work well if your contracts are welldefined domain knowledge is limited your team is under the size of a pizza and your platform needs are diverse. eg some small teams prefer containers other prefer managed containers serverless others prefer small vm's.soa works well if your teams are larger and have larger domain or end to end however you want to call it knowledge.monoliths work well when the domain of the application is singular the team is large or if you're in prototyping. the big downside for monoliths is that their scaling model must be considered in advance or engineers can tactically corner themselves with architecture. that incurs big expensive rewrites as well as time.while conway's law may be reflective of the enterprises use of or overuse of microservices i think it really has more to do with a different enterprise habit understaffing and budget constraint. microservices and clientside applications from my perspective very rarely have longterm maintainers. instead things get done in cycles and then for most of the year a given service does not receive ianythingi besides some maintenance updates or lowhanging fixes. that makes it look like a microservice is expendable and easier to replace to the people who manage resources staffing and budgets. thus things now look modular to the people who fund the ship that everyone else drives.;0
30761902;HackerNews;2022-03-22;there are techniques to allow large teams to work on monoliths together. they take planning and discipline but overall i would say are far more reliable than microservice explosions for similar sized systems because the earlier you manage the integration the less work it is. ie what you pay at source integration time is less than what you pay dealing with deployments infrastructure and especially support across distributed systems which can get real expensive real fast.i've worked on multiple systems with around 50 developers contributing fulltime to them very practically.;0
30761876;HackerNews;2022-03-22;if we think about the easiest way to swap out pieces of functionality that is by using welldefined interfaces low coupling and separation of concerns.microservices don't enforce good practices and monoliths don't prevent them either.;0
30761873;HackerNews;2022-03-22;but welldefined interfaces are not specific to microservices ms. low coupling high cohesion separation of concerns and well defined interfaces are simply system architecture. which is easier to work with without the infrastructure overhead of loads of semiindependent ms. ms is a net loss here because your complexity budget is consumed by the infrastructure instead of the system architecture.fault tolerance again is largely orthagonal to ms. it's a matter or system architecture see the point above. e.g. a common situation where service one depends on availability from service two having them as seperate ms doesn't help what helps is architectural design to keep service two useful somehow regardless and this is orthagonal to if the services are in process or done as ms.scaling is a whole other discussion and microservices can have good impact here but so can other techniques.;0
30761838;HackerNews;2022-03-22;i've started my current project with microservices and i regret it. if i could start over i'd simply use rails and focus on the business instead.;0
30761767;HackerNews;2022-03-22;microservices is what allows one to scale independently.;0
30761760;HackerNews;2022-03-22;i miss ruby a lot. its just makes developers happy. it just makes sense and i am so sad that microservices killed my livelihood. nowadays theres few ruby jobs w many competitions because fewer company uses it. now been working for jsts amp microservice for 5 years but i am still longing for ruby. i wish ruby is still around. i wish to be happy again.;0
30761742;HackerNews;2022-03-22;i don't usually see companies with microservices. it's more like there's this one big monolithic service with a bunch of satellite services orbiting the big one.the only time where microservices truly exist is if you're part of a big company that has a multitude of initiatives. but within a scope of a single project there's almost always a mothership.;0
30761712;HackerNews;2022-03-22;this is the story of software development. we have no formal way of defining which style is better. it's just anecdotal arguments over and over again with no proof.like evolution you would think the technology gets better through natural selection. however selection pressure in the real world is vague. the best doesn't necessarily win just what works and microservices is a form of genetic drift.;0
30761707;HackerNews;2022-03-22;microservices don't even have to run in separate binaries let along separate machines.if you're not running separate binaries what you have is a monolith with welldefined module boundaries not a set of microservices.;0
30761659;HackerNews;2022-03-22;your problem was using json instead of a typed language like protocol buffers or even java rpcs and that you were using separate repos for everything.microservices don't even have to run in separate binaries let along separate machines.;0
30761637;HackerNews;2022-03-22;it's a case by case scenario.i built my project in a microservice architecture so when the author states that microservices were built so that teams can enjoy their independence it doesn't apply to me as i am currently a 1 man team.i split my services up for many reasons but primarily two the ease of migrating from python to go as the ease of rebuilding one service at a time differs as opposed to a full blown rebuild and also for performance and scaling as parts of my application will be hit harder by outside requests than others.web requests can be managed by one type of instance that results in one ec2 image or whatever. anything that can be handled within the lifecycle of one request can be handled there and these instances are horizontally scaled behind a load balancer.the author gave an extremely simple and generic system design and while this can work for a sizable amount of applications there are still a significant amount of applications that require and demand a more complicated structure.one of the services that i have split almost exclusively deals with real time connectivity with websockets which requires a towering amount of performance as opposed to the other services that i have to place these in a monolithic structure scaling would be incredibly awkward imagine adding 10 more load balanced boxes just so you can handle your websocket requests but now the part of your app that deals with all your http requests is now also horizontally scaled when it didn't need to be.on the communications front internal web services are often doubly inefficient by using rest rather than binary transmissions. theres no reason for any of this and if multiple microservices hops are used this all adds up and slows down the system. even just a conversion to json and back is a wasted effort more so if done dozens of times.this is true while initially developing internal communication with grpc i've reverted back to http despite the 3050ms tlsssl handshake simply because its a tired and true technology.grpc is still relatively new with seemingly insubstantial development and i was afraid to proceed further as roadblocks and technical debt may be accumulated in the future.however in a smaller mesh in my opinion anything shorter than 150ms is insubstantial in my opinion a blink of an eye is just about 150ms and if it is the case that the internal requests are hitting multiple endpoints before resolving the original request then it's more of an architectural problem not that microservices are a problem.not everything has to be finely chopped but breaking some portions down can make it more digestible;0
30761554;HackerNews;2022-03-22;after having reviewed 300 tech stacks i can say with certainty there are use for and against microservices. the benefits are numerous they just tend to be overused and not implemented consistently the appropriate way.;0
30761542;HackerNews;2022-03-22;there's a degree to which i agree with this but the advantage monoliths have is the opinionated frameworks chiefly rails django and the like that handhold a less competent team towards a sane design.in comparison building a good set of microservices is a minefield of infinite possibilities with each decision about where a particular responsibility or piece of data should live being quite significant and often quite painful to change your mind about.;0
30761532;HackerNews;2022-03-22;the problem with modularization and its supposed benefit of autonomy is that the universe disagrees. everything is connected whether you like it or not.a pure microservice ideally has no state or if it does its own data store. that's awesome until the frontend team wants a joined result query from multiple microservices and thus data stores.what are you going to do now? build a proxy microservice in front of it? with shit performance no referential integrity and hard dependencies? more likely you won't do that so the frontend is going to be looping calls. 50 network requests with each having parsing overhead just to render a simple list of things.the autonomous team has their own roadmap which in a connected universe the one i live in is a problem not a solution. the business team really needs that mobile app to be shipped soon but the micro service team has no room on the backlog for another 6 months to build the part needed. a business prioritization problem? perhaps but it just shows that autonomy is largely a fantasy. the reality is that as soon as something is one team away everything becomes dramatically slower and less flexible. that's the price of autonomy.all of this is like a 100 times worse than the ridiculed traditional software stacks but hey i'm not complaining. in a perverted way i benefit from delusional tech choices. it keeps me paid.;0
30761509;HackerNews;2022-03-22;before microservices were a thing i had the chance to work on a couple of telecom systems written in erlangotp but it wasn't until years later that i realized we were already doing most of the things people were using microservices for with the single exception of being polyglot although elixir and gleam are starting to challenge that.small teams were dealing with specific functionality and they were largely autonomous as long as we agree upon the api which was all done via erlang's very elegant message passing system. scalability was automatic part of the runtime. we had systemwide visibility and anyone could test anything even on their own computers. we didn't have to practice defensive programming thanks to otp and any systemic failure was easier to detect and fix. updates could be applied in hot while the system was running one of the nicest features of the beam that microservices try to address.all the complexity associated with microservices or even kubernetes and service meshes are ultimately a way to achieve some sort of polyglot beam. but i question if it's really worth it for all use cases. a lot of the old technology has kept evolving nicely and i'd be perfectly fine using it to achieve the required business outcomes.;0
30761483;HackerNews;2022-03-22;except in my experience most attempts at microservices scale extremely poorly because they have nowhere near enough precision in their apis to get ijust the information you needi and so most applications end up fetching way way more data than they need and whittling it down manually and often having to stitch together the results from multiple calls.that of course leads you down the path of creating an oddly specific api that caters exactly to the needs of the clients down to the point that small changes in the client's needs require changes in the upstream services so your separation of concerns has become a joke.;0
30761477;HackerNews;2022-03-22;i'm not for or against microservices but that seems like quite the cherrypicked list. there are arguments on the other side too such as...if we think about the easiest way to swap out pieces of functionality that is by using welldefined interfaces low coupling and separation of concerns.if we think about the easiest way to scale parts of the whole independently that is by similar mechanisms.if we think about the easiest way to build in faulttolerance that is by distributing work across failure points.and so on...;0
30761430;HackerNews;2022-03-22;microservices is just a tool that can help a technology company scale. like any tool when used improperly or with the wrong architecture can be very bad for those involved.given how many fail to implement it right it would help if we had a paradigm that caused less failure but i don't see the author recommending anything except for going back to monoliths. i understand their perspective but i'm not sure this is an either or scenario.the solution is probably some new paradigm we haven't figured out yet.;0
30761404;HackerNews;2022-03-22;the problem is that there are so many developers now who have never had any experience of anything that isn't some botched attempt at microservices. the idea that it's possible to encapsulate code and separate concerns in any other way is foreign to them and an api to them is 100 synonymous with a restgrpc interface. so there's nothing for them to revert to and they are doomed to repeat this pattern clearly with the impression that this is what app development iisi.meanwhile a lot of the industry is trying to tell them that their problem is they haven't separated things ienoughi and should be using lambdas for everything.;0
30761346;HackerNews;2022-03-22;if you only have a few large services that work quickly and efficiently you probably don't have many teams working on them and have little overhead devops work. if you have thousands of microservices suddenly you need many more architecture platform sso auth ident teams security teams etc. creates more jobs.;0
30761296;HackerNews;2022-03-22;monolith microservice architecture librariesall of your fooservice json endpoints can be libfoo apis the original meaning!;0
30761265;HackerNews;2022-03-22;netflix dropbox slack and pinterest are all mature profitable public companies. not sure if they count as hypefueled.i'd say you're letting your biases blind you. netflix writes mature robust code mostly in java and uses microservices.;0
30761239;HackerNews;2022-03-22;microservices actually allow teams to work independently of each other once there are agreed on interface contracts and more importantly decouple schedule i don't have to wait or switch to something else if you're 3 days late delivering your component it is usually easy to mock the inputs and outputs and build test harnesses and do lots of things that are more difficult with monoliths.however i don't understand why people get religious about methodologies. every time a new fad comes out i don't look at it as the one true way i just evaluate its strengths and weaknesses and add it to my toolbox. i also am not religious about following all the precepts of the new religion. i'll mix agile and waterfall if i want. i will conduct my daily status meetings how i want and call them scrum even if it's just to piss off zealots. i will sit down during standup. i'll mix microservices and monoliths. i will figure out the value i want from a methodology and be happy when i get that i don't believe in utopia anymore.;0
30761182;HackerNews;2022-03-22;alright i agree completely. but i still don't see how it causes the same issues as microservices does. it is definitely conceptual crack which is a genius term btw but it isn't an ominous foot gun the same way the allure of microservices is.edit oh i get it you aren't talking at all about the consequences for the implementers. only the massive effort required to turn the alluring vfs into the react we have today. got it.;0
30761172;HackerNews;2022-03-22;the reason for choosing monolithic architecture is simple velocity. you need to move fast and be nimble until you are able to find a product that people want andor need to use.the people who at least initially advocated for microservices were the first to point out that it is better to start as a monolith and then refactor into microservices as required by external factors.;0
30761167;HackerNews;2022-03-22;the do one thing and do it well unix philosophy already broke down decades ago when people started adding things like cat v and ability to sort ls and whatnot. people like doug mcilroy still argue that's all useless bloat. pretty much the entire rest of the world disagrees. the point is that do one thing and do it well doesn't actually work all that well in reality.a cli not a service there is no operational complexity to keep things running in a cli you just chain some things together with pipes and that's that. the nice thing about that is that the text interface is generic and you can do things the original authors never thought of. with microservices this usually isn't the case and things are extremely specific. this is also why do one thing and do it well doesn't really carry over very well to guis.a lot of microservices i've seen are just functions calls but with the extra steps of the network stack grpc etc. some would argue that this is doing microservices wrong and i'd agree but the reality of the matter is that this is how most people iarei actually using microservices and that this is what microservices mean to many people today.instead of microservices we need to think about eventdriven logic or something like that. currently the industry is absolutely obsessed with ihowi you run things rather than how you idesigni things.;0
30761143;HackerNews;2022-03-22;i find the organizational arguments to be pretty convincing but surely there must be a way to reap these rewards in a monolithic infra setup as well? maybe someone should develop a monolith microservice architecture where all the services are essentially and enforced to be isolated but once deployed is built like a single unit.you could do it with dockercompose i guess but optimally your end result would be a single portable application.;0
30761133;HackerNews;2022-03-22;i think the complexity claims for microservices are way overblown. there are a set of trade offs to be made on both microservices and monoliths.for microservices you need a good idea of how youre going to do ipc and how youre going to maintain isolated state. in most cases there are reasonably easy solutions to both problems but in general there is a little bit more more upfront work to do when starting with microservices.for monoliths you need a good understanding of how you are going to upgrade a running system without downtime and how you are going to stop developers from taking stupid shortcuts that create invisible internal coupling. imo if your team is big enough to have the necessary processes to get this right its big enough to deal with microservices too.so i honestly dont get the hate from some on hn for microservices. you can fuck anything up if you try hard enough but microservices epitomise the principles of good systems engineering most particularly around separation of concerns. i honestly dont understand why anyone would choose a monolithic architecture for a new build in 2022.;0
30761069;HackerNews;2022-03-22;a compact functional monolith can be leaked and downloaded under a warez link somewhere or taken by a former employee to a new company. a sprawling byzantine landscape of poorly documented microservices cant be pirated or even reproduced legally without resources close to the original creator.;0
30761058;HackerNews;2022-03-22;imicroservices are in that essence a religious belief that we should approach with skepticism as is true with many things in software.ithis is a ridiculous strawman. the point of microservices is higherlevel architecture and design to have discrete components in your system that fulfill a single responsibility do one thing and do it well so that reasoning about the entire system as a whole becomes simpler. it allows the microservice to expose its implementation behind a welldefined api and thus keep its privates private. additionally microservices permit those subsystems to scale independently.monoliths can do isomei of that but often the keeping the implementation private is the hard part. when every part of the system has access to a database people iwilli reach behind the api amp just get the data they need. it's not iimpossiblei to prevent per se but having the service entirely separate makes for a much better stronger separation that forces the api design amp planning that would not otherwise occur as it would otherwise require a level of discipline that i don't think today's pms and agilescrum permit to exist.now the article tries to address one of my points iin the usual web application this is not a problem because load and tested ensures each vm will be tested to its autoscaling parameters and then it will grow.ino it most certainly does not i've seen plenty of vms in my career running monoliths that were 90 idle and most ram free because the application was bottlenecked on the database. and even if they're monoliths there's inevitably some other service not part of the monolith either bc it is thirdparty or what that then gets its own asg it's own set of vms for redundancy and it iisi waste. never have i seen exactly 3 vms running exactly 1 monolith.amp vms are like the worse case too as they are inevitably handcrafted snowflakes. but worse if a dependency such as a package is required what part of the system required it? if i remove a use is the package still required? answering these requires reasoning over ithe entire monolithi something that once the codebase is big enough becomes effectively impossible. ion the communications front internal web services are often doubly inefficient by using rest rather than binary transmissions.i this is beyond wrong and it doesn't make any sense. you can serve protocol buffers over rest is that not a binary transmission? not to mention that http2 amp later is a binary protocol sure many people use json today but there's no requirement to do that and i've written several restful endpoints that didn't serve or consume json. generally because the requirements were such that that would make no sense. the protobuf vs. json is a whole different debate and each format has its pros amp cons but it is certainly orthogonal to the question of whether microservices are good or bad icode that needs to be shared between the asynchronous services and the web tier should be kept in libraries used by both of them and is not a service call.iif you're going to do a monolith yeah this is what one should be doing. i've just literally never seen it done. in fact i've suggested it mulitple times when the second third fourth fifth use case comes up we have code for that but it isn't in library form. let's solidify it into a library amp then change the existing consumers to use it and then your use case is just another consumer is inevitably met with but i just want to do whateveritisthatstheusecase it's just one more instance of this code what could it hurt? followed by why am i hitting cornercase and well that's some old organic growth the original code that we would have turned into a library handles that ithe number of which does not really matter but in a world of 200 microservicesithis is strawman is repeated in every i hate microservices article. i've never seen microservices taken to that extreme and yeah if that's what you're doing i expect you're in for a world of hurt. but that's not the point and i doubt you actually have 200 welldefined systems with welldefined boundaries amp apis. but yes if you take something to the absurd it breaks down?;0
30761056;HackerNews;2022-03-22;so then you have been working on a distributed monolith and not a proper microservice architecture. just saying.;0
30761031;HackerNews;2022-03-22;i think there's another hidden element the majority of people in tech love wrangling with complexity on computers.why else would people spend hours trying to configure and customize linux distros?to them it's a puzzle game and they very much enjoy the challenge of solving these puzzles. having a dynamic system with many moving parts that all need to be configured just the right way so they finally fit together and come to produce the desired outcome.this is an epiphany i got from playing the witness. i spent more than 50 hours playing the game and i'm not even 10 finished. the puzzles in the game are original and require high level complex thinking to solve. but at some point it just got frustrating to me. i wanted to play games to sort of relax or perform low key mental activities. but this game wants you to spend a lot of mental energy to solve puzzles that seem arbitrary and pointless. the feeling i had when i was playing this game was very similar to the feelings i had when i was trying to wrangle with confusing docker configurations.that's when it hit me people who love to play with docker configurations treat it like puzzle games and they enjoy every bit of the mental effort it takes to get things just right for the system to work. it doesn't bother them that the system is fragile or over complicated or that the mess they're building is hard to maintain.of course i kind of empathize with that because that's also what got me into computers and programming in the first place. but to me the complexity i want to deal with is in the code. once i write code that solves a problem i don't want to then struggle to get the code running. i want to just compile and run with one command. i want all the complexity to be contained in the code and to keep the environment simple.but if your jobs is devops you don't get to solve hard problems in the product's code base. so instead you solve hard problems in the environment that the code executes in. so you ithrivei in the complexity of microservices and dockers and all that buzz.in other words people in tech love solving hard problems and if you don't give them hard problems they will invent them.;0
30761029;HackerNews;2022-03-22;i've been at a place where a single person is juggling twenty microservices to power a product with barely any users. just the infra cost alone makes it insane.but one day when we get massive growth it will all be worth it he says.alas that day may not come since he is busy configuring load balancers and message queues instead of developing features.;0
30760987;HackerNews;2022-03-22;even absent everything else sometimes a fad driven rewrite is easier to sell than a fundamentals driven rewrite but you can still revisit all of the key decisions in the process and get a lot of advantages out of it.i've used microservices as an argument before now in situations where switching to a microservice architecture for that part of the code was in and of itself not really a significant advantage though not a significant disadvantage either but it bought me the opportunity to clean up everything else about that functionality with an extremely good end result that i don't think i could've got without selling the change that way.;0
30760980;HackerNews;2022-03-22;while microservices talk likes to pretend the solution is some horrific monolith we never really had monoliths before in development that i experienced. what we had were some kinds of tiered architectures.i've worked with with monoliths. the author must not have experienced them. i've worked places that had builds that took hours to run. we had git merges that took days. we had commit histories that were unreadable.the developer experience working with it was one of constant frustration. the system was too big to make large changes safely. incremental changes were too incremental and costly.note nowhere in here am i saying that microservice architecture should always be preferred. but the idea that its all just some sort of trend with no real underlying advantage is sort of silly.every company i've ever been at with a monolith tends to have untouchables of architecture and the original design schematics who understand the system orders of magnitude better than anyone else. that doesn't scale and really messes with an engineering organization.there's conways law where software will eventually reflect the organization structure of the company but there's also a sort of reverse conways law when you have teams dedicated to specific services you also get to be able to target investments in those teams when their services are not executing well enough.;0
30760954;HackerNews;2022-03-22;is it even relevant? usually people who are against microservices or react are against those not because they are new but because usually those are incorrectly chosen tools for the job.;0
30760953;HackerNews;2022-03-22;given sufficiently carefully designed logging with a request id that starts at the outermost service and gets propagated all the way through you should be able to see the equivalent in the logs from a development set of services when something goes wrong. pulling a full request's logs out of production logging is a bit trickier.for me it boils down to this is absolutely doable but i'd still rather have as few services as possible while still maintaining useful levels of separation at least for the primary business services. having a bunch of microservice like things serving pure infrastructure roles can be much cooler depending on your situation.;0
30760932;HackerNews;2022-03-22;if a coordinated rollout is required then doesn't that kind of defeat the whole point of doing microservices?if a coordinated rollout is requires for anything but a change of service api and then only the service and it's direct clients should be impacted and even then a decent deprecation policy should eliminate the need for close coordination you aren't doing microservices because loose coupling is part of the definition of the pattern.;0
30760913;HackerNews;2022-03-22;at what size does a microservice become a service?;0
30760911;HackerNews;2022-03-22;vcs care that an early stage team will be able to execute and to a lesser extent be able to innovate. telling them that you use a 20 year old tech stack that few junior aka cheap engineer's know or want to know doesn't inspire this confidence.you would get a similar read from vcs if you said that you use haskell erlang or up until quite recently rust.there is something pretty comforting to an early stage investor of we use java microservices on mainstream cloud provider. says that the team isn't ancient isn't avant guard and that they will be able to hire people. worst case an acquirer won't mind buying the leftovers or acquisition hiring the team.;0
30760867;HackerNews;2022-03-22;i hate to say it but i told about 100 people this long long ago before they invested hard into microservices...the same people who said to me that the pandemic would just last a few weeks.the same people who though a pt cruiser was a beautiful car.the same people who believed dogecoin and nfts would make them rich.people keep willfully failing because there's no incentive for them to be credible and accountable... there's just all the money they can make from perpetuating lies.sometimes we need to unplug the microphone or ask the more quiet individuals what they think.;0
30760854;HackerNews;2022-03-21;build your monolith with clean hard edges between modules and functions so that it will be easier later but build a monolith until you get big enough that microservices is actually a win.i'd like to see software ecosystems that make it possible to develop an application that seems like a monolith to work with single repository manageable within a seamless code editing environment with tests that run across application modules and yet has the same deployment monitoring and scale upout benefits that microservices have.ensuring that the smallteam benefits would continue to exist comparative to 'traditional' microservices in that kind of platform could be a challenge it's a question of sensibly laying out the application architecture to match the socialorganizational structure and for each of those to be cohesive and effective.;0
30760814;HackerNews;2022-03-21;is this something a lot of people are missing with their microservice implementation? you need to be able to deploy each microservice independently of everyone else. if you have a change that's spread across multiple services you should be able to just do them onebyone in order. if you want to rollout a shared library you should be able to just update your services onebyone. if a coordinated rollout is required then doesn't that kind of defeat the whole point of doing microservices?;0
30760726;HackerNews;2022-03-21;a technical solution to a people problemi think the author has correctly identified the reason but the given explaination is wildly off base. there's a much better answer to this and interestingly it predates the term microservice by around 40 years!in 1968 the conway melvin e. had his paper how do committes invent? published you can read it here since the article author mentions waterfall which also has an excellent paper behind it this one like that is super readable and accessible.tldr organizations which design systems in the broad sense used here are constrained to produce designs which are copies of the communication structures of these organizations;0
30760691;HackerNews;2022-03-21;you don't really get a lot of the gains of microservices if you're using a monorepoi think the two are completely orthogonal.at google when you check in code it tests against things it icould havei broken. not all tests in the system. for most services that means just testing the service. for infrastructure code itheni you have to test many services.;0
30760650;HackerNews;2022-03-21;i see a lot of people acting like microservices are some conspiracy theory pushed on us engineers. ive never worked anywhere that pushed microservices the places ive used them they tended to be additional functionality we could easily decouple from the standard backend. even if they were i like the idea of microservices having everything as abstracted away from each other as possible. also would probably make code easier to onboard just get a junior up to speed on one service at a time.;0
30760482;HackerNews;2022-03-21;couldn't agree more just like nosql vs regular old sql don't assume you need a nosql solution until you actually prove you need it. probably 9097 of solutions will be better off with a relational database boring yes but they 'just work'. choose nosql only when you need them choose micro services the same way.if you 'think' you need nosql or a microservice architecture chances are you don't.;0
30760451;HackerNews;2022-03-21;the past few companies i was at we discussed whether we wanted a single or multiple repos. but that was a separate conversation from microservices so i don't think its unusual to have a monorepo with microservices.;0
30760437;HackerNews;2022-03-21;i have had similar experience building microservices that used shared repositories. the pr paperwork was so bad that at one point i've made all my services selfcontained just to avoid having to modify my own code in two different places and synchronize the changes.the whole problem i think comes from the split the code cargocult. we need to think about iwhyi we're splitting the code and use that iwhyi to figure out iwheni to split code.imho code separation arises naturally from modular programming once your code is mature enough it becomes just a piece of glue around a set of libraries that you can just rip out and put in their own repos provided that they're useful enough.;0
30760436;HackerNews;2022-03-21;stop talking about how inappropriate microservices are for applications that will never scale they're a goldmine for consultants contracting with cios that every middling sized company decided they needed because they heard about ransomeware on fox news. billable hours out the wazoo converting totally reasonable monoliths into microservices that can't be maintained by the clients and will always go over time and over budget.;0
30760427;HackerNews;2022-03-21;each releasable unit can wait for whatever tests you want. usually it's just the tests for that unit. google is actually a good example of why monolithmicroservices is a completely different concept to monorepomultirepo.i.e. you can put your monolith in multiple repos and you can put 100000 services in 1 repo.;0
30760380;HackerNews;2022-03-21;decreasing merge conflicts sounds more like muting andor deferring problems.microservice fanaticism seems to be coupled with this psychosclerotic view that world can exist in state of microservices or as monolith.from what i've seen in last 20 years if i had to pick one sentence to describe fitall enterprise setup and it's as stupid as saying x is the best without context it'd be monorepo with a dozen or two services shared libraries typed so refactoring and changes are reliable and fast single versioned deployed at once using single database in most cases one setup like this perupto12 devs team. multiple teams like this with coordinated backward compatibility on interfaces where they interact.;0
30760376;HackerNews;2022-03-21;they provide huge advantages to large companies every startup i advise i tell them don't do microservices at the start.i think you nailed it. microservices are a solution for organizational problems that arise when the company grow in size unfortunately it's not rare to see small startups with a handful of engineers and 5 to 10 times more services;0
30760344;HackerNews;2022-03-21;ii worked on consisted of 7 python repositories that shared one standard library repository. something as simple as adding an additional argument to a function required a pr to 7 repos and sign off on eachithis is an engineering process failure not a failure of microservices or shared dependencies. you should be versioning your shared library that way you only need to make a deployment to the service that requires the update leaving the others pegged at the previous version until a business or engineering need motivates the upgrade.;0
30760325;HackerNews;2022-03-21;i'm part of a team that is slowly breaking down our systems into microservices. our old monoliths were a pain to maintain the pain comes from overengineering rather than being a monolith. i don't fully buy that our business is better now because we use microservices. it just works well for us now that most of the business is moving to a new language.we managed to write more performant code even though we're calling off to 10 services each request. did microservices make our applications faster? of course not but they clearly exposed the issues with our monoliths. we could make the same applications even faster if we moved back to a monolith but the worry is when does it get back to the state we were in before?it was not uncommon to have multiple pieces of code calling into the database to grab the same data in our monoliths. the fact is that it's way too easy to just di a service where it doesn't need to be and boom a pointless db call. do it in a few more places add a bit of a spiderweb here and there and you've just amplified the number of database requests doing the same thing. yes a lot of this comes down to fundamental issues with the architecture of the applications things that have been stacked over years and years of tech debt. it's not an issue with a monolith but rather how developers often treat them. there's a sense that everything is on the table because it's all in the same code base. a lot of developers don't care to think of the future implications of injecting a service where it doesn't belong it does what they were asked and the person reviewing it thinks the same.with microservices it feels like the decisions and behaviour of them are more public and there's more eyes seeing what they're doing. if someone is doing something weird it's easier to call out since these interfaces are public. previously all the shit code got hidden in random pull requests. now the shit decisions are out in the open. everyone is interacting with the same microservices a shit api is shit for everyone a slow service slows everyone else's services down people seem to care more and make better decisions. there's still those guys who just don't give a shit and make a microservice into a macroservice. but when that happens it's easier to see now it's in our faces it's not 500 lines of code hidden in a library it's easier to call out.as time goes on i do long for a monolith again because personally i've learnt a lot from breaking down our systems into microservices. i know what touches what i know what shouldn't touch what. the domain knowledge gained from this project would indefinitely lead to a better engineered monolith. but at the end of the day microservices force these decisions into the open and less architectural mistakes are being made which is good.this is also a big reason why i'm a fan of elixirerlang you're almost forced to think in microservices and that leads to better decisions.one mistake i think a lot of people make is creating a web of microservices. you want to keep the hierarchy as flat as possible so that each microservice is entirely independent of another. when you want to actually do work you write an orchestrator that calls into each of these services to carry out the work. this orchestrator is not a consumable service it's console app it's a website it's a product.;0
30760282;HackerNews;2022-03-21;most younger large enterprises use microserviceswhich ones? amazon uses roughly 1team1service not 1team100microservices.facebook famously built their main service as a monolith.edit and don't get me wrong i'm not saying services are bad as long as they are the right size and with the right design rather than tiny.;0
30760270;HackerNews;2022-03-21;i saw lots of churn working on microservices that were preproduction. when its like this things are more tightly coupled than the microservice concept would have you believe and that causes additional work. instead of writing a new function at a higher version you had to go change existing ones pretty much the same workflow as a monolith but now in separate code bases. and there wasnt a need for any of these microservices to go to production before the front end product so we couldnt start incrementing the versioning for the api endpoints to avoid changing existing functions. a monolith almost doesnt need api versioning for itself usually libraries do that but its effectively a version 1.0 contract if translated to microservices.;0
30760250;HackerNews;2022-03-21;hi i saw your profile on linkedin and wanted to reach to say our team is looking to hire a 'senior boolean microservice architect';0
30760247;HackerNews;2022-03-21;the first part of your comment is accurate and beautifully poetic. but i don't believe the second part follows from the first.at most companies that do microservices well they have a dedicated platform team that builds tools specifically for building microservices. this includes things like deployment canaries data storage data pipelines caching libraries for service discovery and connections etc.this leaves the teams building the services focusing on business logic while having similar developer experiences. the code might use different conventions internally and even different languages but they all interact with the larger ecosystem in the same way so that devs at the company can move around to different services with ease and onboarding is similar throughout.;0
30760232;HackerNews;2022-03-21;a monolith with a denial of service vector in part of its functionality can suddenly take down your entire fleet because everything was exactly the same.just like a microservice can bring down the core functions of your service because a single component locks up under dos;0
30760214;HackerNews;2022-03-21;also linked from that article 0 10 i think that's it original link doesn't work anymore this looks like a copy of it1;0
30760213;HackerNews;2022-03-21;honestly we originally did microservices because it sounded like a fun idea and because it would look really cool in our marketing materials. at the time this was a very shiny new word that even our nontech customers were dazzled by.as oxidation and reality set in we realized the shiny thing was actually a horrific distraction from our underlying business needs. we lost 2 important customers because we were playing type checking games across json wire protocols instead of doing actual work. why spend all that money for an expensive workstation if you are going to do all the basic bullshit in your own brain?we are now back into a monolithic software stack. we also use a monorepo which is an obvious pairing with this grain. some days we joke as a team about the days where we'd have to go check for issues or api contract mismatches on 9 repositories. now when someone says issuepr 12842 or provides a commit hash we know precisely what that means and where to go to deal with it.monolithic software is better in literally every way if you can figure out how to work together as a team on a shared codebase. absolutely no software product should start as a distributed cloud special. you wait until it becomes essential ito the businessi and even then only consider it with intense disdain as a technology expert.;0
30760188;HackerNews;2022-03-21;yes that is a fair distinction that i simplified over. you don't really get a lot of the gains of microservices if you're using a monorepo so while they do have multiple binariesservices you still have to check into a single repo and wait for all the testsetc. to be fair i haven't visited google in a while and maybe it's changed now but at least decade ago it was very different from how everyone else did microservices.;0
30760158;HackerNews;2022-03-21;i...you get big enough that microservices is actually a win.ican you speak more about the criteria here?you may be implying that microservices enforce conway's law. if so then when the monolith divides it gives away some of it's api to another name such that the new node has it's own endpoints. this named set is adopted by a team and evolves separately from that point on according to costrevenue. the team and its microservice form a semiautonomous unit in theory able to evolve faster in relative isolation from the original.the problem from the capital perspective is that you get a bazillion bespoke developer experiences all good and bad in their unique and special ways which means that the personal dev experience will matter a guide in the wilderness who's lived there for years. the more tools are required to run a typical dx the more tightly coupled the service will be to the developers who built it. this generally favors the developer which may also explain why the architecture is popular.;0
30760142;HackerNews;2022-03-21;if you don't really understand how they work you get blog posts like this. microservices add many design benefits that prioritize rapid independent work. monoliths add many design benefits that prioritize simplification and tight integration testing and releasing. both exist for good reasons and both have to be implemented properly. ineither of them is a silver bullet.ibut the real reason we use microservices is they're just more popular. nobody wants to recommend something obscure or old for fear they'll be laughed out of the office. nobody can hire tech people to work on 'uncool' technology. people like to follow trends. that's why we are doing this.;0
30760109;HackerNews;2022-03-21;i somewhat disagree with this article. microservice is great for complex software modules. but some jokers in industry starts writing miscroservice for every small functionmethod in the code. it's better that microservice should be designed by experts.;0
30760080;HackerNews;2022-03-21;whether you build microservices or just services distributed systems are undeniably here to stay. in todays world there are very few products that can run on a single machine whether it is for latency or availability or redundancy.that said the challenges of building such systems are real and the developer experience is universally quite awful compared to our monolithic singleserver past.its for that reason that ive been building 1 for the past four years. would love your feedback if the op resonates with you.1;0
30760078;HackerNews;2022-03-21;new? are you sure?react is about a decade old.microservices is between two and iseveni decades old depending on your definition.none of this stuff is inewi.;0
30760062;HackerNews;2022-03-21;i grew up using unix where the philosophy is do one thing and do it well and i think that carries over well into microservices.but honestly i'm not sure there is much of a line between the two. i've seen microservices that just return truefalse and ones that return 100 lines of json which are arguably more webservices than microservices.i honestly think it's a distinction without meaning.;0
30760022;HackerNews;2022-03-21;why would you advocate for microservices over services?;0
30760016;HackerNews;2022-03-21;i think this is a bit naive. startup founders do not care about providing careers for engineers and usually want to stop being a startup founder as soon as they possibly can they are chasing huge exits and being a founder is incredibly stressful.the real reason that microservices are so prevalent is that they became fashionable for exactly the same reason a particular item or brand of clothing becomes fashionable influential people were seen using them and so regular people aspired to start using them too. at a certain point in the popularity curve not using microservices becomes a controversial viewpoint.they also suffer from being what i call conceptual crack. there is a certain kind of idea that really tickles some kinds of engineer's brains. microservices seem like a such a clean solution each service having its own single responsibility so easy to draw on a whiteboard so neat and tidy. other ideas i place in this category are blockchain redux and vfs. clean and tidy ideas that are compelling conceptually but result in nightmarish levels of hidden complexity when they're put into practice.;0
30759956;HackerNews;2022-03-21;this really reads like a badfaith interpretation of microservices. of course microservices suck whenever someone starts a new one to do something that shares code or logic with already existing services. likewise of course monoliths suck when people just willy nilly add code and modules for each thing low quality programming is low quality regardless of where it livesreal microservices implementations don't deliver so much from the proposed statement about synchronous webtier request handling vs asynchronous compute workers in my experience. a few easy rules to guide this development are even touched on in the article but treated like they could only ever be a tenet of monoliths.very strange.;0
30759936;HackerNews;2022-03-21;i wonder how much of this can be traced back to the proliferation of system design interview stages and resulting training material?from my experience all of these resources tend to direct you to think in microservices uberdistributed architectures. i can easily imagine this causing folks to consider this as the way we do systems now and taking it to extremes.the low barrier as well for 1 engineer to decide they want to just get busy on a weekend on their own and build something is another way i've seen this proliferate.;0
30759925;HackerNews;2022-03-21;i'm a huge proponent of microservices having worked on one of the earliest and largest ones in the cloud. and i absolutely think that they provide huge advantages to large companies smaller teams easier releases independently scaling separation of concerns a different security posture that i personally think is easier to secure and so on.it's not a surprise that most younger large enterprises use microservices with google being a notable exception. google however has spent 10s possibly 100s of millions of dollars on building tooling to make that possible possibly even more than a billion dollars!.all that being said every startup i advise i tell them don't do microservices at the start. build your monolith with clean hard edges between modules and functions so that it will be easier later but build a monolith until you get big enough that microservices is actually a win.;0
30759888;HackerNews;2022-03-21;teams want to make their own choices dislike code review or overbearing architects above them and to a lesser extent want to use different and newer languages.i'm not sure this is 100 correct or at least has never been the case in the 20 years or so i've been working with microservice architectures. there's always an architecture team dictating the form of the services themselves usually much more so than a module in a monolithic application. part of this standardization is usually a set of languages you can use python with django or java with spring boot but anything else has to be approved by the committee.that said i agree with is ultimate conclusion that microservices haven't lived up to their promise. the usual justification for microservices was and continues to be we can update one component without disturbing the others. i've never seen that actually happen. every time one component changes everything that depends on it has to be retested just to be on the safe side and most of the time something is found.;0
30759886;HackerNews;2022-03-21;if you're going to embrace microservices you need to be very confident that they solve real problems that you currently have and that they will result in an improvement to your engineering velocity within a reasonable timeframe.the additional complexity in terms of code and operations is significant. you need to be very confident that it's going to pay for itself.;0
30759885;HackerNews;2022-03-21;incompetent teams and engineering organizations will find a way to mess up both monoliths and microservices. great ones will pick what works best for their specific use case and be effective at it.the only correct answer is to not waste time with the decade worth of pointless internet debates on the topic.;0
30759839;HackerNews;2022-03-21;i really like the way uncle bob described microservices in this article he made the point that microservices are a deployment method not an architecture. a good clean architecture shouldn't care how it's deployed. if you need to move from plugins to microservices to be massively scalable your architecture shouldn't care. if you need to move from microservices to plugins to make your app simple to host and debug your architecture should also not care.this strategy has been implemented in frameworks like abp.io very successfully. you can start your application as a single collection of split assemblies deployed as a single application and move to deploying as microservices when it's necessary.;0
30759835;HackerNews;2022-03-21;it's nihilistic if you find meaning in microservices and cynical if you don't think there's a weird tech vc bubble..;0
30759834;HackerNews;2022-03-21;so... you worked on something terrible that people called a microservice architecture? once a pattern gets popular people start writing nasty code in the style and then the pattern takes the reputation hit and people move on to the next thing or just back to the last thing. rinse repeat.my company uses microservices deploys restart one service and prs are one repo at a time. there's a shared library but it's versioned and there's nothing compelling you to keep on the bleeding edge.;0
30759800;HackerNews;2022-03-21;yes i came to learn that microservices would probably greatly excel at sending json strings back and forth. then i wondered why we weren't just all using erlang;0
30759724;HackerNews;2022-03-21;i hate to tell you but new technologies like react and microservices are very useful. top tech companies regularly design whole systems using microservices. its the legacy companies with legacy tech stacks that fail at it.;0
30759721;HackerNews;2022-03-21;the last microservice architecture i worked on consisted of 7 python repositories that shared one standard library repository. something as simple as adding an additional argument to a function required a pr to 7 repos and sign off on each. when it came to release we had to do a mass docker swarm restart and spin up because the giant entanglement of microservices was really just a monolithic uncontrolled cthulhu in disguise.the business revolved around filling out a form and pdf generations of said form. i felt like i got no work done in a year and so i left;0
30759673;HackerNews;2022-03-21;i think the real reason is that cloud software development has enabled microservices. meaning if you arent on aws or gcp forget it. but if you are its a paradigm that fits very well with cloud software architecture. those criticizing it for the complexity probably just havent spent enough time in code bases where it makes sense.;0
30759588;HackerNews;2022-03-21;i agree. i think organizational scalability is an important benefit of microservices that doesn't always come up in these discussions. having smaller more focused services and repositories allows your organization to scale up to dozens or hundreds of developers in a way that just wouldn't be practical with a monolithic application at least in my experience i'm sure there are exceptions.;0
30759515;HackerNews;2022-03-21;i found microservices had the benefit of increasing release cadence and decreasing merge conflicts.are there complications? sure. are they manageable? relatively easily with correct tooling. do microservices with container management allow you better use of your expensive cloud resources? that was our experience and a primary motivator.i also feel they increase developer autonomy which is very valuable imo.;0
30759415;HackerNews;2022-03-21;as i build out my infrastructure for adama my realtime saas for state machines i'm leaning hard into a monolithic design. the key reason is to minimize cost and maximize performance.for instance comparing adama to the services needed to build similar experiences offered by aws has interesting results. adama costs 97 less than aws and a key thing is that the microservice approach is amenable to metering every interaction which scales linear to demand whilst a monolithic approaches condenses compute and memory.;0
