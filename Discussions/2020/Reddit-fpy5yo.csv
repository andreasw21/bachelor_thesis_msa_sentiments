ID;Source;Creation Date;Content;Sentiment
fpy5yo;Reddit;2020-03-27;Title:Why Rails succeeded and why microservices fail from DHH, Content: https://corecursive.com/david-heinemeier-hansson-software-contrarian-transcript/;0

flns7ol;Reddit;2020-03-27 17:01:07;my experience with microservices was not good. no one seemed to have a clue how anything worked. it would take days to track someone down who could help with every tiny problem. that said i firmly believe that they can work. they're just hard to get right.;0
flnrih3;Reddit;2020-03-27 16:54:49;then the premature application of microservices. i am a stound. stout and proud supporter of the majestic monolith. this idea that you have a single application that a single person can fully grasp comprehend understand deploy operate and then as far far preferable to this. idea of having a fleet of microservices a building a hundred different toolkits and languages that no one knows how to sort of operate in and go on. this is the i read the tldr and am looking at this from a manager perspective argument. the problem with microservices is that it's a domaindriven design pattern and people just claim they read the book. the basis of microservices is as follows create a hard barrier between unrelated pieces of code so we cannot be tempted to do things we aren't supposed to because it's easier here and now. as an example you work in a shop and a customer wants to know how much something is you walk over to a cashier pauses her work to scan the product and everyone returns to work. 1. it was the easiest way to solve the request. 2. it took time from an unrelated part of the domain the cashier that has nothing to do with price requests from customers wandering around the store. in a real world scenario that is a frontend developer trying to fix a bug having rudimentary knowledge of backend programming but making a change anyway in the backend because he didn't want to bother the backend developers with such a small fix and has now written code that isn't using dependency injection or unit testing because they simply don't do either in that specific frontend team and average code quality goes down. so we split these aggregates collection of related entities working together to fulfill one job i.e cashier cash register etc together becoming a point of sale into separate programs so that we cannot no matter how hard we try cheat. this also means design flaws become painfully obvious why cannot i access this from here? instead of let me just import this service.... as you can see this has absolutely nothing to do with the management promises of rapid individual deployment! or zoo of technology! hire any developer no matter the tech stack to work on your software today!. those things are just benefits of decoupling. you can do that using traditional soa architecture. on top of that microservices has one huge benefit which the guy seems to disagree on you don't need to learn the entire application to be safe in what you are changing. the idea here is that if you need to fix a bug with your cart in your web shop you aren't faced with source code stretching thousands of files but rather just a small application that deals specifically with the cart. this means it's easily understood as the complexity of just the cart is low. reality is that developers join new jobs all the time and we all know how scary those first months are when you're trying to figure out how that big project actually works and finding out there's 457 edge cases that you need to be aware of. that's what microservices fights. those are the points of microservices from a developer's standpoint. everything else is just trying to convince your manager why and i can understand why a lot of people are adverse to microservices when they're built as a cost savings feature when they're honestly a lot more complex to wrap your head around than any monolith ever was if you're aiming to understand the entire application and not just the parts you're developing. edit if you guys have some time to spend i highly recommend you watch this presentation by eric evans the guy that wrote domaindriven design https he explains it in a very pragmatic way.;0
flon2ft;Reddit;2020-03-27 21:38:11;ive said it a thousand times at this point but the reason 90 of organizations use microservices is just as a shorthand for having strict rules around coupling. dhh doesnt see the point in microservices for most people because most people dont use them in situation were you might actually need them they just use them to enforce a loosely coupled system and if you already enforce decoupling in your monolith app then you dont need them.;0
flo0020;Reddit;2020-03-27 18:11:29;a dev wanted to implement microservices in our company but changed his mind almost instantly when a senior asked cool how hard is it to implement transactions and error propagation across microservices?;0
flo89vo;Reddit;2020-03-27 19:23:55;microservices is a great example of an organizational tech pattern. its not actually a programming tech pattern. microservices is what you do when you have teams so large that they essentially need. dominion over their own domain. right. they need to sort of control their own boundaries and so on. and when you have 50000 programmers yeah its a completely reasonable pattern and it makes total sense trying to apply it while you have two five 2050 programmers. this guy gets it. i've been at too many places where the company came up with a definition for a microservice without looking at the environment. i've had to explain to multiple managers it's called microservice architecture because it's an organization of the services not a definition of what a service is.;0
flnmqz1;Reddit;2020-03-27 16:10:21;i don't agree with dhh on everything. i really am glad i left ruby behind but his opinions on microservices being usually a bad call is really spot on. same for his earlier call on tdd being not the panacea that people were saying it was. he is a bit brash and over the top in his opinions but he seems to be the person calling things out that need to be called out.;0
flo7n1z;Reddit;2020-03-27 19:18:17;i think that the problem is that micro part. it's the oop's problem all over again of how small my classes should be. make your microservices not that micro and learn to enjoy them. you can always split them as needed with like zero pain because of the nature of them.;0
flnzorz;Reddit;2020-03-27 18:08:43;i'm relieved the interview had more nuance than the title implied. of course microservices aren't a silver bullet you need to weigh the pros and cons when using them for your scenario.;0
flrktlx;Reddit;2020-03-28 20:04:25;i wish this podcast was on spotify. i don't have an issue with microservices per se but they are often badly applied and often a premature optimization. in es since this optimization only shifts work....;0
flodm7q;Reddit;2020-03-27 20:10:59;i like a little bit of the pushback against microservicesaspanacea but the i have a hard time buying dhh's arguments against the railsasapi spa architecture in fact saying that it's more damaging than microservices. while he derided the complexity of redux et al i can only think back with horror at some of the .erb templates i've seen in rails projects... truly horrifying messes that were difficult to reason about because you were injecting one language into another instead of passing data back and forth. so even without the other benefits of the static frontend api split i'd still advocate and in fact have advocated in rails projects treating rails as an api and consuming that api with a static frontend. and then probably ditching rails for sinatra but that's another story.;0
flo5a2v;Reddit;2020-03-27 18:57:46;this is quite a horrible statement. you can view sinatra's dslapi just as rack's dslapi as a microservice. and it works very well. yes it is missing a lot of useful things by default. that's not good but rails is bloated to no ends generating a gazillion of totally pointless files nobody really needs. the most important thing the most important design criteria for our. programming language is going to be programmer happiness. i am also hugely annoyed about the programmer happiness meme. how do you assess happiness? people feel differently so their assessment will be different. culture differences exist too you can see this e. g. with japanese devs versus us devs or devs from europe. you will notice a culture difference. ruby is a very good language even without the programmer happiness meme. what ruby actually showed was how utterly horrible most languages are. even ruby is not perfect way aside from the number one criterium everyone has to pursue comparing your language to the speed of c. adam yeah. i agree there is though there is a certain weight like to popularity right? like there is a certain like fullness of of libraries or or whatever. that is an advantage when youre a gazillion of libraries won't help if the language is horrible see perl. all the work ive done in rails its not just the rails its the fact that so many people got to work with ruby and. perhaps they otherwise wouldnt have had. i came to ruby before rails. to me it would not be important whether rails would exist or would not exist. not that i have anything against rails per se its existence or nonexistence would not change whether i would use ruby or not though. then the premature application of microservices. i am a stound. stout and proud supporter of the majestic monolith. and here is where he is wrong the sinatra model is actually far superior from the hey we are rails everyone go mvc if not you are doing it wrong. no thanks. not that i think the sinatra model is perfect it also sucks a lot. but i rather take the flexibility and build with it quickly than enter any deeply interwoven complex framework that is just annoying to adapt and adjust. microservices is what you do when you have teams so large that they essentially need. this is not necessarily wrong but you see this in rails just as well. i wrote a lot of tests first and then i wrote my code and i didnt like it. i thought it was not a way to fit with my flow of my brain. agreed. oh youre against tdd therefore youre against automated testing. agreed. i just got fucking tired of listening to people telling me like i just didnt get it. no i get it. i just dont agree. like those are two separate things. right. same with rails and mvc. people need to become more serious when it comes to simplicity.;0
flpmswc;Reddit;2020-03-28 03:41:47;aren't microservices usually a performance thing?;0
flocjr0;Reddit;2020-03-27 20:01:24;microservices don't solve a technical problem they solve an organizational problem. you move to it when the organizational pain of dealing with a monolith are worse than the organizational pains of moving to a microservices architecture. if you find yourself scratching your head at why your development group is doing microservices you may not actually have the problems its meant to solve yet.;0
flntl6a;Reddit;2020-03-27 17:13:40;the unfortunate reality is that microservices require a ton of instrumenting once the deployment gets complex enough. you need metrics and tracing. all of which means your infrastructure bill increases pretty substantially at that.;0
floaa1n;Reddit;2020-03-27 19:41:30;i firmly believe that microservices can work. they're just hard to get right. agile has a similar profile if all the ducks are lined up good things seem to happen but most orgs are semidysfunctional when it comes to it in my observation and agile is not forgiving of organizational kinks. the hard part is knowing what the exact conditions are for a given technique or tool to be better than the alternatives. to avoid getting spanked by a trendfad follow these guidelines find out what the tradeoffs are because there's rarely a free lunch some aspectsfactors will almost certainly take a hit to gain in others. know what you're losing. don't be the guineapig let other orgs test trendsfads. even if the tool is useful it probably has glitches that only time and roadtesting can fix. it took a good while to know where and how to use oop right. early oop adopters created some of the worse spaghetti ever seen. conway's law make sure the new tool fits your org and team structure. trying to change the latter to fit the former is a fool's errand. size fit. don't try to be like the big dogs out of envy techniques that work for big expensive applications or projects don't necessarily scale down well and vice versa. talk to actual users at other orgs not just managers and salespeople. the view from the front line is different than the general's.;0
flntp36;Reddit;2020-03-27 17:14:40;that is orthogonal to monolithic vs microservice. that's just shitty organization and documentation. you make an undocumented monolith the same size and you won't understand it either plus you'll break it easier.;0
flofgdf;Reddit;2020-03-27 20:27:58;in the same way that you need structure on how to write code in a monolith you'll need structure on how do deal with microservices. if everyone is free to do whatever then it will be chaotic of course. i've only ever had great experiences with microservices;0
flo99ne;Reddit;2020-03-27 19:32:35;we are migrating toward a microservices architecture. we took good care at designing a common set of messages with protobuf and a common set of topics for pubsub messaging. a well thought microservices architecture brings amazing flexibility!;0
flooskr;Reddit;2020-03-27 21:54:20;for me the biggest benefit of microservices isnt isolating the domain its decoupling the deployment and pace of change. you can isolate domains in a monolith by putting them in modules with clear api boundaries enforcing the separation in code reviews which is exactly what we did on a million line web app i worked on but even then the entire monolith is going to be based on a single technology stack that must move forward as a whole and must be deployed as one. you have fast moving parts and slow moving parts. you want to be able to deploy the fast moving parts often move them to new technology stacks scale them up quickly but in a monolith you have to bring the slow moving parts along when you do those things and that takes work. microservices allow you to fully abstract away the slow moving parts. which isnt to say microservices are better. dhh is on the nose when he says its an organizational pattern. whether youre better off with a monolith or microservices depends on your organization not on your tech stack.;0
flok6lt;Reddit;2020-03-27 21:11:18;this argument makes sense at first sight but breaks down when you take a closer look. 1. you can enforce domain boundaries through modules in a monolith as well. a monolith doesn't have to be spaghetti code and simply translating a spaghetti monolith into microservices won't solve your problems it will only aggrevate them. the difference between microservices and a modular monolith is that the microservices can be deployed and scaled independently. this can be both a blessing or a curse. 2. you work in a shop and a customer wants to know how much something is you walk over to a cashier pauses her work to scan the product and everyone returns to work so what do you suggest to do instead? there are only three possibilities ask the service that knows about pricing as in your example have all services that want to know pricing read a shared database that is owned by some service i.e. only that service can write all others can read every service that wants to know pricing keeps it's own price database and updates it through event driven state transfer needless to say all possibilities have big disadvantages. microservices are not decoupled automatically. they can still depend on other services often in ways that are more obscured than in a monolith option 1 and 2 and you need sophisticated mechanisms like circuit breakers to stop cascading failures which would invalidate completely the microservice's advantage of independent deployment. only option 3 is truly decoupled and you pay a high price in data duplication eventual consistency complicated tracing of events event schema migrations etc. i'm not arguing against microservices in principle but don't kid yourself they are not for free and bring significant cost with them. distributed systems are very hard to get right. we need to be honest with ourselves and evaluate very carefully when it is really necessary to split something into a separate service.;0
flpfu3i;Reddit;2020-03-28 02:21:30;i don't quite understand the point you said about not needing to learn the entire application to be safe in what you're changing. regardless of microservice or monolith other code is depending on the behavior of a given piece of code. you still have to understand how other parts of the system are going to be affected by that change. the benefit of a monolith in this case is that you might have integration tests of that dependent code fail before you can even make a code review. in the other case you need to set up your ci system to test against the new change in a stain environment. the primary benefits i see to microservices are around independent deployment and scaling as well as permissioning of access to certain data. i also think that most code development tooling better handling having separate individual code bases rather than monorepo which also helps the microservice case yes i know big companies have microservices in monorepos but they don't have normal tooling;0
flom9ju;Reddit;2020-03-27 21:30:38;idea of having a fleet of microservices a building a hundred different toolkits and languages the companies i've worked at have enforced language and toolkit requirements and i know many others do as well. often when i hear about microservive vs monolith arguments it's usually misunderstood like comparing a small monolith to a huge microservice system.;0
flud3gs;Reddit;2020-03-29 18:43:28;on top of that microservices has one huge benefit which the guy seems to disagree on you don't need to learn the entire application to be safe in what you are changing. the idea here is that if you need to fix a bug with your cart in your web shop you aren't faced with source code stretching thousands of files but rather just a small application that deals specifically with the cart. this means it's easily understood as the complexity of just the cart is low. reality is that developers join new jobs all the time and we all know how scary those first months are when you're trying to figure out how that big project actually works and finding out there's 457 edge cases that you need to be aware of. that's what microservices fights. instead you have a change that looks fine but then breaks ten consumers you didn't even know to integration test it with lol those are the points of microservices from a developer's standpoint. everything else is just trying to convince your manager why and i can understand why a lot of people are adverse to microservices when they're built as a cost savings feature when they're honestly a lot more complex to wrap your head around than any monolith ever was if you're aiming to understand the entire application and not just the parts you're developing. yeah dude this is the problem. if you're google obviously a monolith is an insane idea. if you're a tenperson shop where everyone works on everything anyways the calculation for overhead vs. benefit for spinning up a new service is a lot different. not so different that you should never do it but different enough that you should think harder.;0
flo4tst;Reddit;2020-03-27 18:53:49;that is a frontend developer trying to fix a bug having rudimentary knowledge of backend programming but making a change anyway in the backend because he didn't want to bother the backend developers with such a small fix and has now written code that isn't using dependency injection or unit testing because they simply don't do either in that specific frontend team and average code quality goes down. you are always happy to blame the frontend developer ignoring the fact that the frontend developer is the one that has to understand the whole application because he has to integrate all the parts and he is the one to suffer from your terrible api decisions that cause the whole system to be split into a hundred disconnected parts so that you can have microservices. keep that in mind next time you want to split another microservice. just think about the extra complexity that will be needed to display a report that needs to extract a field from each microservice and now add on top of it the chance of the microservice taking extra time to respond or just not responding at all. and then tell me it's the fault of a junior frontend.;0
flp7nam;Reddit;2020-03-28 00:55:47;cool how hard is it to implement transactions and error propagation across microservices? he if didn't know enough to answer that with not very hard at all it's a good thing he was dissuaded. message passing isn't the most difficult thing to master though it does take some up front time to get your head around it at first i suppose.;0
flodpd8;Reddit;2020-03-27 20:11:46;that's fair as long as the fact it is an optimization at some point is communicated. a good percentage of the dev community are cargo culters so its usually a good idea to point out where it does make sense because otherwise you get everyone arguing it never makes sense which is just as silly. the fact is most people aren't working in a shop where the organizational complexity of 15 teams working on a monolith has been experienced yet and so they have no experience with when the scale tips in favor of microservices. i usually like to just ask do you have a dedicated devops group?. if the answer is no you probably don't have the problems it solves yet.;0
flnpcg7;Reddit;2020-03-27 16:34:54;i completely disagree with him on microservices. i've worked on enough rails monoliths over the years of my career to be tired of them i'd much rather work with an application that has prematurely moved to microservices than the mythical majestic monolith. nothing more fun than trying to get your code through ci except some unrelated team on an unrelated domain has bungled up a unit test somewhere and now they're holding up the whole show for everyone while we wait patiently for fixes to integrate from upstream. having to absorb x years of institutionalized knowledge of engineering that reach across the entire codebase sucks vs having to just figure out small well insulated pieces of functionality.;0
flo8cli;Reddit;2020-03-27 19:24:34;i really am glad i left ruby behind searches for reasons hmm. microservices are not exactly built into ruby ya know? and we don't need dhh to know that tdd is lousy. i am surprised how people can't think on their own really. he is a bit brash and over the top in his opinions agreed. it's the ego driven by wanting to succeed. i get hugely annoyed when faced with such egos. i do agree on some particular points though. for example that ruby is a very good programming language. by the way you should state to which language you transitioned into. but he seems to be the person calling things out that need to be called out. uhm? not really. i think the very idea behind microservices is perfectly fine. evidently it threatens the big rails blob thinking where you autogenerate thousand files literally. and the horrible mess that are gemfiles. i manage everything via rubygems no need to ever have any gemfiles no need to ever switch into using rvm etc... either because i use versioned appdirs similar to how gobolinux uses it but for literally every program. on microservices dhh is simply wrong even more so when we look at the rails monster monolithoblobs.;0
flq8zyd;Reddit;2020-03-28 09:30:45;true but he still can be right about microservices...;0
flqb3h3;Reddit;2020-03-28 10:15:56;and this is relevant to his opinion about microservices how?;0
flq4joz;Reddit;2020-03-28 08:00:41;organisational is far from the only aspect the other typical one is horizontal scaling of the parts of the application. obviously both existed before microservices were even a word.;0
flobcuf;Reddit;2020-03-27 19:50:56;disagree. will still be shit if it is badly managed but logs will be vomited from same place there is one place to plug debugger in code navigation will lead you thru the spaghetti reasonably well compared to navigating a bunch of interconnected apis compared to that in microservices to just even start debugging something you need central logging with service event correlation. you're utterly fucked if you don't have it and you end up guessing based on oh both happened in same second maybe it was same request. even when you managed that you still can't just attach a debugger to track something all the way. there is slight benefit of being able to record input to the service and try to recreate it but that assumes someone did their homework and actually designed it correctly and if we're complaining about shitty organization that aint happening and it will probably have unobvious deps or share db with some other service or whatever else.;0
flo4ols;Reddit;2020-03-27 18:52:33;i don't think it's completely orthogonal. i mean one not the only main selling point of microservices is that different teams can own each subcomponent or microservice. which means it's a lot easier for there to be worse documentationorganization.;0
flpiv9w;Reddit;2020-03-28 02:55:22;as a guy who's all in for microservices for the right use cases... i don't fuck with protobuf. mandatory nullable fields in serialization is a shit show. but wait there's more.httpsreasonablypolymorphic.comblogprotosarewrong you want a serialization scheme with firstclass nullability sum types arrays and maps. at the minimum.;0
flp3p75;Reddit;2020-03-28 00:17:09;dhh is on the nose when he says its an organizational pattern. whether youre better off with a monolith or microservices depends on your organization not on your tech stack. then dhh is not on the nose and is saying the exact opposite of what you're saying. to him monoliths are always better than micro services period. then again he has an extremely narrow knowledge of the domain because of his position employer and background of these past ten years so he just can't know what he doesn't know.;0
flpji2u;Reddit;2020-03-28 03:02:35;microservices in a monorepo until you need separate release cycles andor need to support multiple versions of a microservice concurrently is a good middle road approach.;0
flq0io9;Reddit;2020-03-28 06:49:39;you're definitely right and if you take a look at the video i linked eric says so himself. his argument and mine is that physical isolation of code stops the temptation to just grab that one thing i need this one time because i want to go home in 5 minutes as opposed to logical isolation that is the matter of the developer stopping himself from doing things she maybe shouldn't. domaindriven design is the design of reflecting the real world in code to be able to mirror the physical real world actions as entities and related functionality in code. as such a better solution would be for the worker to have a handheld unit that he could look up pricing with i.e productservice getpriceproduct. this is the same service the cashier uses when registering the products the customer is buying. this makes for the following floorworker productservice getprice instead of floorworker pointofsaleservice productservice getprice as said microservices are a domaindriven design pattern and as such you need to understand domaindriven design first for it to make sense. if you just look at it from a let's split my program into pieces! perspective you will probably end up with weird programs doing a little bit of everything. that said i'm a huge proponent of ddd and microservices but i realise it's not a silver bullet nor the best design for all software or even teams.;0
flnukpg;Reddit;2020-03-27 17:22:38;this can typically be answered by the simple question how long have you been working at your current company?. in his case he's the ceo so you know forever so he knows everything inside and out already and therefore is distanced from the problems microservices actually solve.;0
flud62j;Reddit;2020-03-29 18:44:09;given a monolith and a set of microservices implementing exactly the same feature set it is probably easier to wrap your head around the monolith than all of the microservices and their interactions. of course it's easier to understand one service in isolation... but what if in practice you need to work with all of them anyways?;0
flpyrxz;Reddit;2020-03-28 06:21:53;sure microservices is just one approach. if you do decide to watch the video i linked eric argues that there's no need for fences either we could just paint a dotted line in the grass.;0
flpzlcn;Reddit;2020-03-28 06:34:51;microservices also have unit tests that typically run as part of your ci telling you something's up. the point here is when you open a microservice your job is the following 1. understand the output 2. understand the input the benefit of this is that all the input and output is generated right there in your tiny program. you are looking at 20 files of code instead of references in 200 places trying to mentally piece it together. naturally there can be hard dependencies in microservices too service a produces messages service b consumes and service b has validation on the message that should have been in service a making a change in service a such as an id now being 4 digits long instead of 3 making service b fail. this is a design flaw but something that does happen in the real world. the point here is still that you have one place to find everything related to service a not potentially hundreds.;0
flpz1dr;Reddit;2020-03-28 06:26:00;we are talking about microservices that is a domaindriven design pattern. you can implement domaindriven design without microservices just like you can skip the ddd pattern of repositories too.;0
flo7031;Reddit;2020-03-27 19:12:42;you forgot to sign that with a best regards disgruntled frontend developer. no but seriously though skipping the part where microservices for frontends are a thing and very successful at that ignoring the fact that the frontend developer is the one that has to understand the whole application what you mean by application is actually functionality exposed to the user. these are two different things. a frontend developer cares no more about the backend than does sending or retrieving data tofrom this endpoint do what i want it to do. all the code outside of that is in all reality irrelevant for frontend development and might as well be 90 of your application that is just a big black box of don't care. as said boundaries are a good thing. this is the same approach microservices take what does this service consume andor produce. you don't care about the details. just think about the extra complexity that will be needed to display a report that needs to extract a field from each microservice which should typically just be one call to your report service. to e myself this also means design flaws become painfully obvious why cannot i access this from here? instead of let me just import this service.... all in all i get where you're coming from but your criticism is based in frontend vs backend which was definitely not the point.;0
flodp1t;Reddit;2020-03-27 20:11:41;sounds like bad architectual design for microservices. the api shouldn't be splitting anything. you have data. you write apis to expose that data. the fes can use those apis to get various pieces of data to display to clients in the form of a service. business intelligence and dataeng create new data points be engineers write new api calls to expose those points etc. the cycle continues.;0
flo23jw;Reddit;2020-03-27 18:29:58;the problem with microservices is that theyre a clear improvement in the best case and theyre easy to fuck up. really easy. and once you fuck up you now have to refactor the flow for a physically deployed service if not services not just code. and id say the people most likely to fuck them up are the ones that have dealt with massive monolithic code bases and actually think that just slicing up a lot of code into smaller services is the point. in the worst case theyre like a monolith if you split up random parts of it and had them talk to each other over http and not just by importing their functionality. and i can guarantee that debugging that is orders of magnitude harder than a monolith. even debugging good microservices when something goes wrong is tough because you need so much stuff to support them and theyre constantly changing versions in whatever environment youre looking at. i guess my thing is that if you hate the monolith you work on because its messy and think that it would be better as a microservice youre most likely dead wrong. if you cant build a monolith the right way you will not be able to build microservices well either. youll just make your spaghetti code into macaroni.;0
flnsvud;Reddit;2020-03-27 17:07:15;like he even admits he doesnt really have experience with microservices doesnt he? its been a while since i listened to this episode;0
flq7goo;Reddit;2020-03-28 08:58:22;shouldn't an unrelated team on an unrelated domain be holding up an unrelated merge request? if they can block something that's truly unrelated in a monolith they can block an entire microservicebased system in a monorepo. that's an organizational and workflow challenge that won't go away just because you start building microservices. i rather feel that if an architectural change can't win out in an applestoapples comparison with the people and organization you already have you're better off dealing with the problems that you already have. like dave who changes the return type of every fucking function he touches without consulting anybody and then forcemerges. you need to take away dave's ability to force a merge through take dave himself out back and kick the shit out of him until he stops doing shit like that and then probably take a break with a cold beer because damn that must have felt good. once you've dealt with the organizational and human issues behind your horrible current system you'll be able to make an architectural change without just making a worse version of your current system.;0
flq80ea;Reddit;2020-03-28 09:09:46;i never said it was the only benefit i said it was the driving force to moving to a full microservices solution and to add the that the only one i think actually justifies the weight of the approach. i also wouldn't call a background worker service i split off for various tasks a microservice just because it might communicate via an api though. most monoliths i've seen are more defined by a monoculture around the deployment dependency management strategy than about all the code being in a single executable actually that's basically the story of the distributed monolith evolution. you can horizontally scale a monolith too it just becomes hard organizationally to sustain that when builds and deploys start taking hours and hours and involving 30 people sitting in a room coordinating and signing off. its not at all uncommon for a monolith to have multiple apps background services threads on dedicated servers as part of your scale out of the monolith and that's even before hitting distributed monolith levels. you can get away with this for a long time. actually acheiving a microservices solution is hard. and most people fail at it and go back to something like a distributed monolith. i'm saying the reason most of them don't see enough benefit for the cost isn't because they didn't see that splitting workloads off was beneficial or that only deploying the pieces they needed was neat but because the operational overhead of microservices didn't cost less than the operational overhead of managing the monolith. that is pretty much 100 always why you see these failure stories. they might as well be titled how we learned we don't have the problems microservices solve.;0
flq51zi;Reddit;2020-03-28 08:10:14;microservices do not eliminate the shared database and it is not as if people weren't doing that before microservices were a word. ws specification stack for example contains wsatomic transaction httpsen.wikipedia.orgwikiwsatomictransaction which is specifically about multiple transactional systems e.g databases. the funny thing about microservices is that anything people claim they do or somehow invented has been done before.;0
flpzo3q;Reddit;2020-03-28 06:36:01;there is not rule about single responsibility its just a basic design suggestion for oop. it is a means to an end not the end itself. im not saying that isn't a nice feature of microservices but weighed next to the complexity of microservices it is not a sufficient reason to pursue them. scales don't tip under the organizational issues at scale really. that's not to say you might not split off pieces of an app to separate apps split databases up shard to scale out past the maximum cpu count for your sql servers etc. those are all acceptable steps in the process and usually about where people realize the complexity of microservices require a lot more management and people than they thought and decry the failure of microservices. again those are all nice effects but i think what drives them are usually management of organizational complexity dev ops dependencies deployment complexity project management team specialization stewardship etc.. these articles can do a good job of pointing out these costs inherent to microservices and then you find out they have two dev teams and no dedicated dev ops etc... i mean no wonder they never see the payoff or the payoff they get being worth the cost because they never had the actual problems that make the cost worth it.;0
flogm55;Reddit;2020-03-27 20:38:38;what ive found is that you need the organizational structure of people to match the organizational structure of microservices. individual microservices also need to log what exactly their dependencies are giving them back so if issues occur you can at least obviously tell where they are coming from and who needs to be doing further work.;0
flo2k83;Reddit;2020-03-27 18:34:02;which to some degree and in certain cases are easier to manage than microservices depending on the resources and development pipeline in place. but still likely to hit a transition point if the service grows.;0
flqdkvb;Reddit;2020-03-28 11:09:43;if true might also explain why hes so successful. huge and complex pieces of software are a bog doesnt matter whether they are monolith or microservice. its just that a microservice architecture faces a much much higher risk of accidental complexity. it seems to me that microservices are mostly motivated by someone looking at a monolith deciding they dont understand it and blaming everyone else for not understanding it. so they fix this by eradicating all the ugly bits into quarantined modules so at least they dont have to suffer looking at those pieces.;0
flnxwgb;Reddit;2020-03-27 17:52:40;or as the ceo he makes sure that things don't get to the point where they'd need microservices to be able to deal with it.;0
flod4xb;Reddit;2020-03-27 20:06:39;a framework isn't something that lends itself to microservices anyways. putting microservices into the framework sure but not the framework itself.;0
flpzt93;Reddit;2020-03-28 06:38:14;yes microservices can be ddd just like nonmicroservice architecture can be ddd. but you only mentioned the name ddd everything else you said has nothing to do with ddd at all so why mention ddd at all?;0
floaa1g;Reddit;2020-03-27 19:41:30;you forgot to sign that with a best regards disgruntled frontend developer. i'll go with disgruntled fullstack developer that is going through the third microservices project. what you mean by application is actually functionality exposed to the user every piece of functionality is exposed to the user either directly or indirectly. if it's directly exposed you get to see a field with it. if it's indirectly exposed you get a request that takes longer than expected or that fails by external means such as someone in the org using another ui to approvereject the request based on some policy. a frontend developer cares no more about the backend than does sending or retrieving data tofrom this endpoint do what i want it to do. yes except when the endpoint takes a long time to respond or doesn't respond at all or responds by changing something somewhere in another microservice and now i have to request the result from another endpoint and wait for the endpoint to stop returning the old value and start returning the new value. which should typically just be one call to your report service so now your report service has to either understand the whole application or use the whole application. if you go the first way you are throwing away ddd. if you go the second way next time we have to change the revenue for average revenue per client we have to go to the report service team and tell them to call the user service team so that they create an api endpoint that returns the number of clients and then the report service team has to create a new endpoint that calls the other api in order to do a division and expose the average revenue per client and now this tiny change that i can do in excel in 20 seconds takes 4 weeks and has to go through three teams and requires multiple user stories. your criticism is based in frontend vs backend which was definitely not the point no. my criticism is based on backend making decisions that affect everyone but benefit only backend and then ignoring the damage they cause to other parts of the organization.;0
flp7svj;Reddit;2020-03-28 00:57:17;beyond simple deterministic information requests? your goal in microservices is to get as close to this as possible honestly. you can't always do it but simpler is always better.;0
flp7644;Reddit;2020-03-28 00:51:01;if they have to jump to 12 different projects to get little things done then you don't have microservices you have a distributed monolith which is an antipattern.;0
flodlob;Reddit;2020-03-27 20:10:51;if your company designed your microservices in such a way as to needing to jump to 12 different projects to get one little thing done then i can't imagine that a monolith built by the same company would be that much easier to work with. the microservices i worked on usually have a pretty good domain cut which means for one little thing you generally just have to add it to one place.;0
flrr5gr;Reddit;2020-03-28 21:08:15;i mean it doesn't matter how many humans you kick the shit out of humans are going to do human stuff. and sometimes things just don't work the way you expect in different environments. it happens in microservice architecture too.;0
flpyl2i;Reddit;2020-03-28 06:18:55;to just even start debugging something you need central logging with service event correlation. you're utterly fucked if you don't have it and you end up guessing based on oh both happened in same second maybe it was same request. so generate a correlationid at the api gateway. not only that you need apps to pass and support it too. but that's the point you have to fix a lot in bad microservice architecture just to get some visibilty and start looking for the problem. using a debugger is mostly an antipattern anyway. see httpslemire.meblog20160621idonotuseadebugger. this guy is just bragging about his ignorance and excusing it with a bunch of appeals to authority. and being disgustingly dishonest about it. for example linus torvalds the creator of linux does not use a debugger. and in the fucking post he linked never have probably never will. i use gdb all the time but i tend to use it not as a debugger but as a disassembler on steroids that you can program. but that's irrelevant by doing all the visibility microservice stuff you're basically building a distributed debugger anyway and one that featurewise is pretty bad now i don't use debuggers that often but when i do it is usually for problems that would be insanely harder to solve without it. there is slight benefit of being able to record input to the service and try to recreate it but that assumes someone did their homework and actually designed it correctly and if we're complaining about shitty organization that aint happening and it will probably have unobvious deps or share db with some other service or whatever else. i am sorry you don't work for a competent organization. no they are incompetent in different ways but we dont have that kind of problems at least yet. some clients definitely had usually crystallized in form of performance blaming with them having zero tools to find whether it is their or our app being slow and us having zero access to production to verify anything.... but that's banking sector so it is behind the buzzword curve i'm sure our developer's next k8s app will have them;0
flqjtb4;Reddit;2020-03-28 13:11:57;12factor.net a modular monolith doesn't enforce boundaries at the service level. you need to understand the whole system to understand its parts. microservices may not be 100 decoupled there's a web of clientserver relationships but information hiding is better accomplished and interactions happen at the network level which makes debugging and interoperability more standardized.;0
flotogb;Reddit;2020-03-27 22:41:02;which to some degree and in certain cases are easier to manage than microservices a small application provided it isn't written bizarrely will likely always be easier to understand than an application written in a microservice architecture. monoliths on the other hand... wew lad. every day is a history lesson on projects that are of any sort of age.;0
flumygj;Reddit;2020-03-29 20:17:43;of course but that's an extreme example. the big risk with trying to do everything as a microservice upfront is you find the wrong boundaries and then it's just a headache that doesn't solve a problem.;0
flq0r2p;Reddit;2020-03-28 06:53:31;i literally talk about identifying aggregates and splitting these into services. and microservices are ddd so not quite sure what you're objecting to honestly.;0
floeeuv;Reddit;2020-03-27 20:18:24;it's a bit hard to take you seriously when you are dead set that all code supports frontend customer functionality. in simplistic i built this at home systems sure but not in the real world where microservices makes sense. we write code that doesn't even make it to production such as unit tests and config transformation. how do those support customer functionality when they're not even present in the code the customer accesses? here's some stuff off the top of my head logging supports debugging secret management as you really shouldn't hard code those connection strings analytics supports management decisions and let's not get started with infrastructure as code that said if it takes you four weeks to gather and expose slightly different data in a service perhaps it is not the code's fault but the horrible inefficiencies of the people working with the code. but even then you're actually just making weird scenarios to prove a point that doesn't exist. no software out there allows unlimited access to all of it's data. you are really just saying you would like to write a big sql query and select all the data you're interested in anywhere you want. sure but there's absolutely nothing stopping you from having a query service if that's your use case and supporting exposing relevant data in your services. as said your use case is weird and forced you can do what you want without issues using a microservice architecture you just have to plan for it.;0
flqp3vr;Reddit;2020-03-28 14:33:53;my point is that microservices are a highrisk architecture with large benefits in certain conditions and require experience and careful planning to architect properly. microservices are also very much a best practice as well as flavor of the month. so you couple high potential reward plus dogmatism for best practices and you get people who use the tool of microservices to solve the wrong problem or they dont give the downsides the respect they deserve and dont plan properly. to your second point parallelism has nothing to do with microservices. its the idea that if you need certain parts of your system to scale up or down as opposed to the whole thing. theres no reason you cant spin up another instance of your monolith behind a load balancer if you get lots of traffic to increase throughput and really the only reason a microservice in this case would be a benefit is that you could be more selective with what parts you scale up if say service x is getting 100 times more work than the rest of the system you could spin up more instances of x instead of the whole system. i think microservices can be a great tool. but from what ive seen in industry theyre often used incorrectly.;0
flxf3zy;Reddit;2020-03-30 17:20:34;you didn't get what i meant. your microservices based architecture relies on all parts of the code testing and building successfully too. all you've done by breaking things up into microservices is break up your ci build into multiple as a side effect but you could do the latter without the former. also consider that nothing stops you having a build system where you depend on the last version of a component that passed ci so if a component build breaks the other components stop depending on it during a regular build. again that's basically what you're doing with a microservices setup except conflated with multiple processes and rpc protocols.;0
flrzhwy;Reddit;2020-03-28 22:32:31;the point is that you transition to a microservice architecture with the people that you already have. if you can't handle a frankly solved problem like unrelated teams holding up your merges that's on your organization not on your architecture. a good microservice architecture can handle a lot of scale and complexity sure. i just doubt that an organization that hasn't figured out basic branch strategy and testing issues can get there. people misbehave but organizations can absolutely learn to work better. my point is sometimes focusing on making the organization better will yield more improvement than rearchitecting the system.;0
flqk4f1;Reddit;2020-03-28 13:17:12;why wouldn't you be able to enforce module boundaries? debugging and comunication in microservices is in fact less standardized because a monolith leaves less choices for each module. this doesn't make sense to me.;0
flup5s3;Reddit;2020-03-29 20:38:58;extreme example? how many monoliths that exised for a few years aren't exactly that? i'm not saying microservices are good all the time and that small monolith can't work but the original argument that a monolith is always easier to grasp than microservices is just crazy talk.;0
flq21x5;Reddit;2020-03-28 07:15:33;i also literally said splitting things into services is not ddd that's actually called serviceoriented architecture. although identifying aggregates is ddd but you haven't elaborated on this at all in your description of microservice architecture. ddd has no unique relationship to microservice architecture at all. no unique relationship means microservice can be implemented in a nonddd way and ddd can be applied on nonmicroservice architecture. hope i've made my point clearer.;0
flohqzk;Reddit;2020-03-27 20:49:02;you are really just saying you would like to write a big sql query and select all the data you're interested in anywhere you want. so what's the problem with this? wouldn't this be great? this is what graphql proposes actually. your use case is weird and forced it's not my use case. this is the cfo's use case. you can do what you want without issues using a microservice architecture you just have to plan for it i don't have time to plan for every minor feature. that's the problem with microservices it requires weeks of planning for everything or otherwise you get yourself into a mess that requires even more planning to get out. it's all about time or the lack of it that is exacerbated by architectural decisions.;0
floh0gr;Reddit;2020-03-27 20:42:18;it's a bit hard to take you seriously when you are dead set that all code supports frontend customer functionality. you added frontend there where i claimed all code affects customer functionality regardless of if it goes through frontend or not. in simplistic i built this at home systems sure but not in the real world where microservices makes sense. sure i have been paid to deal with homemade microservices systems for the last four years. my employers agree on paying me for their homemade systems that are not designed for profit at all. we write code that doesn't even make it to production such as unit tests and config transformation. how does unit testing require microservices? how does config transformation require microservices? how do those support customer functionality when they're not even present in the code the customer accesses? ok then let's remove all this code as it's not providing value for the customer. here's some stuff off the top of my head logging supports debugging secret management as you really shouldn't hard code those connection strings analytics supports management decisions and let's not get started with infrastructure as code so logging doesn't provide value to the customer except when the customer calls support because something is not working and support has to go through logging to understand what went wrong and respond to the customer. secret management doesn't provide value to the customer especially when those secrets are leaked and we have a length of time during the customers can't use the platforms because the api providers have revoked our api key for being leaked. also infrastructure as a code doesn't provide value to the customer especially when the customer can't get new features because a part of the dev team is manually deploying servers instead of implementing new features. you can do all of the above with a monolith without microservices as most of the microservice proposers did to scale to a revenue of several millions before actually going to microservices. now go ahead and downvote me for challenging your knowledge.;0
flp44ct;Reddit;2020-03-28 00:21:13;if you need a series of events to happen within a transaction boundary then the domain you're splitting your services over is tightly coupled which is fine btw. don't use separate services for that case. there are many systems which don't require this but can leverage the benefits of microservices.;0
flp43nm;Reddit;2020-03-28 00:21:02;and that doesnt work across distributed microservices. whats your point? use distributed transactions? fuck that theyre flaky as hell and dont even fully solve the problem.;0
floabtt;Reddit;2020-03-27 19:41:56;i mean it's not unheard of for a unit test to fail in an integration environment where it worked locally but more broadly integration tests are particularly susceptible to this. or maybe the offshore team decided they didn't wanna fuck with the tests anymore and integrated their team's code anyway and said fuck it the americans can deal with it tomorrow. there's a ton of ways you can break a build once it leaves your workstation this happens with microservices all the same but the impact is more manageable and more importantly you can immediately deal with it within your own team.;0
flq5yvr;Reddit;2020-03-28 08:27:58;i meant that 99 of people hosting microservice should be using something like istio. not that 99 of anyone hosting anything should be using istio.;0
flqlgu8;Reddit;2020-03-28 13:39:17;you could enforce almost equally rigid boundaries between modules but you don't have to. it's one less constraint on your system so there's no guarantee. because your boundaries aren't at the network level your debugging methodology is going to vary by language. microservices require message passing which is far easier to debug. even if you're using dependency injection ioc your module a might well depend on module b's implementation rather than its interface. the point is that microservices force really clean boundaries compared with a monolith. monoliths encourage cramming a multithreaded system into a single process which has scalability edit and reliability issues as well. monoliths are not composed of discrete parts by definition. edit debugging and comunication in microservices is in fact less standardized because a monolith leaves less choices for each module. leaving less choices for each module is the antithesis of standardized boundaries and again you're talking modules instead of services. excessive modularity is problematic whether we're talking services in a system or parts of your monolith. with that out of the way if you do want modularity to make something pluggable servicenetwork boundaries are more standardized in the sense that they are typically implemented as a rest or gql api or a database wire protocol all of these permit language interoperability for example and allow languageagnistic debugging tools that handle the given interchange format usually json and protocol usually http. i think the argument you really want to be making is breaking a system down into smaller and smaller parts yields diminishing returns and results in a system with more moving parts and we would be in agreement on that point. you seem to be imagining this extreme example where no module can directly depend on other modules and maybe every function is packaged up as a microservice. the problem is that is not even close to what's being suggested here. in defending monoliths on the other hand you are advocating for the exact opposite extreme all dependencies in the monolith are in code and they all need to run on the same server yes if all your data is separate from your application code you can have multiple servers behind a load balancer but you can't scale parts of your monolith individually. a monorepo lets you release and deploy as a singular unit reaping the system simplicity benefits of a monolith while they outweigh the costslimitations but ifwhen it comes time to start splitting up the pieces for scalability reliability andor independent release cycles which are essential if you scale your workforce to e.g. 10 teams of 10 people you don't have to go through the pains of breaking apart a monolith you don't need to do all of the testing associated with extracting services because they're already discrete. in the meantime you can more easily test components of the system by stubbing network responses or standing up mock services.;0
flqqpp6;Reddit;2020-03-28 14:55:19;no i'm saying micro services introduce complexity that's true and also false. microservices reduce complexity because as said you're now breaking your big program into many small programs each individual part is infinitely less complex than previously thus making it a lot easier to work with. what would you rather work on a small program or a large program? obviously the first one right. however the webbing that holds your application together not to mention you are exposing the entire application to transient errors by network failure is as you're mentioning complex. it's tradeoff definitely but i do not think it's fair to say that microservices makes everything more complex as if that was the case we'd definitely not use them.;0
flt0dsp;Reddit;2020-03-29 06:19:34;thats true of the cost i agree. just for the record i do firmly believe that at a certain scale or level of complexity the pros outweigh the cons and you should convert into a microservices architecture. but its a tool like anything else and can backfire if used too early by introducing unnecessary complexity improper bounded contexts due to not understanding the problem domain fully and reduced velocity. just like everything in programming its not good or bad but it introduces tradeoffs. i wouldnt use cqrs for a crud app that has 100 users for instance. 100k then reads separated from writes probably makes sense.;0
florso3;Reddit;2020-03-27 22:22:46;fuck it the americans can deal with it tomorrow. i'm not sure i see microservices as an improvement here. at least with a failing test you can see that shit's broke and where. it's a lot harder to figure out that your code doesn't work because offshore said fuck it and broke their api. then you've gotta do the email dance where you tell them their shit's broke they ask you to send a requestresponse then they say it's fixed when it's not then you gotta tell em shit's still broke and on it goes.;0
flusj2c;Reddit;2020-03-29 21:12:11;look i'm not trying to defend microservices but i do believe they have their use and large organizations can benefit from it. the original point of my comment remains though. monolith are also very complicated and can be very complicated to completely grasp for a single developer especially a new one. unless that monolith is trivial but a company that has a big enough application that using microservices is valid will also have a monolith that is massive.;0
flokixb;Reddit;2020-03-27 21:14:28;so now you went from every piece of code is exposed to the customer to generates value. you are not challenging my knowledge nor do i see this as some sort of competition it's just pointless to reason with someone who will constantly twist and turn in a bid to seem right. you went from i like microservices to microservices generates value. it does but for amazon who gets to sell more instances. i pity your coworkers for what they have to deal with. i wish you a lovely weekend. you too enjoy the weekend.;0
