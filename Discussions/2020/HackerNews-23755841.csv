ID;Source;Creation Date;Content;Sentiment
23755841;HackerNews;2020-07-07;Title:Building Domain Driven Microservices, Content: https://medium.com/walmartlabs/building-domain-driven-microservices-af688aa1b1b8;0

23768510;HackerNews;2020-07-08;i see the writer is from walmartlabs so i assume this is advice for walmart scale applications. for the rest of us it's probably good to remember that you are not walmart. now we know that in any modern application sacrificing availability is not a good idea either.i feel like this will apply to less than 10 of applications. normally you'd rather deal with the occasional downtime than dig through the fallout of broken attempts at distributed transactions. ask yourself what amount of x000 are we losing per minute of downtime and see if it rounds down to zero. another way to model this system is to separate or group related models into separate microservices. in ddd these models price priced items and discounts are called aggregates.and this must be the case for less than 1 of readers it would take a massive system before i'd consider having prices and discounts in separate databases. you're taking on the overhead of writing an additional service for what could have been a database join.;0
23766152;HackerNews;2020-07-08;here is an article where i look at this issue in more detail;0
23765974;HackerNews;2020-07-08;bingo. having each team own he boundary of a service lets everyone work as fast as possible making choices that are right for their service while preserving the right level of abstraction between components.thats iveryi different from a team of 8 people managing two dozen microservices which is just insanity.;0
23765965;HackerNews;2020-07-08;the realization ive had after scaling a dev org from a single team to 10 is that you dont need microservices to achieve any of that. when you have 10 teams working on 1 monoservice who is responsible for which parts of the db schema?you can still develop interfaces between teams without microservices. there are a number of ways to do this but the simplest is just a folder structure that reflects the boundaries and enforce them by convention. if the modelrepositoryyour favourite db abstraction lives in context1user you cant access it from context2account without going through context1publicinterface.its surprisingly easy depending on your language to write tools to automatically verify boundary violations if you need to.this still allows you to solve all of the problems you listed .;0
23764443;HackerNews;2020-07-07;ultimately the point of separating code into microservices is to develop the interfaces between teams. they certainly do not make sense compared to a monolithic app until a certain scale.exactly. this is the idea that i haven't been able to articulate. and it is rarely addressed in the literature.;0
23764421;HackerNews;2020-07-07;i find this opinion to be rather odd. fang and ecommerce firms like ebay solved scale by partitioning functionality into services for scalability.what is key is to have a scalable time series db to monitor the interactions of the components and services and microservices that comprise your platform. measure the kpis around hardware os software and services interactions. monitor and alert on them via realtime dashboards.;0
23764389;HackerNews;2020-07-07;this only works for the simplest cases. if the two microservices must share data and direct calls api calls are not allowedactually one assumption is that the microservices don't share data. only api rest soap graphql etc calls are allowed. and the boundaries are created minimizing the coupling between microservices. while this let's you scale up teams it's a huge overhead. so unless you have over let's say 500 devs it's not worth it.as opposed to monolith ? i think you will have problems collaborating in a monolith at around 30 devs.what i am opposing is the idea that you can have 30 devs and 50 microservices. which i have seen in real life.;0
23763456;HackerNews;2020-07-07;ultimately the point of separating code into microservices is to develop the interfaces between teams. they certainly do not make sense compared to a monolithic app until a certain scale.when you have 10 teams working in 1 monoservice who is responsible for which parts of the db schema? can i query a table in one part of the app that another part owns? what if another team changes a table that i relied on and introduces a bug? who is responsible for fixing it?microservices solve the people problems more than they solve the tech problems assigning organizational responsibility for functionality infrastructure strategic objectives etc. it also provides clear interface points between these things that can make organizing work easier. you get to split your 1 org into 10 little vertical orgs. this has benefits beyond just code boundaries. now you can have 10 different goals all being achieved at onceyou can go the other way of course and split the stack horizontally one team is responsible for infrastructure one for dba one for frontend etc but then no team is working towards any one goal. who is responsible for making forward progress?;0
23763173;HackerNews;2020-07-07;why do you need microservices to create boundaries in your code?you trade the ability for teams to deploy independently for the ability to be able to make breaking changes. this is a good trade off in my experience and is better for team velocity.the approach we have taken is to keep a single codebase and deploy. we have applied the ideas from ddd to segment the code into contexts and assign ownership of each of those contexts to a team. this allows us to get some of the benefits of microservices without losing all the benefits of a monolith. having these boundaries in place also gives us the flexibility to move to microservices if and when we decide we need to.;0
23763106;HackerNews;2020-07-07;this only works for the simplest cases. if the two microservices must share data and direct calls api calls are not allowed because they make your services highly coupled to each other to the point where if one of them ia down then the other cannot work properly or simply because your use case cannot tolerate the latency overhead then each service must 1 replicate the data needed locally by listening to interesting events of the other service and b emit interesting events so that the other service can update its local db. in other words async communication.while this let's you scale up teams it's a huge overhead. so unless you have over let's say 500 devs it's not worth it.;0
23763043;HackerNews;2020-07-07;microservices are a good way to scale up development teams. so if you have 16 developers you can partition the work in two teams with one microservice each. if you have 80 devs you can have 10 teams with one microservice each team. use conway≈õ law to your advantage. use ddd to decide where the boundaries are.the advantage of having each team own a microservice is that each team can deploy their software independently from the rest of the teams. and it works as long as the apis are honored. so microservices are way to decouple the work of different teams allowing them to work independently from each other.;0
23762560;HackerNews;2020-07-07;can you guarantee ordering? can you guarantee exactly once? how do you get transactional semantics? how do you handle cascading failures? it's all a bit overwhelming.i dont advocate dddmicroservices but if you absolutely must go down this road kafka streams really neatly answers all these questions. ben stopfords book0 and blog posts1 are really great if you want to know more.0 1;0
23762513;HackerNews;2020-07-07;i have done a lot of work with microservices and i agree they come with a ton of cognitive overhead and new ways for things to fail in unexpected and painful ways.in particular it now requires software engineers to understand principles and design patterns for distributed systems that when i was first starting out were relegated to theory and university papers. can you guarantee ordering? can you guarantee exactly once? how do you get transactional semantics? how do you handle cascading failures? it's all a bit overwhelming.i have also seen however that monoliths at some point lock up an organization. the key measures of software delivery performance are deploy frequency lead time from commit to running in production mean time to recovery and change failure rate. monoliths impact all of these when you engineering org starts scaling past a handful of teams. a monolith also becomes a single point of failure. one person in one team checks in bad code and the whole system falls down. microservices can give you resilience. you can also scale microservices independently a cpu intensive service can get a bunch of pods a memory intensive service gets a beefier memory allocation and other services can run idle most of the time or even be deployed as faas functions that almost never run.so i agree it's not a technical solution as much as it is about scaling an organization. at wework the team shrank so much that we began consolidating small services back into a single service because the operational overhead of having separate services didn't make sense any more when a single team was responsible for all of them.i do think choosing to split out a new service is a big decision to make. you have to really think through the cost and benefits. you also need to make sure you have the right tools in place so you can detect and recover quickly.things like log aggregation slos defined measured and alerted on canary deploys progressive delivery etc. without that you're running completely blind.i also think you want to be thoughtful about keeping your coupling low. if each service depends on twenty other services then in my mind you now just have a distributed monolith.;0
23761742;HackerNews;2020-07-07;this is really not true. while every industry and especially software engineering is prone to hype the reason things become popular is that they deliver real value.rest api's and microservices are a design that originated when software teams started growing in size and didn't want to lose the agility they observed when having control of their complete stack. it was enabled by a fundamental shift in infrastructure previously everything was managed by dedicated infra teams but containers and container orchestrators gave development teams control of their deployments. the old model of monolithic services stood in the way of developers who had access to this new power and hence microservices were invented to address that.i could give you similar reasons for the rise of big data infra as code etc. every one of these changes are driven by changes in fundamental technologies. they aren't fads.;0
23760887;HackerNews;2020-07-07;this talks about the thing that makes microservices fail most often getting the bounded contexts wrong. it doesn't go into enough detail to show you how to do it right but does tell you what to watch for when you're doing it wrong.the biggest most common mistake is when a bounded context is called ltnoun service. this should be a huge red flag. unfortunately most books and this post always use this bad naming starting everyone down the bad path. at the very minimum call it a ltnoun management service if it is the primarygeneral createupdate activity. e.g you might have a checkout service that creates most orders and a order management service that can make drafts or adjustments. order management being the decoupled source of truth might even be downstream from checkout service. other services that need this information should get it's own copy asynchronously i.e. decoupled.the best way to learn how to do bounded contexts right is to study ones that worked well. most writing tries to describe this in an abstract way using placeholder widget service things that helps no one.the bff pattern is good but doesn't solve everything. if you're accessing multiple services for a synchronous mutation it's likely not highly reliable but can get by for an interactive service that can tolerate some errors. a messaging service is not one that should they should always accept store and forward with the lowest possible error rates.;0
23760790;HackerNews;2020-07-07;oh i didn't mean to imply that i was only interested in ddd et al. for microservices.;0
23760092;HackerNews;2020-07-07;also aws services are much more standalone products than an components of an inhouselob system consisting of custom built microservices.;0
23759234;HackerNews;2020-07-07;i view a working microservices application as a monolith with unreliable network connections between components. so overall adding a lot more complexity for the promise of lowers costs and scaleability.one advantage that i do see is the ability to deploy components individually but i see more downsides than benefits overall. i hope that consensus is becoming start with a modular well designed monolith and scale out the parts as needed.;0
23758779;HackerNews;2020-07-07;architecture driven by engineering aka security authorization performance processes and timing data flow usersystem interaction hardware devices etc. can informdefine what the subsystems are.the architecture in the article here seems to be driven by a certain type of oo datainterfacemodellingin schoolcoursestutorialsbooks we are initially taught a type of object oriented datamodelling which is at the level of objects in the world are objects in our programs. a person is a person class a shopping cart is a shoppingcart class. you can put stuff into the shoppingcart it belongs to a person and so on.i call this kindergartenoo it puts labels on things in the world and then models software interactions 11 based on that as if software is a simulation of the world.this conflates all kinds of things and the actual engineering and userinteraction requirements get smeared all over your codebase.now this kind of microservice design looks kind of like that but lifted up to a network of computers.you end up with suggestions like design applications around eventual consistency article. why? because you didn't design your architecture around timing processes datastructuresflow and interactions but around this made up simulation with n2 communication channels.a process that takes a longish time and maybe doesn't need to be realtime consistent analytics. let that be eventually consistent close the feedback loop each friday and enrich your data which then informs the rendering ordering emphasis of products and so on on your frontend.an architecture around interactions flow dataprocessing securityauth and so on looks much more like a decision tree statemachine or something like that rather than like a zettelkasten graph.;0
23758479;HackerNews;2020-07-07;you have no idea what you're talking about. monitoring and logging is just as important with a monolith how else are you gonna notice when something is going wrong? in fact it is much more likely that your monolith will go down and lead to a significant outage because the monolith is bigger and thus has more failure points. furthermore a monolith that crashes will take everything else with it whereas a microservice that is unavailable only impacts a part of your business. you can do some disaster recovery in your monolith to a certain degree but you will only be reimplementing things that k8s can already do. you will probably have one or two services that when they go down your entire company is downif you have microservices like that then your macro architecture is bad because one of the key points of an soa is to limit the impact of failures. probably you are using a lot of synchronous communication like rest because it was easier and now you have to pay the price. you chose consistency which can be a valid choice and now you complain about lack of availability when any undergrad knows you can not possibly have both at a scale that requires partitioning. using synchronous communication everywhere between microservices leads to a distributed monolith where you have to pay most of the costs of a soa but get few of the benefits.the one correct thing you said is that a microservice architecture is indeed a huge investment that requires sophisticated devops processes in order not to drown in operational tasks. microservices are a good choice when you need to scale either in amount of users or developers beyond the capabilities of a monolith i.e. you need an application that is partition tolerant. at that point you can chose between consistency easier development or availability. no matter what choice you make it will be painful but it can't be avoided.;0
23758245;HackerNews;2020-07-07;every team needs to deploy in lockstep.team a can finish their part of joint effort before team b and get deployed on monday then team b finishes their effort and gets deployed on tuesday this looks the same in both microservices or monoliths. you can have blue green deployments with monoliths with zero downtime.why does it look the same? because you have to be careful with how you modify the interfaces in any case. if team a is requiring a new field from team b to be not null immediately then the monday deployment breaks in either case. if team a uses a feature toggle or just does the old thing when the new field is null that has nothing to do with microservices vs monoliths. if you are using a monorepo in both cases the synchronization story is the same master needs to build and run without error.the real distinction is what the monday and tuesday deployments look like in either case. with monoliths the monday deployment and the tuesday deployment look identical the whole monolith goes up and down. with microservices team a can be responsible for their deployment on monday and it can be completely distinct from what team b does on tuesday. if team a is team b then the gain was a minor allowance in the deployments being different which might be a net loss.actually when team a and team b are in lock step then the monolith allows changes to be deployed that would otherwise be considered breaking if deployed in a microservice architecture. however a lot of monoliths will still be clustered and might talk to each other across the network killing this advantage.;0
23758158;HackerNews;2020-07-07;am i the only architect that hates microservices with gusto?i only have a problem with the label microservice. a service is an independent product that's all. micro says absolutely nothing about the size of that product. it's like serverless it doesn't even explain what it actually is thus quickly become a marketing buzzword.;0
23758130;HackerNews;2020-07-07;i mean yes if you want a use a new feature using the new api. then your going to have to move onto the new api. but that would happen regardless of using microservices.if you version it though services that don't care can cary on regardless.;0
23758022;HackerNews;2020-07-07;i get where you are coming from. but we certainly did a decent implementation using microservices. the project is basically complete and in production and it's the backbone of a major company running a few million requests a day. not that we didn't make mistakes but i would say it's definitely possible...;0
23757990;HackerNews;2020-07-07;if you want to expose extra features or change the api design you version your api.but you are still coupled. if you have to version your api that means it is relied on by something else and in order to use that extra feature still requires both or more services to all be on the same page.microservices let you deploy and maintain at different times if that is appealing to you but in order to realize a new business feature you are still coupled.now you have x tests for x versions as well make sure the old version remains old and the new feature works in the new version.;0
23757967;HackerNews;2020-07-07;the only application that i encountered that fit the microservice idiom well obviously in my opinion was postfix some diagrams at . note it is usually using unix pipes for communication instead of networking so some of the complaints about the networking disappear.even there the clear separation of concerns means that it becomes difficult to do some things that seem like straightforward business goals. you'd like to bounce emails to a user's aliases if they are over a but allow messages to that user from support. unfortunately the milter and the alias resolution hooks are different services and don't get to communicate unless you use some other functionality... i'm a bit hazy on the specifics but i can remember needing to bend over backwards sometimes to satisfy things because you couldn't chain additional information through. this ordinarily comes up quite a bit when people compare it to exim an smtp monolith where you are more easily able to use information from one service in another.i think postfix is well built but the architectural choice has consequences and it isn't a silver bullet.;0
23757820;HackerNews;2020-07-07;don't forget cohesion. microservices achieve the highest cohesion usually since the microservice does just one thing. it's reasonable to combine services together as long as cohesion is maintained.;0
23757600;HackerNews;2020-07-07;ex amazon sde here. amazon uses a service based architecture where one team e.g. 4 to 8 engineers maintains one service.the main benefit is organizational and lies in having a small and very measurable interface between services.crucially the team the develops the service irunsi it and provides 247 oncall for it. this also include taking decisions on how much to spend on hardware vs optimization as the team is responsible for the overall performance.more importantly the team is now responsible for service outages.this is very different from having a team write imanyi microservices. it's especially bad when a team writes a bunch of microservices the socalled distributed monolith and somebody else has to run them.sadly the article does not focus on this aspect.as a side note once developers realize they get paged out of bed by their own code... it's amusing to see how the cool framework of the month is not cool anymore.;0
23757577;HackerNews;2020-07-07;am i the only architect that hates microservices with gusto?i've only seen bad implementations out there tens of products and have yet to encounter one that looks reasonable. if your average developer has trouble implementing something sane when the only problem is splitting data and functions locally into different components why in the world would you assume that putting in a network layer exponentially increasing the failure rates loosing good stack traces making refactorings that have to move data from one part of the architecture to another a pain in the butt because requirements never change right? etc... would be a good thing?the horrors i've seen... oh boy the horrors.the people i've heard praising microservice architectures so far fall into two categories 1 ex developers that moved into management and read a few articlesbought a book on the subject and think it's a great idea but have no actual practical experience 2 developers that have just started working on a new one and are still in the honeymoon phase mind you not developers that have started working on an existing one that is a few years old those figure out the mess they are in pretty quickly.you can screw up notsomicro services too but it's far easier to screw up microservice architectures and they are far far harder to fix down the line when you figure out how you messed up or rearchitect when that thing that the pm told you was never going to be a use case is going to become a use case after they tell you they are sorry of course.;0
23757358;HackerNews;2020-07-07;domain driven microservices looks good on paper but its a very very terrible idea.1. you can't run join queries across domains2. you can't migrate your schema across domains3. you will need to sync and map a db with domain dbs for reporting4. you need to write apiclient server for every domain and maintain this with db schema changes;0
23757328;HackerNews;2020-07-07;i might be a bit cynical neckbeard but the tech industry tends to go in circles with good engineering principles sold as the newest fads hype. before all the microservices craze it was rest and apis before that web services soa and esbs and before that xmlrpc corba eai and enterprise java beans. and before that we had we someone we had rpc over the network open systems.similarly ddd promotes separation of concerns and test driven development. that is exactly what extreme programming told us in late 90ies when oop and unit testing was in. before that it was structured programming and software design specs 4gl etc.bottom line is i wish people would start calling a spade a spade and indulge in less fads. lets just call it structured programming over the network with clear separation of concerns and clean interfaces. thats good engineering. test early and often. write good documentation.;0
23757276;HackerNews;2020-07-07;and they often are! because that's mainly one of the advantages... you can simply outsource a spec of the endpoints and that's it flop over a ourservice.swagger.yml and get a working system back. possibly in a languageframework you team has no experience with but it was cheap.recent fun a bunch of microservices written by the same contractor were killing the shared db the 'state' of all microservices so while most were running fine some were hitting the db hard and costing the company quite a lot of money until it was fixed. noone felt it was their responsibility to test amp fix because it was an external company and they 'delivered' according to spec. there are many ways to do this better but it happens quite a lot also with monoliths ofcourse but there i find it fastereasier to diagnose fix depending on the size i guess there is a point somewhere in loc where microservices start to shine.;0
23757248;HackerNews;2020-07-07;in both 1 amp 2 i only see money pits... this sounds like so much overhead... par for the course for enterprises but i see too many startups now deploying 50 microservices and suffering with the overhead hosting maintenance employeecountchurntraining monitoring etc.;0
23757158;HackerNews;2020-07-07;regardless of whether youre dealing with monolithic or distributed systemagreeing somewhat but not totally monoliths are much easier to test and stabilise. all bigger microservices projects i know personally not what i read from uber etc have tremendous overheads compared to their monolithic counterparts. some of them are really nicely done but there still is a lot of overhead in support usually the services are written by different people and possible different languagesenvironments for instance .net core .net framework for windows specific services typescriptnode so other people need quite a large ramp up to get into them networking monitoring etc. as far as i have seen it needs a larger team.and it is very different from having you modular built monolith in your ide for a spin than doing a little localdev testrun of 25 microservices the one you are working on. i can feel the benefits but i have yet to encounter them in real life so far i have seen smaller 100myear rev companies going back to monolith and most of the stories i read are from very large companies with massive developmentdeployment teams where you actually can have 3 people per microservice.if you are working with 34 people managing 20 changing forming a complex system i don't really seen it happen but would love to see practical examples of that while monoliths of the same complexityfunctionality literally i worked on a few 'just because scaling!' rebuilds from monolithsmsback have no issues at all with that.;0
23757086;HackerNews;2020-07-07;you don't need micro services to do ddd you can do ddd within a django app. i'm not a django man myself but a quick google shows several projects and blogs discussing it.in essence ddd forces you to have conversations about separation of concerns and then being careful to stick to them. microservices force that but you can get the same effect with wellthought out namespaces in a monolith.;0
23757060;HackerNews;2020-07-07;anyone that isn't able to write modular code using the language features is going to write network spaghetti code with the added benefit to debug network packets and connection issues on top of everything else.this is the most important bit. to me microservices is just another way to arrange your system into module not much different in concept to modules and packages. regardless of whether youre dealing with monolithic or distributed system if your abstractions are poor your work and your system will suffer.;0
23756939;HackerNews;2020-07-07;until you come to the deployment phase where all teams need to communicate and deploy in sync. this can be a significant factor for slow down.also microservices don't sync on the datastore these are in theory not shared.so yes microservices can be emulated in monolithic architectures as can monolithic microservices be built. usually you end up with the worst of both worlds. the complexity of microservices with the speed of monoliths.;0
23756915;HackerNews;2020-07-07;so you are in principle of course correct. but keep in mind that microservices can be deployed independently of each other. with monoliths there is a single deployment that causes a lot of synchronization issues. every team needs to deploy in lockstep.this is all theoretical to some degree because i have seen teams deploy microservices in banks during the deployment windows and i have had people explclaim they have one microservice.so you can definitely do it but microservices have other advantages as in how easy can you then scale the components how resource hungry are individual services and so on.;0
23756833;HackerNews;2020-07-07;organisation and communication between teams is improved by having good apis.you can have that with or without microservices. you can screw this up with or without microservices.the main factors for going for microservices are technical but as always must be understood.;0
23756750;HackerNews;2020-07-07;as if the blame game doesn't take place with microservices as well.it is specially funny if the microservices are developed by several contractors.;0
23756743;HackerNews;2020-07-07;my first microservices were written using sun rpc the company whose motto was the network is the computer.since then we have seen plenty of microservices solutions come and go what stays is the complexity of dealing with distributed programming.anyone that isn't able to write modular code using the language features is going to write network spaghetti code with the added benefit to debug network packets and connection issues on top of everything else.;0
23756638;HackerNews;2020-07-07;if communication friction and overhead is the primary thrust for microservices where you obviate said overhead by keeping to small teams how do you address and manage the need for communication ibetweeni teams?obviating communication costs iwithini teams is one thing but what of the overhead and costs of communication for the whole isystemi? eg. how do you avoid the cost of deploying a new team that ends up deploying a duplicate microservice?;0
23756636;HackerNews;2020-07-07;you're making a point that microservices help teams to solve the problem of increasing communication needs for larger teams. while your statement makes a lot of sense i'd like to ask why this problem cannot be solved with packages or classes within a monolith? a team can own a microservice and expose an api to others the same way they could expose an api on a class or package no? microservices are a way of deploying small parts of software. it's not about communication across teams. it can help with communication but this is not only true for microservices.;0
23756611;HackerNews;2020-07-07;good explanation. but i have two questions1 so which team then takes ownership of the entire katamari ball of sprawling microservices and understands the interconnectnedness and nuances of overlaps and competition between each microservice?2 if the concept of technical debt at yesterday's monolithic architectures is biting us now what does the future technical debt of microservices hold?;0
23756602;HackerNews;2020-07-07;i worked for a company that had tried to adopt microservices without a good reason to and failed miserably. over time we were able to rearchitect it into a happy medium of a few large components. it was a huge costly effort... and i've never learned so much.beyond technical concerns i learned that you can architect a looming disaster and then leave for a higher position at a big company. nobody watching your conference talk will know.;0
23756568;HackerNews;2020-07-07;good points and it feels like this is what most people miss. they take microservices from a purely technical perspective and then rant about its complexity. you don't need a large scale distributed systems platform when you're a small team or have no scaling requirements. microservices is largely driven through that organisational need of teams having to ship productsfeatures independently and its just easier when the communication is via a service api vs humans or explicitly when walking over each others code.;0
23756530;HackerNews;2020-07-07;ihide implementation detail and expose functionality through intentionrevealing interfaces.iexcept rest apis what microservices expose almost always don't reveal anything most of the time wanting to hide internal state behind a beautiful and uniform facade essentially representing a twotier model. for example orders and order line items can't be addeddeleted at will but depending on whether the order has been processed or not should expose a cancel action with partial refundwith penalty for cancelling etc. sure you can hide that behind a delete method or reify a cancelled status but why? iservices are resilient to failures.iin the case of rest apis this means manually and labouriously attempting to reconcile state across multiple services in the client.compare this with state changes though ordinary rpc which can expose a meaningful state model give contextual diagnosticsexceptions and can have transaction context flowing with rpc calls.;0
23756510;HackerNews;2020-07-07;microservices are for when you have no other choice. if you truly cannot build a monolith then build microservices. if you have merely chosen to adopt a microservice architecture when a monolith would have been suitable then you have made a huge mistake.;0
23756509;HackerNews;2020-07-07;i'm really having a hard time finding the willpower to read articles that just even mention microservices in the title after working on such architectures with java for a while.nice idea but most of the times horribly implemented with no care about monitoring and logging as someone has already said.it requires a degree of attention to details during design and development that few are willing to put in. it's easy to go for a prepackaged solutionframework thinking that you are building something that could be considered state of the art when instead you end up with something that takes multiple tries to even boot correctly or 10 minutes or so to stabilize a garbled mess of interdependant components.designing these systems require a whole new set of skills that were not required when designing monoliths.;0
23756506;HackerNews;2020-07-07;its inherent in this comment that you really dont understand ddd and why adhering to its precepts is a critical improvement in designing microservices.plenty of books to read videos to watch. learnlisten before you speak.;0
23756470;HackerNews;2020-07-07;my point is everything they talk about is common to any type of enterprise software development. its not new. and then they slap on microservices at the end so they can claim to have written something new.again your rant makes no sense at all. the blog post talks about a specific distributed system architecture style whose services are designed following a specific architecture style.and here you are angry at someone because... because you believe the author has ulterior motivations? if they want to write something new then talk aboutsorry but you have no authority to tell others what they should or should not write.the author of this post contributed something to the public that's interesting and has value. meanwhile what have you done?;0
23756419;HackerNews;2020-07-07;yes we did all that a few years ago and it's still in use. clean code hexagonal architecture ddd event sourcing.main lesson is that you should not use it for everything yes the books say it but it's easy to overdo it in the beginning. don't do ddd for the crud parts of your app. it works extremely well for business use cases but it's very bad at crud. a mix of both really hits the sweep spot though.no microservices though just a monolith. imo most businesses shouldn't need microservices only the ones that really need to scale. we definitely don't have anything even close to that.;0
23756409;HackerNews;2020-07-07;i think that many people look at microservices from a purely technical standpoint. how much compute power do i get per dollar spent. what about the monitoring complexities and the logging problems?microservices are actually often driven by business requirements. according to the myhtical man month communication channels follow nn ‚àí 1 2. so a team of 4 developers has 6 possible communication channels a team of 5 already 10. this eincreases sharply as team sizes increase and is one of the reasons big enterprise projects suffer compare to startups.the business benefit of microservices done right is that you build islands of communication that communicate using only one outside channel. now communication increases less sharply as teams are separated by their boundaries.according to the guardian the team size and structure is one of the secret for amazons success. for smaller teams the communication benefit will often not outweigh the additional complexity.;0
23756400;HackerNews;2020-07-07;but with microservices you have more supposed independent interfaces.you don't. you have more services accessed over a network and might not have control over all services. but that's already par for the course in nonoliths.if you were to refactor your components by changing classes around say a major version update in a dependency while not updating the components that used them then you would also have problems.that's why versioning and service discovery and hateoas are a thing.;0
23756392;HackerNews;2020-07-07;i've been through a couple monolith to microservice transitions. i will say this... if you're monolith is slow because of it's design limitations and your plan is to propagate those limitations across n microservices w all the overhead that comes with microservices you're microservices will only be good at scaling the billable hours of the consultants who sold you on the idea in the first place.;0
23756372;HackerNews;2020-07-07;my point is everything they talk about is common to any type of enterprise software development. its not new. and then they slap on microservices at the end so they can claim to have written something new.if they want to write something new then talk about the realities of how microservice development is different than regular enterprise software development. not regurgitating the same old concepts and pretending its eye opening and new.;0
23756351;HackerNews;2020-07-07;wow microservices sound like a very painful tradeoff to make. is it really worth it?;0
23756317;HackerNews;2020-07-07;bleah. i hate articles like this. they regurgitate all the well known talking points about enterprise software development but none of the realities of micro services.i disagree. the post is a good summary of all the key features and main concepts of a microservices architecture developed with domaindriven design. it does what it says on the tin and you don't have to read three books to get there. it sounds like they havent actually worked in the trenches supporting and coding real microservices at scale.i have no idea where you got that idea. it certainly wasn't from the blog post though. the realities are that going from monolith to microservices is a huge investment and only large engineering teams should do this migration.your rant makes no sense at all. you're just mindlessly repeating cliches about issues that have absolutely nothing to do with the subject. i mean the blog post is about microservices software architecture with domaindriven design and clean code but here you are whining about how you believe refactoring projects designed following an entirely different architectural style is hard.;0
23756302;HackerNews;2020-07-07;but with microservices you have more supposed independent interfaces. with a more monolithic approach you might just change a system internally and deploy it. internal interfaces are generally easy to adapt.;0
23756259;HackerNews;2020-07-07;bleah. i hate articles like this. they regurgitate all the well known talking points about enterprise software development but none of the realities of micro services. it sounds like they havent actually worked in the trenches supporting and coding real microservices at scale.the realities are that going from monolith to microservices is a huge investment and only large engineering teams should do this migration.the reason is that once you go microservices you instantly require an immediate investment in devops which is something you didnt need as much before with a monolith. oncall rotations and pager duty schedules become imperative because services will go down. also monitoring is another investment that you immediately need otherwise youre completely blind.the article talks about things that are obvious like designing the apis etc but those are the same regardless of if its a module within a monolith or a microservice. all the characteristics they list at the beginning is no different than what a team that owns a module in a monolith would require as well. it feels like this article isnt very useful because it regurgitates concepts from regular enterprise development and packages as new for microservices when its not.what the article lacks is the difference in architecting for a real microservice environment.one of the biggest missed issues is never mentioning dependencies. sure its great to talk about how to model services with eventual consistency blah blah. but if you already have a large engineering team which you must have otherwise why have microservices then there will be a dependency between services and to believe otherwise is crazy. you will probably have one or two services that when they go down your entire company is down. its imperative that every service is architected with that in mind and what happens when its down. hand waving eventual consistency wont cut it in the real world its the biggest problem that each team needs to focus on early otherwise its a ticking time bomb.;0
23756210;HackerNews;2020-07-07;great then a new us comes in that changes the intention and you enjoy the pleasure of changing the interface.that's not a microservices problem not even a software architecture problem. that's at best a project management problem. in fact pretty much every single engineering project there ever was would struggle to meet any form of neckbreaking change in design requirements.;0
