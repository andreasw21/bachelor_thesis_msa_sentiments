ID;Source;Creation Date;Content;Sentiment
25498079;HackerNews;2020-12-21;Title:I've been merging microservices back into the monolith, Content: https://www.bennadel.com/blog/3944-why-ive-been-merging-microservices-back-into-the-monolith-at-invision.htm;0

25518931;HackerNews;2020-12-23;not a real issue at all in my experience. businesses all over have done this for decades.if you have many many microservices what is the combined resource usage vs. the monolith? probably about the same and microservices may use more resources actually if we are talking anything with a runtime like java.migrations in my experience mean migration of data so its about the volume of the data you need to change and not about the code operating against that data. whether you have your monolith or a bunch of microservices waiting for the conversion job does not matter. it also does not matter whether your monolith or the microservices have to be able to read the data at any given time. with a quick starting microservice you may be able to say eff it a transaction might fail but the new service will be up quick and the user can redo it but that's not what you really want in big mission critical workloads. you really want to wait until all transactions on the old nodes finish before shutting them down. so your load balancer will route all traffic to the old nodes until new nodes are up then shift traffic over and you kill your old nodes when all transactions have finished. then you deploy those nodes and bring them back in. you have reduced redundancy and less capacity to handle load if we are talking old real iron businesses but in current cloud environments you just start up new instances and literally just kill old nodes after you've let the transactions finish. so you could even deploy during high load times.i'm not talking hours of deployment here. monolith doesn't mean you have to have all the cruft and startup times that say a jboss server with ejbs. you can have a monolith that starts up in a reasonable amount of time if you make the right choices for how you build your monolith.post deployment verification is slower why? if you do this manually why does it matter whether your changed customer flows are spread across 6 microservices that you just deployed new versions of or your monolith?also monolith doesn't necessarily mean you only have exactly one service. at my last place we had multiple services for various parts of the overall system but they were all monoliths themselves and shared some code through a library as well. but the services definitely weren't micro and did lots of things that weren't that related in the end. could've split it up into many microservices.;0
25518619;HackerNews;2020-12-23;the modern answer? really?i'm sorry but this is exactly what tons of old businesses have done for ages. but they are being told over and over that that isn't web scale.in my old life we just scaled via the db and were able to deploy as many copies of our monolithic services as we needed to scale. we had a few monolithic services no not microservices really nothing micro about them at all that even shared some core code through a library.in my new life that is no longer wanted and we need microservices and multiple databases. except that it's all just logically split and in reality ends up in the same db instance. but you know we could scale it to a new db instance if we ever needed to. not that we will if you ask me because we run maaaany customers on the same database instance too. so it's all fake and we could've just used the same old boring working fine approach as any old business. go figure.;0
25513758;HackerNews;2020-12-23;same problem every development team has. who setup up the ci server? who setup the frontend proxy? who configured the aws setup? everything needs redundancy.sure so all those things should be owned by a team rather than an individual. but that makes the whole when a containervm would run out of memory we all didn't have to scramble to figure out who broke something. the person who owned the code for that service dealt with it. if a service started kicking out errors nobody but the owner had to be distracted. kind of pointless the whole team should know about the service and be aware of any recent changes to it and everyone should be able to debug it. i disagree that external services are hard to interface to. they are hard to work with when they are buggy but if they hit the specs they generally are not an issue.well of course programming is easy as long as there are no bugs! but the most important and hardest part of programming is debugging and every time you hit a service boundary you have to figure out which side of it the bug lies on that ends up being a significant amount of work. practically speaking you need to implement a stub version of the service for testing with monitoring that can confirm whether that service is up and running maybe some kind of tracingreplay that lets you track specific problematic requests... and that's even more work for internal services for something like s3 at least some of the bits and pieces for doing that have been built already. because of the loose coupling things were very extensible and easy to modify.absolutely but you don't need a network boundary to achieve that. i mean maybe you do in python because it has no visibility rulesenforcement and incredibly poor dependency management but that's not a general problem. you conveniently left out or branch.different commits on the same branch can be just as different as different branches. you can't have it both ways either you keep all your services in lockstep which means you have to restart everything to fix a bug or you have to worry about different services being on different versions. actually since you normally can't restart a group of microservices atomically you have to worry about version compatibility even if you try to always deploy new versions of everything together ime. listen i am not trying to sell anything i don't care what you think. i am just sharing my teams experience. it was overwhelmingly positive using services to build a complex system with real revenue from fortune 100 customers for almost a decade.your post sounds like a salespersoncultist with the not a single engineer that ever voiced a concern over how things worked emphasis. i've worked in multiple microserviceoriented environments including those that claimed success for microservices and they've all either had the same problems i'm talking about or actually not been talking about microservices but rather reasonably sized services i.e. having teams groups of 10 people who worked together and had standups together maintain one or two services each.;0
25513666;HackerNews;2020-12-23;i am very familiar with the tech. you cannot move the goal posts around regarding the nature of your application architecture and then claim that i am spreading fud as a result. strong type checking iacross the scope of the entire problem domaini is the guarantee that i am ultimately looking for. only if you compile your whole application into a single binary output do you get these guarantees.i do not care that each microservice independently passes type checks. this is hardly a compelling argument if we are talking about delivering working products. the most critical points of verification in a system with multiple services are where all of these pieces connect back together.;0
25512354;HackerNews;2020-12-22;this seems quite subjective i have worked with services like these and would probably call that soa where you need to split code concerns along domain boundaries.in the example above i would probably use cloud functions or a distributed actor system.perfect a microservice perhaps just service? can be whatever you want it to be and i don't see any reason why you shouldn't split code along technical boundaries if it somehow improves your software;0
25512028;HackerNews;2020-12-22;microservices idoesi break compiletime type checking. runtime correctness ! compiletime correctness. this is all assuming you managed to convince everyone to use the same language and throw everything under 1 solution too.i absolutely love that our application takes just a little bit longer to build than a smaller isolated microservice. this is when my computer is doing all of the hard troubleshooting work for me ahead of time. 32 cores diligently seeking out my wasted time and banishing bugs before they can even make it into qa.determining that your types don't line up during integration testing seems like a foolish approach if you value your time.;0
25510764;HackerNews;2020-12-22;the article says exactly why they moved to microservices too many teams were deploying the monolith and it slowed them down.the article also says why they are moving back to a monolith the services in question are legacy and being replaced and only one team is maintaining them so the reason they moved to microservices no longer applies. in addition combining the services makes their lives easier enough that its worth it from their perspective.your aggressive tone and assumption that they didnt have good reasons for what theyre doing is why i said you were rushing to express superiority.;0
25510074;HackerNews;2020-12-22;it's about domain boundaries application architecture coupling.thank you! as a service consumer if i need to call the same 3 other services for every operation then we've achieved microservice hell.monolith with 500.0000 lines of code could be very well designed... as someone who was part of a demonolith effort the first step of our process was to create internal service facades that grouped things according to the logical domains that aligned well with our required functionality data storage and availability requirements.once those were functional decoupled and comprehensible we actually had an easy to maintain clean monolithic code base that exposed a small handful of services that were deloosely coupled and conformed to workflows we need to support via web services.;0
25509889;HackerNews;2020-12-22;it might not necessarily and i was genuinely wondering what patterns people use but there are a few things about our monolith in particular that have seemed to make it harder for us the monolith has to do all the work of the whole system when it starts so startup time is a lot longer which makes rolling deployments much slower the monolith is much heavier in resource requirements so it's much more expensive to spin up multiple of them the monolith has a much larger surface area so postdeployment but prerelease verification is much more complex the migration path for a smaller service to support zerodowntime is simpler than for a larger service so on average it's probably easier to get it working for an existing 'microservice' although may be easier for the monolith than an equivalent full set of microservices;0
25509622;HackerNews;2020-12-22;but you can avoid this quite easily without resorting to microservices.;0
25508873;HackerNews;2020-12-22;my last job had 43 microservices one per sql table. best part it was across 8 repos and shared a core library. even better it was python so imagine adding an additional functions argument to the core library and updating the caller in 7 other repos pushing 7 prs and it still breaking 3 weeks later in production because you missed a function argument in one of the repos;0
25508309;HackerNews;2020-12-22;thats because the main advantages of microservices have nothing to do with writing code.as an example the pathofexile.com website goes down every time the game servers restart because they share infrastructure. this should be avoided.;0
25507969;HackerNews;2020-12-22;i am not talking about pitfalls of microservices i am talking about pitfalls of people trying to do microservices.microservices is not a single idea but a point in a progression of maturity of various aspects of the application and the team developing it.think about this you don't get to be f1 driver just because you decide to. you need to spend a considerable amount of time preparing to be an f1 driver. if your manager ie. yourself decides to sit in f1 driver seat but disregards advice to first get years of experience before doing so this is only going to end in a disaster. and it will not be a pitfall of f1 car.obviously the problem are managers who misplace their focus. microservices is a shiny object everyone wants to brag about but nobody wants to do the ground work necessary.so i see teams that don't even have repeatable builddeployment procedure want to do microservices. why not have repeatable builds and deployments first? this is already going to improve the situation a lot and be basis for further development which may culminate at some point with microservicesstyle environment.;0
25507267;HackerNews;2020-12-22;a real issue with microservices is that you can no longer use the database system for transactional integrity. is there a better option? and what is it?if you truly have a distributed system then you have to pick from a number of notideal options.but there are certainly many systems where the developers and architects have a choice as to whether to create a microservices or a monolith. if you're facing that sort of choice the better option in terms of being a solution to distributed transactions is to use a monolith and not have to deal with distributed transactions at all. you get the facility to just rollback the entire transaction.;0
25507221;HackerNews;2020-12-22;i always found the microservices make things simpler argument to be suspicious. at the end of the day it is just a monolith with unreliable network connections between components. each microservice may be less complex but you have just pushed complexity from the application layer to the devops layer. in a well written monlith the components shouldn't need to be any more complex than a microservice component.;0
25506740;HackerNews;2020-12-22;i read an article recently basically decrying how junior devs and some not so are holding tech leaders to ransom unless they adopt the architecture of their choice microservices being the current hot paradigm and so they are capitulating in order to keep them despite the fact that probably 99 of these devs are demanding something they will have zero experience with.i definitely saw the same thing playing out at my previous company and not being in the mood for a conflict over that have moved on.;0
25506735;HackerNews;2020-12-22;1 sure that may be an example of a good microservice but i'm not sure that is a requirement to follow a broad microservices architecture. this can also be handled via proxiesload balancers and rolling deployments of monoliths.2 agreed for individual services. maybemaybe not for the entire system.3 i think this is generally true but if you have a service that others are dependent on you can still have these problems. auth services for example that was a fun day at work.4 sure but now you have two binaries.;0
25506627;HackerNews;2020-12-22;microservices are easier to understand and debug.i think an individual microservice is easier to grok and debug but i also think a system made of microservices is harder to understand and debug. depending on scale this is a bit of a wash to me ymmv.;0
25506307;HackerNews;2020-12-22;i'd be interested to hear about the sorts of systems that you've worked on and how anything you can do with microservices you can do with a monolith. some problems that i've had to solve in recent years urgently deploying a fix in one part of the system without having to deploy the whole system. updating the framework or the language my favourite updating from java 8 to java 11 which broke a lot of things and which we would have hated to have to do all in one go if we'd had a monolith. scaling different parts of the system independently both in terms of running different services on different numbers of nodes and in terms of using different hardware for application nodes and dbs. load testing different parts of the system independently. trialling a new language or framework in a small part of the system without affecting the rest of the system.i personally wasn't aware of how much of a big deal some of these problems would have been until our system grew to the size that it is now with a dozen or so development teams working on at least as many services. i personally have no idea how you could solve these problems on a system this size without splitting it into independently deployable services without incurring a massive cost.;0
25506265;HackerNews;2020-12-22;in short ddd domain driven designthat's also the most useful thing i learned with doing microservices at work.note many good articlesvideos about practical domain boundariesdesigning aggregateroot though. does anyone have any tips? i feel that i'm lacking somewhat in designing them.;0
25506232;HackerNews;2020-12-22;the ceo was not a fraud and given the genuine fullyestablished and world class credentials of his technical reports in previous engagements entirely unlikely that he could have faked it with that crowd. no. it seems he had adjusted per prevailing and current norms of sv.beyond that clarification i think it irresponsible to name names. this wasn't a case of fraud peter principle ruled the day. both cto and doe had in fact lead a successful very large scale internet product company which is the reason they were tapped. it just happens that this domain was far more nuanced and complex than the domain of their previous victory tour.also as expected they including the super enthusiastic junior engineers that kept pushing for microservices have all moved on.this is just how the industry works.;0
25505992;HackerNews;2020-12-22;having a compiler able to check your whole system at once tends to increase stability of highly complex systems.but microservices breaks that as well as introduces many other consistency problems plus huge complexity overhead all of which are forces toward instability in highly complex systems.i suggest that the important factors for stability are not really about microservices and that depending on the situation microservices is usually a net negative for stability for the reasons mentioned above.;0
25505932;HackerNews;2020-12-22;look this is a great answer and i love martin fowler. that's one rational explanation. it may however be a rationalised explanation that misses out on the difference that makes a difference to understanding what's really going on.so here's another perspective that of a software anthropologist .. .common patterns of networked systems were developed over decades and as it developed over decades it built various advanced features on top of the core network callresponse features service busses routing useful abstractions like decoupling services from host processes propogating security contexts through the chains of service calls that can develop when these systems evolve strong typing which enabled layers of tooling to replace manually doing jobs with these systems and various advanced features.that was called soa because it looks at software architecture as a set of services.then along came a bunch of programmers that weren't very studious started from scratch just doing basic message passing without all the advanced features that had been built up by the decades of previous hard won lessons. that was called microservices. note the removal of the 'architecture' from microservices!slightly s;0
25505856;HackerNews;2020-12-22;microservices wereare an attempt of standardizing software development practices at really large organizations.for example your typical big bank has hundreds or thousands of teams both internal and through professional services companies developing all kinds of applications under different technologieshardware.in this case due to domainorganizational scale it is not feasible to have a mono repo or 2 or 3 with a giant codebase.and as a result the typical situation is an expensive hell full of code duplication adhoc integration methods nightmarish deployments and such.microservices are helpful in situations like this even if they are not perfect.but for a company with a couple of development teams and a domain that can be understood almost entirely by a couple of business analysts itÂ´s overkill.;0
25505702;HackerNews;2020-12-22;you push the data from all the microservices to a single data warehouse and do the reporting from there so all the aspects that modify the data are microservices but the reporting is based on a data storage monolith.;0
25505642;HackerNews;2020-12-22;i broke out all our code for displaying public content into a few different microservices so my sites could easily grab them which allowed me to play with different frameworks and ways to display our content blog posts and directoryreferences for biology. the new content microservices endpoints are also a public though undocumented api as an extra bonus.basically it gave me the flexibility to work faster and generating the code e.g. the rest endpoint or the sveltesapper frontend is also a lot faster and i get to host them on vercel for freeoh and it also helps me to separate business logic code and other notsopublic data to somewhere else heroku instead of vercel and it just runs completely separately. that way i don't have to worry about accidentally sharing dataas a solo designerengineer this vercel microservices tiny apis tiny frontends makes my life much easier;0
25505634;HackerNews;2020-12-22;in my experience this will result in a ton of unneeded extra complexity. microservices are very heavy and should be cut along domain boundaries and not technical boundaries so that they are as independent as possible and you reduce the need for synchronous communication. in the example above i would probably use cloud functions or a distributed actor system.;0
25505563;HackerNews;2020-12-22;from a technical point of view we're on the same page. but then there is the reality of modern software development.a few years ago the new cto of a union square ventures' investment tapped me as technical advisor to review this startups efforts to expand their software to new verticals. he came in as part of a reshuffle. he had brought his director of engineering from his previous well known company and there was even a star ceo which is the reason i signed up! with a monumentally impressive cv. as compensation i was billing lawyer hourly rates.after two months of reviewing their existing architecture and picking the brains of the dev support and sales team the new verticals i came with an iarchitecturali solution to their immediate and longterm needs. i gave them exactly what they said they wanted.what then happened is that for one the star ceo turned out to be an echo chamber of growth growth growth and entirely disappointing as a leader of a software company. and this was a sv veteran from both hw and sw side of sv. huge disappointment.the cto who was entirely clueless apparently gave in to back channel efforts of his doe to disregard my work product. a few days later i walk into an all hands meeting where the next generation was announced to be a ball of mud of microservices. this same cto later took me aside and basically offered to give me hush money will you be my personal advisor? to keep quiet while getting the same insanely high hourly rate for the remainder of my contract.so this is the reality of modern software development. architecture is simply not valued at extremities of tech orgnizations the bottom ranks are young developers who simply don't know enough to appreciate thoughtful design. and the management is facing incentives that simply do not align with thoughtful design and development.;0
25505467;HackerNews;2020-12-22;but aside from that anything you can do with microservices you can also do in monoliths.microservices can give you some things that a modular monolith can't provide independent deployments different tech stacks independent scaling and better resiliency.;0
25505442;HackerNews;2020-12-22;i think microservices can work for large organizations with many teams. however for smaller orgs and smaller teams it can for sure be a real killer.it's hard to keep track on different applications with different dependencies different deployments etc etc.of course one could standardize things but then some of the benefits of using microservices to begin with disappears. i am a big believer in the big monolith but that is because i am almost always working in either a very small team or alone.;0
25505291;HackerNews;2020-12-22;for that reason people employ data warehouse systems and architectures. microservices aren't complete without that complexity.;0
25505260;HackerNews;2020-12-22;microservices are easier to understand and debug.this should speak for itself. if you ship a service which is well defined and only handles a reasonable amount of functionality reasoning about its runtime behavior memory cpu usage io etc becomes much simpler.microservices are easier to test either through unit testing loadtesting integration testing etc. if you push a new version of a microservice and you see it's using more memory than the previous iteration it's usually trivial to work out which line of code caused the change.microservices are mentally easier to grok for engineers working on them. i've worked on monoliths that required months for engineers to get up to speed on working with them because they did so much stuff and if we had a memory issue with our monolith it could take weeks to diagnose the issue and we had to have our best engineers look at those problems because the service had grown so big and complex over many years.;0
25505237;HackerNews;2020-12-22;my question was rhetorical to be honest point being that the only new thing if any with microservices is that they should be micro and you should have a lot of them.people have been running 1 services for a long time. sometimes calling it soa and sometimes calling it nothing just doing it because it made sense.;0
25505234;HackerNews;2020-12-22;i think you're starting to get the pointthere are idiots out there. and they're doing microservices. for no reason besides hype.;0
25505228;HackerNews;2020-12-22;inefficient as in slow? yes it is slower than a join of course this is explicitely a migration strategy to move from a ms architecture to a monolithic architecture. the alternative is a bigbang migration which is a much bigger risk. so are ms relevantappropriate when you are trying to push stuff through the door ...that really wasn't my argument i was highlighting that it's possible to do a progressive migration from ms to monolith i was not making an argument that one is better than the other.to answer this question though no. a ms architecture will probably give slower responses than the equivalent monolithic architecture multiple db lookups interservice comms but that's just one element in the balance and rarely the most important one it's rarely important whether you get a response in 100ms or 200ms. i'm not going to go into why microservices there's plenty of litterature about it on the internet by people that know much more than me.a decoupled monolith is harder to achieve than decoupled services. services are decoupled because they have to. it's perfectly normal to go from ball of mud monolith decoupled services decoupled monolith. these transitions do not need to happen either they're just perfectly okay;0
25505110;HackerNews;2020-12-22;it would be nice to have some of those basic ideas that led to your thorough explaination of the pit falls of microservice development. what you write in this post is too general sure if you have to release your microservices as one mega monolith then it feels like an easy choice. when your application is not suited for microservices there are still things that can be easier updating dependencies because of security is usually easier if the whole code base needs it. so it all depends on the application what kind of development work does it need in a ten year frame etc.i really do not recommend big monoliths but the most important this is that it should be easy to start development that is usually easier with microservices. i feel your pain the automation really only starts to matter when you are above 40 services in my view.;0
25504964;HackerNews;2020-12-22;i think most microservice implementations get it wrong. you're not supposed to run one service per machine or even process that leads to orchestration hell and fragmentation cost at the loss of redundancy the way you get all benefits of a microservice architecture is if you run all services on all machines by vm sandboxing them all on many distributed machines f.ex. like this does this requires your entire solution to be async.toasync. endtoend though. but performance scalability and strength is unmatched it becomes antifragile!;0
25504891;HackerNews;2020-12-22;i have been working in couple organizations where i have thoroughly explained why we should undo the microservices approach and go back to monolythic application.basically the problem is that in most cases going to microservices is being pushed by management to complete exclusion of understanding whether the organization is ready to implement it.microservices require that you have mature approach to many topics. you need to really have nailed down automated deployments and you really need to have nailed down automatically creating development infrastructure.in one company i had a tool where i could log in give a new project name click couple parameters like namespace and a completely new microservice would be generated with bitbucket jira automated deployments confluence space etc.if you need to spend time to configure anything individually for a project to do deployments etc. you are not yet ready to do microservices.so in all those cases where we have scaled back on microservices the developers switched from developing the application to being full time engaged with managing the application and its numerous configurations.in one of the applications we had 140 services rolled back to one. before preparing the deployment would take 2 weeks as the developers would be sending and compiling emails with information what needed to be done where. then the deployment would take one day as an engineer would be executing all those runbook instructions. each of the 140 services had its own version which made ensuring correct versions a separate problem.after the change where we have rolled it all into a single service under a single version the entire thing took 2h. still manually but way cheaper and more reliably.;0
25504861;HackerNews;2020-12-22;prolific design patterns services could use different architectural patternsvery true.but there is still a lot of architecture that crosses microservice boundaries how the domain is split the dependency hierarchy or lack thereof between services data lifecycles ...it's important not to forget that.;0
25504842;HackerNews;2020-12-22;yea.once you have good domain boundaries you can use microservices to make the split more visible for less thoughtful devs and use the associated tooling contract testing ... to reduce operational coupling around deployments and tests.but aside from that anything you can do with microservices you can also do in monoliths.;0
25504789;HackerNews;2020-12-22;changing a system architecture twice like this specially to go back to what it was before is a large cost to a company. in this line of thinking they may have to move back to a microservice if they had a bigger team for the exact same application! this is fine by me but rather than what other benefits they enjoyed by migrating the second time a clear analysis of motivations behind moving to microservice and then back to monolith without compromising the benefits attained by doing the first migration would be a lot more enlightening. because i don't imagine the first migration to microservices happened just because they had too big a team. i suppose this thread will naturally attract people who hate microservices in principle.logicbecause of microservices we had bugs okay what kind of bugs?. therefore we moved back to a monolith again why did they use a microservice architecture in the first place. then the bugs disappeared how? and we got a whole bunch of other benefits as a bonus any trade offs?.cool so the initial migration to microservices must have been done by complete idiots then. it seems that even to question that is too much here.;0
25504710;HackerNews;2020-12-22;yeah. one thing i've noticed is that people are really bad at working towards highlevel nebulous goals like code quality right abstractions decoupling cohesion. keeping these goals in mind requires constant thought analysis and decision making as each case is different and there's no universal solution.so people jump at simple singlefaceted goals like normalise the database spin out microservices don't use html tables rewrite using rust etc. these involve no further thought no continuous evaluation of nebulous targets like quality no keeping up with moving goals.it explains quite a lot of problems with politics too. choose from red or blue. no further thinking required. if even that's too difficult just pick the one your parentsfriends picked. easy!;0
25504552;HackerNews;2020-12-22;it would appear to make sense to separate two things a service as isolated business logic with clean requirements process ownership slas interfaces testing and build infra for maintenance a service as an endpoint you can access from most any environment other services in whatever language web appsthe trick is to keep these two things apart and assign services to physicalvirtual nodespodswhatever as late as possible rather than making deployment decisions through choosing implementation techniques. eg it's not reasonable to expect scalability by deploying individual services to a large number of nodes with excessive granularity of services having the option to deploy a called service on the same host as the calling service to have essentially no network overhead might make more sense. it's also not reasonable to attempt to scale out services to a large number of nodes when your bottleneck is an rdbms or other storage.this was already very clear with 2nd gen soa architectures like sca service component architecture around 2007 or so with options for binding implementations to remote protocols soap or locally via procedure calls or both at the same time. this separation is notably absent from microservice architectures which always want to produce a pod or vm image as result artifact.now soap and sca and other soa frameworks also allowed transactions and auth context propagation something that isn't even on the radar of microservicelike approaches. the many ones i saw at customers at least only naively implemented the happy path not allowing for twophase commit or at least compensation services to be called on abort by an aggregating service.;0
25504527;HackerNews;2020-12-22;it's not about microservices or not it's about domain boundaries application architecture coupling. whether it runs in a service or in a monolith isn't the deciding factor of wether its good or bad.architecture and design is. a 100 services app with 5000 lines of code each could be really badly designed and entangled and a monolith with 500.0000 lines of code could be very well designed...it's about code quality right abstractions decoupling cohesion. correct domain modelling etc.microservices are just a tool but you have to have a good design first.;0
25504515;HackerNews;2020-12-22;i think the biggest difference is as defined by martin fowler when building communication structures between different processes we've seen many products and approaches that stress putting significant smarts into the communication mechanism itself. a good example of this is the enterprise service bus esb where esb products often include sophisticated facilities for message routing choreography transformation and applying business rules.the microservice community favours an alternative approach smart endpoints and dumb pipes. applications built from microservices aim to be as decoupled and as cohesive as possible they own their own domain logic and act more as filters in the classical unix sense receiving a request applying logic as appropriate and producing a response. these are choreographed using simple restish protocols rather than complex protocols such as wschoreography or bpel or orchestration by a central tool.;0
25504455;HackerNews;2020-12-22;microservices are indepently deployable modules. thus the same principles of modular design in a monolith apply. so yes you're correct with the network part.;0
25504214;HackerNews;2020-12-22;i still fail to see the point of your approach.it sounds like you're referring to bluegreen deployments without using it's name for some reason and while failing to present any case of why a monolith provides an advantage. you're just showing downsides without any upside as a tradeoff.i mean with microservices you can also do bluegreen deployments and they are not allin like monoliths. each deployment only covers a subset of features that can gradually be rolled in and out with the only risk of causing partial failures.;0
25504197;HackerNews;2020-12-22;in your opinion what is the difference between an soa and microservice architecture? when does a microservice become just an soa service or vice versa?;0
25503800;HackerNews;2020-12-22;i have worked at several companies with soa. in fact i was lead at one of the companies where we were breaking monolith to smaller services. we were having lots of issues with scalability with monolith. first we tried breaking to scale it horizontally by creating shards and routing users to different shards. that helped but with the growth we were seeing we were back to scaling issue in 14 months. we broke it further into 4 shards and started working on soa. after year and half we had dozens of smaller services and scaling was really smaller problem as it boiled down to scaling specific service. over all few points to add for without regards to soa that i didnt see here in threads smaller blast radius every change is small and specific to service so easy to rollback and understand the impact load tests capacity management was relatively easy small services with small dependencies easier to update dependencies java version updates was not huge project with every feature development on hold autonomy team had more autonomy as it didnt require committee approvals prolific design patterns services could use different architectural patternsthis obviously came with lot of other issues latencies cross service atomocity logs correlation. but at the end i believe pros outweigh the cons and i would continue to use soa pattern wherever i could.industry has been trending towards microserviceslambdas which in my opinion take it too far. finding that balance between monolith and micro service is what works in my opinion.;0
25503509;HackerNews;2020-12-22;they're the cure and the disease.without a way to keep the system heterogeneous people have to accept that they are on the same upgrade treadmill as the rest of the people in the organization which means they have to constantly invest time and energy into keeping up with things.containers or microservices mean that the upgrade happens fifteen times not once and each group has their own little passion play about why they should do it later instead of now. and in the time it takes to argue about 15 upgrades 2 more versions have come out.;0
25502236;HackerNews;2020-12-22;microservices are a technical tool for solving business problem business problem people and organizational problem;0
25502168;HackerNews;2020-12-22;not only were the various teams all competing for the same deployment resources it meant that every time an incident was declared several teams' code had to get rolledback and no team could deploy while an incident was being managed.so how exactly did switching back to monolith solved the above problems? seems to me like your actual problem is in qa and managing releases than application architecture whether it's towards or away from microservices. what i'm hearing is that you decided to fallback on relying on people to not push broken code out to production. which is fine and all but what are you going to do if your team grows again? rearchitect the system into microservices? a little heavy handed don't you think? in your particular case i think be it monolith or microservice architecture you need to work more on improving qa and streamlining releases. these once automated don't depend much on the number of developers. i've experienced this with a team of 3 as well as a team of about 15 not 30 though. i don't think that the application architecture has anything to do with your problems one way or the other.having said that if the late night calls stopped after this exercise then that's fine because no one should have to go through that!;0
25501201;HackerNews;2020-12-22;there is an alternate view of what microservices should be. check out the sample chapter for monolith to microservice by sam newman. as described in this article microservices seem like just a way to horizontally scale development and deployed implementations. nothing like independently deployable network functions corresponding to business needs.;0
25501077;HackerNews;2020-12-22;microservices taught me how to correctly apply ddd in a monolith.that's probably the most useful thing i picked up on the last year's.;0
25501013;HackerNews;2020-12-22;it's insane to me that for a few years so many organizations were somehow convinced that monstrosities like trying to do distributed transactions using things like 2 phase commit just to make the almighty microservices god happy was an acceptable way of doing things.the first law of microservice architecture should have been do the microservice boundaries you have defined result in the need for cross service transactions? if so slam on those breaks hard.;0
25500932;HackerNews;2020-12-22;i'd love some additional examples of technical problems microservices solve that are unrelated to scaling the organization.i've mainly come across the occasional oneoff where a different language is significantly better suited to the problem at hand so that has been broken out as its own service and there's another one here in the comments about migrating a python application between versions i could argue the semantics of microservice here but i'll roll with it but i have not come across many where a microservice was the right solution to a purely technical problem.;0
25500749;HackerNews;2020-12-22;this is exactly what always made me very skeptical about microservices as i said no actual experience so i might just change my mind if i start using them for any nontrivial problem reasoning about your data in a integrated and coherent way seems pretty daunting.;0
25500694;HackerNews;2020-12-21;seems like microservices has moved past the peak of inflated expectations and into the trough of disillusionment phase of the hype lifecycle.the only change i've been witnessing with regards to microservices is where their critics place their personal goalpost.microservices is a buzzword that is used as synonym for distributed systems and the evolution of serviceoriented architectures after removing the constraints of rigid interfacerelated xmlbased technologies like uddi and wisdl in favour of adhoc interfaces. some responsibilities are moved to dedicated services when the operations side justifies it and services are developed based on key design principles to reflect lessons that have been learned throughout the past couple of decades.but even if the hype associated with a buzzword comes and goes the concepts and its uses are still the same.;0
25500669;HackerNews;2020-12-21;microservices tend to provide good isolation barriers in systems and those tend to increase stability of highly complex systems.though erlang is a counterexample.;0
25500539;HackerNews;2020-12-21;this article isn't about microservices. it's about a monolith that microservices were built on top of then that code pulled back into the monolith.if you built serviced with its own data built translation layers to handle deltas you could move away from the monolith over time and have discreet services for your domain and subdomains.;0
25500533;HackerNews;2020-12-21;i would say 99 of all articles on this site and rprogramming on reddit have someone say exactly what you have that microservices are an organizational tool. at this point your view is not an unpopular one.microservices have been from the start an organizational tool with reliability and the ability to scale horizontally to avoid constraints of vertical scaling trailing at second place.the rationale is that the first bottleneck that is hit by a growing organization is developer's throughput i.e. the ability to deploy bugfixes and features without hitting blockers due to multiple teams being affected by a changeset. after that point a service has to grow a tad more until reaching a point where the requests bounded to a subset of features justifies peeling them out to independent services.;0
25500465;HackerNews;2020-12-21;i think you missed part of this from the article emphasis mine microservices solve iiibothltiii technical and people problems;0
25500177;HackerNews;2020-12-21;seconded.in a job we were mostly serverlessmicroservices but tested and deployed as a monolith. we got many benefits from the monolith simplified management testing code wrangling and some benefits of microservices theoretically independent functions scalingcosting down to zero.;0
25500128;HackerNews;2020-12-21;yeah but is that microservices? this is what we did the first place i worked 15 years ago.;0
25500063;HackerNews;2020-12-21;here is a post by martin fowler james lewis in 2014 pointing out the same thing 0. a lot of the thoughts expressed there i think are still relevant but i guess we had to wait for this hype cycle to play out?0;0
25500052;HackerNews;2020-12-21;...microservices are a technical tool for solving a people and organizational problemthey're also available to solve technical problems. for instance it's hard to run some python3.5 and some python3.9 in a python monolith. a monolith must choose one python version and cut over en masse at some point. microservices allow more gradual adoption in production not just in test suites! of low level technology changes.;0
25499740;HackerNews;2020-12-21;i don't really see what this article nails. so if i understand the argument correctly. microservices were used to increase development speed. while old pieces were left behind legacy new systems have come up to modernize these are still microservices? his team now responsible for many legacy unloved old microservices are being merged back into a monolith. the real question is is remerging all the code back into 1 application the right solution for their problems they had with stability.i think mental models are important and having a huge blob of unrelated roles makes sense to the current development team. but won't just like the old situation to the new developers.perhaps it's just the clickbait article but a better title would have been. homogenizing our wildwest legacy microservices.for me personally microservices was a god send working on getting stuff done instead of dealing with ancient code that doesn't reflect the current business anymore.i still buy in the thought of if you can't develop a great monolith you sure won't be great at building microservices. modularmonolith is the cool thing currently. create a monolith without the shortcuts that create problems in the long run. public interfaces are your most valuable pieces in the system. worship them codereview them fight about them. currently i could care less about the implementation itself. does it solve our problems is it fast enough is it tested great ship it. what language you used architecture. database i don't care. just make sure it's a joy to use from the outside.if more developers would spend longer on thinking about the problems and less with throwing large amount of code that makes them feel smart. making a microservice doesn't fix that problem.think that what is missing is the stability that microservice are able to give in its most optimal form. each service being the main source the second it leaves the system it is stale reference data. is stability important? use the old reference data how fresh does your data really needs to be.;0
25499436;HackerNews;2020-12-21;one thing i always try and vouch for is that you do need to go allin on microservicesdid you mean don't need? i agree with the rest of your post but this first sentence confuses me;0
25499397;HackerNews;2020-12-21;this is a great article one thing i always try and vouch for is that you don't need to go allin on microservices. there is nothing wrong with having a main monolithic application with a few parts separated out into microservices that are necessary for performance or team management.the author hits the nail on the head at the end;0
25499390;HackerNews;2020-12-21;monolith or microservices and monorepo vs polyrepo are best treated as two entirely separate engineering questions. you can have a monolith built from code in many repos or many microservices maintained in one big repo.there are various proscons for whichever combination you choose there's no best answer that applies to every single situation.;0
25499239;HackerNews;2020-12-21;a real issue with microservices is that you can no longer use the database system for transactional integrity. microservices are fine for things you never have to back out. but if something can go wrong that requires a clean cancel of an entire transaction now you need all the logic for that in the microservice calls. which is very hard to get right for the cases where either side fails.today's interaction with phone support convincing smart and final that when their thirdparty delivery company had their systems go down they didn't actually deliver the order even though they generated a receipt for it.;0
25499115;HackerNews;2020-12-21;future thinking is future trashing.though i've had mixed feelings about this e in the case of the author this is probably valid. yes microservices are not a bad idea. they are in fact a great idea and they are needed sometimes. but there is a time and place for everything. they are unnecessary and completely counterproductive and cumbersome unless you have a very large and complex system which needs to be distributed. if that is the case of course god speed. but if you can work without them you should not go for a microservice architecture let's face it they are hard to design develop and in many cases a nightmare to debug when something goes wrong. annoyingly the term microservice is yet another pr campaign gone horribly wrong. as a consequence it has become a buzzword like blockchain ai agile etc. just because faang is doing it does not mean that your online shop for selling socks needs microservices in any shape or form.a short while ago a friend dragged me in as a side consultant for one of his clients. he owned a site which is basically craigslist for musical instruments and he was in the process of hiring a company to rebuild and subsequently modernize his site. realistically the site has around 5k usersday tops and no more than a gb of traffc and a mysql database which over the course of 15 years is less than 50gb. basically a tiny site. the company he was about to hire had designed an architecture which involved a large eks cluster 15 microservices mysql postgeres elastic memcache and redis complicated grpc communication and their claims were that this architecture would make it the best in the business. ok let's give them the benefit of a doubt i advised him to ask them how much more performance would he gain out of that and if there are any other advantage over the typical vps with a webserver. their response was infinitely more performant you'll be able to scale to 100 million users per day and the system wouldn't feel a thing. that is what google facebook and all other large companies are doing. yeah... and does he expect to have 100 million users pour in at any point in time? take a wild guess... mind you they asked for the same amount of money for a simple buy now website.;0
25498841;HackerNews;2020-12-21;the author correctly identifies the problem as part technical part people. my shotinthedark estimation is probably 70 of teams doing microservices do it to solve the people problem before if ever they need it to solve the technical problem.technical solutions are usually bad solutions for people problems and architectural patterns are probably even worse solutions at solving the problem of human collaboration. it doesn't help that microservices are mostly a bettersounding name for soa but smaller that has grown in prominence mostly to sell you hosting for your very many microservices. microservices takes one of the hardest and most important parts of of soa service boundaries and replaces it with...smaller.glad to see someone at a larger company publishing about this.;0
25498839;HackerNews;2020-12-21;oh the amount of time our industry wastes behind technology for the sake of technology! first let's write tons of articles extolling the virtues of microservices. then let's counter that with tons extolling the virtues of using microservices the right way. hype followed by wisdom and then go back to hype again! when are we going to mature! boring is good and predictable.;0
25498808;HackerNews;2020-12-21;monolithic software maintained in a single computerrepository is so much better than software spread across many computers and repositories. there are some firstorder arguments against a monolithic codebase but the higherorder points will win out every time. i.e. the reason you want a separate codebase for each concern is probably because no one figured out how to work together as a team toward a common objective. this lack of teamwork will ultimately kill your project if you do not resolve it so whether or not you do microservices in the expected way i.e. http rpc will make no difference either way.if you still want micro services because it actually makes technological sense you can build these at a lower level of abstraction under some services folder. many languages have namespaces which allow for boundless organizational schemes. only for a lack of imagination would you fail to organize even the most complex of applications in this manner.;0
25498672;HackerNews;2020-12-21;i would say 99 of all articles on this site and rprogramming on reddit have someone say exactly what you have that microservices are an organizational tool. at this point your view is not an unpopular one.however microservices can also serve actual technical purposes too. but the nuances of accepting two viewpoints often placed in juxtaposition to one another is not internet friendly. microservices service oriented architecture whatever you call it depends on your level of cynicism i suppose or optimism?.;0
25498664;HackerNews;2020-12-21;seems like microservices has moved past the peak of inflated expectations and into the trough of disillusionment phase of the hype lifecycle.thank god. i'm tired of semitechnical product managers throwing around the term.;0
25498500;HackerNews;2020-12-21;from what i understand never actually worked with ms so no handson experience a proper ms architecture will also include separate data persistence layers for each service.i.e. if your service manages persisted data it will access and own a dedicated storage instance which no other service has access to.assuming it is really true folding a microservice back into a monolith should also mean that the data are ported back into the main db? the article does not seem to spend much time discussing this though. so maybe it is one of those ideas that everyone conveniently decides to ignore when they actually start dealing with a real world problem?;0
25498429;HackerNews;2020-12-21;this article absolutely nails it. finally recognition that microservices are a technical tool for solving a people and organizational problem. we need to understand that a lot of new technology paradigms especially those coming down from faang or other large organizations are often designed to solve the organizational problems of operating at scale not to provide some kind of technical panacea we should all aspire to built towards.;0
25498375;HackerNews;2020-12-21;glad to see a reality check post around the hype of microservices.;0
