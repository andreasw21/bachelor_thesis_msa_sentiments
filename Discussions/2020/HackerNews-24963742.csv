ID;Source;Creation Date;Content;Sentiment
24963742;HackerNews;2020-11-02;Title:Microservices – architecture nihilism in minimalism's clothes, Content: https://vlfig.me/posts/microservices;0

24991308;HackerNews;2020-11-04;and yet i will contradict myself to say that actually microservices have the potential to be that original vision of objectoriented programming from the 1960s. the fundamental idea is very cheap computational nodes that only interact by passing messages around with the idea that a recursive design inspired by cells and biology will be much more successful than traditional programming where you try to separate data structures from the procedures that operate on them. if your microservice has setters and getters you're missing the point of this original vision of oop. you could certainly build a system with 40000 of these live but probably you would not have 40000 different chunks of source code behind them.lovely description of the actor model in erlangelixir and akka;0
24991248;HackerNews;2020-11-04;i logged into just to say this is spot on.the complexity added by all the services for deploy bug tracing and dear god security auditing made for a living hellscape that crippled our ability to ship software for some time. not to mention the bifurcation of resources to keep the monolith happening for customers using it while the microservice mess is being created.there is almost a zealotlikebrainwashing that has happened to folks. i made case after case to our engineering team this doesn't solve our business use cases. we're prematurely scaling. we're unable to move code into production efficiently. this is very hard to understand for outsiders joining our team. all fell on deaf ears since i didn't get it. when i put a hard stop on adding any more microservices without a use scale for why we need that scale i was called toxic.in the end we fired the whole team since they wouldn't buy into destroying their microservice dream world for something practical and put everything back in the monolith except for one service.our amazon bill is 18th what it was. security auditingupkeep is 1100th what it once was. deploys are done without fanfare more than 1xweek. our average response time is down from 500ms to less than 100ms since we aren't hopscotching services all over god's green earth.note this isn't a tiny project. 200k users 7001000 requestsminute during peak times lots of data moving through this.;0
24986134;HackerNews;2020-11-04;this is the most correct answer here. your products will mirror your organizational structure. see building microservices designing finegrained systems by sam newman chapter 10;0
24985670;HackerNews;2020-11-04;well you began by saying that monoliths are universally bad in every imaginable way. you're now saying that a select few poorlymaintained 25year old monoliths are bad which is an entirely different claim. that doesn't really prove that microservices are any better are 25year old poorly maintained clusters of services really going to be an improvement?. let alone better in every imaginable way.;0
24984835;HackerNews;2020-11-03;fully agree. another point worth considering is costs. cloud providers now let you use ephemeral vms which are amazing in terms of value. if you can identify some parts of your system that use too much in terms of resources you can get quite some nice costs savings by wrapping that around a microservice and deploy it in said cheap vms.;0
24984535;HackerNews;2020-11-03;input doesnt have to be malicious to cause problems just unexpected. separating memoryunsafe code into the finest granularity memory spaces possible is just good practice regardless of whether its microservices or just process isolation in a monolith.;0
24982337;HackerNews;2020-11-03;we have user profiles user id the users names email etc in one microservice relationships between users user id other user ids in another. each has its own datastorehow do you maintain referential integrity between datastores?for example when a user is deleted how do you update the relationships between users in a concurrencysafe way?;0
24981430;HackerNews;2020-11-03;my take1. i have this application but i need to process batch jobs run heavy workflows do ml etc... definitely split into multiple services.2. i have this application but this one feature i want to add is implemented really well as a libraryapp that's not easy to integrate same spirit as 1 also a good candidate for soa3. i have an application for end users and various internal tools that differ in their qualitysecurityprivacy requirements probably a good reason to build those separately but not a necessity4. i have an application and it doesn't scale well with my growth this is one of the most common reason behind implementing microservice architecture but i think it requires a lot more thought than just 'yup let's obviously do horizontally scalable microservices'5' our monolith is slow to compile run and test careful with this one it's probably easier in the majority of cases to fix your tests builds and runtime speeds than start splitting up your probably already very complex application into services6. our org is split into multiple functional groups and we want to move independently not a good reason for soamicroservices you're increasing eng complexity and reducing org collaboration and risking a lot of work overlap.7. microservices have been successful in big company not a good reason. the benefitstradeoffs are usually fairly unique to each organization and require careful inward thinking instead of following trends8. one microservice per business function is a good pattern and we're going to mandate it terrible idea. topdown eng culture mandates prevent better solutions from even being considered. don't do this at your company.;0
24979801;HackerNews;2020-11-03;i refer to these as reasonable sized services. i feel like a lot of people that do microservices spent to much time in crud systems and havent done a lot of domain driven design.;0
24979757;HackerNews;2020-11-03;that makes sense but is nowhere near universally applicable. for folks working in most startups talking about different lines of business is nonsensical there's generally one product.it sounds like you're describing a monolith that actually contained multiple completely independent applications which i don't think anyone would disagree with being a good case for splitting.in most cases i've seen the decision to split into microservices usually involves a fairly high amount of dependency between different services to achieve a common business goal hence the concerns about things like referential integrity;0
24979200;HackerNews;2020-11-03;the requirement of transactional consistency is one of the ways you identify a bounded domain in ddd. well aggregates at least.if you require transaction consistency across multiple microservices. they are to small.if you don't require transactional consistency across microservices that's ok. therefor they can be in separate databases anyway and messaging can be used.;0
24979189;HackerNews;2020-11-03;that seems like a conveniently contrived example.why in this example would ionlyi 1 instance of the monolith go down but all instances of the crucial microservice go down?;0
24978933;HackerNews;2020-11-03;naïve microservices are separated per data storedb. because dbs are usually the bottleneck and we want to scale them separately per usage. looks like they combined some to make it possible to manage while not utilizing resources to the max.;0
24978894;HackerNews;2020-11-03;if i go the microservices route i usually implement a serviceclient library for any services i expect to be called internally often. this way service a which needs to communicate with service b can just pull serviceclientb into the project and call its methods. most verificationerrorhandlingtransport is abstracted away in the serviceclient library. this library usually also includes modeldto classes.this approach only works well if most of your services are using the same language and sometimes framework.;0
24978803;HackerNews;2020-11-03;hard agree. as an sre half the time my current company splits something off into its own service its for performance reasons driven by us. its just as often us working with the devs because we need x service off the primary database or y service the ability to scale on its own as it is them having created a separate service of their own accord. plus as an sre its a lot easier to wrap my head around what each service does on its own and what responsibilities are broken when its down than it is to understand the full workings of a monolith and building monitoring around the smaller chunks is easier.obviously its possible to overdo it. generally it seems that splitting out services as appropriate is more intelligent than just sitting down with the thought were going to build a microservice architecture. goes back to the idea that gets banded around a lot that you should start with something as simple as possible and if you get in a situation where you are at the scale to need to rewrite then thats a good sign for your business.;0
24978757;HackerNews;2020-11-03;i'd like to challenge the i can't imagine a better way of separating bit. i agree that microservices if done right are awesome.recently however i had the chance to work with a quite extensive codebase that powers a monolith for a fintech company. the code is written in scala and extensively uses akkastreams to neatly separate concerns. in my opinion this approach is the the sweet spot as 1 devops burden is low as you only have one binary to run deploy 2 shapes of the various akkastreams subgraphs are statically typed checked unless you optout by doing stupid things 3 makes it much easier to reason about the data flow and 4 testability is really high as you don't have to mock services but only the upstream subgraphs.the downsides are that 1 the learning curve is very steep at the beginning as akka in general is very complex to use effectively and 2 squeezing the maximum performance can be hard as you don't have the ability to horizontally scale only some microservices.i fell in love with the approach and i'm migrating some personal projects to it.;0
24978588;HackerNews;2020-11-03;honest questionis there a typesafe way of communicating across microservices without duplicating verification logic writing extra layers for the protocol overhead and conceding to more cognitive load during programming?;0
24978440;HackerNews;2020-11-03;sure you can do transactions across services. do you really want to deal with the problem of distributed consensus though? if software especially ibuilti to deal with it often gets it wrong as i think jepsen tests have frequently demonstrated what are the chances your team is going to succeed and not build a distributed monolith instead?i suppose in the end it depends on if you want to trade the hard problem of managing a monolith for possibly a much harder problem.i find that for these discussions the definition of a microservice is too nebulous. personally i think that if you have state that crosses service boundaries ie. a fault in either service causes the loss of that aggregate state you have instead built a distributed monolith.;0
24978311;HackerNews;2020-11-03;sometimes a monolith is the way to go and sometimes microservices are the way to go it really all depends on a number of factors.;0
24977869;HackerNews;2020-11-03;i find it bizarre how many arguments on the topic are just of the type microservices are the cure microservices are cancer no reflection on specific domains and context.it's very much like the case with unit tests.what is a unit? how small is micro? these two questions on their own are subject of debates of religious proportions.;0
24977834;HackerNews;2020-11-03;you could certainly build a system with 40000 of these live but probably you would not have 40000 different chunks of source code behind them.we're replacing an old system that has lived on a mainframe for the past 60 years. in a strict microservice scenario we would indeed need 40000 microservices to replace our core business.the thing about our mainframe integration is that it is essentially made up of microservices only they're small chunks of cobol being called like pearls on a string each producing output for the next in the chain.;0
24977802;HackerNews;2020-11-03;i agree wholeheartily that conway's law is a very useful guiding principle for making architectural decisions.i also think this applies much more broadly than just microservices vs monoliths. i recently moved 40 repositories into just a few. what i've found is that anything that releases together by teams and timeframe should stay together. this helps ease modification of related components in an agile way simplify tagging components simplifies ci workflow no multiproject pipelines.anything that breaks with this principle should have a concrete reason for it. if you need to combine the results of several teams into one large release it may be easier to develop tooling for handling it all in one repository rather than developing tooling for handling many repositories. that's really the monorepo tradeoff.similarily there are concrete reasons for breaking a service into smaller parts. perhaps you want to horizontally scale a part of the service. perhaps you need a part of the service to have a different lifecycle. but you're paying with increased deployment complexity so you'd better get something worthwhile in return.;0
24977667;HackerNews;2020-11-03;there is nothing inherently bad about storing unrelated things in the same db in general.there might be security issues but good dbs offer security grants that are granular enough to deal with this.data sovereignty might be an issue forcing you to split that depends on the domain and application requirements.but in general two things being unrelated isnt a reason to split the db and splitting the db isnt a reason to split into services.im not for or against microservices. im definitely for good reasoning though!;0
24977526;HackerNews;2020-11-03;but doesnt go as granular as perfunction servicesnobody anywhere says microservices has to be singlefunctionsized services.;0
24977444;HackerNews;2020-11-03;that is more or less the approach that i would recommend to modern microservices i would advise someone to read about domaindriven design and i would ask them to pay very careful attention to the notion of bounded contexts the idea of a namespace for business level words. if you build your microservices partitioned at bounded context level and you vehemently resist the idea of a remote procedure callunder no circumstances are you giving me orders you are maybe telling me about a state change that has happened to you but don't you dare tell me what to do and when those two principles can guide a decent architecture. have a message broker. do event storming with nontechnical users of the system to get a better model of the domain. stuff like that.and yet i will contradict myself to say that actually microservices have the potential to be that original vision of objectoriented programming from the 1960s. the fundamental idea is very cheap computational nodes that only interact by passing messages around with the idea that a recursive design inspired by cells and biology will be much more successful than traditional programming where you try to separate data structures from the procedures that operate on them. if your microservice has setters and getters you're missing the point of this original vision of oop. you could certainly build a system with 40000 of these live but probably you would not have 40000 different chunks of source code behind them.;0
24977392;HackerNews;2020-11-03;i've been through a couple of iterations of monolith bad! where none of the issues were monolith related but instead database design and usage. also an iteration of microservices good! where there are more microservices than entire company employees not just devs and yeah it's a bad idea at this scale.;0
24977377;HackerNews;2020-11-03;we looked very hard at microservices some 56 years ago and estimated we'd need 40000 of them to replace our monoliths and given a scale like that who'd keep track of what does what ?instead we opted for macroservices. it's still services they're still a lot smaller units than our monoliths but they focus on business level units of work.;0
24977353;HackerNews;2020-11-03;from your following comments i see that you consider a monolith a software that does everything from managing staff holidays to giving services to customers. but this isn't what monolithic architecture vs microservices is about if you have independent business processes it's been completely normal forever to have independent monoliths to manage them.many proponents of microservices though request that you split your software into small independent services even when they manage the same business process and this is where the complications come.;0
24977299;HackerNews;2020-11-03;that would be microservices. like you said theres rarely a need to break apart services beyond that and thats fine.;0
24977268;HackerNews;2020-11-03;in case of rewriting the codebase it actually makes sense. your organisation already has a codebase and complementary org structure. any microservices rewrite should be tailored to the existing boundaries of teams for maximum effectiveness.;0
24977173;HackerNews;2020-11-03;it seems like those who have success with microservice and advocate their use often have a much lower number of service than those critical of microservice architecture.one customer i work with managed to create 10 container based services in order to do a database lookup render a notification template and send the notification to one of three notification services. because its java based theres now also a pretty large menory overhead as each service needs its own memory allocation for the jvm. on the plus side they have became very aware the this is too many micro service and are refactoring and combining a few of the service.;0
24977029;HackerNews;2020-11-03;the things that don't depend on it don't go down. eg. your email system doesn't go down because the building's elevator had a bug.it also let's you choose which parts to pay closer attention to the microservices that's depended on by everything gets the extra operations;0
24976936;HackerNews;2020-11-03;microservices are popular because managing large teams is a pain in the ass and creating a small team to spin off some new business case is really easy to manage. you get budget you create the new team if it sucks reorganize or fire the team and offload the services to other teams.i'm telling you it's all conway's law. we literally just don't want to think about the design in a complex way so we make tiny little apps and then handwave the complexity away. i've watched software architects get red in the face when you ask them how they're managing dependencies and testing for 100s of interdependent services changing all the time because they literally don't want to stop and figure it out. microservices are just a giant copout so somebody can push some shit into production without thinking of the 80 maintenance cost.;0
24976895;HackerNews;2020-11-03;how is a blast radius limited in the case where a bunch of things depend on that microservice? it seems a microservice can have an arbitrarily large blast radius.;0
24976784;HackerNews;2020-11-03;in my experience it's easy enough to have services which have a large blast radius themselves and can become points of failure for your entire ecosystem. i don't find this to be a huge point of difference from a monolith although of course it depends a lot on what you're working on.it's a huge different because if some core critical service starts causing problems it's almost certainly because the last binary push was bad and you roll it back. you only have to roll back that particular service any everything starts behaving correctly again. moreover you probably detected the problem in the first place when the rollout of that service began by replacing a single instance of the updated service with the new binary. monitoring picks up a spike in errorslatencydatabaseloadwhatever and the push is stopped and rolled back.monoliths have inventive ways to address this problem without having to roll the entire binary back like pushing patches or using feature flags but few would argue that the microservice approach to handling bad pushes isn't superior. to me that sounds like poorly written software regardless of architecture. i can't imagine a scenario in any of the recent codebases i've worked on microservices and monoliths both where errors in what sounds like an internal crud tool would cause an entire production application to crash. i find it even harder to imagine if the application has a halfway decent test suite.easy enough with a sufficiently large codebase in c or c. somebody's parser encounters an input that was isupposedi to never happen and now it's off clobbering the memory of whoknowswhat with garbage.;0
24976722;HackerNews;2020-11-03;if i may join in this game of hubris i have discovered a pattern as well.report 1 milk is amazing for you. report 2 we were wrong milk is terrible for you report 3 milk may have some benefits report n whew milk is good within boundsrepeat for chocolate microservices meditation religion wine nuclear power;0
24976686;HackerNews;2020-11-03;of course microservices should be sliced with referential integrity in mind. but a monolith by definition has ieverythingi including utterly unrelated things that have absolutely nothing to do with each other bundled up into a single giant well monolith. what referential integrity could there possibly be between eg business partner user profiles and internal staff vacation hours?;0
24976341;HackerNews;2020-11-03;this is a debate i will never understand.the position of the monolithics is you should have one thing. well that's obviously wrong if you're doing anything even slightly complex.the position of the microservice people is you should have more than one thing but it gets pretty fuzzy after that. it's so poorly defined it's not useful.how about have enough things such that all your codebases remain at a size where you don't dread digging into even the one that you're most prolifically incompetent coworker has gone to town on? enough things that when not very critical things fail it doesn't matter very much.but only that many things. if you need to update more than one thing when you want to add a simple feature if small to medium changes propagate across multiple codebases well ya done messed up.if you're one of the people believing monoliths are the way you're making a bizarre bet because there's n potential pieces you can have to create a complex system and you're saying the most optimal is n 1. what are the odds of that? sometimes maybe. but mostly n will be like 7 or something. occasionally 1000. occasionally 2. but usually 7. or something.this seems really obvious to me.;0
24976272;HackerNews;2020-11-03;if you're like facebook it makes sense to split user profiles and relationships to two microservices but if you handle a few tens of thousands of users it does not so you're doing yourself a disservice by using a poor example to drive the point;0
24976233;HackerNews;2020-11-03;agreed isolation is a good reason to opt for microservices. one app goes offline others still accessible and you can do isolated maintenance. that and features that aren't directly related are super lightweight quick to build run low on memory and cpu as little projects.;0
24976203;HackerNews;2020-11-03;in my experience it's easy enough to have services which have a large blast radius themselves and can become points of failure for your entire ecosystem. i don't find this to be a huge point of difference from a monolith although of course it depends a lot on what you're working on. to pick on the op a bit here sorry! they said that their entire legacy system could go down because of issues to do with completely unrelated non critical things like eg internal staff vacation hours. to me that sounds like poorly written software regardless of architecture. i can't imagine a scenario in any of the recent codebases i've worked on microservices and monoliths both where errors in what sounds like an internal crud tool would cause an entire production application to crash. i find it even harder to imagine if the application has a halfway decent test suite.to add to that when you have hundreds of services running around and something goes wrong it ends up being a lot harder to track down exactly what's happening. so when you idoi get that critical error oftentimes the downtime is worsened.as for dev velocity i find the claims of the microservice gospel a little bit exaggerated. your layers of nested services all talk to each other and any of them could be a point of failure. this isn't really all that different from calling another function in your monolithic app you've just distributed that function call across a network boundary. you still need to know the callee's api and you'll still spend a decent amount of time trying to understand the ways that the callee might fail. but you've also created a huge amount of iadditionali developer work whenever you need to do something that spans the boundaries of existing services.i think microservices certainly have their advantages but a lot of the simplistic claims made by their biggest proponents only hold up prima facie.;0
24976113;HackerNews;2020-11-03;honestly a confusing article to read. i think it's difficult to put into abstract words when microservices should be used without bringing up anecdotes of when it shouldn't have been or... that it's simple 'start with one split with reason' which is so simple it's hard to follow.i enjoyed reading it several times.;0
24976104;HackerNews;2020-11-03;i agree with your notions of what the problems are and what the goals ought to be.though i think microservices didn't actually make it hard to put coupling between parts of the system.it's the same old story of how everyone is doing agile wrong. the cargocult implementations fail to deliver on the promises because they don't actually follow the principles.microservices often means little more than not the monolith. it's a pretty low bar. the looselycoupled property is what is important. if that doesn't hold then you've almost certainly made things worse. if it holds then you've almost certainly created a path towards making things better.;0
24976063;HackerNews;2020-11-03;you start with a monolith.i think that is the hn syndrome people start projects like they will be larger than facebook even though the project will probably never launch and if it does get more than 10 users. yet it runs all services aws has to offer and has 100 microservices and the little companys investors are paying through the nose in both dev time and hosting while a raw php script on a 1mo vps wouldve been sufficient to validate the idea and get to ramen profitability and far beyond. like someone said in another thread focus on your market and acquisition channels first build great stuff much later.;0
24976013;HackerNews;2020-11-03;maybe i don't understand microservices but what is to stop a team from declaring the whole monolith to be just one microservice?i have interviewed at a few places over the last year and not one interviewer has given me a hundred percent guarantee that we will never have to allow access to the backing store database that isn't through our service.of course microservice will fail in such environments. that's not a microservice fault. that's a defect in management.;0
24975962;HackerNews;2020-11-03;if it were up to hackernews commenters no software created after 1998 would be used everything would run on a single monolith use postgresql run with system v and written in i don't know perl with cgi. it worked fine back then why do we need to change it and make it all fancy and complicated?i don't know the career histories of these kinds of people i'm sure its varied but i just can't imagine them working in very large public facing dynamic sites that update multiple times a day with monoliths thinking this sure can't be improved! we have reached the peak of computing!i've seen microservices go really badly of course i worked in a place where the devs insisted that two microservices need to go out at the same time as if such a concept existed because they depended on each other. at the end of me working there there were around 40 microservices all java so they needed at least 2gb of memory each some 8gb and at least 3 replicas for high availability. cost a small fortune in servers for what really could have been like 5 microservices written in go or node and run on a handful of normal servers.but microservices like kubernetes are not hype they are not a flash in the pan and they're here to stay because they are a good idea conceptually even if they often aren't executed very well.;0
24975951;HackerNews;2020-11-03;particularly imo for iinternali business apps microservices make it more likely that you can align products business owners and teams whereas monoliths force complicated governance as well as multiteam products. and in practice the development teams and business owners aren't aligned so you get a manytomany web of requirements and approvals communication.;0
24975924;HackerNews;2020-11-03;i couldnt have put this a better way. i was on the receiving end of the microservices chaos.;0
24975833;HackerNews;2020-11-03;monoliths can do transactionally consistent stuff.so can microservices both internal to the service via simple transactions and between services via distributed transactions e.g. 2pc though a good service design minimizes the need for the latter and is mostly guided by consistency boundaries as to where to draw service boundaries.it's true that there are naive microservices architectures pursued that are essentially normalized relational designs with a oneservicepertable rule but that's just badand usually cargocultdesign.;0
24975809;HackerNews;2020-11-03;i love my service based architecture. it's about 10 years old and i can't imagine a better way of separating concerns and keeping a clean maintainable and resilient ecommerce operation up and running. i don't have hundreds of services there are maybe 30. each service is responsible for a particular domain and if another service wants access to that domain it must go through the appropriate service. i can't imagine having a single process monolith being responsible for so many things it would be a nightmare. i also can't imagine not enforcing separation of concerns via services code would be duplicated everywhere. i was thinking the other day about the cost of serialization which isn't too bad. if it is too bad then you're probably sending too much data over the wire and should do more processing on the remote end of the wire. i think some people go overboard with the micro part of microservices. if there isn't a clear separation of domain then there should probably just be one service. you can still modularize the code as much as you want within the service.;0
24975800;HackerNews;2020-11-03;it doesn't matter if it's multiple services or one monolith once you have multiple teams on one product the complexity is already there. the argument is that microservices force it to be visible and dealt with while monoliths hide it until you blow your feet off.;0
24975785;HackerNews;2020-11-03;20 microservices have been released2 in our case.;0
24975755;HackerNews;2020-11-03;monothlics are not good or bad. it's just that monothlic architecture made it easy to add couplings between dependencies and this is the real problems of software engineering. loosecoupling is the goal.so to me microservices made it hard to put coupling between parts of system so it made system overall easier to maintain less tech debt.;0
24975734;HackerNews;2020-11-03;microservices can too just most databases don't support this without an additional service layer. fwiw spanner does.;0
24975692;HackerNews;2020-11-03;last august delaware rolled out the laws for new protected series llcs. after founding one main llc for 300 you can then created an unlimited number of llcs under it each with their own debts liabilities and obligations which cannot be enforced against another series or the original founding llc as a whole.if one series llc gets ensnared in a legal dispute the others can continue operating as usual.you can probably guess where i'm going with this. the idea is a tech company can use this new structure to put each microservice into its own llc and basically operate as its own company that communicates with others through a rich api and formal company communications.whats useful about this is you can use it to get around gdpr and other 21st century issues. microservice llcs could basically launder data among themselves buying and selling it and using creative hollywood style accounting. when a service gets sued for some privacy violation and threatened with a fine it could shut down and go out of business and be replaced by a new llc that rises mysteriously from no where. it then becomes increasingly expensive to pursue litigation. every time you get close to levying a fine or getting justice the target evaporates and is replaced by entirely new companies with a whole new corporate structure.;0
24975685;HackerNews;2020-11-03;real life microservices documentary;0
24975661;HackerNews;2020-11-03;in my opinion microservices are all the rage because they're an easily digestible way for doing rewrites. everyone hates their legacy monolith written in java .net ruby python or php and wants to rewrite it in whatever flavor of the month it is. they get buy in by saying it'll be an incremental rewrite using microservices.fast forward to six months or a year later the monolith is still around features are piling up 20 microservices have been released and no one has a flipping clue what does what what to work on or who to blame. the person who originally sold the microservice concept has left the company for greener pastures i architected and deployed microservices at my last job! and everyone else is floating their resumes under the crushing weight of staying the course.proceed with caution.;0
24975651;HackerNews;2020-11-03;i've seen both extremes. for instance i'm told github largely has a rails monolith and that they have to run headless instances of rails to do database leader election although this statement implies they are trying to break things out.i've also talked to junior engineers who want to make every function call a pubsub message.i've heard principals from amazon promote a model where one service is responsible for one entity.what i've decided is that the services in your company should follow conway's law. most of the problems with a monolith come when multiple teams with differing release cycles and requirements are making changes in a shared codebase and they are having trouble keeping their tree green. you should generally have one to a few services per team. scoping a service to a team ensures that people can have true ownership.for sres microservices are harder but they give sres the control plane they need to do a good job. if communication happens between services rather than function calls it's easier to instrument all services in a common way and build dashboards. it's simpler to spin up different instances connected to different datasources.;0
24975641;HackerNews;2020-11-03;our enterprise db was bursting at the seams containing literally everything. now every part of the split up monolith has it's own self contained data store tailored to what is appropriate for that particular thing. some use mariadb others redis etc etcwhy do you consider an enterprise db bursting at the seams to be a bad thing? isn't that what enterprise dbs are built for? seems like you traded having everything in one large database to having everything scattered in different databases. you probably sacrificed some referential integrity in the process. developing building testing and deploying took ages. eg if i only needed to capture some new detail about a business partner user eg their mfa preference app vs sms i would still have to do deal with the unwieldy monolith. now i can do it in the dedicated business partner user service which is much easier and faster.you traded a clean codebase with a solid toolchain for probably a template repository that you hope your users use or everyone is reinventing some kind of lintingtestingdeployment toolchain for every microservice the whole monolith including business partner facing operations could go down because of issues to do with completely unrelated non critical things like eg internal staff vacation hours.this could apply to any software. sure a monolith can have a large blast radius but i can guarantee one of your microservices is critical path and would cause the same outage if it goes offline. the few callers that do need to obtain both pieces of data just make concurrent calls to both and them zip them into a single result.almost like a database join?;0
24975587;HackerNews;2020-11-03;you nailed it so perfectly. the difference is encapsulation of dependencies and independent scalability of each service. that aside whether we have a monolith or microservices you cannot fix bad architecture.its like spreading out components with larger copper traces and separating them. if youre circuit is wrong no amount of things you can do on the pcb level will fix it. fix the schematic circuit first.;0
24975516;HackerNews;2020-11-03;a huge part of my career has been splitting monoliths into cohesive smaller codebases did that ... create business value for your company?not op but the big value of splitting into microservices is isolation.in production this isolation offers a limited blast radius in the case of an errant service. also independent scaling. business value improved reliability.in code isolation lets development teams have a smaller and more focused domain set of concerns to reason about vs. the entirety of the monolith. business value increased dev velocity.;0
24975513;HackerNews;2020-11-03;sounds like you have a simple system in which case the separation have few drawbacks. it's not uncommon for a customer to ask for a report that to be generated needs to span dozens of tables. or to save a dto object that will trigger multiple microservices and a lot of validations transactions rollback etc. business rules can be very complex and entangled in some shops.;0
24975512;HackerNews;2020-11-03;the issue for me at least is not the idea of microservices itself it is the granularity at which services get definedsplit off. what usually happens is that companies go allin on the microservices idea and force it upon all teams regardless of their sizehead count. it is far easier for a 10 person team to maintain a microservice than it is for a 3 person team. microservices impart some fixed costs to every team managing a service and thus make very little sense for small teams.on the other hand a 3 person team can much more productively contribute to a monolith. from my experience in the industry so far taking into account the current quality of tooling i would say it starts to make sense for teams above the 10 person mark to own their own service.;0
24975406;HackerNews;2020-11-03;a huge part of my career has been splitting monoliths into cohesive smaller codebasesdid that ... create business value for your company? eg currently we have user profiles user id the users names email etc in one microservice relationships between users user id other user ids in another.this sounds like a parody of microservices.;0
24975369;HackerNews;2020-11-03;i don't think that definition of microservice is useful and i think it promoting it will add to the confusion around the issue. you can comment on the similarities in the way modern microservices and watchdate are architected without calling the latter microservices.;0
24975319;HackerNews;2020-11-03;i have found that this applies all the way up to the loftiest levels of abstraction. for instance we partition our problem space in terms of logical business process once you get to a certain altitude in the architecture. but the most obvious way to represent these discrete process domains was with... objects. so yeah. it's objects all the way up. the only difference between good and bad code is how the developers handle namespacing drawing abstraction hierarchies and modeling business facts.microservices are about organization not about requests being sent on wires throughout some abomination of a cloud infrastructure. developing a userservice class and having the audacity to just directly inject it into your application for usage is probably one of the most rebellious things you could do in 2020. extra jail time if you also decide to use sqlite where appropriate.;0
24975290;HackerNews;2020-11-03;currently we have user profiles user id the users names email etc in one microservice relationships between users user id other user ids in another.what do you do when you need to query data across these boundaries?;0
24975270;HackerNews;2020-11-03;i like this way of thinking about services decoupling the project model from the deployment model is a good way of thinking about things.some random thoughts what build toolchains are suited to these arbitrary dag arrangements? bazel? perhaps i missed a reference in the article but i'd be interested in the author's take on this and of course any thoughts from the community here. the testing monolith is a pattern that i've used in a less wellnamed fashion and it's great for cases where lots of codeservices need to execute a business process that might span weeks or months building a test rig to mock time across an ensemble of microservices sounds like an interesting challenge mocking time inside a single process running the combined logic of all the services is much more palatable. this isn't really possible if you use multiple languages though so it only gets you so far. ddd bounded contexts as service boundary this is a good starting point especially if you take a loose definition of service. under the ddd definition of service you can actually have multiple deployables running for example a typical djangorails monolith will have a db sql and an async worker celerysidekiq via redisrmq and perhaps a cache redis so it's really a bunch of different deployables even if we refer to it as a monolith. likewise with smaller services. if you think of the service as being a constellation of processes with an external api then you can start splitting out parts into separate deployables without the outside world caring say to scale a particular workload independently of the rest of the service logic. this is kind of the direction that uber ended up moving in with their domain oriented architecture . this is actually how django monoliths already work you use the same codebase to specify your sync api workers and your async celery tasks and you'll deploy them as separate deployables from the same repo.;0
24975256;HackerNews;2020-11-03;overstated. makes the usual i hate blah blah essay mistake of confusing the way something is understood and implemented in the general dev community with what it actually iisi.most of the time things start off for good reason and represent good practices. we just butcher the hell out of them when we start selling them to one another. same thing happens in reverse once enough people destroy any goodness left in a buzzword people oversell how bad the idea is when they start pitching their plan to get rid of itto be clear i don't disagree with the premise that lots of microservices implementations are a clusterfuck of monumental proportions. it's just ranting and raving about devs and dev shops screw up stuff isn't exactly news to anybody. that's the natural state of affairs no matter what your flavoroftheweek.we get close to something useful near the end ...focus on the right criteria for splitting a service instead of on its size and apply those criteria more thoughtfully...the rest of this looks like a rehash of generallyaccepted architectural principles most of which were misapplied and resulted in us getting here in the first place. i'm not going to linebyline critique this. there are far too many points to counter and i can't imagine the discussion keeping any sort of reasonable cohesion hardy har har if it spreads out that wide. oddly enough i find this discussion of why monoliths might be a preferable default state too monolithic to split up into reasonable chunks to analyze. much irony there.we got to microservices or i might rather say we returned to microservices by following good code organization principles. instead of starting with the resulting implementation such as the dags and various models in this essay and trying to argue first principles it's better to start with first principles and then come up with criteria for evaluating various results.i feel i would be neglectful if i didn't add this if your code is right whether you're deploying as a microservice or a monolith shouldn't matter. that's a deployment decision. if it's not an easy deployment decision if you can't change by flipping a bit somewhere then either your first principles are off somewhere or you made a mistake in implementing them. the way you code should all be about solving a real problem for your users. how you chunk your code and where those chunks go are hardly ever one of those problems.;0
24975247;HackerNews;2020-11-03;i think we need to go back and think about what micro service really means. in my company the terms web api service and microservice are pretty much the same. the only difference is that microservice is cool now.;0
24975239;HackerNews;2020-11-03;i've never understood all this drama. in my experience monoliths are universally bad in every imaginable way. a huge part of my career has been splitting monoliths into cohesive smaller codebases which could be called microservices.how to split them has never really been a problem you tend to develop an intuition and the monolith kind of splits itself.eg currently we have user profiles user id the users names email etc in one microservice relationships between users user id other user ids in another.each has its own datastore deployment scaling etc. it works great and while there is a small overhead cost to pay for splitting things it's vastly preferable to the monolith we used to have which contained lots of things that had very little to do with each other took ages to test and deploy if it went down it was game over etc etc etc.;0
24975132;HackerNews;2020-11-03;my manager at work is a big believer in microservices.i never reveal my true thoughts because i dont think he would understand the heresy of the unbeliever.never tell anyone to their face that you dont believe their god is real.;0
24975059;HackerNews;2020-11-03;unfortunately this is only a marginal improvement as the team remains devoid of engineering discipline. this strikes me as the crux here along with this line from the article there were three main reasons for the initial success of microservices as an architectural pattern for software ... 3 an excuse for having no architecture.microservices are a little bit too much of a just so story to me. it's a cozy nonanswer to the hard problems of system design.;0
24975050;HackerNews;2020-11-03;imo it's not really about the build at all. it's about people and business.one for microservices created by the companies themselves those bascically grow out of their org chart. it is well known that organizations ship their org chart and this is no exception. person a wants to become a manager to make more money and ascend the societal hierarchy. person a's manager wants to grow their fiefdom and have more people under them which is the only true measure of one's worth as a manager as far longer term career is concerned so the person a proposes to their manager that they use best practices and carve off a microservice. their manager happily obliges because they don't know anything about distributed systems and consistency. person a gets promoted. now person b wants to become a manager to make more money and have their fiefdom... the end result is you have a nightmarish maze of microservices where a single simple monolithic binary would do a better job at one quarter the dev cost. you also have a very deep and branchy org chart which is the preferred state for the management since it lets them justify and increase their pay.two for cloud microservices they offer a simple way to create recurring extremely sticky revenue.that's not to say that microservices are useless they are useful sometimes. it's just that nobody ever got fired for moving to aws and when the incentive structure does not encourage more robust engineering andor cost savings your money won't be spent wisely because nobody gives a shit about that.as with any people problem the only way to push back against this is by making the desired state the lowest energy state. this can be done several different ways none of which have anything to do with engineering arguments at least not if you want it be be effective against such very human things as greed and desire for social status.;0
24975037;HackerNews;2020-11-03;ive always seen microservices as primarily used a trendy way to impose basic engineering discipline on projects where there isnt the will to define interfaces between components explicitly dns being a crude service locator pattern different vms providing basic encapsulation. unfortunately this is only a marginal improvement as the team remains devoid of engineering discipline. this article has meaningful advice but im not sure that it will be often applied.;0
24975031;HackerNews;2020-11-03;i prefer lower devops complexity and higher software application complexity. any day.microservices is higher devops complexity in exchange for lower software application complexity. a really terrible deal imo.;0
24974889;HackerNews;2020-11-03;programmers have always partitioned their code in roughly the following way the languagesterms differed but that's how software has been constructed since approximately forever and we've always had debates on optimal sizelength of linesfunctionsobjectsmodules etc. we've also had numerous reincarnations of binaries talking to each other over some form of rpc. what happened here was a marketing knifewar between companies in the container management space. then someone we'll never remember who tried to differentiate by coining this term which basically means binaries with rpc.every binary in your usrbin is a microservice. just type watch date and enjoy two microservices running no need for containerskubernetes;0
24974879;HackerNews;2020-11-03;wow. this is so much cutting through a lot of noise on microservices for me.;0
