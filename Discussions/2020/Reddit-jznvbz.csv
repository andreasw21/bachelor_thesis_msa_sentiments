ID;Source;Creation Date;Content;Sentiment
jznvbz;Reddit;2020-11-23;Title:The macro problem with microservices, Content: https://stackoverflow.blog/2020/11/23/the-macro-problem-with-microservices/;0

gdd13hu;Reddit;2020-11-23 20:40:34;of the places ive worked over the last decade maybe one of them has really had a web scale issue that warranted microservices. all of them had a legacy monolith that micro services were magically going to fix and i could never persuade them otherwise. so i spend increasing amounts of time dealing with infrastructure concerns and smile.;0
gdd59uc;Reddit;2020-11-23 21:12:55;i've never had an issue where microservices helped with scalability but microservices have been very helpful in deployability. the traditional monolith might run many services but if you want to redeploy one you may end up having to redeploy all. which basically means that if i wanted to deploy one service out of many i might have to check with users of the other services to see if they are doing anything which might get impacted. the nice thing i've found with microservices especially in a cloud environment is i can just redploy the service i want to redeploy and not disturb the existing running services. microservices also work well with a continuous deployment model because you can push out tiny changes to production on a continuous basis that you can roll back if they don't work out. this is much nicer than release events which require much more elaborate planning validation and rollback scenarios.;0
gddhzth;Reddit;2020-11-23 22:54:58;i'm really not sold on microservices. i read quite a lot about them and i recently worked on a project that was very proud of their microservice architecture. a pattern i noticed is that microservices are great for deployability and scaling but they also add a lot of complexity and it can be quite hard to manage dependencies between microservices. most real world systems i've seen and the one i worked on suffered a lot from turning everything into a microservice. it would have been a lot easier to use a mixed architecture where only the parts that actually have to scale rapidly are microservices.;0
gddl18w;Reddit;2020-11-23 23:19:59;in just 20 years software engineering has shifted from architecting monoliths with a single database and centralized state to microservices where everything is distributed across multiple containers servers data centers and even continents i would argue most things even new projects are still monoliths.;0
gdft031;Reddit;2020-11-24 14:18:26;one thing with monoliths vs microservices is that people seem to think you need to change all the characteristics of one to the other simultaneously. in a monolith you supposedly have a single database and a single database vendor. yet when talking about changing it to microservices it is instantly assumed that you will have a different database for each service and apparently also a different database vendor for each one too. but that is an additional potentially unfounded assumption. if you don't need the additional database don't add an additional database. if you don't need the additional database vendor don't change the database vendor. do incremental changes based on what you need.;0
gddgvbn;Reddit;2020-11-23 22:45:58;firstly i really really hate articles where they take one particular implementation of whatever architecturemethodology find holes in it and then claim that all implementation of whatever architecturemethodology has those holes. secondly why soa got renamed to microservices? who is keep coming out with those stupid names? it was good old fashioned dilemma of centralized monolithsocialism vs distributed servicescapitalism. thirdly monolith is problematic even if you do not have scalability issues.;0
gdd5sft;Reddit;2020-11-23 21:17:00;btw the problem described in the op is essentially the problem solved by service mesheshttps;0
gdd2dnq;Reddit;2020-11-23 20:50:25;sorry if this isnt the place but you seem like you have practical experience. do microservices actually help you scale an application? ive never seen it and dont see how they could. trivial example i could either have 2 services that run on 20 instances each or i could package them together and run them on 40 instances what is the actual difference here besides ease to deploy changes? e lots of good answers and discussion here;0
gddxb8q;Reddit;2020-11-24 01:05:24;the project i'm working on when i joined had about sixty different lambdas each in its own repository all talking to the same database. not really microservices but structured as such. each change touched about five or six repos at minimum. it was hell. we have since moved to a single repo. still a ton of lambdas but at least we use the same package just with different entry points. like with the nosql fad a few years ago i just wish people would really think about what each decision means and what the consequences are. if you're unsure go with the simple defaults monolithic application with relational db and a well maintained and established languageframework. otherwise you're just creating pain for whoever comes next.;0
gddvzc5;Reddit;2020-11-24 00:53:44;where i am working now there is a legacy monolith that is absolutely horrible to work with. the company has moved some parts of the code into microservices but the bulk of the monolith remains... like the article describes they are attempting to horizontally scale the monolith. basically sharding by a key. whatever they do the existing monolith must die. even if that means a new monolith...;0
gde84ld;Reddit;2020-11-24 02:42:55;it's a more cultural problem than technological. new technologies like microservices may be useful but shouldn't been used as a magic wand that solves everything. unfortunately sometimes customers are too easitant to sign the check or contract even with facts and salespeople has to impress them ...;0
gdemjxa;Reddit;2020-11-24 04:53:06;it's not just for scaling it's way faster development once set up. building and testing the entire application when just changing three lines of code instead of just one microservice is something i don't want to miss;0
gdeewes;Reddit;2020-11-24 03:42:30;maybe one of them has really had a web scale issue that warranted microservices... the whole thing is the definition of the last 5 years a lie wrapped in another lie wrapped in another lie. your app never gets bigger than one server and if it did microservices either don't improve performance or would be a poor way to improve them. it's just empty sales and handwaving hype.;0
gdd95jl;Reddit;2020-11-23 21:43:46;if other professions had the equivalent of microservices what it would be like. like what would be the microservices equivalent of going to the urologist? send you to 20 different labs and orchestrate aggregating the results over kubernetes? the way the use the term monolith is also really full of the cringe when the outdated insufficient monoliths most of them a lot better designed too actually bothered to solve hard to deal with issues they themselves just don't give a shit about and they try to get everything done all over again badly made but in a trendy microservices fashion that really only belongs to scaling and balancing problems but tech consultants and sales men convince people to do it everywhere.;0
gdf4vss;Reddit;2020-11-24 08:33:29;in one case that i can attest to our monolith iswas exclusively singletenant and very hard to change and with a growing customer base was becoming super expensive to run and impossible to scale horizontally. the move to microservices or just services was more about making the services multitenant more than anything else.;0
gdybh84;Reddit;2020-11-29 01:40:25;what measure did you use to determine the one that warranted microservices? in other words when do i know if my monolith is in line for micro services?;0
gdepkh3;Reddit;2020-11-24 05:22:33;tied in with both your points is how much easier safer it is to deploy new versions of microservices;0
gddzyyn;Reddit;2020-11-24 01:29:20;i dont get why are you comparing one microservice with the whole monolith? obviously its easy to rewrite or understand one microservice how much easier its to rewrite and understand them all? point being monolith doesnt mean all of its parts are connected to all of its other parts. you rewrite parts modules libraries whats the problem? whats the difference?;0
gdfetly;Reddit;2020-11-24 11:17:05;you are describing a modularization problem. see you in 25 yrs of microservices.;0
gdfo98d;Reddit;2020-11-24 13:33:42;i see your point but in monolith you can also rewrite modulesservices it's divided to. in microservices you also have much more overhead related to infrastructure and while rewriting you will often be required to also change the api. so you have to decide if adding more work upfront will be profitable. i would say that scalability is certainly not nice to have in applications that the microservices emerged from it's a necessity there.;0
gdgylv6;Reddit;2020-11-24 19:49:08;yeah that is my reasoning. microservices increase code disposability which is a huge win. never mind reusability deletability rules.;0
gddkb7d;Reddit;2020-11-23 23:13:58;actually this is exactly the problem temporal solves. we provide a consistent layer that makes it possible to build with microservices without feeling like the ground is shifting out from under you. we feel that microservices aren't the end all to be all but they exposed a weakness in the way developers write distributed applications. for the last 10 years nobody has succeeded in addressing this which is one of the reasons microservices probably get so much hate. temporal aims to abstract away the specifics of microservices and instead provide a generic solution for writing distributed applications. this way it doesn't matter how things are exactly deployed microservices soa kubernetes nomad swarm aws gcp elb alb etc your code won't change. check it out httpsgithub.comtemporaliotemporal;0
gde819t;Reddit;2020-11-24 02:42:05;microservices aren't best in all cases. if the benefit from deploying and scaling isn't large enough to justify the added complexity then its pretty obvious that the wrong architecture was chosen. for some teams the tradeoff will be worth it. for others it won't.;0
gddiyg1;Reddit;2020-11-23 23:02:41;hey! author here sincerely appreciate the feedback. i wasn't trying to imply anything about implementations but rather the fundamental requirements that come with microservices. regardless of how experienced you are with implementing microservices you still have to deal with the fundamental way they change development. as for soa vs microservices i knew this might be controversial. i made the choice because my observation is that 90 of people use them interchangeably in 2020 and the problems i describe apply the exact same to soa as they do microservices. that being said i have no particular fondness for terms whether they be soa or microservices. i just optimize for the audience. would love to hear more about the problems you've seen in monoliths! really appreciate you reading the article and providing feedback.;0
gdda8gg;Reddit;2020-11-23 21:52:27;in a lot of ways service meshes do solve a lot of the problems i described. that being said service meshes in general do not address the application level deficiencies that microservices introduce. there are many distributed systems problems which can only be addressed by the application developer within their code. service meshes fall flat for solving this class of issues. things such as compensation logic functiongranularity retries and many more are either not possible or significantly less convenient with a service mesh. that being said many of our users run temporal within their existing service mesh!;0
gdd305s;Reddit;2020-11-23 20:55:15;you will generally see a lot of people in this sub that absolutely hate microservices. in the end they're supposed to scale the development and not the services themself. we could use a monolith as well at our workplace but that would mean that 200 developers work on the same codebase spanning roughly 500.000 lines and it'd get deployed almost every hour.;0
gdd4h6k;Reddit;2020-11-23 21:06:37;most people are biased and refuse to look at microservices as anything other than a bad design or organizational tool. you can find very real usecases for splitting a service out of a monolith for greater scalability. here are a few reasons why you'd consider it readheavy services are very scalable across n instances and if you have a service separate from your monolith that increases 10x in demand youd hate to scale your big monolith service 10x just to accomodate that one function. greater reliability. monoliths tend to have important and less important things going on in them. if a particular piece of functionality requires 4 9's itd be nice to isolate it from noisy neighbors and potential issues caused by low priority features in a monolith. a stupid example would be a password reset class throwing a npe and taking down your banking software. consistency concerns. if you require some portions of your app to be strongly consistent they may use a db very differently than an eventuallyconsistent monitoring service. while still possible to configure multiple connection pools its sometimes easier to split the app instead and use a more vanilla approach. additionally some apps must run as singletons unless you want leader election so its easy to make them their own service performance performance performance. noisy neighbors are tough and modelling perf across many features to make sure you arent io bound or cpu bound or network bound i know this is io too can be hard. easier to model if they sit on different machines containers whatever.;0
gddf8v9;Reddit;2020-11-23 22:32:53;depends... generally speaking microservices are favored not just because of their ability to scale with the advent of cloud computing and containers monoliths scale just as easily as a microservice but because they match more closely with the organizational structure of the company i want to say it's often referred to as conway's law. from personal experiences it's trivial today to greenfield a suite of microservices and whereas there is some overhead for microservices in terms of monitoring so long as you are aware of saas solutions appd datadog etc. even that becomes trivial. monoliths though also have advances that make them extremely trivial to develop on and deploy at least for java you can use an osgi container to componentize your application having worked with apache servicemix it wasn't terrible but had some warts. now... should you start building out microservices vs a monolith and convert when needed is the million dollar question and personally i feel like it comes down to what are you building?. generally speaking monolithic approaches will be cheaper upfront and as i said before you can still containerize a monolith just be lazy in terms of bootstrapping and use a healthcheck enabled loadbalancer to allow it to be visible online so they generally are better candidates when budgets are slim. however if your application requires multitenancy and has clear system splits and latency is acceptable and you are thinking about an overarching platform starting out with microservices likely isn't a bad idea however as noted above you can simulate a microservice like architecture by utilizing a component module system while retaining a monolithic application. sorry that it isn't a cut and dry it's just better but it does have some cons that i feel are quite huge and solutions exist to fix those issues but without as many cons.;0
gdgsk8p;Reddit;2020-11-24 19:02:25;i've once decomposed a monolith into a dozen microservices executing roughly the same workflow. this had a bunch of steps some of them cpu heavy some of them ram heavy and some of them disk io heavy. the monolith required a couple thousand servers that were at most times idle idle in most resource types and still had tons of hiccups with overloads. the flock of microservices was rock stable but also fit in just a couple hundred servers with good utilisation.;0
gdddbtz;Reddit;2020-11-23 22:17:23;like what would be the microservices equivalent of going to the urologist? send you to 20 different labs and orchestrate aggregating the results over kubernetes? you've just described the american medical system.;0
gdejq7f;Reddit;2020-11-24 04:26:32;this is a good description of where microservices can go too far. but the monolith isn't usually just going to a urologist it's a combination tattoo parlor daycare raw sushi bar plastic surgery clinic that does urology on the side. i think monolith is actually a good description of that problem and there are advantages to isolating some of those things from each other.;0
gde6l73;Reddit;2020-11-24 02:29:07;the difference is practice and theory. microservices enforces these benefits to a much larger degree than a monolith does. so while a monolith can be well made and have loosely coupled or not coupled at all modules the fact is that its so much easier to mess it up. especially in a team. one day youre doing one simple exception. ill just get this data from some non ideal place instead of a better but more expensive and time consuming. its convenient in this particular case and then some weeks or months go by. you quit your job or some new person comes in. a junior maybe. they are asked to implement something which will touch the same code as previous. they see the anti pattern in the code already and assume its fine to do the same for their feature. now we have 2 bad cases. as time passes more and more of these kind of cases will definitely happen. eventually it reaches a point where no one single person knows about all the exceptions and hacks implemented throughout the years and youre stuck with a giant blob of code that no one really understands thats also incredibly hard to just fix. micro services doesnt solve this issue directly but it greatly helps in preventing this kind of stuff from happening. and whenif it does you can much more easily replace the one service thats gone bad or is outdated to a point where its easier to do a rewrite than upgrade and who knows maybe this time around its time to pick a new and modern framework or language that the monolith does not currently support? 2 for 1 of course micro services have their drawbacks and are often overused. resulting in overengineered systems that doesnt really need the benefits provided by a micro services architecture in the first place. but when to go for a single monolith and when to go for micro services is a different discussion;0
gde7cnk;Reddit;2020-11-24 02:35:56;i'm not comparing them directly. it's a collection of microservices versus a single monolith. think of it this way. microservices force interfaces between components in a very apparent and explicit way. instead of being buried inside the code they're exposed and even published. here's another thing httpsen.wikipedia.orgwikiconway27slaw if you have microservices you can have a collection of projects each managed by a single group. perhaps a group managing 23 projects. perhaps a group is a group of 2 people. so it's forms a nice way to divide up the work while keeping ownership. the communication between the groups mirrors the communication between the software.;0
gdemtwx;Reddit;2020-11-24 04:55:40;microservices also work well with a continuous deployment model because you can push out tiny changes to production on a continuous basis that you can roll back if they don't work out. you should have the testing and monitoring in place so you can be made aware of any undesirable behavior and fixrevert the changes.;0
gdg2jym;Reddit;2020-11-24 15:38:02;a bigger question to ask is why do you have a monolith in the first place? usually a monolith has a bunch of independent services that really only share a ui a database and authentication through a shared session. independent services whose consumer is only a ui for example should be independently deployable. this is usually the scenario that i've commonly dealt with. i made some functional changes to one part of the app but redeploying means restarting every service introducing service disruption to unrelated parts of the app. shared services are a different matter. and are another example of where microservices can shine. if you're separating services into their own processes you're also likely using something like oauth to distribute authorization. if you properly scope your resources you know exactly who is using which services. so you can even redeploy shared services independently coordinating the deployment with the specific users who have grants to those specific scopes.;0
gdf1czv;Reddit;2020-11-24 07:42:58;there's a lot of room for architectural patterns between a monolith that's too large to handle and microservices. your whole comment is just a false dichotomy.;0
gdduzm7;Reddit;2020-11-24 00:45:00;just completed 4 year long complete rewrite of microservices system of 80 independent interconnected modules than can only run together as a single instance and can only be built together as most header files are shared and reused thru ifdefs made me suicidal for a year. basically a monolith under disguise of microservices just as 95 of all microservices solutions out there. developers just break out functional elements into separate entity and call it a microservices. but it ain't so. every time system needed update the whole things shuts down service outage for customers. emergency fix same thing. interface changes oh dear do not go there. monolith is only suitable for compact application that only does one or two functional operations. that's how it is usually starts and then developers add bells whistles and drums all over. all of it in order data processing. new system has only 6 modules but can be deployed any reasonably number of instances on any reasonably number of servers and completely out of order data processing. all updatespatches are live. cannot call it micro services though. macroservices? hardest part was stopping my customers my developers and myself from thinking process a consists of processes b and c to process a is process b if process c completed or process a is process c if process b completed. basically changing business process first before even starting coding. then all of the sudden all of us moved from concept of transaction to concept of final state. now even if some data is delayed for an hour data model is still consistent across all nodes. does it have limitations? yes of source. at 40000 unique messages per second it starts choking on performance on 2 servers. regular load is around 1000 so we good there. in retrospect it could have been done better probably with 8 or 9 modules and few processes need better definition. also probably we should have moved away from csockets altogether. my experience soa is really really hard to make since it requires a lot of thinking and cooperation from customers to hammer out scalable business process first but if system design gets close to soa damn things do fall in place as predicted.;0
gddc26r;Reddit;2020-11-23 22:07:07;there are many distributed systems problems which can only be addressed by the application developer within their code. one of the fundamental problems i see in this space is that people work with services as if they were ordinary synchronous method calls. there is definitely a shift in perspective that is required for example how you approach functiongranularity. this is where knowledge of ddd can become very useful. fine grained method calls should be within one bounded context and coherent bounded contexts should define service boundaries. ideally this same practice applies to monoliths as well aka modular monolith but monoliths can tolerate ball of mud architectures better than microservices. things such as compensation logic... working within a service oriented mindset requires a shift in thinking. compensation logic retries circuit breakers etc. can be pushed out into the infrastructure rather than being baked into the application. service meshes formalize this process but you still have to design your services correctly.;0
gddh7lh;Reddit;2020-11-23 22:48:41;in the end they're supposed to scale the development and not the services themselves yip conway's law. if you don't have the organization structured for independent services then microservices will likely fail. i suggest one test the new service team on the monolith first. if there are coordination problems mostly related to organizational management issues and not technology then a separate team is probably a bad idea. for example our org kicked around the idea of producing a glorified active directly ad replacement service to have more detail than ad could supply including change history. currently each application tends to invent its own copy with localized tweaks. ad is only used for rudimentary authenticationauthorization. but it was realized that such a team didn't have sufficient authority to dictate organizational standards and those at the top didn't want to give authority to a bunch of techies. whether it was a good idea or not it didn't fly with top management. a toothless microservice would just degenerate into local customizations like the original situation.;0
gde0k6o;Reddit;2020-11-24 01:34:38;iÂ´ve worked in 3 fast growing startups during the last 10 years. in all of them we started with a monolith and later we migrated to microservices architectures. for me the advantages have been 1. scaling development as you mention. splitting the big monolith in to frontend static app deployed in s3 cloudflare api gateway workers and connectors to external systems made it easier to split groups as the team size increased. 2. process scaling was easier instead of having to have 1 4xlarge instance with the monolith we have a couple of microsmall instances depending on the microservice all communicating through sqs or rabbitmq and we could spin additional autoscaling or manually at peak times or if necessary. 3. resilience i have had aws ec2 instances die on me just because. one very true thing i read someone say is that people tend to forget that cloud infrastructure is actually real hardware and it fails... there are some dreaded aws mails saying instance unreachable. having reduntant infrastructure in the form of scalable microservices means we don't have surprises.;0
gdd97vo;Reddit;2020-11-23 21:44:18;there is a distinct difference between a monolithic service and a monorepo though. it's a perfectly valid development method to implement microservices within the same monorepo to take advantage of shared tooling and code bases without the need of internal private package management.;0
gdf52oi;Reddit;2020-11-24 08:36:18;this 100. we use microservices or just services because it means we can divide ownership of code into smaller teams of 26 developers each. even just 30 developers working on one big codebase becomes harder to manage.;0
gdfyc2z;Reddit;2020-11-24 15:04:03;i don't do this type of software so i don't have a race in this horse but clearly anything that can be modelled as separately running microservices can be modelled as separately developed loadable libraries that can be built and tested individually but delivered monolithically and even then still potentially very flexibly with configuration driving what kind and how many of those modules are loaded what their 'addresses' are and so forth. that's been the case forever and it's every bit as conceptually and developmentally separated but without the extra complexity and moving part of the network to connect them. if you can't make that sort of situation work then i can't see how you can make microservices work since it's the same thing but with just less control over the glue between the bits.;0
gdd8cqu;Reddit;2020-11-23 21:37:18;most people are biased and refuse to look at microservices as anything other than a bad design or organizational tool. i think one reason people are biased is that they have been burned by bad implementations which are easy to do with microservices. distributed services are hard. when design goes wrong instead of synchronous spaghetti you get asynchronous distributed spaghetti. single application management and monitoring is a well known problem with a whole slew of best practices. management of microservices is still a very young discipline. we're learning a lot and people are building experience which is being translated into best practices and products. but i can see why some people would rather let others to build stuff at the bleeding edge and stick with the tried and true.;0
gdeggvd;Reddit;2020-11-24 03:56:37;microservices don't actually do any of this. they only have 1 instance. you're not spinning up multiple instances that's not how they work.;0
gdevsl7;Reddit;2020-11-24 06:31:21;the term was used a lot by the people that wrote unix to describe the way they wrote it with 100 smaller utilities and calls etc. vs alternative approaches they could use. it meant that instead of writing a few components that could do a lot by being supplied a lot of ad hoc configuration they wrote more components that did a little butyou could easily compose their input output etc. like for a very rough example they wouldn't begin by adding a filter criteria sorting criteria as configuration to the list files call but make it 3 seperate calls so the other 2 could be reused everywhere on their own. microservices architecture say it starts with a similar idea which is why they call other approaches monoliths but they part they distort it is that the microservice is more like an object than a function it has state and it sends and receives messages. like when a waits for b to contact c send a broadcast message a receives it back and then sends a message supposed to be received by d and a then gets a confirmation that it got synchronized etc. etc. that's like the parts have dependencies and often they must have since they have to synchronize state. all these dependencies and configuration to get a working involves stuff the original users of the term wanted to avoid and called an attribute of monoliothic software and which the microservices proponents still do but allude to not doing it there is some contradiction here.;0
gdh1f77;Reddit;2020-11-24 20:10:44;think of it this way. microservices force interfaces between components in a very apparent and explicit way. instead of being buried inside the code they're exposed and even published. but if you break the interface between modules your application won't compile. if you break the interface between microservices you won't find out until cicd testing or possibly deployment. how is the microservices version more explicit?;0
gdhwzlh;Reddit;2020-11-25 00:28:15;java 9 modules could be similarly used to force explicit component separation. you could even have parts of the process run on thread pools of a configurable size. effectively microservices but running in a single process so you can pass data around directly rather than having to design it so it can safely and efficiently roundtrip through your preferred serialization format and you have access to all the intraprocess synchronization primitives that are unavailable to multiprocess or multiserver code. then when you'd finally need the multiserver scaling or separate update capabilities of a microservice you could implement serialization network etc. and accept the performance and debuggability tradeoffs.;0
gde508z;Reddit;2020-11-24 02:14:50;number one to the top. microservices scale teams. restapisgrpc are so ubiquitous they make it incredibly easy to decompose a project along service lines. they are ubiquitous. devs need to know them. teaching them is valuable and will be reused time and time again. compare teaching microservices to say... teaching design patterns you would commonly encounter in a larger monoliths. while i appreciate the organizational and extensibility value in repository pattern java's factoryfactoryfactory pattern dependency injection mvvm etc... they only needed when the codebase is expected to grow and be extensible. also those patterns aren't nearly as ubiquitous as say apis in general and more importantly they aren't as brutally efficient at decomposing large projects like microservices. you can pull a diverse set of developers together different languages and skill levels and get a basic poc working quickly with microservices. of course it will take a few iterations to iron out kinks but there is something to be said about getting that value out quickly and having the team learn from one another and iterate quickly independently or together with few constraints.;0
gdg1406;Reddit;2020-11-24 15:26:20;microservices are easier to do since separate libraries would still imply deploying the large monolith every time a library needs to update the production code. sure you can work with dynamic linking and loadunload libraries but that's far far worse than doing a standard tcphttp request that's been in use for 30 years.;0
gddoji4;Reddit;2020-11-23 23:49:32;the antipattern you're describing is more commonly known as a distributed monolith which is what happens when we break apart a large service without understanding it along the proper lines of abstraction. https the real issue i think hits organizations hardest is that an organization is not able to adopt anything new lowhanging fruit in terms of mindset hardware etc. that can help them scale to meet business demands. you can train everyone in a team on every new practice and tool for months but it won't matter if the team isn't enabled to actually change the code and quickly receive feedback before innovation drops engineers leave and things just rot. it means you can take the best technical and business leadership in the world and they won't do any better than who you have now it means you need a new team built from the ground up which is even more expensive than a software rewrite. instead of asking hard questions and doing the necessary work most companies keep passing the buck and sweeping deployments something that's an emergent activity that springs up organically rather than a deliberate activity like a business strategy feature etc. the opposite is more effective better infrastructure and tooling helps bring rise to enabling faster experiments and innovations both business and technical.;0
gdhk50z;Reddit;2020-11-24 22:39:23;if there was a great way to force module to actually keep separation that might work. i don't see this often enough. and with microservices you can mix different languages and frameworks. this is sometimes a good thing.;0
gdljxzb;Reddit;2020-11-25 23:14:58;a reddit account with posts on nothing but streetwear clothing and no recent history went dark four years ago woke up for a spurt of activity ten months ago then dark again wakes up yesterday with a single post on microservices and you the author happen to be in the subreddit to answer questions and promote your company? it may not be breaking the rules per se but that is one hell of a coincidence. it's not as brazen as some of the blogspam on rprogramming but it is certainly advertising by an indirect route. honestly it's an interesting article and i wish your company well. the discussion here in the comments is valuable so i don't have a problem with it it's just that astroturfing never sits right with me.;0
gdht4lr;Reddit;2020-11-24 23:54:18;oh wow. you're not only pretty rude you're also extremely wrong. there are countless monolithic applications in the wild that are small enough to handle that will never be too large to handle since their scope isn't all that large. and this may shock you but the term microservice is defined relative to regularly sized services. that's still an architectural paradigm that's not monolithic but also not a pure microservice architecture. but sure there's this giant fad that only really exists for ten years and then there's the wrong way s;0
gdgw1xp;Reddit;2020-11-24 19:29:17;microservices are easier to do since separate libraries would still imply deploying the large monolith every time a library needs to update the production code. you say that like it's somehow an inherently bad thing. what do you think are the difficulties of deploying a monolith service? i don't have a lot of experience with microservices but isn't it the same clickbutton deploy for a monolith as a microservice?;0
gdhahmi;Reddit;2020-11-24 21:21:48;i always scour microservices post comments for answers to exactly this sort of question and have never found a sufficient one. if every library should be its own http service with it's own instance own jvm or other runtime own http server implementation then why not every class? every method? this is really the coherency v coupling debate but with services. if things are tightly coupled keep them together. personally the main reason i like microservices is they make it impossible for somebody to fuck with isolation. every monolith will end up with cross contamination of concerns making it impossible to dismantle the whole to delete dead components. monoliths accumulate appendices like nothing else. i've not actually seen it done properly despite everyone telling me it can be done. by using microservices i've committed the company to not doing that. it isn't easily possible for them to take short cuts we'll pay for forever. subsequently i can now delete stuff with ease when it is time.;0
gdgujlp;Reddit;2020-11-24 19:17:37;an app with 5 microservices always runs 5 microservices. it's not an architecture choice that lets you to deploy multiple instances.;0
gdlmy52;Reddit;2020-11-25 23:42:05;i genuinely appreciate the thorough investigation. obviously its impossible for me to prove that i didnt do something so no value in that line of discussion. on a personal level it seems like youre basing the accusation on what could easily be a coincidence. if anything i find the theory a bit ironic. considering that my post history clearly shows that i will shamelessly post my own content on this subreddit. its also worth pointing out the article isnt on a personal blog but one of the most trafficked developer sites that exists. if posting my own work has clearly not been an issue in the past why would me having someone else post even be an issue in the first place? i would also say its a bit of a stretch to imply i happened to be here when i have multiple posts on this subreddit over multiple months. it also happens to be the most popular developer subreddit and im in charge of the product for a developer company. that being said if someone else hadnt posted it i honestly would have just done it myself. so its not the allegations i have an issue with its the methodology. glad you appreciated the article. it was one of the hardest articles ive written because our product is so complex that even explaining why its important is a struggle. i actually felt the comment section didnt go the way which benefits temporal unfortunately but it was enlightening to see how vitriolic people are about microservices.;0
gddqjgt;Reddit;2020-11-24 00:06:33;i think you missed the point that temporal is more like a service mesh for long running reliable operations than javaee. javaee was about synchronous communication while temporal is fully asynchronous giving a synchronous programming model to developers. it actually encourages highlevel organizing principles of microservices. but it allows making reliable calls without a lot of boilerplate. look at the example from the article and try to map it to javaee or whatever other technology out there public class subscriptionworkflowimpl implements subscriptionworkflow private final subscriptionactivities activities workflow.newactivitystubsubscriptionactivities.class public void executestring customerid activities.onboardtofreetrialcustomerid try workflow.sleepduration.ofdays180 activities.upgradefromtrialtopaidcustomerid while true workflow.sleepduration.ofdays30 activities.chargemonthlyfeecustomerid catch cancellationexception e activities.processsubscriptioncancellationcustomerid;0
gdennxg;Reddit;2020-11-24 05:03:42;many of these types of discussions around microservices and monorepos end up really being discussions around cicd and team organizationautonomy. not all organizations have equally mature tech departments.;0
gdgsyop;Reddit;2020-11-24 19:05:32;the entire value of a microservice to most orgs is breaking the atomicity of one merge. to elucidate the primary value is splitting code amongst the teams that are responsible preventing a lot of nasty interconnected dependencies in code. it should not be possible for another team to break my service. without me opting into a library version change in my own code.;0
gdhed1g;Reddit;2020-11-24 21:52:28;we have a monolith at my workplace. yeah it can achieve the same performance with one instance vs our microservices with 2. which doesn't matter much difference is literally a few cents. however that monolith is running at a 9x config to handle the load it's getting. meanwhile 90 of the actual code in it is unused. this means a few things. deploying the monolith takes time just because downloading the docker image or heck the binary and dependencies takes longer than a microservice there's more moving parts. deploying the monolith may break 50 features while deploying a microservice may break 5. there's more congestion. deploying it every hour or more means that it's only finally fully deployed when the next person needs to deploy it. it also means that there's more costs for building it as it needs more time to be compiled larger codebase and thus more overall costs as it needs to be compiled fully much more often. it's harder to coordinate features. in a microservice architecture you'd deploy a new microservice 2x and have one use a new feature essentially a canary deployment. monolith not only means that you need to coordinate all moving parts in it to either use or not use the new feature but also that you'd need to scale the huge monolith 2x to do the same canary deployment wasting tons of resources. deployments need to be coordinated. some cds may be able to stopstart deployments but that's messy but you'd still need to coordinate across everyone working on the project to synchronise deployments or have a few select people that are able to deploy which is not only a bottleneck again and a liability but also generally disliked. there's tons of examples of successful monoliths but also tons of examples of successful microservices. some people are just too blind to see them. the blind comment isn't directed towards you;0
gdh20sv;Reddit;2020-11-24 20:15:22;you either have a very narrow definition of a service or are missing the point. a microservice doesn't mean one single container running code it usually means everything that makes up that service caching db and yes n n1 application instances.;0
gdfakfh;Reddit;2020-11-24 10:02:35;no. i'm sorry but absolutely not. microservices are easier and faster to run through cicd pipelines easier to identify and debug issues usually much less state and smaller call stacks when an exception occurs easier for small teams to take ownership of and understand completely easier to replaceupgrade dependencies easier to manage merge conflicts easier to refactor and easier to rebuild vs trying to surgically rebuild one small component of a monolith. microservices divide responsibility and help developers focus. they allow large companies to create small teams of experts on specific features that own their corresponding projects. real world moneymaking software is rarely built and maintained by lone wolves. the runtime scalability is just a byproduct that's nice to have. source 15 years in the industry and software architecture consultant for aws and other companies.;0
gdjq8pb;Reddit;2020-11-25 13:24:49;microservices were always about team organization.;0
gdhzih6;Reddit;2020-11-25 00:50:44;i don't agree that the value of microservices has anything to do with breaking atomicity of merges. google literally operates their entire company from a monorepo. while also hosting tens of thousands of services. it similarly shouldn't be possible to merge broken code as best practices in site reliability engineering would enforce testing of modules that are impacted by changes. it would be more difficult to ensure you don't introduce breaking changes when codebases are separated and changes can occur in parallel between the two without knowledge of the changes yet to be merged. i also don't state that monorepos are the answer to everything. for larger projects that span many teams it may not make sense. especially if teams develop different domains of the project you can mirror organizational separation with logical separation. you would expose packages for accessing the api but not necessarily share a single repository where something like artifactory would come into play.;0
gdheg39;Reddit;2020-11-24 21:53:09;i'll rephrase making it a microservice does not not improve or prevent you from writing it in such a way that you can deploy multiple instances. being a microservice has nothing to do with that. if you write the microservice like most people do you can't just like you can't with a normal monolith. to be able to do it you'd need to write it differently and that has nothing to do with microservicemonolith architecture.;0
gdhflnt;Reddit;2020-11-24 22:02:30;that is the point though...you have a user microservice with it's own database. that db has all the users in it. you can't just deploy a 2nd new blank db with a 2nd microservice instance. if you do them like most buzzworddriven development does it poorly with microservices all hitting the same db then deploying multiple instances wouldn't do anything as db access is the main point of overhead.;0
gdferh2;Reddit;2020-11-24 11:16:04;maybe microservice articles should have a disclaimer at the top if you have fewer than 50 developers stop reading. a lot of real world money making software is built and maintained in medium sized companies by teams of 5 people. for them instead of a small team of experts for each microservice they end up with each developer being the sole expert on two microservices.;0
gdfulzp;Reddit;2020-11-24 14:32:28;absolutely it's insufficient testing. but that's kind of the point. if you use microservices you're making it really hard to test the connections between your services. if service a depends on service b even if service a's tests would normally catch the problem service b aren't running service a's tests they only run their own tests. in fact they might not even know service a depends on them at all so it never occurred to them to write a test. and that's why it's much less likely that anything will go wrong in the first place in a monolith world. service b would make the change and see service a's test failing right there in the pr. of course you could still be missing test coverage in a monolith in which case yes an outage is more impactful. but then again it's also usually easier to resolve. often you can just roll the monolith back to a previous state and figure out what went wrong the next morning. if there's an outage to do with the communication between two services which one do you roll back? can you roll them back? how? they both have their own unique deployment quirks. the testing problem can be solved by monorepos rather than monoliths but managing microservices in a monorepo comes with its own costs too. you need strong tooling to make sure you can buildtestdeploy only what's changed rather than the whole world etc.;0
ge6wpvf;Reddit;2020-11-30 22:47:22;i feel like this comment is about monorepos not microservices since imo cicd is one of the things that microservices make easy due to the team having full autonomy on how to implement their cicd not being restricted by any questionable decisions elsewhere in the codebase in my previous job being enslaved to a 'core' team which controlled the stack used by all the other teams and therefore determined our cicd process which was terrible like download files to your laptop and then upload them to another server by hand via a convoluted multirepo manualversionnumber manual process costing 8 hours of manual actions per weekly delivery no git isn't an option makes me very interested in team autonomy when it comes to cicd implementations. all code was stored in a complicated series of sql tables and delivered to onprem customers via a thinlydisguised db diff file of course maybe the real solution was to fire everyone on the 'core' team or more realistically my solution which was to find a new job;0
gdh0n1g;Reddit;2020-11-24 20:04:38;each developer being the sole expert on two microservices generous;0
gdfyrax;Reddit;2020-11-24 15:07:24;i'm not sure i agree. when you write a microservice you have to also write an explicit interface api. then you fully cover this interface with tests. that is imo fairly trivial. and sure like everywhere else you might make mistakes and not have all cases properly covered but that can happen with any piece of code. if you have a monolith you could in theory do the same but nothing forces you to do it and eventually you will end up with crossmodule dependencies that make it harder to develop write tests for etc. like once you lose this explicit distinction you can be sure that someone will forget to write a test or use the proper interface and now you aren't covered. and sure it might be easier to find problems in that but i wouldn't exactly call it a win. often you can just roll the monolith back to a previous state and figure out what went wrong the next morning. if there's an outage to do with the communication between two services which one do you roll back? can you roll them back? how? they both have their own unique deployment quirks. that's an interesting problem and you'd probably need some decent logging to solve this issue properly. the testing problem can be solved by monorepos rather than monoliths but managing microservices in a monorepo comes with its own costs too. you need strong tooling to make sure you can buildtestdeploy only what's changed rather than the whole world etc. the proper way to test microservices would be ci that for every commitmergewhatever in any microservice spins up all the dependent microservices in their current versions and tests against that. so yeah strong tooling. but it's definitely doable. just a pain to set up.;0
gdh1h3c;Reddit;2020-11-24 20:11:08;the companies i'm thinking of are very much mature already. mature physical economy companies with 5 developers don't have any projected path which expands them to 50 developers. if you're one of the larger car dealership chains in your region you aren't suddenly going to scale up by an order of magnitude the number of new car sales per year doesn't do that. but the overhead of managing a microservice architecture that could handle cars purchased like toothpaste will break you.;0
gdh2e5f;Reddit;2020-11-24 20:18:15;i had a scenario where a contractor added to a team for a new project added three microservices during a year. one of the microservices does nothing but call an external api and parse the xml returned into json. the contractor is gone and now a year later two of these microservices are running in production with no experts on them.;0
gdgzh2w;Reddit;2020-11-24 19:55:39;i'm not sure i agree. when you write a microservice you have to also write an explicit interface api. then you fully cover this interface with tests. that is imo fairly trivial. and sure like everywhere else you might make mistakes and not have all cases properly covered but that can happen with any piece of code. if you have a monolith you could in theory do the same but nothing forces you to do it and eventually you will end up with crossmodule dependencies that make it harder to develop write tests for etc. like once you lose this explicit distinction you can be sure that someone will forget to write a test or use the proper interface and now you aren't covered. monoliths are just a bunch of microservices bundled together conceptually. are you saying microservices force you to write a suite of api interface tests but a monolith service doesn't?;0
gdgl988;Reddit;2020-11-24 18:07:07;so my smoke tests prevent somebody else's service from going to prod? fwiw i agree with this but it breaks the independently deployable supposed benefit of microservices.;0
gdhlcbo;Reddit;2020-11-24 22:49:07;i'm saying microservices force you to write interfaces which in turn makes testing easier. it's also easier to keep those interfaces cleaner. but i admit it comes with certain baggage and it also can't save you if you don't try to write proper tests at all.;0
gdh4jxv;Reddit;2020-11-24 20:35:02;the main difference and this is really all i'm trying to say is that it's easier to write those tests in a monolith so it actually happens more in real life. with microservices you'll either have these services a monorepo which is good but will take up a lot of your time. but once you've got a mature org with a strong platform team yes you can and probably will test those boundaries have them in separate repos in which case you can pretty much forget about those tests just enjoy your silos and cross your fingers;0
