ID;Source;Creation Date;Content;Sentiment
23449152;HackerNews;2020-06-07;Title:Microservices Considered Harmful (2019), Content: https://blog.matthieud.me/2019/microservices-considered-harmful/;0

23493472;HackerNews;2020-06-11;its losing „some adventages of startup grade microservices and gain maintainability adventages of „netflixfacebook level grid... depends whats your scale. shipping shit fast is often not the best solution at that scale doing it right is. and i have already explained to someone else in this thread why that approach is important.;0
23459729;HackerNews;2020-06-08;ok but then you have a very controlled way of deploying each service.each team can't just deploy a new version of their microservice when it makes sense to them.so your collection of microservices becomes a bit of a distributed monolith losing some of the classic microservice advantages.or so it seems to me. i just read about this stuff have never used it. happy to be educated.;0
23456510;HackerNews;2020-06-08;unrelated? i' beg to differ. more to the point all systems have an access control model. it could be explicit or implicit depending on how the system is built. regardless it defines the barriers and boundaries between everything in the system.the comment suggests that just by separating things in the popular sense of microservices results in a barrier to enforce separation of concerns. that's how i read it at least and i find that to be is misleading.this is the crux i see around popular discourse of microservices. it's often presented without a broader context.;0
23455777;HackerNews;2020-06-08;well i'd answer that with two things 1 good leadership is probably rare and 2 doing the wrong thing isn't always wrong.in my experience the best leadership comes from people who don't hyperfocus on one thing but are constantly thinking about many different things mostly centered around the customer experience because that's the whole point of this thing to makesellrun a product not to have perfect software craftsmanship. i find those people rare and usually not working at lower levels of a product.in a sense doing the wrong thing is perfectly fine if you don't ineedi to be doing the right thing to provide a great customer experience. of course maintainability availability recoverability extensibility etc are all necessary considerations but even within these you can often do the wrong thing and still be fine. i have seen some truly ugly stuff in production yet the customers seemed happy. though there were probably some chronically sleepless engineers keeping it alive which sucks and shouldn't happeni don't like microservices because of how poorly they're usually implemented by default. but at the same time even poorly implemented microservices give some great benefits more rapidagile work reusability separation of concerns bu independence even if you're struggling against some harmful aspects.;0
23455613;HackerNews;2020-06-08;it is true for companies that recently trying to adopt this microservices catchphrase. just because it is a trend and somebody sold kubernetescfsomeothercloudsolution to the company they end up overusing it and creating a new microservice for something that could just be a separate package in already existing microservice. i am definitely not encouraging monolith architecture they are horrible to work with but i am also not suggesting 1500 microservices for a company like monzo just considering their lack of functionalities compared to other new banks 1500 microservices sound like nanoservices instead to me;0
23454511;HackerNews;2020-06-08;this is exactly the point of the original article by monzo. microservices don't provide any tool to deal with access control thus you have to implement it yourself. i rather avoid that when i can.;0
23453821;HackerNews;2020-06-08;microservices aren't a panacea by any means but like any tool they provide certain advantages when dealing with certain usecases.one thing the article fails to mention are the boat loads of tooling out there to address the failings of and complement microservices architecture of which kubernetes is only one.sure they come with their own levels of complexity but deploying k8 today is orders of magnitude simpler than it was 4 years ago. the same will hold true for similar tooling in the general microservicescontainer orchestration domain such as service mesh it's a lot simpler to get up and running with istio or linkerd than it was 18 months ago distributed tracing jaegeropentelemetry and general observability.i'd also point out that ms can provide benefits outside of just independent scaling and independent deployment of services but should in theory also allow for faster velocity in adding new services all dependent on following effective ddd when scaffolding services they allow different teams in a large org to design build and own their own service ecosystem with apis as contracts between their services and upstreamdownstream consumers in their own org and new team members coming onboard should in theory be able to get familiar with a tighterleaner codebase for a microservice as opposed to wading through thousands of lines of a monoliths code to findunderstand the parts relevant to their jobs.;0
23453713;HackerNews;2020-06-08;you are making a lot of ageist remarks. there are plenty of senior engineers making wrong decisions. for example the istio project moved from microservices to monolith and none of those engineers are junior engineers by any means.;0
23453696;HackerNews;2020-06-08;microservice architecture is soa for the 2010sit's basically agileized soa.key features are domain focused services devops friendly deployment via containerization and continuous integration.;0
23453690;HackerNews;2020-06-08;what you're referring to is just soa which has been around for a couple of decadesmicroservices is just a new name for soa that ditches the psychological association soa had developed with the ws series of xmlbased standards and associated enterprise bloat.;0
23453683;HackerNews;2020-06-08;the things you described aren't exactly novel programming concepts unique to or invented by microservices.i don't think anyone has ever claimed novelty in microservice architecture. it's very clearly derivative.shared state is moved. you get some level of isolation simply from the fact that there are two distinct pieces of hardware operating on state. you can then move state to another piece of hardware and share that state between services somewhat discouraged but this is a much more explicit and heavy lift than just calling a function with an implicitly mutable variable or sharing a memory space file system etc. but can't you just as easily argue they weren't creating a proper monolith to begin with?maybe. you can say this about anything there's no science to any of this. i could say functional programming leads to better code than oop but i couldn't really prove it and certainly you can still do crazy bad garbage coding things with fp languages. but i would argue that the patterns that make up microservice architecture can help you make bad things look bad and good things look good. it's not magic fairy dust that you can just use to make your project better by some metric but no one informed would ever claim so.;0
23453676;HackerNews;2020-06-08;still don't need microservices. what you're referring to is just soa which has been around for a couple of decades. microservices typically outnumber engineers or aren't too far off.;0
23453675;HackerNews;2020-06-08;is microservices trading development complexity for deployment complexity?;0
23453639;HackerNews;2020-06-08;i think he is skipping a couple of points.for example the deployment aspect monolith single deployable unit. microservice multiple independently deployable units.multiple teams on a monolith you have to coordinate releases and rolebacks... code base grows and dependencies between modules that have shouldn't have dependencies on each other as well unless you have a good code review culture. deployment get slower and slower over time. db migrations also need to coordinates over multiple teams.these problems go away when you go microservices. of course you get other problems.my point is in the discussion microservices vs monolith you need to consider a whole bunch of dimensions to figure our what is the best fit for your org.;0
23453562;HackerNews;2020-06-08;in my experience microservices grew to prominence not because of their technical merit but because it allowed engineering leadership to not have to make decisions. every developer or group of developers could create their own fiefdoms and management didn't have to worry about fostering consensus or team efforts all that had to be agreed on was service contracts.we end up with way too many developers on a given product an explosion of systems that are only the least bit architected but thankfully the vp of engineering didn't have to worry themselves with actually understanding anything about the technology and could do the bare minimum of people management.individual minor wins collectively massive loss. there are reasons for microservices at big scales if everyone is still fitting in the same roomauditorium for an allhands i would seriously doubt that they're needed.;0
23453476;HackerNews;2020-06-08;my point is that microservice architecture is not just the singular pattern of code talking over the internet but a collection of patterns and techniques focusing on when and where to split up code and to focusing on the communication strategy you use. you can 'get around' microservice architecture by not doing it. the point is that if you're familiar with it it's a lot easier to 'accidentally' be successful or at least that's the proposition.i don't disagree with your definition though i think it's a hard sell to say that's the correct definition when it really depends on who you ask but the things you described aren't exactly novel programming concepts unique to or invented by microservices. i could say the same things about oop modularity and api design aren't new things.with that the idea that things like shared state are removed due a network being between the services just isn't true it still requires design effort to achieve that goal i would argue the same design effort as before. and if your previous design efforts and development practices for whatever reason did not lead to good designs and you're not actually making an attempt to fix the existing issues along with the reasons why you were making such decisions then you're likely just going to repeat the same mistakes but now with a network inbetween.and yes to an extent i agree it's not really microservices at that point you're just emulating something that looks like microservices when it's really a ball of mud. but can't you just as easily argue they weren't creating a proper monolith to begin with?;0
23453386;HackerNews;2020-06-08;imo microservice has two practice levels. level 1 single codebase with multiple entrances programs. at this level the application already scales in horizontal and functional while still has the benefit of code amp data sharing. level 2 eliminate code amp data sharing use rpc or mq for communication split the project into multipile repositories. this level might be regarded as the ture microservices which is considered harmful according to the blog post. generally speak if level 1 could fit your business there is no need to go for level 2. if it does need level 2 well it is the complexity itself which leads to the architecture there is no shortcut.btw for level 1 businesses i have a boilerplate for node.js amp typescript you may want to give it a try;0
23453331;HackerNews;2020-06-08;start with a monolith for your core business logic. rely on external services for things outside your value prop be it persistent storage or email or something else. keep on building and growing until the monolith is causing teams to regularly step on each other's toes. by that i mean continue well past teams needing to coordinate or needing dedicated headcount to handle coordination to the point where coordination is impossible. when that point approaches allow new functionality to be built in microservices and gradually break off pieces of the monolith when necessary.;0
23453107;HackerNews;2020-06-08;people here keep on repeating that statement yet people actually implementing microservices keep on believing it is a solution for an architectural problem. if they majority keeps on implementing microservices for the wrong reasons then who's right? what you describe is just classic soa. then what are microservices exactly?;0
23453068;HackerNews;2020-06-08;my point is that microservice architecture is not just the singular pattern of code talking over the internet but a collection of patterns and techniques focusing on when and where to split up code and to focusing on the communication strategy you use.you can 'get around' microservice architecture by not doing it. the point is that if you're familiar with it it's a lot easier to 'accidentally' be successful or at least that's the proposition.;0
23452943;HackerNews;2020-06-08;then couldn't i just follow the same patterns in a modular monolith eg avoid shared state make sure errors are handled properly etc and get the bulk of the benefits without having to introduce network related problems into the mix?sure. microservice architecture is a set of design patterns and a discipline for knowing how to structure your applications.many including myself would argue that by leveraging patterns such as separate processes as a focal point for the architecture leads to patterns that are harder to break out of and abuse but of course anyone can do anything.error handling is the easiest one. with any 'service oriented' approach where processes are separated you ican'ti share mutable state without setting up another service entirely ex a database. microservices encourage message passing and rpclike communication instead and it's much easier to fall into the pit of success.could you do this with functions? sure you can just have your monolith move things to other processes on the same box. not sure how you'd get there without a process abstraction ultimately but you could push things quite far with immutability purity and perhaps isolated heaps.;0
23452927;HackerNews;2020-06-08;just using separate processesmicroservice architecture is not just using separate processes.;0
23452872;HackerNews;2020-06-08;when people decided to go microservices route in my 4 yrs of experience with it please define couple of things before you go down that route. 1. how to share the database when there is too much of dependency between 2 microservices think event driven or other mechanism like materilized views. 2. please give developer more importance in this setup as there is too much of responsitbility being thrown up at devs.;0
23452837;HackerNews;2020-06-08;heh i have a masters degree focused on distributed systems. my thesis was about tracing and debugging in microservicestyle systems. i generally write monoliths on purpose. the massive overheads and debugging nightmares are not worth it most of the time.global state still gets pushed out into backend services redis postgres and i can still scale horizontally all day but theres no crazy chain of backend interservice http requests to cause no end of chaos;0
23452799;HackerNews;2020-06-08;that solves part of the problem. if you can turn it on and off with a feature flag then you probably have some modularity. but for an internal service or a saas offering or any number of things where you have one application that you need to scale do feature flags really make sense?edit the above was not fully considered. i think the original article makes a really good point about thissplitting an application into microservices gives finergrained allocation possibility but do we actually need that ? i would argue that by having to anticipate the traffic for each microservice specifically we will face more problem because one part of the app can't compensate for another one. with a single application any part let's say user registration can use all allocated servers if needed but now it can only scale to a fixed smaller part of the server fleet. welcome to the multiple points of failure architecture.having a monolith where each feature is deployed separately according to feature flags makes some sense in that you have one codebase deployed modularly like microservices but you still leave yourself open to the multiple points of failure arhitecture as the author describes it. in addition the feature flags idea doesn't really remove the deployment disadvantages of the monolith unless you're willing to have different parts of your horizontally deployed application on different versions.;0
23452795;HackerNews;2020-06-08;they force you to not share memory on a single systemso instead people use a single sql database between 20 microservices. give you scale and failure isolationonly if you configure and test them properly and they actually tend to increase failure and make it harder to isolate its origin hello distributed tracing force you to handle the fact that a called subroutine might fail because it's across a networkthey don't force that at all. it's good when people do handle that but often they don't. i would argue that if you're manually scaling things then you're doing it wrongand i would argue that if people are given a default choice of doing the wrong thing they will do that wrong thing until someone forces them not to.microservices allow people to make hundreds of bad decisions because nobody else can tell if they're making bad decisions unless they audit all of the code. usually the only people auditing code are the people writing it and usually they have no special incentive to make the best decisions they just need to ship a feature.;0
23452740;HackerNews;2020-06-08;i cannot figure out how you can see that. rpc just adds a remote on top of the procedure call part we add a failure mode but the thought process is the same.as witnessed by many teams spaghetti happens just as poorly in a distributed monolith as it does in a proper monolith it just adds latency and makes it harder to debug.the boundaries you're imagining are not drawn by the technology nor by the separate codebases they're drawn by the programmers making the calls. and i guarantee you that the average developer with their usual oop exposure can understand much more easily where to draw decent boundaries following some pattern like cleanhexagonalonionwhatever architecture as opposed to microservices where it's far more arbitrary to determine the concerns of a microservice specially when a usecase cuts through previously drawn boundaries.;0
23452626;HackerNews;2020-06-08;i agree 99.9 of products do not need a micro service architecture because 1. they will never see scaling to the extent that you need to isolate services 2. they dont have zero downtime requirements 3. they dont have enough feature velocity to warrant breaking a monolith 4. they can be maintained by a smaller teami also agree that the way to build new software is to build a monolith and when it becomes really necessary introduce new smaller services that take away functionality from the monolith little by little.microservices do have a good usecase even for smaller teams in some cases where functionality is independent of existing service. think of something like linkedin front end making calls directly to multiple microservices in the backend one that returns your contacts one that shows people similar to you one that shows who viewed your profiles one that shows job ads etc. none of these is central to the functionality of the site and you dont want to introduce delay by having one service compute and send all data back to the front end. you dont want failure in one to cause the page to break etc.unfortunately like many new tech junior engineers are chasing the shiniest objects and senior engineers fail to guide junior devs or foresee these issues. part of the problem is that there is so much tech junk out there on medium or the next cool blog platform that anyone can read learn to regurgitate and sound like an expert that its hard to distinguish between junior and senior engineers anymore. so if leaders are not hands on they might end up making decisions based on whoever sounds like an expert and results will be seen a few years later. but hey every damn company has the same problem at this point.. so its normal.;0
23452430;HackerNews;2020-06-08;functions allow shared state they don't isolate errors. processes over networks do. that's a massive difference. if you read up on the fundamental papers regarding software reliability this is something that's brought up ad nauseum.i think you missed the point just using separate processes does not guarantee you separate errors and state between services there's lots of ways to get 'around' that. what if the two services talk to the same databaseservice? what if there's weird codependencies and odd workarounds for shared state? what if one service failing means the entire thing grinds to a halt or data is screwed up?now that said yes if you use igoodi development practices and have a good architecture microservices can work quite well but if you were capable of that you probably wouldn't have created a nonmicroservice ball of mud. and if you're currently unable to fix your existing ball of mud attempting to make it distributed is likely going to result in you adding more distributed mud instead. in other words the problem here isn't really a technical one it's a process one. and using their current failing processes to make microservices is just going to make worse mud because they haven't yet figured out how to deal with their existing mud.;0
23452371;HackerNews;2020-06-08;because engineering discipline is actually hard. not necessarily in the here is how you do it sense just in the sense of getting the buyin from engineers and engineering leadership that will make it happen.this is like the one thing that microservices might actually be sort of good at drawing a few very hard boundaries that do actually sort of push people in the general direction of sanity e.g. it's easier to have basic encapsulation when the process might be on another computer...;0
23452097;HackerNews;2020-06-08;teams of ten. each service is owned by exactly one team.that rules out every monolith i've seen at companies that still did that.but unfortunately microservices becomes a religion a cargo cult and companies have hundreds of tiny little services.my services are not monoliths. but are they microservices? don't care. they work. certainly they are just a couple of services within a network of several hundred but i work at a large company. and every one of those services has one team responsible for them.;0
23452091;HackerNews;2020-06-08;just to be clear microservices are not just separate binaries on a network. if you're not following the actual patterns of microservice architecture... you're just complaining about something elseso what you're saying is that the way to avoid this problem in a microservice architecture is to be disciplined and follow the right patterns. then couldn't i just follow the same patterns in a modular monolith eg avoid shared state make sure errors are handled properly etc and get the bulk of the benefits without having to introduce network related problems into the mix?;0
23451988;HackerNews;2020-06-08;the central premise of microservices architecture is that the services manage their own data.no microservices can handle data from a bounded context that can be its own data external data or aggregate data. a bounded context is data that is part of a specific domain that may connect to other domains that have edges explicitly defined. therefore the data is decentralized it can connect to an api that is a monolith it can interface with messaging services send notifications over websockets etc because its... a middleware service.from the article that you linked to debunk me the guardian website is a good example of an application that was designed and built as a monolith but has been evolving in a microservice direction. the monolith still is the core of the website but they prefer to add new features by building microservices that use the monolith's api. this approach is particularly handy for features that are inherently temporary such as specialized pages to handle a sporting event. such a part of the website can quickly be put together using rapid development languages and removed once the event is over. we've seen similar approaches at a financial institution where new services are added for a market opportunity and discarded after a few months or even weeks.and if i am reading this right they have a monolith backend but the frontend doesn't read directly from that it reads from some 'thing' in the imiddle?i oh what's that called? its on the tip of my tongue. ah right its called middleware. because microservices are middleware.edit oh look that article you linked to debunk me also has the very image i am trying to describe with words;0
23451833;HackerNews;2020-06-08;at work we have two services that accept requests via telephony protocols ss7 sip these are quite small and forwards the request to the business logic component large only because of the complexity of the business logic implemented. when there's some state changes it sends a request to the replication module say midsized which ensures that the state change is replicated at the other site to handle geographical redundancy a requirement from our customer. there's one other microservice that the business logic uses and that's to send some data to apple so they can hand it off to ios phones all our stuff internally uses udp except for the ss7 stuffthe addition of a tls based service was too much to add to the business logic component and this is quite small as well.all of these modules are owned by the team i'm on namely due to the esoteric nature of it the telephony protocols this is real time since it's part of the call path 1 etc.. within our team we can work on any component but generally speaking we tend to specialize on a few components i work with the telephony interfaces and the apple interface my fellow office mate deals with the business logic.1 as a cell phone call is being made.;0
23451812;HackerNews;2020-06-08;microservices are good for scaling teams not hardware. if you don't have more than one team then there is no reason to break up your monolith.;0
23451780;HackerNews;2020-06-08;network failure or configuration error is a reality. the probability of having one part of your software unreachable is infinitely bigger now.network partitions are indeed a problem for distributed software in general. by the time microservices are worthwhile however the application likely already necessitates a distributed design. remember your nice local debugger with breakpoints and variables? forget it you are back to printfstyle debugging....why? what's stopping you from using a debugger? a microservice v. a monolith should make zero difference here.at worst you might have to open up multiple debuggers if you're debugging multiple services. big whoop. sql transaction ? you have to reimplement it yourself....why? what's stopping you from pulling it from a library of such transactions?i don't even really think this is a problem per se. yeah might be inconvenient for some long and complicated query but that's usually a good sign that you should turn that into a stored procedure or a view or a service layer so that other services ain't pinging the database directly or something else since it simply means bad api design sql being the api in this context. communication between your services is not handled by the programming language anymore you have to define and implement your own calling conventionwhich is arguably a good thing since you're able to more readily control that calling convention and tailor it to your specific needs. it also gives ample opportunities for logging that communication which is a boon for troubleshootingdiagnostics and for intrusion detection. security which service can call which service is checked by the programming language with the private keyword if you use classes as your encapsulation technique for example. this is way harder with microservices the original monzo article shows that pretty clearly.the programming language can do little to nothing about security if all the services are in the same process' memory address space nothing stopping a malicious piece of code from completely ignoring languageenforced encapsulation.microservices if anything help iconsiderablyi here since they force at least processlevel if not machinelevel isolation that can't so easily be bypassed. they're obviously not a silver bullet and there are other measures that should absolutely be taken but separation of concerns and enforcing that separation as strictly as possible is indeed among the most critical of those measures and microservices happen to more or less bake that separation of concerns into the design.;0
23451680;HackerNews;2020-06-08;microservices have some inherent advantages mainly that you can manage modify and deploy one service at a time without taking downredeploying the rest of your applications. this is arguably the big thing that is missing from monoliths. it's hard to only change a single api endpoint in a monolith but easier to do a change across the entire monolith when you have to change something about how the whole system works. the best compromise that i've come up with would be to have something that can keep your entire app in one place but allow individual portions of it to be hotswapped in the running application and is built to be run in a distributed horizontally scalable fashion in addition there's a lot to be said for the old way of putting business logic in stored procedures despite the poor abstraction capabilities of sql relative to something like lisp but with modern distributed databases we can conceivably run code in stored procedures written in something like clojure keeping code close to the database or rather data close to the code allowing hotswapping modification introspection replay of events and all other manner of things all while managing the whole thing like a monolith with a single application configuration etc. to deploy and a more manageable and obvious attack surface to secure.this is my solution called dataworks if anyone's interested some of those things like introspection and replayofevents are in the road map but the core aspects of hotswapping and modification of codeindb work.;0
23451621;HackerNews;2020-06-08;this blog seems selfcontradicting.the main benefit is independencyin the absence of independency a service development organization will hit a ceiling and fail to scale beyond that. while there may be a whole host of other problems that microservices does not solve this single problem makes it worthwhile in many cases.that all said implementing microservices well or even scaling beyond the point where microservices become useful requires a great deal of engineering discipline. concepts like configuration as code and api contracts have to become something more than theoretical.;0
23451147;HackerNews;2020-06-07;in my experience the benefits of microservices are primarily better delineated responsibilities and narrower scope and secondary benefits tend to fall out from these. there are downsides but the harmful effects do not reflect my experience. i fully grant more things on a network invite lower availability higher latency but i contend that you already need to handle these issues. microservices do not tend to grossly exacerbate the problem in my experience anyway.the other callout is clean apis over a network can just be clean apis internally. this is true in theory but hardly in practice from what i've seen. microservices tend to create boundaries that are more strictly enforced. the code data and resources are inaccessible except through what is exposed through public apis. there is real friction to exposing additional data or models from one service and then consuming it in another service even if both services are owned by the same team and moreso if a different team is involved. at least in my experience spaghetti was still primarily the domain of the internal code rather than the service apis.there's also a number of benefits as far as nontechnical management of microservices. knowledge transfer is easier since again the scope is narrower and the service does less. this is a great benefit as people rotate in and out of the team and also simplifies shifting the service to another team if it becomes clear the service better aligns with another team's responsibilities.;0
23450636;HackerNews;2020-06-07;yeah something in between a monolith and microservices and i'm going to name it services architecture.hmmm... i think i can do better service oriented architecture... yeah i like this name. soa.are you telling me i just invented something that's 30 years old? bollocks!;0
23450635;HackerNews;2020-06-07;agreed. or as i've heard it said microservices solve a people problem not a technical one. this is certainly how they were pushed at my current workplace it was all about twopizza teams being able to develop and deploy independently.out of interest what does the frontend service do in your setup? for my personal projects i generally just go for a single serverservice for simplicity.;0
23450591;HackerNews;2020-06-07;i see microservices as a peopleteam architecture. it's a way to scale up people and define boundaries around who is responsible for what without having to standardize how everyone implements what they are responsible for. just expose it as a rest api. problem solved. and problems created. this isn't all bad it just isn't a everyone should do this and all your problems will go away architecture. that architecture doesn't exist.;0
23450470;HackerNews;2020-06-07;without going into detail on the actual debate i just want to make a meta point here if you are writing an article and the following all technical challenges ... will not be magically solved by using microservicesis the key statement of your article then you should really consider adding a lot of nuance or not publishing it at all.;0
23450466;HackerNews;2020-06-07;what in case when that „service is actually a thousend of „microservice instances thats communicating with other „services via some „api gateways?and the teams managing those „services do full devsecops? 10 people working on such component is actually pretty decent team size for that task...;0
23450452;HackerNews;2020-06-07;this is true for moderatelysized microservices. if your microservices are itooi small though it's essentially impossible to write integration tests of the overall system as a wholeany such test would need to spin up n different dependencies.;0
23450442;HackerNews;2020-06-07;i think there's a tendency to believe that a microservice written by someone else can be replaced with a stub that just validates json or something.but in my experience that thinking leads to bugs where the json was correct but it still triggers an error when you run real business logic on it.it's an easy trap to fall into because that microservice exists to abstract away that business logic but you can't just pretend it doesn't exist when it comes to testing.so stubs may be good for unit tests but only if there are integration tests to match.;0
23450438;HackerNews;2020-06-07;microservices are the actor model erlang or akka except they require lots of devops work being on call for x services every night and a container management system like kubernetes to be manageable.actors are a simple solution to the same problems microservices solve and have existed since the 1970s. actor implementations address the problem foundationally by making hot deployment fault tolerance message passing and scaling fundamental to both the language and vm. this is the layer at which the problem should be solved but it rules out a lot of languages or tools we are used to.so in my opinion microservices are a symptom of an abusive relationship with languages and tools that don't love us grow with us or care about what we care about.but i also think they're pretty much the same thing as ejbs which makes kubernetes google jboss.;0
23450434;HackerNews;2020-06-07;and a crossconcern fix that a dev used to be able to apply by himself in a day now has to go through 5 teams 5 programming languages 5 kanban boards and 5 qa runs to reach production.if you ever find yourself in that situation rest assured that something went wrong way before the decision to use microservices was made.if your systems are that tightly coupled you'll have problems regardless of architecture.;0
23450403;HackerNews;2020-06-07;i came here to make a similar point. i see two big benefits to microservices neither of which is spoken to by the article1. using smallish i hate the word micro domainbounded services leads engineers to think more carefully about their boundaries abstractions and interfaces than when you're in a monolith. it reduces the temptation to cheat there.2. conway's law is real. if you don't think very deliberately about your domain boundaries as you code then you'll end up with service boundaries that reflect your org structure. this creates a lot of pain when the business needs to grow or pivot. smaller domainbounded services give you more flexibility to evolve your team structure as your business grows and changes without needing to rewrite the world.i'm a big fan of the monolith first approach described by martin fowler. start with the monolith while you're small. carve off pieces into separate services as you grow and need to divide responsibilities.a multi service architecture works best if you think about each service as a component in a domaindriven or clean architecture model. each service should live either in the outer ring where you interface with the outside world or the inner ring where you do business logic. avoid the temptation to have services that span both. and dependencies should only point inward.carving pieces off a monolith is easier if the monolith is built along clean architecture lines as well but in my experience the full stack frameworks that people reach for when starting out e.g rails django don't lead you down a cleanly decoupleable path.;0
23450374;HackerNews;2020-06-07;this is a completely unrelated issue. microservices have nothing to do with access control. if anything they should lend themselves to more fine grained control but again microservice architecture says nothing about it.;0
23450350;HackerNews;2020-06-07;you'll never achieve the level of operational stability of an air gap that you would without a strictly in process system.shared state is part of it. isolation of failure is another. your haskell code can still blow up.immutability makes that way easier to recover from but it's just one part.of course microservices are much more than processes over a network they're a discipline. and i think one can go much further than microservices as well microservice architecture doesn't tell you ihowi processes should communicate it's more focused on how they're split up and leaves the protocol to you. good protocol design is critical.;0
23450342;HackerNews;2020-06-07;i read the explanation and i think the answer is still it depends. think about it this way in your kitchen you dont just have 1 kind of knife. you probably have 2 or 3 different kinds of knives if you're doing basic stuff and maybe 5 to 10 different knives if you're a top chef.the same applies to systems architecture. microservices isn't the only solution or the best solution.case in point i've worked on highfrequency trading systems for much of my career. the early systems circa 20002005 were built on top of pubsub systems like tibco rv or 29west this was effectively microservices before the term was used popularly.what happened around 2006 was that the latency required to be profitable in highfrequency came down drastically. strategies that were profitable before needed to run much faster. the result was to move to more monolithic architectures where much of the tick to trade process happened in a single thread.point is use the right tool for the job. sometimes requirements change and the tools needed change as well.;0
23450272;HackerNews;2020-06-07;the central premise of microservices architecture is that the services manage their own data.if you have a shared data store then you are not really implementing microservices. in fact the linked article by martin fowler pretty much describes it as the opposite of what you are describing;0
23450266;HackerNews;2020-06-07;if you have ten people working fulltime on it it is not a microservice it is just a service.i think the discussion about microservices has suffered more than anyone realises from a lack of shared understanding about what a microservice actually is.;0
23450259;HackerNews;2020-06-07;microservices are useful but not for the reasons listed here or the reasons often assumedpersonally i'm more a fan of realm of responsibility scoped services to decouple technologiesdatastores of parts of a system that do not interact by design for instance your user account credentials handling from literally anything else and then use a system like kafka with producerowned format to have a common data bus that can tolerate services that process data asyncronously or even things that keep users in the typical refresh loop dying for a bit.;0
23450243;HackerNews;2020-06-07;this is absolutely a fallacy. if you're testing a microservice and stubbing the other microservices you aren't doing the equivalent of the highlevel test on the monolith. you're doing something like a macrounit test of the monolith with internal services stubbed.;0
23450219;HackerNews;2020-06-07;microservice testing come with version combination hell.if you have 10 microservices each of which can be on one of two versions that's 1024 combinations. how do you test that?;0
23450158;HackerNews;2020-06-07;a major benefit to microservices over monoliths that i havent seen mentioned yet is testability. i find it hard or improbable to achieve a healthy pyramid of tests on a large monolith.for example a high level black box test of a service endpoint requires mocking external dependencies like other services queues and data stores. with a large monolith a single process might touch a staggering number of the aforementioned dependencies whereas something constrained to be smaller in scope a microservice will have a manageable number.i enjoy writing integration and api tests of a microservice. the ones that we manage have amazing coverage and any refactor on the inside can be made with confidence.our monoliths tend to only support unit tests. automated endtoend tests exist but due to the number of dependencies these things rely on theyre executed in a live environment which makes them hardly deterministic.microservices allow for a healthy pyramid of tests.;0
23450116;HackerNews;2020-06-07;stop off! drop a bunch microservices into the same network without any access control and you don't have a physical barrier at all! in fact it becomes even harder to have a clue as to what's interfacing with what unless you can observe your inter process traffic.;0
23450033;HackerNews;2020-06-07;thats wild. microservices are mostly beneficial organizationally a small team can own a service and be able to communicate with the services of other small teams.and a crossconcern fix that a dev used to be able to apply by himself in a day now has to go through 5 teams 5 programming languages 5 kanban boards and 5 qa runs to reach production. i never understood the appeal of teams owning services. in my dream world every engineer can and should be allowed to intervene in as many layersslices of the code as his mental capacity and understanding allows. artificial and sometimes bureaucratic boundaries are hurtful.to me it's the result of midtosenior software engineers not being ready to let go of their little turfs as the company grows so they build an organizational wall around their code and call it a service. it has nothing to do with computer science or good engineering. it is pure conway's law.;0
23450027;HackerNews;2020-06-07;for the most part this level of microservice solves the problem of new engineering leader comes in. new engineering leader wants to rewrite the entire thing cause it sucks. business doesn't have resources to rewrite for the nth time. new leader and business compromise to create a microservice. rinse and repeat. cloudcontainervm tech as really allowed this pattern to work. the art of taking over an existing codebase keeping it going at low cost low overhead is gone. nobody's promo packet is fulled with sustainment work. one microservice per promotion. etc etc.;0
23449996;HackerNews;2020-06-07;that just adds one failure mode to the list of failure modes people ignore due to the happypath development that languages with unchecked exceptions as default error handling encourage.there are only two meaningful failure modes persistent and transient. so adding another transient failure network partition is not extra work to handle. except not because just dump that on a databasekvstore is an alltoocommon workaround chosen as an easy way out.just to be clear microservices are not just separate binaries on a network. if you're not following the actual patterns of microservice architecture... you're just complaining about something else.;0
23449973;HackerNews;2020-06-07;that statement goes against everything i have learned about soa and microservices.;0
23449968;HackerNews;2020-06-07;they force you to not share memory on a single system they encourage you to focus on how you communicate they give you scale and failure isolation for force you to handle the fact that a called subroutine might fail because it's across a network.the problem distributed systems are hard to get right. better stay away from them unless you really need them and you have the timeresources to implement them correctly. the benefits of microservices are a bad excuse most of the time.;0
23449910;HackerNews;2020-06-07;at a goto talk an uber engineer said they had so many microservices it was impossible to really count how many they had;0
23449893;HackerNews;2020-06-07;microservices make the boundary between units defined and forces api design on those boundariesuntil one engineer say hmmm why adding a new endpoint in their service while we could simply connect our microservice to their database directly;0
23449886;HackerNews;2020-06-07;however your codebase has now to deal with network and multiple processes.here's the thing i see repeatedly called out as a negative but it's a positive!processes and networks are amazing abstractions. they force you to not share memory on a single system they encourage you to focus on how you communicate they give you scale and failure isolation for force you to handle the fact that a called subroutine might fail because it's across a network. f your codebase has failed to achieve modularity with tools such as functions and packages it will not magically succeed by adding network layers and binary boundaries inside itfunctions allow shared state they don't isolate errors. processes over networks do. that's a massive difference.if you read up on the fundamental papers regarding software reliability this is something that's brought up ad nauseum. this might be the reason why the video game industry is still safe from this whole microservice trend.performance is more complex than this. for a video game system latency might be the dominating criteria. for a data processing service it might be throughput or the ability to scale up and down. for many microservices have the performance characteristics that they need because many tasks are not latency sensitive or the latency sensitive part can be handled separately. would argue that by having to anticipate the traffic for each microservice specifically we will face more problem because one part of the app can't compensate for another one.i would argue that if you're manually scaling things then you're doing it wrong. your whole system should grow and shrink has needed.;0
23449884;HackerNews;2020-06-07;microservices make the boundary between units defined and forces api design on those boundariesno it doesn't. google distributed monolith to read some horror stories.bad architecture or good architecture without enough quality control over time will cause these issues one way or another.there's no silver bullet for this.;0
23449879;HackerNews;2020-06-07;the author is totally right about the http layernetworking stuff. i don't think you have to reimplement sql transactions but you do need a backing store that allows acknowledging a message has been processed and not downsides to processing the same thing twice idempotent.i did a post about microservices as i've seen them and i see the more as software evolution matching that of our own biological and social evolution like our own immune system the thousands of moving parts have somehow evolved to fight infections and keep us alive but it's easy to not be able to understand how any of it really works together.;0
23449860;HackerNews;2020-06-07;dont blame dijkstra for that. ithe original title of the letter as submitted to cacm was a case against the goto statement but cacm editor niklaus wirth changed the title to go to statement considered harmful.iso dijkstras choice for a title would be a case against microservices.;0
23449859;HackerNews;2020-06-07;you arent really implementing a microservices architecture in that case though.the idea of microservices is that they are selfcontained not just middleware to a monolithic backend.;0
23449851;HackerNews;2020-06-07;data api over http spaghetti is surely a bad way to do microservices some accidental exclusions apply1. and if you'd have to do crossservice transaction or jump back and forth through the logs tracing the event as it hops across myriad of microservices it means that either your boundaries are wrong or you're doing something architecturally weird. it's probably a distributed monolith with inprocess function invocations replaced with network api calls something worse than a monolith.at my current place we have a monolith and trying to get services right by modelling them as a sort of events pipeline. this is what we're using as a foundation and i believe it addresses a lot of raised pain points full disclosure i'm not personally affiliated with this project at all but a coworker of mine is.1 at one of my previous jobs i've had success with factoring out all paymentrelated code into a separate service unifying various provider apis. given that this wasn't a true service but a multiplexeradapter in front of other apis it worked fine. certainly no worse than all the thirdparty services out there and i believe they're generally considered okay.;0
23449768;HackerNews;2020-06-07;this misses some of the main reason microservices are nice its much easier to change code that isnt woven throughout a code base. microservices make the boundary between units defined and forces api design on those boundaries. yes you can properly design these abstractions without a service boundary but having the forcing function makes it required.;0
23449762;HackerNews;2020-06-07;like almost anything when not used for the correct application. say a hammer to insert a screw. it is not a good idea. one of my favorite things about using microservice is that you can use multiple languages. this can grant you the ability to use a language which is better for the task or for other programmers to contribute in their favorite language.;0
23449756;HackerNews;2020-06-07;if your codebase has failed to achieve modularity with tools such as functions and packages it will not magically succeed by adding network layers and binary boundaries inside itthis is assuming you're converting an existing nonmodular monolithic service to micro services. if you're starting from scratch or converting a modular monolithic service then this point is moot. it says nothing about the advantages or disadvantages of maintaining a modular code base with monoliths or microservices which is what people are actually talking about.;0
23449744;HackerNews;2020-06-07;a recent blog post by neobank monzo explains that they have reached the crazy amount of 1500 microservices a ratio of 10 microservices per engineerthats wild. microservices are mostly beneficial organizationally a small team can own a service and be able to communicate with the services of other small teams.if anything i think a 101 software engineersservices is probably not far off from the ideal.;0
23449738;HackerNews;2020-06-07;microservices are middleware. that's they way i treat them anyway. i build them as the glue between the backend and frontend. they handle things like authentication business logic data aggregation caching persistence and generally act as an api gateway. i really only ever use microservices to handle crosscutting concerns that are not directly implemented by the backend but have a frontend requirement. the only way that is harmful is if you write bad code. bad code is always harmful.;0
23449736;HackerNews;2020-06-07;i wish dijkstra had named his article on the go to statement1 something else. it feels like every other author nowadays want to use the sense of authority that the considered harmful gives them. like it's obvious and widely accepted that it's harmful and they're giving you an fyi.just name it the downsides of microservices and we'll know that it's your personal opinion. this title might get you more clicks but it's a turn off for me.1;0
23449672;HackerNews;2020-06-07;microservices were never about code architecture they were an organisational pattern to enable teams to own different services. most microservices don't actually look micro to those implementing them because it's really just a lot of services.for my personal projects i just have a frontend service http server and a backend service api server. anything more is overkill.;0
23449637;HackerNews;2020-06-07;while i agree with the notion of treating microservices with caution i found the article a bit too shallow barely supporting the claim. especially the second fallacy reads like a draft and it overall ends abruptly.;0
