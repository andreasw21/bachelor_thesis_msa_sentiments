ID;Source;Creation Date;Content;Sentiment
23017160;HackerNews;2020-04-29;Title:Why Segment Went Back to a Monolith, Content: https://www.infoq.com/news/2020/04/microservices-back-again/;0

23067252;HackerNews;2020-05-04;on the other hand if a memory leak concerns one key microservice your whole operation is also likely to suffer even if 99 of services run fine.;0
23060927;HackerNews;2020-05-03;this thread considered an issue whether services and microservices are equivalent concepts. they are not. there is a quality that is held by microservices yet which is not universally held by services.you have observed that other services also have that quality. indeed. nowhere did i say all services with decoupled deployment are microservices.;0
23040980;HackerNews;2020-05-01;like computer lib dream machines where you flip it over backwards to get the other book! and of course the microservices section should be really thin while the monolith section is extremely thick.like popedotninja pointed out you can just flip the book over when one approach starts to peak. vcf east xi ted nelson ted nelson designed the xanadu hypertext software and wrote the twoinone personal computing book computer lib dream machines in 1974. his work deeply influenced the personal computing revolution. ted earned two ph.d.s and penned several other wellregarded academic papers and books about ethical historical and moral issues in computing. computer libdream machines is a 1974 book by ted nelson printed as a twofrontcover paperback to indicate its intertwingled nature. originally selfpublished by nelson it was republished with a foreword by stewart brand in 1987 by microsoft press.in steven levy's book hackers computer lib is described as the epic of the computer revolution the bible of the hacker dream. nelson was stubborn enough to publish it when no one else seemed to think it was a good idea.;0
23040882;HackerNews;2020-05-01;maybe it's because you weren't able to explain why you thought microservices can be really bad or your explanation didn't hold water. so what was the explanation you gave them or do you not want to say?or perhaps there are other reasons you're simply not recognizing? like your sarcastic tone?;0
23032345;HackerNews;2020-04-30;it seems like a lot of the issues were around sharing code and libraries resulting from isolated codebases per service and the versioning hell of shared libraries.i work in a org that migrated to microservices over time but intentionally adopted a monorepo approach as part of it. it works quite well and seems to avoid a lot of the pain points expressed here while also gaining the benefits of microservices.there are definitely tradeoffs to the monorepo approach. it makes development on shared libraries more delicate and stressful however this can be mitigated by more robust crossservice ci and i definitely think it's a worthwhile tradeoff to the painful cycle of shared lib versions diverging across services and finding issues when some service finally gets around to upgrading its version weeksmonths after shared lib changes.;0
23030086;HackerNews;2020-04-30;often they didnt. how many stories have we all heard about wow.. transitioning to microservices was way harder than we expected followed by a move back to monolith instead of fixing the issues.that doesnt mean a micro service architecture is wrong... just that you have to either learn from your mistakes or hire an amazingly talented team... that have learned from mistakes somewhere else.;0
23029303;HackerNews;2020-04-30;if you're up for a humoristic take on microservices you could have a look at this video;0
23027984;HackerNews;2020-04-30;the general view of microservices was largely invented out of thin air when you look at martin fowlers wiki or adrian cockcrofts presentations which were the originating popularizers of the term it was all a reasonable refinement of soa.but then youd get some that would make bizarre claims like a microservices must be under 100 lines of code. shrug;0
23026522;HackerNews;2020-04-30;where you can get into trouble is if the problem affects all your instances across the entire cluster. if all your organization's code is running in the same process if any of that code has a severe memory leak or other serious issue it could impact the stability of everything else.not to say that wouldn't happen for spof microservices e.g. your auth servers but the surface area is potentially larger for monoliths.;0
23025177;HackerNews;2020-04-30;i dont think this is accurate. ive worked at companies that did serviceoriented architecture long before the rise of the term microservice and it was clearly recognized that different services shouldnt be so coupled together you cant redeploy them separately.;0
23025121;HackerNews;2020-04-30;my org is starting to migrate from a php monolith to microservices as a way of freeing ourselves from php.microservices will require more time spent writing interservice apis and code execution will be slower since many procedure calls will require data serialization and network requests. but we believe it will be worth the overhead to not be locked into php for every new component of the project.;0
23024884;HackerNews;2020-04-29;honestly that sounds like the devops team didn't communicate well with the business when they pitched them microservices. the business can't reasonably know that moving to microservices entails a change in infrastructure and toolingyou have to build that into your high level estimates.;0
23024606;HackerNews;2020-04-29;that advice of starting with a monolith has consistently been given by those involved in microservices since the start. i remember a fowler article in particular. unfortunately the if you only have a hammer everything is a nail analogy holds true when people start looking at where microservices may fit into an overall system architecture. their answer is invariably everywhere!really small reusableshareable and stable domains are the sweet spot for microservices. as you say that is most likely to come from decomposing from a monolith. microservices can really help with building rich domain components in an overall architecture and removing complexity from other components through delegation to the microservice is my experience. they just don't need to be everywhere.the same problem of overeagerness is becoming apparent with some of the movement to eventbased architectures. people become obsessed acolytes and there is no other way. when in fact they may well be ideal for a portion of your overall system architecture but are unlikely to serve it all well.;0
23024132;HackerNews;2020-04-29;like others have mentioned here simply pointing out examples where microservices have failed doesn't imply that microservices can't succeed. i've attempted to bake bread twice and they both failed. i didn't conclude that baking bread can't be done but that my skills to do it were insufficient.there are lots of examples of successful companies using microservices but i believe the real problem is in defining what constitutes a microservice. most people call things microservices that are nothing of the sort. i can unequivocally say if you built a service that depends on other things being 100 available like another service than you haven't built a microservice ie those things you built shouldn't be called services.by that token autonomy is a pretty important factor. the udi dahan teachings currently available for free promote this style of architecture. a concrete example of a toolkit for building itruei microservices can be found in message db andor eventide i wouldn't suggest however that anyone can just watch the course pick up these tools and succeed. like baking a good loaf of bread it takes a lot of skill work and experience. whether or not you succeed at building microservices is ultimately up to you and your team.;0
23023922;HackerNews;2020-04-29;that may sound cynical but if we agree that software development is a show bet entertainment whatever for investors in 99 then microservices are good to keep people excited.;0
23023590;HackerNews;2020-04-29;i mean you admit it yourself far too often the splitting off is inappropriate. normally an inappropriate microsservices is a net negative over all that costs you money in the long run. just because its working doesn't mean it is efficient.my last two assimilations where because one microservice was written in java. the original guy left and no one around the company likes to touch java or pretend they don't knowdo it which means it was alaways me who had to update it. it was a very small service likely why he thought small micro! but it was about 3 hours of work in the monolith. now anyone can updatecontribute to it and not bug me every timethe other was a microservice that only served the monolith. new features required the monolith to be updated in order to realize the new features.;0
23023521;HackerNews;2020-04-29;sharing databases across services micro or not is generally a pretty bad ideai don't think such a blanket statement is justified. there are plenty of situations where it may make sense to pull out some functionality into its own serviceso it can be written in a different language scaled independently isolated from failures or whateverbut where giving that service its own separate database would be serious overkill complicating ops and introducing potential data integrity issues for no real benefit.if your deployment relies on synchronized service deployments you really dont have independent services at all.so what? that's really the point blindly following the microservices tm doctrine is often a mistake. it's better to just solve whatever problem you're facing in the simplest possible way. while that imayi mean bythebook microservices with independent databases in many cases something in between is a better choice.;0
23023424;HackerNews;2020-04-29;another aspect no one seems to talk about is whether your deployment is monolithic or fragmented. it seems like a lot of the pain of managing microservices comes from designing a coherent cicd pipeline how to share libraries between various microservices etc. if you have a monorepo good build tooling and a good infrastructure as code tool i think much of that pain goes away but none of those things are easy and the precise selection and combination of tools depends a lot on your organization i wouldn't recommend bazel or nixbuild toolsto a small or mediumsized organization for example.;0
23023328;HackerNews;2020-04-29;it's also really hard. trying to determine how to split up any code base into logical divisions such that you when adding the next 5 years of functionality you'll have the fewest number of cross division processes is hard.this is why martin fowler recommends starting with a monolith and refactoring into microservices unless you have extensive experience building out very similar applications in the same domain.;0
23023251;HackerNews;2020-04-29;monolith microservices difficult refactoring i guess my point is that it doesn't have to be complicated if you architect the monolith carefully. that usually doesn't happen though because frameworks don't necessarily promote the practice and projects are short sighted.;0
23023040;HackerNews;2020-04-29;as it is so often the case the choice between monolith and microservices is not a binary one rather it is a sliding scale between two extremes.on one end we have a real monolith a single executable binary with no external dependencies apart from the os bindings. this is very rare in practice and most commonly found in games and probably mobile apps when it comes to webbased services even a traditional idea of singlecodebase app usually has a sql database as an external dependency.on the other end of the scale there is a complex system consisting of hundreds or even thousands 0 of tiny services that require complex orchestration mechanisms such as a service hub or service mesh.so each team in a wide sense could be a company organisation department etc needs to consider where they fall in the continuum considering a which architecture will provide most benefit while b still being maintainable by the team both the architecture and the team need to evolve together.0;0
23023008;HackerNews;2020-04-29;monolith microservices difficult refactoringmicroservices monolith difficult refactoringmicroservices with poorly chosen context boundaries microservices with well chosen context boundaries very difficult refactoring.;0
23022954;HackerNews;2020-04-29;if it's working well why change it?if your coworkers argument is just microservices bad then obviously they are making a mistake. but in the general i've seen far more frequent inappropriate splitting of monoliths than inappropriate combining of microservices. this is honestly the first time i've heard of it.;0
23022953;HackerNews;2020-04-29;this means you're effectively building a monolith with a microservice architecture. is that really what you want?i actually kinda do want that although maybe it's a niche thing.it would be nice to be able to deploy a monolith that's already cut at seams where there's an obvious api boundary. at one extreme you could imagine a single binary where processes communicate via rpc.what that would give you is an easy way to split off microservices as they're needed.i'm sure somebody has done work along these lines.;0
23022687;HackerNews;2020-04-29;as matt easton says context!i think 5 whys might be a useful exercise here.why was building x as a microservice faster? reason? well why was that?imy general rules for this are to always start in a monolith and break things out as they start to fail or break other parts of the codebase and don't go all in just because you now have one microservice that works well by itselfii like this. a key tactic is to always do things such that one can change one's mind!;0
23022373;HackerNews;2020-04-29;if you take a look at some of segment's open source code it isn't hard to see why they wound up struggling with microservices. it looks like they subscribe to the leftpad style of software development. they have tons of repositories that have less than 10 lines of code. they have a two line repository for calling ipreventdefaulti0 a four line repository for getting the url of a page1 and a eight line repository for clearing the browser state that calls into eight different packages2.disclaimer i run a segment competitor. i'm pretty biased but still...0 1 2;0
23022339;HackerNews;2020-04-29;i don't blame them microservices requires discipline careful planning in depth monitoring and debugging capabilities and whole different mindset. very few companies can implement it successfully.;0
23022290;HackerNews;2020-04-29;if microservices are implemented incorrectly or used as a bandaid without addressing some of the root flaws in your system you'll be unable to do new product development because you're drowning in the complexity.which is nearly verbatim what some of us have been telling you since before the term microservices was coined.coupling is the problem. yes microservices add friction to coupling but they don't prevent it. coupled microservices exist boy howdy and they're resource intensive resistant to evolution or both.;0
23022168;HackerNews;2020-04-29;monolith vs microservice feels like a higher level case of the expression problem.;0
23022148;HackerNews;2020-04-29;before going full microservices try writing your code in a hyper modularized way and see if this doesnt solve your problem first.;0
23022114;HackerNews;2020-04-29;i've found it most helpful to think in terms of deployments each microservice effectively gets deployed independently.one implication of this is you need to ensure your apis are backwards compatible with any other services even if it's only one service that your team also manages. this also includes databases if shared by multiple services which i won't get into suffice to say congrats your database schema is now also a crappy api.as soon as you start having concurrent deployment dependencies that is the updates for service a b ibothi have to be deployed at the same time or things are broken you've effectively built a monolith anyway just with an annoying code layout eg spread across multiple repositories.you can use orchestration to tie these deployments together but this means you're effectively building a monolith with a microservice architecture. is that ireallyi what you want?;0
23022037;HackerNews;2020-04-29;i am not saying thats how soa was defined just that it was used to refer to such team organization around architecture. ex iamazon famously uses a serviceoriented architecture where a service often maps 11 with a team of 3 to 10 engineers.i at the beginning microservice was generally viewed as more granular than soa though thats been backed off of.;0
23022024;HackerNews;2020-04-29;i have an idea. bring the concept of microservices into software!within software module interfaces that can only communicate with one another via socket like serial interfaces with no type checking!or simply have all your software modules running as forked processes on the same hardware and have them all communicate with one another via sockets or http. that means every software module must be it's own server!to further imitate microservices make sure that code in one software module can never ever be moved to another software module. make it hard to reorganize things. also make sure teams can only ever work on one section of the code base.does the above make any sense to you? if it doesn't make any sense to you it's probably because code organization using microservices doesn't make any sense period because the examples above are literally doing the same thing in software that is done in hardware.if it does make sense to you then why are you using microservices to add extra complexity to the code? if you can do the same in software then you'd be doing the exact same thing as the hardware equivalent minus the extra complexity of multiple containers or vms.don't use hardware to organize code use code to organize code and use hardware to maximize performance.;0
23021980;HackerNews;2020-04-29;at my current place of work we have1 monolith and 2 microserivcesworking in the monolith is fine but running tests is slow because it is a giant rails app that is 7 years old.there is 1 microservice that does its thing and the few people who need to interact with it like it.the second microservice was created deployed and abandoned. now people want to move it into the core monolith. it is a distinct unit of functionality that doesn't really have any overlap with the core app. i'm going through and adding all of the tooling to this project because it enables us to solve a certain class of problem report generation that the monolith can't do very well for a couple of reasons. articles like this have fueled the fire to recombine it but the pain points have nothing to do with this particular service being separate.;0
23021934;HackerNews;2020-04-29;a subroutine is a service.which makes the term microservice even weirder given that any microservice is going to be bigger than a single subroutine.;0
23021877;HackerNews;2020-04-29;i saw a talk with alexandra from segment before. when it makes sense to go with monolith it makes sense.when it makes sense to use microservices it makes sense.doing anything for no reason whatsoever never makes sense.that is all.;0
23021782;HackerNews;2020-04-29;microservices in terms of code organization was always a redundant concept.you can organize code with functions and namespaces why do you need hardware to segregate code? it only makes the segregation permanent but offers nothing else beneficial in terms of code organization.the underlying reasoning was always that developers tend to move outside of boxed software modules if it wasn't enforced by hardware so the modules will end up not being modules but everything will be blurred into monoliths.i always figured that if you want really hard lines drawn between software modules you can still do the same stuff in software itself like why do you need actual silicon or vmscontainers to do it?the only real need for different services is performance otherwise all the benefits and downsides of microservices can be replicated in software.;0
23021741;HackerNews;2020-04-29;i think microservices work well in organizations that are big enough to have a team per microservice.presumably by definition were talking about a few hundred lines of code or a couple of weeks development time here at most. what does this team do all day otherwise?;0
23021732;HackerNews;2020-04-29;we do separate code repos my last place did separate repos place before that did monoliths but still did separate repos for anything not in the same monolith. i'm pretty sure it's more common to do separate repos rather than monorepo for separate services.seems to me though the problem is people trying so hard to reuse code. that's the main problem cited in the article. people get really gungho about reusing code and creating shared libraries but reusing code is actually bad most of the time. you should strive to only depend on things that you can reasonably expect to not change and that you don't need to update even if a new version comes out. what you're supposed to do is take that code in the shared library and make it a microservice and obey the usual backwardforward compatibility rules.using a monolith hides that problem because the code remains easy to update and build but just as fragile and in need of heavy testing whenever you change code modules that have multiple consumers. that goes against the idea of monorepos as well.;0
23021714;HackerNews;2020-04-29;what's notably absent are descriptions of problems with versioning interfaces failures from network unreliability or problems managing connecting infrastructure or poor delineation of service boundaries leading to undesired change dependencieswhich is to say it seems like they executed well. there's no sign they fell into common pitfalls.there are definitely some good insights here that i don't often read about. the idea that with a sufficient number of microservices say 50 you not only treat your instances ascattlenotpets you have to treat the service types enmasse ascattlenotpets. this requires more automation and organized management as pointed out by the need for tuned autoscaling rules. this requires continued investment into automating things you would do manually if you had 50 services.the other thing to consider is that going to microservices and back to a monolith is not necessarily a failure. microservices are good for periods of high change velocity once a platform is mostly built requiring much less new development consolidation completely makes sense. at all points we're solving for impedance mismatch whether that's the org structure velocity of changes or numbers of developers vs numbers of deployed units.;0
23021580;HackerNews;2020-04-29;i see a lot of places that seem to either think that1. microservices will let them ship things faster or2. it's microservices everywhere or nothingmicroservices might let you ship faster if you are really good at deciding where to draw the lines between services and really good at managing multiple deployment pipelines and all the infra that's a pretty tough ask.also if you have a monolith it's perfectly fine to pull out one or two parts that need to scale much more efficiently and leave most of your codebase in the monolith but a lot of times i see companies think once you have created one microservice the monolith is now the worst thing possible and it needs to be broken up entirely.my general rules for this are to always start in a monolith and break things out as they start to fail or break other parts of the codebase and don't go all in just because you now have one microservice that works well by itself;0
23021484;HackerNews;2020-04-29;if the question are there any case studies where microservices went well is a valid question then so must be are there any case studies where monolithic architecture went well.my point being that if and only if we have a track record as an entire field of making decisions based on case studies and if case studies have a track record of being objective rather than proffered as a result of a marketing agenda then the question is ultimately legitimate.there are more shops by total count that fail with monolithic architecture. that's inevitable just based on the infinitesimal number of projects executed as service architectures rather than monoliths at large in the wild. but still we carry on with monolithic architectural style as if its outcomes were assured.it's far easier for the vast majority of developers to build a monolith because it allows development to proceed without having to have any knowledge of or practice with the tricks and traps of distributed systems an entire body of knowledge that a developer might never get meaningful and practical exposure to for an entire career.the trouble starts when microservices are attempted by developers who can't imagine that there are entire bodies of software development knowledge that developers aren't presently in possession of.microservices is just as adrian cockroft used to say serviceoriented architecture with bounded contexts.web development is absolutely not a preparatory course in service oriented architecture. but the vast majority of web developers who attempt to take on soa while simultaneously presuming an omniscience in all things software development due to their experiences only with monolithic web development will often fail to build a soa. they usually end up with something that isn't quite soa and isn't quite a monolith. and that's where the failures largely come from.i work exclusively in microservices and soa and have since 2015. before that i worked principally as a web app developer and did some work offandon in soa implementations. and before that i spent years becoming oriented to the architecture. i don't make the mistakes that web developers typically do when they presume that web development knowledge is a sufficient prerequisite for working in soa.so it's not a question of whether an architectural style works or doesn't. the majority of failures in microservices can be attributed to ignorance and to the narcissism that is permissive of it.so i would ask this question instead are there any cases where developer overconfidence and oversimplification went well?these qualities don't tend to serve any architectural style well.i've never heard of a welldesigned soa not going well. every single case of microservice project remediation that i've participated in had as the most significant contributing factor an utter disregard for the body of knowledge that the microservices architectural style is built upon.there are a lot of things that developers can get away with when doing the kinds of tinkering and wandering that typifies typical web development work. but those things don't work once we cross the line into soa. and unfortunately the incessant chasing after trivial resumé candy hasn't prepared the average developer for the rigorous mindset needed for soa work.as microservices became to next fad for perennial fad chasers of the software development world they finally encountered a kind of work that they could not get away with by faking it. and so we see a lot of failures. but the vast majority of the failures are personal failures and character failures rather than failures of an architectural style.the fat part of the developer bell curve was simply overreaching when it presumed to try to get away with building service architectures with the same level of disinterest in architecture and process that we can get away with in typical web development. like a kid with copious experience building kites presuming to strap themselves to a hang glider and just going for it. the outcomes are mostly predictable.in the end if a little time is invested in learning the fundamentals that have so far been eschewed for the sake of expediency anyone can succeed with soa and microservices. it's not that the realities of the architectural style are unlearnable but it can't be arrived at by the level of tinkering and wandering that we can just get away with in monolithic web development.;0
23021260;HackerNews;2020-04-29;oh all of those were heavily modularized to begin with. but that wasn't enough to keep them manageable. so at the end what we did is figure out which are the core components between the different modules isolate what they did and put them aside in a smaller microservices which were easier to track maintain and monitor. what was once the monolith is now arguably just an interfaceapi for all the heavy lifting which is done by microservices. again my point is that all this must be done depending on the scale and complexity of your application. if you are going to make an authentication microservice for an application that has 50000 users which simply fetches a username and compares a hash in a database obviously you are doing it wrong. i am talking about applications which in the simplest of times operated on 24 different databases located in completely different geographical locationsthe case of my first such monolith. some of those databases used different engines. and due to the nature of the infrastructure and the requirements we couldn't simply ditch everything and start over from scratch. so splitting everything into microservices was the only option. and this is something i was working on back in 2012 iirc so back when microservices were considered witchcraft by most people. and yes i'm talking about several million lines of code and 2 developers my inexperienced out of uni ass and an utterly conservative dev twice my age. took us around 6 months but the project was extremely successful.there is this trend in technology every few years everyone changes their minds about everything 2012 sql is the best. 2016 sql sucks nosql is the future 2020 nosql suck sql is the best. 2024 fill in the blank.the same thing is happening with microservices. but in addition docker kubernetes and recently unikernels have joined the party. the concept is the same though.what i am trying to say is that either of those can be good or bad in different scenarios. it's a question of picking the most appropriate one for the situation.;0
23021255;HackerNews;2020-04-29;i don't agree with your premise that development structure deployment structure. there are plenty of good ways of splitting up development of a monolith without the huge devops headache of deploying microservices.;0
23021184;HackerNews;2020-04-29;i cannot agree more i worked at a company where we went from a monolith deployed on iaas with a couple handful of engineers to docker containers deployed on ecs with over 200 engineers. the main reason we did it was because dockerecs was cheaper than a bunch of ec2 instances and you can't effectively use 200 engineers with a single monolith.after 2 years we had over 450 microservices while keeping our aws bill flat or slightly decreasing.;0
23021139;HackerNews;2020-04-29;that's generally true and it's a big problem with microservices because they need so much upkeep.but if your code is living as a few hundred or thousand readable lines in the common codebase that isn't really a problem. the code is there readable and working and if anyone needs to change it they can. if it falls out of fashion it can be deleted.;0
23021132;HackerNews;2020-04-29;why do you assume they have more fault tolerance scenarios simply because they have more deployable units?in every service architecture i've worked with in the last few years you could theoretically run every single service within the same physical process provided they all shared the same runtimelang the way a monolith does. i tend to start service architectures using ruby exclusively with the eventide toolkit so this is actually a viable approach for most teams i've worked with. but it's never ultimately made sense. weighing the proscons a consolidated deployment topology wouldn't add any benefit and it would actually make it far more difficult for the operations folks practically speaking.i've helped put services into production that 1. carry out crucial core business logic reliably and efficiently 2. can be scaled horizontally without changing the code 3. never raise exceptions or cause outages and 4. don't need to be touched for years because new features are more naturally composed around them anyways i.e. openclosed principle. practically speaking it's quite a bit easier for human programmers to reach this degree of precision with a smaller program than with a much larger one. and if you add up a lot of these high quality programs you get a high quality system. building a high quality system out of a single program is much much harder for humans in practice.i'll use crude terms here for a second every igoodi service put into production brings a net benefit to the organization relative to the same code having been entangled with an existing pile of code. that may sound like a no true scotsman fallacy but the idefinitioni of good in this context is precisely the net benefit being added. if you build and deploy services that have a high degree of quality you get a corresponding benefit. if you build and deploy programs that don't stand on their own don't leverage durable messaging and take other programs down with them when they crash then you get a rather large mess on your hands. in fact you never had a service architecture at all we call this failure mode a distributed monolith.i'll acknowledge that most attempts at microservice architectures in the wild don't seem to succeed. anecdotally they are particularly prone to failure when their architects don't understand the underlying principles of distributed systems all that well they neglect important considerations like messaging idempotence the deleterious effect of synchronous requestresponse messaging and the need for deliberate thoughtful design. in other words they build systems out of n number of microservices and get n2 fault tolerance scenarios which you adeptly called out for being foolish. they're arguably worse off than if they went with a monolith but neither would be an architecture i'd personally want to work with.;0
23021077;HackerNews;2020-04-29;in all honesty i think the monolithmicroservice distinction misses the point a little bit.it's inevitable that the longer the codebase exists the more difficult it is to maintain. it's a battle that you can't necessarily win and it's turtles all the way down as your dependencies and their dependencies tackle the same issues.all it takes is one or two roughly defined apis and you've already created the nucleation point for evermore tech debt and while you'll be able to tame some of it you won't manage all of it due to business requirements or other teams depending on private apis to save time or whatever else you can imagine. switch the architecture and you'll either have all your problems bunched in one codebase or you'll have distributed your problems all over the place.i'd go as far as saying that a perfect monolith and a perfect distributed architecture are theoretical ideals that require perfect communication to build them.;0
23021064;HackerNews;2020-04-29;yep each single microservice is simple ... but the whole is not.i always find it more interesting what's not in the single microservices the stuff you do see. when you make a diagram with boxes and arrows the interesting stuff would be the arrows not the boxes themselves.;0
23021051;HackerNews;2020-04-29;this is a discussion on pretty much every team i've been on for the last 5 or so years. i agree mostly this stuff is done for the wrong reasons.imho it doesn't matter if you replace microservices by components corba objects rpc objects soap services etc. it all boils down to chopping your software into smaller bits that than immediately start having a need for sending messages between them finding each other defending their boundaries etc.so the first mistake would be assuming this is a new problem to think about. it's not. you can find similar debates about how to chop up software ever since people moved beyond just having their code ship in punch card form.the right discussion to have would be first deciding whether you want to break down by your logical architecture so that your deployment architecture reflects that or your organization diagram aka. conway's law. then the next step is deciding whether your primary goal is network isolation of unrelated chunks of code or enabling asynchronous development of these chunks of code if so there are other solutions. usually it boils down to again conway's law different teams just don't want their stuff to depend on shit happening in another team because of internal bureaucracy and hassle.now say you have a valid business reason or technical reason for actually wanting to have different stuff be isolated e.g. for scaling reasons or security reasons. the next step is deciding whether this means you also want to break up your code base. monorepos and microservices are a thing. look at e.g. lerna for node.js or multi module gradle projects on the jvm. in go this is well supported as well. if you're really sure that you don't want micro services because of conway's law there are lots of valid reasons for having a well structured mono repo with a bit of reuse of shared functionality a simplified review process and more visibility in what is happening.imho people do this for completely the wrong reasons like wanting to try out some new language organizational issues etc. that ultimately result in fragmented code bases lots of devops overhead and complexity it's never simple or cheap lots of project management overhead etc. you pay a price.;0
23020944;HackerNews;2020-04-29;there's no need for half of the word to exist.yes there is. a service is a very generic concept to the point it's only relevant as a highlevel concept.the concept of a microservice makes all the sense in the world if you look back to where we came from web services. when compared with all the work and requirements and complications of using soap and wsdl and uddi and everything around just sending small json payloads around and the ability to peel off smaller services leveraging that architecture approach was a far lighter and uncomplicated way of doing business.i mean the name microservices becomes obvious once you look back and all that you see is macroservices.;0
23020886;HackerNews;2020-04-29;i'm reminded of the classic problem of static utility classes where you have functions for say formatting phone numbers or computing a commonly occurring simple mathematical function. it can be difficult to figure out how to better modularize the functionality provided by this class the motivation typically being having a large static utility class often violates the principle of a class having a clear single responsibility. breaking up a large static class into other static classes that better encapsulate some functionalityconcept can help but isn't always the best solution.so lets say we have shared code for doing something like phone formatting. my question for more experienced microservice practitioners is does it make sense to create a microservice for preprocessing data in general? phone numberformatingasaservice is excessive but creating a microservice for processing data where phone number formatting is just one aspect of this service makes sense to me. all other services can throw data at the data processing service and get data back in some sort of standard and expected way conforming to whatever business logicprocessing rules required.;0
23020869;HackerNews;2020-04-29;one view is that the difference between a service and a microservice is that a microservice can be sketched between being a local library or wrapped in an rpc server.;0
23020829;HackerNews;2020-04-29;my takeaway from these kinds of stories is that microservices make sense if it's no longer possible to operate a monolith. by existence proof that was clearly never the case at segment. the common fallacy seems to be that microservices lead to better software via better architecture regardless of human factors like team size. my sense is that it's the opposite microservices are a necessary evil to scale teams past a certain size due to the bottlenecks that emerge with monoliths as more people begin trying to make changes simultaneously and should be viewed as neutral at best in terms of a software architecture pattern to increase reliability performance etc. in practice it seems wise to keep your engineering team as small as possible for many reasons one large one of which is that past a certain point you will be forced to move to microservices. all other things being equal that's a move you don't want to ever have to make.if you have hundreds of engineers then certainly microservice architecture starts to make sense since even the idea of transactional deploys of the monolith break down due to queuing at that scale. but jeeze don't pull that trigger until you actually find yourself backing up on necessary complexity like deploy queues prs stuck due to inability to maintain the branch given the velocity of master etc. don't let conways law lead you prematurely to microservices. if i'm ever in a position where i am feeling real pain that leads to an urgency for microservices i am probably going to first ask the question if i can just fire some people to make the problem go away. the risk of the transition to microservices is just that high.it's the same rule of thumb with other things like hiring feature roadmaps etc yagni. if you are hiring someone before the pain is so high the work cannot be done otherwise building features before you have people explicitly showing the need for them or making deep cross cutting architectural changes that impact everyone before they are strictly necessary due to concrete problems with shipping software you're probably choosing the wrong use of opportunity cost capital etc.;0
23020805;HackerNews;2020-04-29;why can't you have both independently deployed microservices and a shared code base?this is what everyone does so i can't even comprehend what segment was doing. maybe they were deploying a fleet of microservices inside a monolithic deployment? if so there's no wonder it failed.;0
23020723;HackerNews;2020-04-29;a team iperi microservice? that sounds really wasteful. how many microservices need constant evolution?;0
23020650;HackerNews;2020-04-29;split along domain lines with minimum interservice dependencies.exactly and done right that quite often means big 'microservices'.all too often i see the 'functional programming disease' where the aim is to deconstruct to the smallest possible reusable functions 'micro' services right? often prematurely creating high levels of compositional complexity and with zero tools to help you understand how the actual 'app' say payment system works if it's distributed across 20 services.yep each single microservice is simple but the payment system might not be and that's what you need to understand better if your payment system is one thing with maybe one or two things separated out if you need to scale that part.;0
23020641;HackerNews;2020-04-29;i wish more engineering teams would consider spending half the effort of microservices on simply disciplining their monoliths100. this is an uphill battle though. i've encountered so many engineers who equate real engineering with building giant machines. you just can't convince them otherwise.i've watched people build giant realtime stream processing pipelines compromising tons of moving pieces lambda sqs s3 sns stepfunctions etc.. to build... a reporting table and all for... 1.3gb of data. literally.ultimately despite the sell i don't think microservices as a forcing function for good practices works in practice. if the team lacks the skills to build a disciplined monolith then they 100 lack the skills to build a distributed one.;0
23020420;HackerNews;2020-04-29;i bombed an interview before because i said microservices can be really bad.;0
23020337;HackerNews;2020-04-29;i see quite a few people defending microservices the org is the problem they must not have written the software correctly etc. most org structures are not great. most software is not great. if you expect the exception to be the rule you're setting yourself up for a career full of disappointment.microservices are a modern rebranding of serviceoriented architecture but 'microservices' sounds cuter and less like it belongs in javaland and there's some theoretical idea that splitting your app into even smaller pieces will somehow make the whole thing better.soamicroservices solves a few problems and introduces a great many. the original soa proponents were pretty explicit about this. beware! there be dragons here! but one of the main pieces of prescriptive advice from domain driven design is helpful for splitting into distributed services split along domain lines with minimum interservice dependencies. payments is an obvious one. microservices seems to buck much of this advice in favor for a blissfully ignorant principle of small or isolated. good luck isolating something that is not meant to be isolated.scaling software is hard. scaling teams is harder. trying to scale teams by scalingdistributing software is an understandable goal but extremely hard to pull off because of additional complexities and costs you incur in doing so. dev gets harder deploymentops becomes harder testing becomes harder. crossteam communication documentation api publishing and adherence goes from being very low impact within an org to suddenly being critically important.to do soamicroservices effectively you need complete organizational buyin and you have to commit completely to developing tooling and solving all the associated problems in moving to a services approach. often it's easier to just put it all back together organize the code in such a way to minimize merge conflicts and wait for the ungodly slow test suite to run in ci. there are good reasons you rarely hear soamicroservices success stories outside of enormous companies netflix facebook google amazing etc. doing this stuff takes an enormous investment and commitment from the entire organization and there are just lower friction ways to skin this cat if you don't operate at mega web scale.growing a monolith is hard. growing a microservicessoa architecture is also very hard. growing is hard.;0
23020306;HackerNews;2020-04-29;i think that microservice approach is good when you can share those services between many applications in most cases microservices can be the new premature optimization because you can start to lose the focus on the product itself and think about the the microservice as a product;0
23020295;HackerNews;2020-04-29;as with a lot of things it comes down to communication. between teams and between the services they write. which is just another expression of conway's law.this is so accurate. i've heard engineers give state not needing to communicate chillingly as a positive for microservices like we won't need to talk to each other if all of us are working on different services. my other favorite is using microservices as an excuse for why the product isn't working oh imyi service is working fine but ihisi service is doing this when it shouldn't when we're on a small engineering team.;0
23020228;HackerNews;2020-04-29;let me clarify because i wasn't clear in the parent comment.microservices using shared libraries okmicroservices suffering from shared libraries not ok.;0
23020205;HackerNews;2020-04-29;sorry for not being clear.having a shared library is not a bad thing on its own. making the library a bottleneck is the antipattern.if you wish to have a sharedlibrary of microservices you should be prepared to have multiple versions of it running at the same time without any pressure to update everything at once.if your shared library is the bottleneck it means that your microservices are tighly coupled hence the distributed monolith;0
23020199;HackerNews;2020-04-29;thats not quite right soa as originally defined had no mapping to team structure or deployment runtime it was mostly about defining discrete service interfaces and ensuring your clients used that contract rather than back channels to communicate. most often you had a dozen services running in a single app server cluster. conways law was rarely discussed with some exceptions.microservices tended towards a single runtime per service ensuring the deployment lifecycle was tied to the build lifecycle and thus allowing for independent evolution.;0
23020195;HackerNews;2020-04-29;one of the lines is going to be acceptable performance. your phone number formatting microservice is going to be orders of magnitude slower than a client library.the auth service will likely have to hit a db anyways. assuming the microservice call has roughly the same network latency as the db call and the db has 0 response time it would double the total time to perform the auth. it only gets more favorable as db response times go up.more generally i think microservices make sense in scenarios where the time to process the request is longer than the network latency incurred by making it a microservice. things that have to hit a db are generally okay. pure functional things that just compute on cpu and ram are generally not unless they're very computationally expensive like running a simulation or something like that.;0
23020159;HackerNews;2020-04-29;i'm struggling to understand the problem with shared code and the desire to fragment the code repo!why can't you have both independently deployed microservices and a shared code base?if the deployment lifecycle is different for each microservices and each ideploymenti is selfcontained then they can be deployed with different versions of the code even if they use the same source tree and share code.obviously the shared code needs to be properly maintained and evolved but it seems to me a lot of the software engineering problems occur when people move away from source code dependencies with great tooling versioning diffs debuggers to other types of dependencies shared libs etc where the tools are nonexistent or very simple.now granted if you needed to fix a critical bug in the shared code that would require a redeploy of everything but that happens much less frequently than the need to deploy a single service with immunity as long as your keep your microservice contract. it also means the discipline of making sure every services is deployable at anytime is kept to.and if you didn't share code you probably wouldn't be fixing a single bug once you'd have much more code with many more bugs.;0
23020138;HackerNews;2020-04-29;it is probably too late to change the name. but you have a good point the micro prefix is highly misleading. furthermore there is little guidance in the literature on how big the microservices are.;0
23020131;HackerNews;2020-04-29;whatever monothlic or microservice it's all about modularity. monothlic or microservice is just the implementation on how you achive modularity.so the problem here to me is how you design the modularity for your system not how you implement it.;0
23020118;HackerNews;2020-04-29;as a researcher the monitoring and faultpropagation modeling work theyve done to get it to stay up at all is impressive but its not clear all of that tooling would be necessary if they didnt have to reason about n2 fault tolerance scenarios where n 100s of microservices. thats on the order of one fault tolerance scenario for each atom in the universe.that doesn't seem true. i would imagine that at netflix scale you probably have request tracing libraries that can give you a graph of service dependencies. whether it's worthwhile to consume that or easier to just let chaos monkey run rampant is another question.also i very rarely have issues with netflix. typically when i do i can just exit the stream and restart it. anecdata but i could count on one hand the number of times i've had a title just not play or netflix be down entirely.;0
23020009;HackerNews;2020-04-29;having read their articles a few times the issues that they were attributing to microservice architecture were really ci problems.;0
23019997;HackerNews;2020-04-29;there is now a single code repository and all destination workers use the same version of the shared library.what if i told you this is unrelated to microservices? you can keep all of their sources in the same repository sharing dependencies.;0
23019973;HackerNews;2020-04-29;i think we can have both architectures monolith and microservices peacefully coexisting with their own pros and cons.;0
23019962;HackerNews;2020-04-29;i dont know that you need to be much more disciplined to write a large application in a module way vs writing any application in a modular way. a monolith could definitely get messy though if you write them how i see people write microservices.;0
23019908;HackerNews;2020-04-29;i think this is actually one of the reasons that microservices became a thing to begin with teams wouldn't actually apply engineering best practices.microservices actually make you encapsulate your code at least within the microservices because you can't call out to it directly. they don't necessarily iforcei you to implement the single responsibility principle but they do a good job of pushing you. microservices implement a servicelocator pattern through dns or web routing one form of the dependency inversion principle. microservices make you pass data around as entities instead of active record instances.the price for this sort of thing is very steep though distributed systems are inherently icky harder to trace and more prone to failure and besides this you've added network overhead to each service call.i wish more engineering teams would consider spending half the effort of microservices on simply disciplining their monoliths. they might get somewhere...;0
23019903;HackerNews;2020-04-29;there is a related post on segment's blog which helps to get a bit more details and contextsupdate and related video;0
23019822;HackerNews;2020-04-29;by sheer number of attempts somebody probably got good results with microservices somewhere.netflix runs quite well in practice. i think they do redundant service calls what is the only minimally sane way to develop a distributed system. the funny thing is that i have never seen any serious discussion of redundant calls except for it being implicit on practical designs on the anecdotal how it works for us articles that pop once in a while. most times people won't even discuss redundant servers. i imagine everybody thinks it's obvious and well i would agree except for the fact that most people i see do not think so.but well netflix couldn't avoid having a distributed system so they aren't really representative for nearly anybody.;0
23019798;HackerNews;2020-04-29;conway's law is a physical law in the same sense as murphy's law.it's also obviously true. the organization builds the architecture. the architecture either helps or hinders the organization. the organization builds a new architecture. there's no indirect connection here. if you've seen hierarchical organizations implement microservices it's because that organization's complement was a microservices architecture. and likewise for a chaotic organization.well sidetrack aren't strongly hierarchical organizations the best suited for microservices? with all the strongly divided responsibilities and whatnot?;0
23019692;HackerNews;2020-04-29;you're right and i think you've highlighted what makes a good monolith so hard to build and maintain.you need to be disciplined to keep a monolith highly modularized. for microservices in contrast their architecture encourages modularization.;0
23019688;HackerNews;2020-04-29;microservices working well is entirely about the team and my current group of teams works very well with the monolith pattern. a big part of this is because for business reasons not technical ones they frequently trade ownership of parts so if a service isn't well constrained it will be very quickly. we also have mature devops practices and engineers handle significant parts of devops themselves instead of just kicking the can.but the reason i say this is about the team is because i've seen a well built well groomed service be passed off to an outside team and immediately turned into a disaster. same service same business case just a team without the devops savvy and willingness to follow the patterns.netflix does some.. unusual things with microservices mostly with how they treat version rollovers. it's not bad or good but it looks different from how many other shops handle the same problem and it means asking the question is everything working? is extremely difficult but asking the question how many people are able to start watching? is pretty easy.;0
23019634;HackerNews;2020-04-29;are there any case studies where microservices went well?you answered your own question with netflix. while you're right that it's not clear netflix would've needed to develop their chaos monkey tooling and the like it's not clear at all at that an equivalent system is possible as a monolith. even if a monolithic netflix system were technically possible it's not clear if a monolithic system would be organizationally feasible either conway's law;0
23019619;HackerNews;2020-04-29;there was a period of time when service had a different meaning than microservice. a service traditionally may exist across bounded contexts and be almost a minimonolith whereas a strict microservice should touch very few data models and exist strictly in a bounded context.of course real life is messy and plenty of people realized writing small single purpose services was valuable and plenty of people build giant microservices that have nothing to do with the original term and are just badly constructed monoliths.;0
23019587;HackerNews;2020-04-29;they went to 50 services in a few months were applying the same policies across all services. it sounds like they didn't plan well enough and jumped straight into it without any good devops or infrastructure mindset. it was a disaster waiting to happen. this shouldn't be an article that people read and say oh im never using microservices. this should be an article people read and say wow that is exactly the right way to not break apart a monolith.;0
23019461;HackerNews;2020-04-29;there is nothing wrong with most developers working on and communicating about the entire code base. having teams work in silos is not a benefit. you're touting as a benefit what is one of microservices' gravest issues teams stop communicating beyond the surface level of their respective apis.;0
23019283;HackerNews;2020-04-29;microservice is not an organizational problem. microservices is a design problem. if you implement ddd domain driven design first to your application and then start to design the application around your ddd concept then it might work.but it's extremely hard even to do that. microservices simply complicates things if any of your domains need to share code with each other. many ddd paradigms exist to address this but none are practical. for example authentication related code. if one domain sets a cookie and the other one has to rely on that to keep the user a shared model between the two domains authenticated then this means you need to duplicate code bases across two domains or in the very least put them into some sort of shared helperlibrary which ddd is kind of against.that's why it totally makes sense to go monolith first and really identify the parts of your application that are slowing you down either development wise testing wise or performance wise and put them into separate contexts.phoenix actually does microservices right. from all the way to scaffold generation to instructing best practices on keeping your domains properly separated. but even then i've burnt my finger many a times trying to write simple cms solutions into mutliple microservices then going back to monoliths again.;0
23019280;HackerNews;2020-04-29;i totally agree with you.i think this article is more evidence against the credibility of multirepo than against microservices.anecdotally my current place of work has grown to about 200 engineers maintains a monorepo and hundreds of deployed cron jobs adhoc jobs and microservices. we have none of the problems discussed here. we invest maybe 20 eng weeks a year in monorepospecific tooling and perhaps another 30 eng weeks per year in microservicestooling.;0
23019096;HackerNews;2020-04-29;are there any case studies where microservices went well?from an end user perspective netflix runs in constantly degraded mod.from an engineering perspective they track number of successful stream starts instead of percentage of the time 100 of their services are working. thats a huge red flag.as a researcher the monitoring and faultpropagation modeling work theyve done to get it to stay up at all is impressive but its not clear all of that tooling would be necessary if they didnt have to reason about n2 fault tolerance scenarios where n 100s of microservices. thats on the order of one fault tolerance scenario for each atom in the universe.;0
23019069;HackerNews;2020-04-29;good monoliths are highly modularized. but it's a whole different thing to package up a module as a separately deployable unit for external public use external to your app that is not your company.i'm just curious to know when you said the easiest and most sensible thing to do is chunk out large parts of the project and put them aside as a microservice ... were these chunks separately deployable units for external public use.;0
23018911;HackerNews;2020-04-29;the micro in microservices implies excessive factoring. otherwise theyd be services.;0
23018790;HackerNews;2020-04-29;microservice implies systems that are decoupled for deployment purposes. for example microservice a could restart to a new version while microservice b keeps running. this is a more complicated interaction contract than services where their deployment is coordinated in concert.;0
23018780;HackerNews;2020-04-29;conway's laws isn't a law it's just an interesting thought experiment. organization and architecture bidirectionally effect each other but not directly and not completely. i hate how current discourse invokes these different laws as if they are physical properties of the universe. i've worked at places with a strong hierarchical organization that created a wonderful set of micro services and i've worked at places with a chaotic environment that developed monoliths.there are shitty hierarchies and shitty flat organizations just like there are shitty monoliths and shitty microservices.sorry if you actually agree with this more nuanced view it's just that i've seen conway's law invoked more than once in this discussion and it drives me bonkers. i get the same way when someone medium developers i call them more than green but less than seasoned who swallow everything the read on medium as gospel and run around ing it zealously ed liskov substitution principle at me as if it was one of newton's laws.;0
23018723;HackerNews;2020-04-29;i agree with you but i find some value in people using that term it signals to me that i should consider the the architecture was prematurely splitup and could suffer from the various pitfalls associated with microservices.;0
23018714;HackerNews;2020-04-29;mmmmyes and no. depending on the size of your project that may not be the case. i've had to work with two titans of monoliths maintained by relatively small teamsanywhere between 2 and 67 people for several million lines of code. at some point managing a codebase this big within a single project becomes a huge burden for both developers and even more so for those who develop and do codereviewsfirst hand experience right here. at times i've spent 3 weeks straight doing code reviews with 2 notebooks filled with notes and diagrams of the different components inside the code. and at that point the easiest and most sensible thing to do is chunk out large parts of the project and put them aside as a microservice with the adequate amounts of tests. for small projects microservices make little absolutely no sense. but in the case of something the size of adwordswhich my two such experiences can be compared to you are playing with a raging lion if you decide to go monolith.my argument here is that it's not so much the size of your team but rather the size and scale of your project that needs to be taken into consideration.;0
23018711;HackerNews;2020-04-29;in general yes.everyone seems to have their preferred style of coding and it is an easy defence mechanism when presented with anyone who tries and finds it wanting to say that well they didn't do it properly.you find that with microservices vs monolith strong types vs weak types exception handling vs results agile vs waterfall.people fragment into camps which turn into echo chambers and it's easy to dismiss anyone who doesn't commit to that cult as being unpure and not worthy of being in the cult anyway.;0
23018618;HackerNews;2020-04-29;while that is true a microservices architecture can and in my opinion should rely on messaging and account for message schema evolution. dependencies between services should be way less coupling than dependencies between an application and a library.;0
23018600;HackerNews;2020-04-29;what is your alternative?aggressively small teams with no handsoff middlemanagement layer.you can build massive capability around a small number of wellmanaged messagebackbones and a single codebase. by keeping the number of hands small and the structure flat you force high standards. skilled staff won't tolerate distractions caused by bad engineering or inadequate automation.heuristic for analysing firms who has strategic power in decisionmaking? conventional answer a group of handsoff middlemanagers who run on meeting tempo and who are valued by how many people and systems report into them. under ast an engineering effort running on maker tempo in cooperation with a handson sales effort.microservices tend to have multilateral contracts with other systems in the organisation. this steers all planning towards meetings. this creates middlemanagement bloat.;0
23018418;HackerNews;2020-04-29;so like monoliths vs microservices it's probably a balance between the two leaning heavily in one direction.i've never understood why it needs to be eitheror. is it really that difficult to support a microservice deployment that only represents 50 or even 2025 of the orgproject?;0
23018404;HackerNews;2020-04-29;that's not what the person you are replying to said though the organizational structure is wrong. more like it is a mistake to use microservices unless you have a certain organizational structurecapacity already.i think they were saying something more aligned with your opinion than you read it as.;0
23018326;HackerNews;2020-04-29;i agree. i hate the term microservice for the same reason i hate superlative infected clickbait titles. there's no need for half of the word to exist. service. what's wrong with service?;0
23018020;HackerNews;2020-04-29;2 pizza team?well finally i might get my own microservice after all.;0
23017867;HackerNews;2020-04-29;microservicearchitecture is one of these trends where the value is unproven the upfront costs are high and the unknowns are unknown.there's also a clear conflict of interest with saas and cloud providers benefiting from the perception that microservices are the way to go.under these circumstances letting isomeone elsei figure out all the issues is the wise thing to do. thanks to the authors for doing just that.;0
23017849;HackerNews;2020-04-29;ime it is always environmental factors.when you have 200 developers working on the same product without well defined boundaries it will be a mess with a monolith and a mess with microservices.also arbitrary rules such as one service per team or one service per employee that force engineers to jerryrig things that don't belong together. either allow them to make a new service make or a new team or admit that microservices are not singlepurpose and are just a blob of multipurpose code. i've seen this way too much.also pure organizational inertia working against good engineering practices sometimes a team will be severely overworked while others are overstaffed. but god forbid there's a temporary reorganization to improve the work of engineers so people send tasks to other teams but there's minimal communication between engineers.;0
23017829;HackerNews;2020-04-29;microservices that suffer from shared code changes are not really microservices but a distributed monolith instead.in other words if you can share a lot of code between services a monolith is actually an appropriate architecture.;0
23017785;HackerNews;2020-04-29;if the microservices are in a single repo and tested and deployed together then they are arguably no longer microservices but a distributed monolith!;0
23017726;HackerNews;2020-04-29;because if you share something like auth for example you should have microservice for that. the question is not about duplicate code but about duplicate libraries that handle the same thing. decoupling the auth process into separate microservice removes the bottleneck.;0
23017712;HackerNews;2020-04-29;also a proper solution for true fault isolation would have been one microservice per queue per customer but that would have required over 10000 microservices.i'm a bit confused they seem to imply that they need a microservice per costumerdestination but you generically have one instance aka process per costumer not an entire separate codebase. the article seem to use the same term for two different concepts. or i am missing something?;0
23017708;HackerNews;2020-04-29;reinventing all parts for every microservice sounds wasteful to me. especially if they handle the same data andor use the similar business logic.;0
23017705;HackerNews;2020-04-29;i agree.writer michael feathers has an article where he suggests that microservices are a replacement to encapsulation all we have to do it use encapsulation well.;0
23017654;HackerNews;2020-04-29;without knowing more about their architecture it is difficult to comment beyond the conclusion alexandra noonan came to stated at the beginning of the article. it looks like to me that the architectural assumptions were changing too quickly due to the demands of a fast growing business. having all their code in a single repository means that they can control dependencies versioning and deployment centrally it gives them central control of their software development lifecycle. i can't see how they could not have had the same benefits of the monolith if their microservices existed in a single repo to begin with and had the appropriate tooling to enforce testing versioning deployment across all services in the repo. i guess this is the whole monorepo debate and tooling.this article for me is more about the complexity of managing a large team across different sites where the architecture needs to change rapidly when modularity is absent. they did get a measurable benefit around performance though. i wonder if alexandra will comment on the challenges of running a team in an environment of this complexity?;0
23017630;HackerNews;2020-04-29;even then this is risky if that developer is hit by a bus do you throw the service away and have another developer write it again?we recently had an interview candidate say this when we questioned the wisdom of having over a thousand microservices some in languages that only the one developer maintaining them used! for me this is insane but i digressmonzo says that they have 800 people and 1500 services. if we're generous and say 500800 are developers then each developer is responsible for 3 services! a team of 6 would have 18 projects in their domain.;0
23017615;HackerNews;2020-04-29;shared libraries were created to provide behavior that was similar for all workers. however this created a new bottleneck where changes to the shared code could require a week of developer effort mostly due to testing constraints.that is a big red flag. microservices that suffer from shared code changes are not really microservices but a distributed monolith instead.;0
23017594;HackerNews;2020-04-29;noo! building teams around software components cements your architecture and prevents most crosscutting improvements.i'll claim that splitting a wellstructured monolith into microservices will always make it less maintanable but it might be worth it if you need to for some reason like elasticity or failure tolerance.but for the love of god keep the design open. don't tie the existence of internal software components to peoples livelihoods.;0
23017589;HackerNews;2020-04-29;yeah the problem with microservices is because the organisation structure is wrong. ive literally heard every excuse about microservices at this point. my architecture is better but it doesnt have a snappy name its called the smallest possible number of services that can be reasoned about and network partitions are not necessary to create bounded contexts in a codebase often just a directory is fine.;0
23017577;HackerNews;2020-04-29;iyou could still do microservices and still fail to deal with conways law.ithat's what the poster suggests happened. nowhere do they suggest that microservices are overall required.;0
23017564;HackerNews;2020-04-29;a team that fails to understand how to write modular code is just going to write spaghetti rpc callsthis is interesting. i always assumed we were talking about good developers here.i wonder what's a more likely cause for a failed attempt at microservices. is it developer incompetence and lack of discipline or is it environmental factors related to the product and the organization?;0
23017549;HackerNews;2020-04-29;with microservices there's no way around it as there's additional overhead when splitting a for loop between multiple services. won't stop people from jumping on the bandwagon though.;0
23017541;HackerNews;2020-04-29;yes i dont think that you need microservices to be able to tackle conway's law. at least it doesnt have anything to do with each other.you could still do microservices and still fail to deal with conways law.;0
23017521;HackerNews;2020-04-29;this is why i struggle with microservice architectures. it seems like there is a basic contradiction. on the one hand it's vitally important that the microservices are carved into the correct modules otherwise you get a nightmare of operational complexity where simple functional changes require coordinated changes across multiple services. but defining the correct way modules requires a bird'seye architectural view of the entire system which seems contradictory to idea of selforganizing independent teams. i can see how it works when the right way to divide things up is obvious or when you are dealing with iaas or paas services but in a complex business domain who decides how to carve things up?;0
23017509;HackerNews;2020-04-29;if your code is bad in a monolith itll be bad with microservices. if you cant build a good monolith you cant build a good microservices architecture because it introduces even more complexity and requires even more consideration.discipline is fundamental to good software engineering you cant force it with microservices.;0
23017501;HackerNews;2020-04-29;as with a lot of things it comes down to communication. between teams and between the services they write. which is just another expression of conway's law.iirc fred brooks pointed out that the of bugs in a system correlates closely with the of lines of communication within and between the teams. joshua bloch recommends in effective java that if possible 3 potential clients should participate in the design of an api for the same reason. so a welldesigned interface or openapi spec is worth its weight in gold.ofc microservices here means separate running instances available on a network. but monoliths can be serviceoriented as well. osgi was good for this in java but any system able to load shared objects or plugins dynamically can follow the same pattern. and the benefit is that if your app hits the jackpot and needs to scale outwards the service interfaces ie the lines of communication are already welldefined.so serviceoriented monolith first then microservices if needed.;0
23017449;HackerNews;2020-04-29;which includes your api middle ware and then databaselayered microservices are an antipattern. in most cases functionality is best divided by domain.;0
23017440;HackerNews;2020-04-29;if all the services that the microservice needs are also services behind an api what's the overhead? something likeihiredeveloper 10 10x.addtopayroll.officeopenplan wfh.enforcehrpoliciesiis all you needthe best thing about this is that you can keep everything in change control and just rollback whenever you need to or spin up new companies at will.;0
23017427;HackerNews;2020-04-29;but does conways law require microservices? it doesnt say anything about microservices.;0
23017425;HackerNews;2020-04-29;i'm just curious if there is a middle ground somewhere?on one end you have a giant monolith. all services rolled into one which includes your api middle ware and then database.one the other end you have microservices which bundle services into individual distinct units with each service being responsible for its api middleware and database.are there any preexisting patterns which seek to combine these two and come up with an architecture which is midway between those two. a few months ago i had read an article about data oriented architecture on hn which comes close though i'm wondering if there are others.;0
23017420;HackerNews;2020-04-29;well.. just consider every microservice a separate company exposing its own productservice. also think about all the overhead that comes with it product managers finance recruitment etc.;0
23017396;HackerNews;2020-04-29;absolutely you probably can't succeed with microservices without selforganizing teams. you just get more hot potatoes to drop;0
23017388;HackerNews;2020-04-29;i think that the problem here was that they were fighting against conway's law any organization that designs a system defined broadly will produce a design whose structure is a copy of the organization's communication structure.i think microservices work well in organizations that are big enough to have a team per microservice. however if you've just split your monolith up and have the same team managing lots of microservices you've made a lot more work for the team without the organisational decoupling which are the real win of microservices.in my experience it is really difficult to fight conway's law you have to work with it and arrange your business accordingly.;0
23017371;HackerNews;2020-04-29;i always felt like the biggest benefit of microservices for the average company that just jumped on the band wagon was simply the fact it forced them to break things up. yes they could achieve the same result with none of the overhead on a monolith but it would take... discipline. it's much easier to just enforce a hard external constraint.realizing this and circling back is still a useful life lesson.;0
23017370;HackerNews;2020-04-29;why do you thinkfeel that there are too many? what's the threshold for an acceptable number of microservices? not asking this to be confrontational. just curious because it's a sentiment i've seen before without the reasoning behind it being articulated.;0
23017340;HackerNews;2020-04-29;exactly i would wager that very few organizations go from monolith to microservices and back. getting organization buyin to do the big rewrite is hard. getting buyin to do the second big rewrite after the first one didn't go well is going to be even harder.;0
23017334;HackerNews;2020-04-29;could it be valid to say that even if microservices are implemented correctly you're swimming if not drowning in complexity? but for some problems and teams that's better than the alternative.;0
23017327;HackerNews;2020-04-29;it seems like they introduce microservices for the wrong reason. instead of having a service per team the focussed on services to solve a technical problemhaving a code repository for each service was manageable for a handful of destination workersmicroservices should be introduced to make teams go faster not to decouple external api endpoints....;0
23017319;HackerNews;2020-04-29;i have this thing about microservicescomplexity in that it follows conway's law the architecture follows the organisational structure.if you push authority and decision making and responsibility for a iservicei to a 2 pizza team then guess what microservices work really well.if you have vast monolithic centralised production operations teams and no way in hell is their cexec going to assign two of them to look after the userlogin service you might not do so well.like most things the organisation needs to change to get the best out of the opportunities software offers. those that don't will face increasing friction and eventually die off.;0
23017318;HackerNews;2020-04-29;still waiting for monzo's following blogpost on cutting down their outrageous number of 1500 microservices 0 and moving some back into monoliths. i'm not sure if i would be too excited over the number of microservices if there is a degree of complexity involved here. that is just too many here.0;0
23017276;HackerNews;2020-04-29;my experience of moving to a microservice architecture the most important consideration with microservices is who will develop maintain and operate them?. you can split them down functional lines architectural lines whatever you like but if you don't have teams with definite ownership of each microservice and that aren't swamped by maintaining lots of them like it seems happened with segment it will become impossible. the operational complexity tax is a real thing but is manageable if your engineerservice ratio is sensible and considered.;0
23017272;HackerNews;2020-04-29;just waiting for o'reilly to drop a book called microservices to monolith;0
23017260;HackerNews;2020-04-29;i want to see the microservice architecture where you don't drown in complexity.;0
23017246;HackerNews;2020-04-29;tldr if microservices are implemented incorrectly ... you're drowning in the complexity.;0
23017239;HackerNews;2020-04-29;how many places have gone from monolith to microservices and back to monolith? i'm sure there's been quite a few.;0
