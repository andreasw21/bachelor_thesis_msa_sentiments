ID;Source;Creation Date;Content;Sentiment
18crnmz;Reddit;2023-12-07;Title:Death by a thousand microservices, Content: https://renegadeotter.com/2023/09/10/death-by-a-thousand-microservices;0

kccjok7;Reddit;2023-12-07 11:02:18;as someone who has worked on both giant monolith and complex microservice structure i can confidently say both suck! in my case the monolith was much worse though. it needed 60 minutes to compile some bugs took days to find. 100 devs working on a single repo constantly caused problems. we eventually fixed it by separating it into a smaller monolith and 10 reasonably sized still large services. working on those services was much better and the monolith only took 40 minutes to compile. i'm not sure if that is a valid architecture. but i personally liked the projects with medium sized services the most. like big repos with severel hundred files that take resposibilty for one logic part of business but also have internal processes and all. not too big to handle but not so small that they constantly need to communicate with 20 others services.;0
kccxkmp;Reddit;2023-12-07 13:47:46;these are getting old. it's time to just admit that most developers are average developers and average developers are not skilled enough to design systems of any architecture. not only will their engineering decisions be wholly based on the last 1020 blog posts telling them what to think they'll argue for those ideas like they will die on the hill. your microservice architecture probably sucks. your monolith architecture probably sucks. there are engineering tradeoffs and benefits to both but neither are going to escape sucking if you don't have some engineering adults in the room.;0
kcckrre;Reddit;2023-12-07 11:17:52;an answer that works is depends on the usecase. our company used to have multiple microservices bundled together for a release. idk why. this meant a bug in another team's code blocked us from high urgency fixes. moving to an actual microservices arch helped speed up releases by a looot. months became days for releases.;0
kccfuke;Reddit;2023-12-07 10:07:01;snapshot summary the post critiques the software industry's overcomplication through microservices highlighting the unnecessary complexity and resource waste. it suggests that simpler monolithic architectures are often more practical and that microservices should be adopted only when necessary for scale and resilience. if you don't like the summary just downvote and i'll try to delete the comment eventually;0
kccmyd2;Reddit;2023-12-07 11:47:48;isn't this just another repost? i remember this catchy and clickbait title. regarding the topic. every solution can be a pain in the ass when you screw up the basics. this applies to monoliths with a severe lack of discipline and coordinating where the boundaries between modules become more and more blurred and ending up in a big ball of spaghetti. it also applies to microservices where people take the micro to serious and as a driving force to build services. by the way i hate the term microservice because it's misleading and fools people into misconceptions about how to cut or cave them out of a business context or existing monolith. soley based on keeping things micro such as singleentity centered services without seeing a bigger picture of use cases within the business context it ends up often in a red hot mess of either remotecall or eventdriven in an event pingpong.;0
kcctth1;Reddit;2023-12-07 13:10:03;i'm currently in a system that uses microservices for modern solutions while still maintaining a legacy monolith until we have time to break it out completely. i like developing in our microservices and despise developing in the monolith. we use a fork of netflix's eureka service discovery tool to hook all our microservices together and it's pretty nice.;0
kcet8t1;Reddit;2023-12-07 21:52:07;ok i will share my funny rime created 01122021 every time i read or hear the word monolith in technical articlepost. is childish but that is the point. have fun! if anyone makes this a song i will flip. we can split the revenue 5050. monolithicahaahamonolithic from mvc to mvvc microservices will set me free if you create pooh i produce weed i think you should monitor me... monolithicahaahamonolithic from oop to functional wee this is irrational is not like me focus on output not behavior save the stats wear a hazmat... monolithicahaahamonolithic my sql scrooge is nosql fudge whats all the fuzz? reverse the index double the footprint the document goes zoom... monolithicahaahamonolithic ant the maven make amazement is it just project heaven? grab maven central to scrape to gradle no worries is just cidi grable... monolithicahaahamonolithic the service bus was just soap fuzz give me an envelope is loaded is bloated the parser has molasses no worries send me a rest post monolithicahaahamonolithic etl is ancient elt is just what i want who wants the old ugly batch the stream is young very sexy whiplash! monolithicahaahamonolithic vertical architecture is sooo horizontal only when minimized double folded virtualized and containerized monolithicahaahamonolithic a data warehouse snowflake whoot! from flakes to lakes is not a mistake it is missshaped monolithicahaahamonolithic java groovy scala kotlin a basic reversible evolution gooble the python people just dont listen just another sharpcopycat boy! monolithicahaahamonolithic junit testng spock mock with report nothing more than ascii blocks listen to the doc if your algorithm is made by buble its a turing spock monolithicahaahamonolithic your algorithm is not worth the bigo because if you cant handle threads youre no good or just a chump monolithicahaahamonolithic sharding is just like arting split the love because the smeller is the feller monolithicahaahamonolithic j2ee turns me green with all the dependencies assembly i hear is more like war dont worry we have spring fever simpler or justaclusterclassnametogetherbean.whoot! monolithicahaahamonolithic i data mine your predictive analytics in nearrealtime ml agents try all flawed algorithm models is legos everybody is awesome land monolithicahaahamonolithic why hire a knowitall architect with no technical intellect to make all decisions? have developers they know what to do with resumebuilding di bublevision monolithicahaahamonolithic don't worry about me i am having fun with events data streams and spark in hand i have a job a great idea with a cool stream flow time to akka my play... monolithicahaahamonolithic i dream of cpp with parallel mpi for no particular reason but i am not working hard enough to monetize the unreal truth of my life monolithicahaahamonolithic thank you i will be here until tuesday try the veal and a programming hat;0
kchnv0u;Reddit;2023-12-08 12:57:48;guys what if all functions had network latencies? guy about to invent microservices;0
kccnrx1;Reddit;2023-12-07 11:58:46;microservices suck but nothing will sell me on a giant monolith. giant monoliths are a whole level of suck to whatever you will deal in microservices;0
kcdhzlu;Reddit;2023-12-07 16:26:26;microservices are a valid architecture choice when used correctly. too many will make things as microservices that should remain as monoliths because either the utilization is too low the rate of change is too low or the solutionecosystem has a sunset date for replacement. microservices are more chatty by nature and considerations should be made with network engineering database engineering observability tooling teams such as sres and others to ensure their part of the design will hold up to the increased requirements. while microservices are a popular design pattern theyre not the only modern or performant one. i would discourage implementing microservices in cultures which do not adequately practice agile delivery principles product and platform model team structures and prioritize technical debt repayment with a high degree of maturity. everything dies on the vine if any of those elements is insufficiently present and matured. for a microservices architecture to work properly a core collection of guiding principles separation of responsibilities and clearly defined communication contracts between both the services and the product teams who ownmaintain them.;0
kccj2yb;Reddit;2023-12-07 10:53:45;krazam on microservices httpsyoutu.bey8onoxkotpq?siszpttvmh8pxlp9mu;0
kccsr05;Reddit;2023-12-07 12:58:23;yeah because what we all want is a simple schema change to involve 12 different teams. the problem with every microservices rant is that people don't know what a microservice is. micro doesn't mean small it means smaller than if you had a monolith. a microservice is just a service it can be arbitrarily large. if you have 1 service you have a monolith. if you do something like break auth out into another service you now have microservices. if you have a node app for serving your website and the add a python service for pytorch inference you have microservices.;0
kcfb5t4;Reddit;2023-12-07 23:44:08;microservices are great. problem is between the keyboard and chair. like the bit about not knowing how to do integration tests setup a company wide staging environment otherwise duplicating production except for running integration tests... what was that nearly impossible? lol. oh and btw that solution is something that should be done with monoliths too so it's not something extra for microservices. what about just services? they are just services. micro refers to breaking it down into decoupled modules instead of one massive monolith. that's it it's not restricting the underlying size of the code base. it's based upon scope you make clean breaks as necessary. people don't understand the things they're complaining about anymore. just superficial bs takes. mostly when people complain about microservices it's just complaining about the bad code they have to work with. then they daydream that monoliths would somehow fix it... but reality is that bad code in a monolith would be worse. half the problems in the article are things microservices actually solve and the author just makes up mental map of the entire system? no other microservices are black boxes. however in a monolith you need a mental map! just another article pretending to be smarter than best practices. quality is exactly as expected.;0
kccl2k3;Reddit;2023-12-07 11:22:00;depends on the implementation. i like the idea of trees with small branches as in think of complex services like an os. have a kernel like thing to it have controller services and small branches for unique stuff that can be properly segmented and recover independently. if you are making 15 services and doing it just because microservice you are as bad as monolith people. i usually don't have a branch that is 3 services deep intentionally like if i can't explain it as a manager and architect in 10 seconds without a diagram how will a 10 euro an hour support guy use it.;0
kcdgu6i;Reddit;2023-12-07 16:18:42;i don't mind either but for god sake don't build a a monolith made of two giant microservices that are completely dependent upon each other and can't be updated separately.;0
kcezgfe;Reddit;2023-12-07 22:30:32;this was an entertaining read although i have a feeling this was written due to the current popularity of microservices bad as an opinion. imo microservices suck because your company sucks. something something the architecture reflects the org chat.;0
kcd6ul2;Reddit;2023-12-07 15:06:35;this is not a picture of a microservice architecture it is a picture of a distributed soa monolith as seen by the large number of dependencies between nodes.;0
kce6d4s;Reddit;2023-12-07 19:05:48;as an honest counterpoint i like working with microservices because the interface is clear and noone can screw around with it once it's established. it also has testability built in. other aspects do suck for sure and some people go way too micro with their microservices but breaking down a large problem into digestible blocks with clear interfaces has helped me personally deal with larger problems as well as delegate work. not saying that you can't do that with monolithic systems just that the incentives for developers push them in different directions.;0
kce6jfd;Reddit;2023-12-07 19:08:08;the discussion shouldn't be microservices vs monoliths but rather is the system implementing high cohesion and low coupling? the answer may be yes today only to have the system design challenged by the addition of a single feature tomorrow. engineers need to be constantly designing their system and be willing to make small but foundational changes to design frequently. leaders need to be willing to refactor their organizations without hesitation as bounded contexts evolve.;0
kcfo21e;Reddit;2023-12-08 01:14:00;one thing that i keep saying lately is that more or less you just cannot have a separate service if it doesn't do something generallyuseful and isn't nicely planned ahead. if it can't be something like a public library nicely versioned independent and you can't avoid breaking stuff all the time no you probably can't have it as a microservice either. adhoc business logic and prototypes are bound to change often they're the worst possible thing to split across microservices and repos. there are decent services stuff like databases but they're nothing like the average microservices. i believe you could sometimes have less generallyuseful microservices but you have to think hard about it not just break up stuff randomly. the trouble is many projects don't really have the skills to create and maintain something like that nor the willingness and just think of microservices as an easy way out to silo development. in manymost cases it makes things worse even if you do get to hire cheaper workforce since the effort to do anything meaningful also grows. given unchecked complexity it grows faster than a proportional factor. anything nontrivial takes 10 prs across just as many repos and which may need to be mergedcreated in a very specific order and there is lots of boilerplate involved. and scaling is a joke you could easily see a monolith scaling better given that you could avoid like 80 of the effort just by not worrying about interfacing then you could load balance and shard data you could offload some stuff to different instances like in a distributed system if you really wanted and so on.;0
kcfzl8n;Reddit;2023-12-08 02:37:54;sometimes we do desire simplicity but the sweats of developers are warranted if it makes the system highly available highly scalable a lot more secure and better preserves user's private data. i've seen numerous times where the devs ask why we need message queues and even more message queues as we progress. why don't we simplify the links by eliminating the message queues and many other docker microservices it is because we don't want to give full authorization to anybody. you sit on the other side of a message queue and that trusted team sit on the inside of the system and no we aren't going to risk running your code on a bare metal among other code and data. if this gives you nightmares so be it. you're hired to work thru these.;0
kcg1p2d;Reddit;2023-12-08 02:53:13;anyone who thinks microservices is always the right answer is a dipshit. anyone who thinks microservices is always the wrong answer is a dipshit. choose the right architecture for a given situation. don't be dogmatic in either direction. it's not rocket science.;0
kcpgd16;Reddit;2023-12-10 01:32:39;i'm pretty confident that i bombed my latest tech interview due to me naively mentioning that i worked with a system with 150 microservices and to me they seemed too many.;0
kcrk4c0;Reddit;2023-12-10 14:53:54;this topic has been discussed over and over again more than a thousand times. hundreds of articles have been written on the topic so this article provides nothing new. why does everyone think that they need to give their two cents on microservices and monoliths? all those articles can be summed up in 4 points. 1. find solutions to problems not problems to solutions. 2. unserstand the problem. httpsen.wikipedia.orgwikidoublediamonddesignprocessmodelhttpsen.wikipedia.orgwikidoublediamonddesignprocessmodel 3. patterns and styles exist so that you do not have to reinvent the wheel every time a new software needs to be built. 4. there are a finite actually small number of architectural styles and architectural patterns to know. if you know them you will be able to tell if any of them are applicable to your system under design without having to compromise on functional and nonfunctional requirements.;0
kccmgka;Reddit;2023-12-07 11:41:08;before microservices we used to call them services! more specifically service oriented architecture. one of the first distributed systems i worked on was in 2001 at a large ecommerce company not amazon. it comprised of about 15 medium size services. you can size your services and the amount of services you have however it suits your company teams and onhand skills.;0
kcdadi5;Reddit;2023-12-07 15:33:12;i've worked in support of both. microservices is much worse to me. sure a monolith took awhile to build and compile and all. but it was just one thing. now i support 50 microservice components i feel i have no hope to set it up and learn them all. they were built via agile so documentation sucks. and when a defect pops up every single one turns into a finger pointing game between the various layers. there are thousands of different kafka events which get fired. so when one fails and we need to correct something hardly anyone knows the impact of 1 event failing has down the line. because 1 event can fire which then calls another which calls another and so on. and the overall business knowledge of the application is much worse as the devs only really consider what's in their walls;0
kccwef0;Reddit;2023-12-07 13:36:26;both perfect monolith and microservices are extremes. the solution lies within these two extremes. one might lean towards one or the other depending on context and requirements.;0
kcfw844;Reddit;2023-12-08 02:13:32;at a certain point companies need to just stop expanding. if your platform is so big that both monoliths and microservices aren't feasible designs then you just have an unwieldy platform that needs simplification. figure out some core functionalities and just stick to it.;0
kcefzdn;Reddit;2023-12-07 20:27:52;most people don't realize a 1000 microservice dependency graph is at least a 1000 library dependency monolith. complexity is complexity. if you get overwhelmed by your microservice graph it's one of two things you're trying to understand everything too deep and are getting overwhelmed because of that or the architecture of the system you are working on is fundamentally screwed up and it has nothing to do with microservices. lets talk about the second scenario. you need to manage and trim your dependencies and keep them at a minimum. every dependency adds an extra layer of complexity that code doesn't. i am not going to say reinvent the wheel but maybe having an external library to find out if an integer is oddhttps or evenhttps defined in terms of the first library! you might be better off paying the upfront cost of building your own in an internal utility library modifying it etc. rather than pay the technical debt cost of maintaining a mapping of library concepts e.j. errors into those that makes sense for your code managing the dependency itself and dealing with inefficiencies the library has because it can't consider shortcuts offered by your specific usecase. i do see how with this mindset from the javascript dev community it would result in a similar microservice explosion. so you have to do dependency management and trimming be those microservices or libraries. and you need to work to keep them decoupled. if you can avoid direct interaction with a dependency letting another dependency manage that fully for you instead you can focus on the one dependency and let transient ones be handled by others. so what i found is that services that users depend on should appear large and consistent rather than exposing their internals. when a user buys a hammer they don't expect to get an iron head and then have to go get a handle though carpentry shops may prefer to have handles on hand most carpenters just don't care enough. they expect the whole package and just use it as a single thing. while internally i may be using a bunch of services in tandem they all get taken in by a frontend that simplifies them into a core medium sized service as you described it working on the whole problem view that an average user another dev would have. rather than have to learn the 56 microservices i use they simply need to learn 1 and only as they grow and understand the system better do they start to see these microservices behind the scenes and how they connect to theirs. lets take a simple example authorization. so a user wants to modify some of their personal data which itself is protected. they used the oauth service to get a token and pass that token with their request. the frontend passes the token to the useradmin service which handles user metdata as part of a request to change some data. the useradmin service doesn't really care about authentication either and just passes this to the database service which then talks to the authorizationmgmt server to validate the token given as having the permissions. note that this means that neither the frontend service nor the useradmin service needed to talk to the authorization service at all if you work on either of those you don't have to worry about the details of authorization and instead see it as a property of the database rather than a microservice you need to talk to. maybe we do want to make the frontend service do a check as an optimization to avoid doing all the work only to find at the last minute they couldn't but we don't go into detail of it because as an optimization it doesn't matter for the functionality and the frontend still fails with the exact same error message as before. only when someone is debugging that specific workflow where an authorization error happens is it worth it to go and understand the optimization and how the authorization service works. even look at the graph shown in the picture. it's not a tech graph but one of complex social interactions between multiple groups in afghanistan and how they result in certain events. so clearly this is an organic system made by the clash of opposing forces and it's going to be far more complex than a artificially created system. so it's a bit of a strawman. but even with this strawman you can see what i mean. the graph seeks to be both dense have a lot of information but also accesible you don't need to first read everything in the graph things are color coded with a largefont item naming the how they collective thing is. then you can first look at arrows between colors and think of these relationships between the largescale items. then you can choose one color and split it to its small parts and see how they map while still thinking when it maps to another color think of it as the abstract concept for that color don't worry about the details then start mapping the detailed interactions between the large component you've deconstructed and another large component then look into what the different arrows symbols etc. mean beyond related and then think about what that means and go from there. the graph is trying to explain a very complex subject and reflects that complexity but it's designed to let you think of it in simpler abstract terms and slowly build up to the whole story rather than having to understand the whole thing. same thing with microservices. many engineers want to show you the complete complexity but really you start small with very large boxes and simple lines. then with that abstract model you show the inner complexity inner here being to whatever you are working on and then as you need to find out show the complexity on bigger issues.;0
kcd86eb;Reddit;2023-12-07 15:16:52;i always did find that monolith services is really a good common ground for small medium and large apps. people here seem to mix services and microservices. these are not the same you don't need orchestrators and complex service meshes if your org has 56 services. and services can do multiple things and they don't have to be small or micro.;0
kckt3oq;Reddit;2023-12-09 02:17:11;microservices aren't the solution for every enterprise architecture. it fits in some cases and not in others. it is sad to see people cram in microservices where it does fit. i feel sad for devs that work at such places. wounded and bleeding because management and architects think they are working with cutting age techs.;0
kcp6g89;Reddit;2023-12-10 00:21:43;imo that same criticism can be laid on any architecture. if it can take days to find a bug in a monolith which is not distributed it's going to take easily as much time in a microservice setup that is distributed. even worse if a small team is breaking down their work into multiple services when they would be better suited to maintaining a single full stack. soa in the way you describe is the cosy middle ground but not an attractive sell to many.;0
kcd1ty3;Reddit;2023-12-07 14:25:51;and the main enemy is always complexity. if you can find ways to avoid complexity congratulations. if you can make a simple change to business processes that simplifies software 10x do it. if your business use case is simply complex prepare for pain translating that complexity into software monolith or microservices. that being said adding network effects increases complexity so make sure it's worth doing for technical reasons and your particular usecase not because everyone says microservices are cool. and you can have relatively good code isolation in monoliths too reusable libraries submodules with interfaces etc. runaway cpu or ram use will remain more of a problem in a monolith though but at least you don't have to deal with network latency or throughput restrictions or eventual consistency. pick your poison i guess...;0
kcd2xqe;Reddit;2023-12-07 14:35:10;there's only the bullet lodged in your skull after choosing microservices.;0
kcluvcw;Reddit;2023-12-09 08:12:37;so they had a monorepo used badly. fwiw the use cases for monorepos are there but it basically boils down to only using it if the common library code they are sharing is small enough and the services themselves are pretty lightweight facades on top of it that do 90 of the same thing but may need to be scaled differently depending on resource requirements. or other edge case things if you didn't do a monorepo you'd be copy pasting the shared code into all microservices that split out from it. if the services inside the monorepo aren't sharing much or shouldn't need to be sharing any of it then you've fucked up;0
kcjzf86;Reddit;2023-12-08 22:41:30;any synchronous communication between microservices is a recipe for disaster including datastore calls. sorry are you saying that loading data from database should be done in an async manner? genuinely curious about this it's the first time i hear about it.;0
kcox5u3;Reddit;2023-12-09 23:20:16;we had that already long before the term microservices was coined we called it corba or the competitor java rmi;0
kccrivx;Reddit;2023-12-07 12:44:33;that's why you start with modular monolith and cut off microservices when absolutely needed.;0
kcf3mtb;Reddit;2023-12-07 22:56:17;the pendulum just swung back. people started to realize that maybe using microservices and kubernetes for their pizza delivery app that 200 people use was not the best use of their time and energy. but the same thing happens with everything. some faang company does x and it works and everyone just assumes it's the best because it worked for their company. the moment you become a fan of a single tool you are doomed to fail. what you need to know is which tool fits best for each task and just do that. to be successful in software engineering you need a toolbox not a box full of hammers. unless the only thing your company does is hammer nails;0
kcevazz;Reddit;2023-12-07 22:04:56;soa is not the same as microservices. probably there were somemany implementations of microservices before the term was coined but it wasn't soa. in soa the services are generic and centralized bus esb had tons of logic to orchestrate all processes. in microservices the bus has no logic and services are not genericreusable but represent processes.;0
kcd6z1x;Reddit;2023-12-07 15:07:35;we still do. this is not a picture of a microservice architecture.;0
kcdho1r;Reddit;2023-12-07 16:24:18;before microservices we used to call them services! more specifically service oriented architecture. soa and µservices are actually quite different. soa was more like a distributed monolith where services were meant to talk to each other synchronously. in true µservice architecture the services don't synchronously communicate with each other. they instead each have their own database which are kept in sync with eventual consistency using events. so a single µservice always has the information it needs to fulfill a request in its database unless a 3rd party integration is needed in which case a synchronous http call is acceptable to the 3rd party service.;0
kcdm32v;Reddit;2023-12-07 16:53:23;you need good logging practices and distributed tracing to make large microservice deployments work if you dont have those things debugging is a nightmare;0
kcckfbg;Reddit;2023-12-07 11:12:53;the real answer here to structure your code in a modular way like you would do for microservices but then just deploy it as a monolith;0
kccmrpg;Reddit;2023-12-07 11:45:21;badly designed monoliths are bad. badly designed microservice architectures are worse. the problem is that it's easier to fuck up with microservices and it's way harder to unfuck. microservices have their place. but they're far from silver bullets.;0
kccnw8s;Reddit;2023-12-07 12:00:21;the difference between monolith and microservices is that in a monolith the complexity is almost all incidentalaccidental so you can either avoid it or remove it whereas in microservices there's a whole lot of essential complexity right out of the gate that you simply can't avoid.;0
kcdf6gp;Reddit;2023-12-07 16:07:22;the main problem i see is that people who are not capable to maintain a well structured modularized monolith switch to microservices because monoliths suck only to end up with a distributed monolith microservices can be great but technically they will always be more complex than a monolith when you split it apart and put a network in between etc;0
kcdedbd;Reddit;2023-12-07 16:01:43;service oriented is simply when you have a 3 layer architecture. before service orientation client side libraries accessed the database directly and clients were heavy with business logic. soa describes the architecture for a single service or sometimes a group of independent services when people are talking about their standard inhouse architecture. when you have a bunch of independent services that are not working together to provide a unified product apiui you just have services and the fact the business logic is hosted on a central server is what makes it service oriented. this way you have a bunch of thin clients and various languages for clients becomes very easy. for example in vfx for example the render farm is one service and the production tracking system is another. they are totally separate apps. you can shut down the render farm and production tracking system still operates at 100. however if the render farm scheduler goes down users can still see their jobs they still have running tasks but no new tasks pick up. so they experience degraded functionality for that application which is both service oriented a server hosts the business logic and a microservices architecture. multiple services combine to create a single application experience. this is the exact same concept as a micro kernel if one part of the kernel crashes maybe your mouse breaks but the machine is still running and that's where the term micro came from. i spent probably all of 19982011 converting perlcpython shell toolsuis that accessed the db directly to sao architecture using various wire formats soap corba xml rpc etc.;0
kcczt55;Reddit;2023-12-07 14:08:15;if services are isolated apps then yes. if they all work together to power a single app then no. well thats the definition from the person who coined the term. he just picked the wrong word and it stuck. micromono comes from kernel architectures. linux is a monolithic kernel mach is micro and what was better was a popular debate at the time. microservices is that concept just applied at a different layer. small is subjective. it will be different for all teams all companies. is small 10 endpoints? 100 endpoints? 1 domain? do you measure by lines of code? a small service at one company could be huge at another. so we cant use small as an any form of guide or benchmark. it should be obvious that as software engineers we need more clarity. same as kernel arch micro here just means many. a backend architecture with 1 service per domain no matter how many lines of code endpoints etc is a microservices architecture since it has many specialized processes like a micro kernel. you put all those services into a single process now you have a monolith. thats the old man software history lesson for today.;0
kcdel4a;Reddit;2023-12-07 16:03:15;getting the interfaces good up front because if you are wrong... well it's also hard to change interfaces honestly i don't know how this is that different from getting the microservices boundaries right. if anything with wrong interfaces you at least have a shot since breaking backward compatibility is within a single deployment which will be upgradeddowngraded in its entirety.;0
kcdpqd1;Reddit;2023-12-07 17:16:55;i have microservices that take longer;0
kch0ew2;Reddit;2023-12-08 07:49:44;so many engineers these days want to be able to create their own services possibly symptomatic of promotionoriented architecture. if people get it in their heads that they need to launch a service to get promoted you're going to get a lot of services. domain driven design via services requires the decider to understand the business and the domain at a very high level corresponding to the business and i think the problem this presents is that many software engineers don't have a strong understanding of their domain until they've been in it for a while. but the pressure is on to deliver now and if microservices spit are a thing then they're going to crank out microservices to deliver. i personally think a saner approach is to build a service and then once you've had time to really come to grips with the business needs and shown some success in solving for them break out smaller decoupled services if it'll help you scale help your availability or improve your operations. the path to taking a big service and breaking it apart while not painfree is pretty welltrodden. the path to taking a bunch of overlymicro services and pulling them back together not so much.;0
kcemgbe;Reddit;2023-12-07 21:09:32;i don't know why you're getting downvoted you're correct. soa sounds generic so people often tend to think of microservices as an implementation of soa but in actuality soa is a distinct architectural philosophy rather than simply a taxonomy.;0
kcdny0a;Reddit;2023-12-07 17:05:27;the monolith i worked on used to log quite literally every reqres payload masking some of the sensitive data. making debugging child's play. the microservices i work on don't log the payloads due to performance concerns making debugging impossible. we do have tracing via datadog which is nice but it only gets you so far.;0
kcf2s3n;Reddit;2023-12-07 22:51:03;its not that complex. but yeah i would prefer one repo and one deploy over multiple ones. as long as the people busy hating on microservices spend more time complaining about complexity than they do fixing the flaky one hour build and deploy times in our monolith but of course they spend even more time fencing waiting for the build i will calmly build outside their shit pile. you can do anything in theory. people complaining about microservices rarely do in my experience. but i can see what they mean.;0
kcctntg;Reddit;2023-12-07 13:08:22;no you can't avoid mess in monolith. it's not incidental. years history has proved it. i have seen a lot of 'microservice's are just simply turn inprocess rpc into outprocess restful calls. these two approaches have their own pros and cons. equally bad or good. but generally small app chooses monolith with big system chooses medium size services to at the boundary of business domain. medium system is 'it depends';0
kcdjsxk;Reddit;2023-12-07 16:38:31;sheer number of them i'd say. in many feeling like nearly all and this was a bad trend to me? microservice companies you have hundreds if not thousands of microservices. often times near duplicate of others that already exist because spawl has went to wild that people didn't know it existed so they made a new one. changing your basic patterns in that is doable for a few but who in their right mind is doing to change test and deploy 50 microservices to fix it? contrast that with a larger service world like soa and you might be talking about deploying 2 services to change just the known path between them. one is real the other is a fools errand in a distributed monolith that people call services;0
kchyx9u;Reddit;2023-12-08 14:40:30;is the bot using microservices?;0
kccxtaj;Reddit;2023-12-07 13:50:00;architecture tests are super brittle and are unable to cover true architectural issues. my favourite example is how people deal with transactional operations in monoliths. in a proper code your transaction boundary should not breach the domain boundary. with microservices it's natural as usually the boundary of a microservice matches the domain boundary and messing with distributed transactions requires too much effort. now with a monolith that concern goes away. instead of each component managing it's own connections to db with its own transaction boundaries you just treat transaction as a crosscutting concern opening it on beginning of request and closing in the end. on first glance you would think but that's a great thing so fast so efficient wow. in reality it's a recipe for disaster. now that components do not control transactions they can't clearly know if the data they are processing 5 levels deep is transient not committed or durably persisted. which is super important if you want to do any sideeffects like writing into secondary data storage or even calling an external api. sure you can apply the same pattern in monoliths and actually manage resources correctly in each component. but in my 20 years of experience i haven't seen a single monolith do that for sake of simplicity.;0
kccy538;Reddit;2023-12-07 13:53:02;pointer memory access is fine if you do it right. still even with an entire world having eyes on the open source code the fact that the internet runs on a backbone of c has been a security nightmare for the history of telecommunications. microservices are also fine if you do it right. you won't be doing it right. not if you do it right is a thought terminating cliche.;0
