ID;Source;Creation Date;Content;Sentiment
38069915;HackerNews;2023-10-30;Title:The costs of microservices (2020), Content: https://robertovitillo.com/costs-of-microservices/;0

38174497;HackerNews;2023-11-07;it's not like microservices don't also give you chances to mess your data up. it's hard to do transactions across boundaries you have to deal with eventual consistency sometimes there is no single source of truth.i struggle to see how microservices fix this for people having worked primarily with them for the past 6 years.;0
38174477;HackerNews;2023-11-07;it's 5050 based on how much clout they have either they mess it up for everyone or they get talked down and don't get to mess up their stuff eitherthis still happens with microservices though people can still make terrible architecture decisions and standup terrible services you depend on.;0
38131102;HackerNews;2023-11-03;the thing with microservices is that shit doesn't have to infect everything. if someone in another team is clueless they'll mess up their microservices but not anyone else'si. if they are in a monolith it's 5050 based on how much clout they have either they mess it up for everyone or they get talked down and don't get to mess up their stuff either.iunless it's a shared library which is why good microservices architecture limit the shared surface as much as possible.;0
38130050;HackerNews;2023-11-03;with proper devops tooling and a half decent design even a junior engineer can manage several microservices without issues. since microservices are about scaling people as much as they are about scaling tech 10 people in one service is a lot to me in that world.the best company i worked at had about 510 deployable per engineers on average and it worked really well. they were small deployed almost instantly dependencies were straightforward etc.monoliths work fine too it's just different tradeoffs.;0
38111422;HackerNews;2023-11-02;i have worked with a company that had around 8 developers and 30 'microservices'. they wanted the front end team fully remote overseas different language culture to go micro front end. they are awesome at presentations and getting funded tho. a common theme in european startups.;0
38105660;HackerNews;2023-11-01;it takes effort to keep a monolithic application set up this way yeah this is the problem and why i think microservices are the way forward as it doesn't take effort because the programmer is forced into do the right thing. on project with many different types of coders and lets face it we are all different consistency drops off fast. of course you can do it with monoliths but i'm coming from a real world scenario where there are many people with different levels of ability and different levels of giving a crp about code quality. micro services let people who code badly to do it in isolation and let themselves be the only ones who have to suffer under it and ultimately learn from it if they are not fired first. also decoupling in a monolith vs by deployment is really just which git repo the code lives in which are next to each other in the same directory on your hard drive. if there is shared code factor it out as a librarymodule and install it into the projects that need it. its not a big deal;0
38090621;HackerNews;2023-10-31;eh?default queue implementations come with cooperating queuing out of the box. i suppose you could use some handrolled queue with no internal locking but this is disingenuous. you'll have race conditions or no cooperative queuing between multiple instances of the application.you're thinking microservice again here. there's no need to have multiple instances at all. any concurrency is handled internal to the application itself with use of e.g. fibers threads etc. a good argument to why monoliths have drawbacks can't be well its not a microservice. a good monolith still requires all the same hard decisions about modularity highavailability etc.never said it didn't. what it doesn't require is all the tech stack to support that over many instances because there's one instance. a large majority of Âµservices is just reimplementing what your runtime gives you for free.;0
38088383;HackerNews;2023-10-31;testing hugely via expensive integration tests or e2e is needed no matter which software you have. and you could easily fall into doing that for microservice architectures. however a common way is rather having contract tests. google fowler's article for it;0
38087344;HackerNews;2023-10-31;kubernetes doesn't come with its own networking. so it's unfair to say that it affects networking because it simply cannot do it.you're the one who brought it up? my claim about performance tax is based on the idea that wo kubernetes you wouldn't need such translations but of course you could build your own version of kubernetes networking with a lot of softwaredefined virtualization in which case you'd be in the same boat.you don't need any of those and i don't know why you think otherwise. you can just use the host network and do whatever you want as with any container. i'm not sure what point are you trying to make.that kafka's architecture allows you to put data into partitions and route it based on that data which allows for shared nothing architectures. but whatever you're clearly not going to get this point from this example. to be clearer your point of you pay a cost here so you're losing performance ignores that you can get performance elsewhere. there aren't any meaningful isolation tools or approaches when it comes to microservices because isolation at the level of service doesn't matter is trivial to achieve by many other means is not a problem in realworld programs.not true at all. services that own a domain of work are a great place to perform isolation and security boundaries. low on what scale?as in an actor is a foundational primitive for asynchronous computation. you have to build up protocols on top of actors hence all of otp. i.e. words from the same general domain strung together but make no sense.i think that's because i actually know what i'm talking about and you're finding it hard to keep up? how did you count?because it's obvious? like it's not even close. actor based systems are exceedingly rare microservices are not. i mean in more simple language this is talking out of your rear. it's not a real argument anyone should pay attention to.one of us actually knows what they're talking about and i doubt we'll agree who ti is.;0
38087034;HackerNews;2023-10-31;on kubernetes impact on network performance well... on one hand kubernetes doesn't come with its own networking. so it's unfair to say that it affects networking because it simply cannot do it. on the other hand it requires external networking component to do certain things in certain ways. so indirectly it does affect networking.so here are some concerns that affect performance they mostly come from the need of various translations done by either iptables ebpf analogues arpatables dns servers. if you read about benchmarks of calico and cilius you'll see that they concentrate on performance of ebpf code necessary to do all these translations. my claim about performance tax is based on the idea that wo kubernetes you wouldn't need such translations but of course you could build your own version of kubernetes networking with a lot of softwaredefined virtualization in which case you'd be in the same boat. kafkais as horrid as it sounds. it's awful performancewise on all counts. i'm not sure what point are you trying to make. can you choose a better example? i mean kafka performs very poorly in all configurations so to think that it can be a good example of software that wants to achieve good resource utilization is just bound to give you bad results. you get isolation at the service layer. i don't see why that would be contentious it's obvious. if you're saying you want more isolation ok you can write your code to do that if you'd like.you either genuinely didn't understand what this is about or pretend to not understand something really simple. micro in microservices means that your services are small. there aren't any meaningful isolation tools or approaches when it comes to microservices because isolation at the level of service doesn't matter is trivial to achieve by many other means is not a problem in realworld programs. yep the actor model is very low level.this is simply a nonsense statement. low on what scale? your answer reads as if it was generated by a chatbot. i.e. words from the same general domain strung together but make no sense. microservice architecture has been far more successful than actor based systemshow did you count? how do you even tell if something is a microservicebased? this is just as absurd of a claim as saying 78 of enterprises use kubernetes i believe i saw this unfettered inanity on cloudnative foundation's web site. how do you tell if it's successful? what if actor model is a more generic description which beside other things also captures microservices?i mean in more simple language this is talking out of your rear. it's not a real argument anyone should pay attention to.;0
38086139;HackerNews;2023-10-31;i ended up getting into a few arguments at work with the over excited engineer in my last place. he wanted microservices. i said it was just going to add complexity. the app was already a mess adding network calls rather than function calls wasn't going to help. we had a small teas 3 backend devs one of them doing mostly devops and two frontend.;0
38085668;HackerNews;2023-10-31;with the microservice architecture its easier to lock things down. you cant have someone outside of your team just give access to a dataset or similar because excel cant get a connection directly into your db. which is an argument you could rightfully make for monoliths except in my experience someone always finds a sneaky way into the data on monoliths but its too hard for them to do so with microservices.if you gave me total control over everything id probably build a couple of monoliths with some shared modules. but every time the data is centralised it always somehow ends up being a total mess. with microservices youll still end up with a total mess in parts of the organisation but at least itll be in something like powerbi or even your datawarehouse and not directly in your master data.or to put it differently for me microservices vs monoliths is all most completely an organisational question and not a technical one.;0
38084540;HackerNews;2023-10-31;the theory is that microservices are supposed to be independent and selfcontained but such a wonderful implementation of ddd is a theoretical fantasy that rarely plays out in practice. it's not just a technical difficulty but an organisational problem where communication between teams also throws a spanner in the works.if your typical microservice setup is simply distributing your call stack over a network and oftentimes that's all it is then you might as well use a language designed to operate in such a manner and reap the benefits of it. that kind of microservice architecture only really exists as a function of the organisation's structure such that teams can work more autonomously.;0
38084155;HackerNews;2023-10-31;there might be a good reason to have independent deployable testable and releaseable unitsof course this is the bottom line. but everything you define in the sentence can be achieved with a proper pipeline and repository architecture based on a monolith as well. for example teams could use a branch setup where they own their own team branches capable of merging to master and deploying. each team could then define their own testing strategy and definition of done on their team master.having the ability to release independently is actually a social problem not a technical one. but the symptom of that social misalignment often shows up as a technical problem dropping release kpis etc.so changing from a monolith to microservice will most likely only fight the symptom not the root cause.;0
38083597;HackerNews;2023-10-31;if you need that much ipc then you aren't doing microservices correctly. microservices are supposed to be independent selfcontained domains wherever possible. purely technical boundaries like dedicated caching services that you see in very large companies like google are more of an exception and should only be used when the nonfunctional requirements absolutely dictate it. a language that is designed around ipc wants to distribute dynamic parts of one application over multiple interchangeable compute resources like in an hpc environment. this is a different thing altogether from microservices which are selfcontained applications working independently to each provide a fixed piece of the whole.;0
38083535;HackerNews;2023-10-31;var queue new queue then sometime later... queue.save or queue.emplaceandsave ... queue.popyeah no... you'll lose data for sure you'll have race conditions or no cooperative queuing between multiple instances of the application. this is exactly the kind of halfassery that people resort to when they say monoliths are so much less complex than microservices. a good monolith still requires all the same hard decisions about modularity highavailability etc.;0
38083263;HackerNews;2023-10-31;absolutely true but also usually your business transactions happen in a business context which happens to be in a microservice. it can be a sign of bad design if you happen to have a lot of those transactional problems.you will have distributed transactions with a distributed microservice setup but most transactions will still be be contained within a single microservice and thus be atomic and not distributed.;0
38083186;HackerNews;2023-10-31;there are many valid reasons and many wrong reasons. i would say if you have multiple stakeholders evoling business needs and many 10 developers there might be a good reason to have independent deployable testable and releaseable units. having few developers with a well defined context working on multiple microservices is a pain though.regarding everything else is just shifting complexity from software development to system maintenance. this sounds reasonable if your software is actively developed. development is expensive. it may very well be that the costs of maintaining a distributed system is lower then the cost of developing a very large monolith with a large team. in the end it depends.;0
38082898;HackerNews;2023-10-31;actually you are wrong. microservices are surely not about defaulting to new microservices but to capture a specific context into one service. there is no rule about how big a context is. a context can contain other context's. there can be technical reasons to split deployments into different microservices but that's not the norm. what you describe is what happens when people get microservices wrong.in the end i like the viewpoint that microservices are a deployment pattern not so much an architecture pattern. usually you can draw a component diagram containing an orderservice and a deliveryservice etc. and without technical details execution environment protocols you couldn't tell if it's describing multiple microservices or multiple components in one service.;0
38082454;HackerNews;2023-10-31;team size is probably the most important factor that should influence the choice about microservices. unfortunately there was a period when it looked like every project and every team had to adopt them or be declared a dinosaur.;0
38082191;HackerNews;2023-10-31;maybe logging should be a microservice....;0
38081938;HackerNews;2023-10-31;that's not microservices it's distributed monolith and it's the one model that doesn't work but everyone seems to doi called ours a macrolith.;0
38081746;HackerNews;2023-10-31;designed. thats sometimes the issue with monoliths though they allow you to cut cornersi find this hard to relate to the idea you have the discipline and culture to do microservices well if you can't do it with a monolith.more likely is you migrate away from the monolith you never invested in fixing and once you get to microservices you either call it a mistake and migrate back or you have to eventually finally invest in fixing things.perhaps your microservice rewrite goes well because you now know your domain after building the monolith that is another option.;0
38081489;HackerNews;2023-10-31;you need a cto with a backbone to say no to the senior people hell bent on padding their resumes and scratching an itch thoughtoo often devs weaponise micro services and say its one of the key reasons for microservices is to allow free language choice !;0
38081198;HackerNews;2023-10-31;your dependencies might be tied to different jvm versions. less likely but happened few times especially during 8 to 9 transition. you would've been stuck with your entire system on java 8 for ages.also jni won't be isolated which occasionally might be a factor more likely for stability.on the other hand one could make colocated multiprocess services to work around this while avoiding all the other complexities of microservices.;0
38080578;HackerNews;2023-10-31;a microservice solves scaling issues for huge companies. if you have 60 microservices you should probably have 600 engineers 10 per to deal with them. if you're completely underwater and have 10 services per engineer you're 100 absolutely playacting webscale for an audience of ireallyi dumb managersinvestors.;0
38080441;HackerNews;2023-10-31;it's a pretty common issue. if you have 23 services it's pretty easy to manage. and if you have 1000 you likely have the infra to manage them and get the full benefit.but if you have 20 engineers and 60 services you're likely in a world of pain. that's not microservices it's distributed monolith and it's the one model that doesn't work but everyone seems to do;0
38079931;HackerNews;2023-10-31;no. a number of startups don't either. i hazard to say that even giants like tinder or uber likely can have a 30 min outage and lose some revenue and goodwill but not be hit by some exorbitant liabilities.also microservices add both resilience by running many copies and fragility many loosely coupled moving parts. which effect prevails depends on many factors.;0
38079904;HackerNews;2023-10-31;we have 2 supported langs across our cloud teams and our core libraries are duallang'd where applicable meaning they're both ruby gems and pypi packages python3 in one repo with unified apis and backed by a shared static config where applicable capability definitions etc. each dual lib is released simultaneously with matching semver versions to our various artifactory instances amp s3 buckets for our lambda layers automatically on every push to mainline by cicd.it works surprisingly well. we're evaluating a 3rd language but won't make that choice lightly if it happens at all.we have 14 micro services and it's fairly easy to rewrite the shit pile when you actually follow the micro designation. one of our services was originally in perl and we quite mechanically rewrote it in ruby in a sprint to align with our other services.speaking from personal experience when monoliths and the teams working on them get big enough you start having action at a distance problems where seemingly benign changes affect completely unrelated flows often to catastrophic effect.you make an innocuous looking resource update in the monolith like an update to a css stylesheet that fixes a bug in a flow your team owns now breaks 10 others flows owned by teams you never heard of because they were using the existing structure for selenium tests or some js that now fails to traverse the dom because some order of selectors changed etc.microservices are as much a team organizational tool as they are a code one. the idea being those that work on the service know it and all it does. they can wrap their head around the whole thing. i think some orgs don't really get this point and start with microservices completely unnecessarily for the stage they're at as a company. you always start with a monolith and if you get to the point where everyone is stepping on each other's toes from the lack of enforceable boundaries in the code you do the obvious and start to create those boundaries.microservices aren't the only way to do this of course. any way of dividing up your service with enforceable contracts will work. modules get designated with codeowners assigned to various teams. resources that were once shared get split up to align with the team structures better. many frameworks allow multiple apps or distinct collections of apis so you can still ship your onebinary without splitting out the collections into different services. as soon as you have to independently scale one set of apis but not another you can state looking at service boundaries again. for the majority that day will never come.;0
38079864;HackerNews;2023-10-31;the only way package feed complexity works and really microservices in general is to be absolutely fastidious about backwards compatibility of your packages and as open as possible with transitive dependency versions.nuget does provide mechanisms for obsoleting packages so it's reasonable to enforce that new packages should allow for a few versions worth of backwards compatibility before deprecation and finally pulling the plug.;0
38079712;HackerNews;2023-10-31;it's the difference between dragdropping a reference between projects or whatnot in your monolith project or coming up with a publish pipeline after which your merged code gets into the repo so that other people can use ityou already have that pipeline for releasedeployment though don't you? and it's already hooked up to your sso or what have you. if you have three projects in three checkouts that all have to be coordinated and merged in order so that you don't accidentally break your environment and worry about security and and and....it's the same as any other library dependency though which is a completely normal thing to deal with. the cost of separating your pieces enough that you can use different versions of a library in different services is that you can use different versions of a library in different services.i'm skeptical about microservices as a deployment model but i'm absolutely convinced that codelevel modularisation and independent release cycles for things that deploy independently are worthwhile at least if your language ecosystem has decent dependency management.;0
38079569;HackerNews;2023-10-31;a typical startup with 20k dau we need scale microservices k8s cdns etc!.stackoverflow we run a single .netbased multitenant web app running across just nine web servers at 5 to 10 of capacity 1.hacker news hn still runs on one core at least the part that serves loggedin requests and yes this will all get better someday...it kills me that this isn't done yet but one day you will all see. 2. hn had 12m mau by the end of 2022.1 2;0
38079516;HackerNews;2023-10-31;the article touches on it a bit but in my experience microservices multiply operational problems especially at startups where you don't have big dedicated infrastructure teams. all of a sudden you have 510x things getting built in ci and deployed. you need some way to debug issues so usually distributed tracing comes up. now that you have 10x as many of everything you obviously want to try to centralize things like networking authnz service discovery so you introduce some platforms to help with that... but someone has to run and maintain all that. that's fine if you want platforminfrastructure teams to maintain these but many startups only have a very small handful of people 10 or less of eng handling ciinfrareleaseperformanceobservabilitynetworkingtraffic mgmt with some title like sre or devops;0
38079514;HackerNews;2023-10-31;this is why i saw microservices are closer to the metal i.e. they depend more on the physical characteristics of their environment than nonmicroservices.a function call in a monolith can all of which are very similar to the rpc situation. however we practically never see this because of the os guarantees like memory safety security etc plus there are standardized ways of handling when these problems do occur notably try catch patterns.these issues ican be abstracted as well but the advantage of scaling being close to the metal is the disadvantage as well being very close to the hardware abstractions that let you scale.e.g. there is no difference between running a microservice on a scaling computer than guarantees memory access across a cluster with interrupts etc some millions of cpus and terabytes of memory and running it on a bunch of instances except the hardware. the former is exotic and abstracts the hardware the later does not and so all these low level errors surface with great frequency.i;0
38079500;HackerNews;2023-10-31;the 8 trillion monolith bad posts are why we are now over inundated with microservices. this is the blowback when people are realizing the cost benefit didn't work for them;0
38079463;HackerNews;2023-10-31;a well run platform removes most of the ops responsibility from the teamit might remove most of the responsibility from the original team but it transfers it somewhere else. making sure the new platform team is well staffed is something i don't see mentioneddiscussed very often in the context of microservices;0
38079352;HackerNews;2023-10-31;can we just build our localized monolith systems in a modular way so they can easily be decomposed into decentralized microservices at any sensible division when the need arises..? must we always have this debate against an idea that is stupid on its face sending remote requests for every single service..?;0
38079002;HackerNews;2023-10-31;functionally its the same stuff.both have boxes of stuff and the stuff talks to other stuff.logistically its a bit easier to scale the one where the boxes are married to closer to the hardware abstraction microservices on instances versus the one where boxes are married to the software abstraction threads with memory for the same reason one monolith is a lot faster devprocesslatency at small scales than the other microservice.you can scale both really its mostly about fights about the tooling process and where your secops decided to screw you over the most did they lock down your environments or did they make it impossible to debug portsget logs.practically aws is expensive and they're bloated. cluster environments that let you merge 1000 computers into 1 big supercomputer and have 1 million coresterabytes of ram come with different technical challenges that not as many people know how to overcome or expensive hardware bills.so i'd say if someone tells you it has to be one or the other they are blowing smoke. microservices were recently the hipnewthing so it makes sense some really really bad nonsense has been written in them so people are rediscovering monoliths and realizing the microservice people were snakeoil salesmen. in 10 years we'll realize again that some monoliths are really badly written and some people without a clue will rewrite them as microservices...;0
38078550;HackerNews;2023-10-31;or how about we want to update a 3rd party library due to a critical security issue but we can't because that library is used in 500 different parts of the code and no way in hell can we stop development across the entire org for multiple weeks.with microservices you deploy the updates to public facing services first write any learnings down pass it along to the next most vulnerable tier.heck on multiple occasions i've been part of projects where just updating the build system for a monolithic codebase was a year long effort involving dozens of engineers trying to work around commits from everyone else.compare this to a microservice model where you just declare all new services get the new build tools. if the new tools come with a large enough carrot e.g. new version of typescript teams may very well update their own build tooling to the latest stuff without anyone even asking them to!;0
38078243;HackerNews;2023-10-31;you can do the same with the approach i described. if you set up the modular dag as i mentioned above you can now set up service boundaries between the leaves of the dag. e.g. parts of the code call other parts of the code as a service. you then version and deploy the same codebase separately.say you have libraries a b and c where b and c depend on a and not one another. you can have b call into c via a service just as you would in a microservice. now b and c can be versioned and deployed independency. you can also deploy updates to library a incrementally tying it to the b and c deployments.if you are literally pushing different features that are in fact unrelated you don't even need to worry about b calling into c you can just partition your app into different modules deploy them separately and use a load balancer with routing rules to arbitrate between the deployments.i like having this type of environment because you can make fairly quick and easilyresersible decisions about whether or not different parts of the codebase are deployed differently sometimes it's compute and hardware requirements sometimes it's because you want parts to be stable and other parts more experimental and volatile.the microservice argument isn't addressing this type of deployment scenario it's suggesting a sharednothing or sharedlittle architecture across services.;0
38078234;HackerNews;2023-10-31;as a contractor having worked with a lot of teams i get the feeling that the kubernetes and microservices hype a few years ago resulted in a lot of unnecessary refactors. it can make sense of course but often doesn't and running a monolith on k8s is perfectly fine.;0
38078064;HackerNews;2023-10-31;why did you have 23 languages does not make sense i've been using microservice for a while and it was only one language at a time.;0
38077939;HackerNews;2023-10-31;i look forward to 2030 when microservices are all the rage. anyone who avoids the temptation to tear down and rebuild their entire org as a monolith will be way ahead of the curve.;0
38077933;HackerNews;2023-10-31;with microservices you can also version them independently. in a monolith you can't roll back a part of the app to the latest version if you pushed multiple unrelated features at once.;0
38077901;HackerNews;2023-10-31;more often than not the choice between microservices and monoliths is more of a business decision than a technical one to make.i think that technically you can use one or the other and make it work. however management is very different in the two cases so i completely agree with you. i hadn't thought of the part about moving people between teams.it's my first job but i understand why they chose microservices 6 teams working on 6 featuresapps can be managed almost fully independently of each other if you split your code base.;0
38077876;HackerNews;2023-10-31;in the department i work there's a lot of microservices about 56 so 56 teams. but everything is quarkusspring java and nothing else.;0
38077430;HackerNews;2023-10-31;yes a good point i think the more dynamic the language the more one gravitates towards microservices as a problem solving tool because you'd give up a lot of the value of the dynamic environment by enforcing strict rules.though i'm seeing a lot of convergence between environments over time which makes me think we're all headed towards a nicer future.for example in scala which does a lot of type inferencing it's typical to tell the linter to require that public methods have explicit types even though the compiler will reify them at compile time anyhow because that makes the interface much more robust to refactoring. meanwhile in a more dynamic environment in python it's getting more typical to use type annotations and similarly to especially use them on functions that define a reusable interface.i figure that the ideal languages in the future have modulelevel systems where they can define strict interfaces across modules but then get as crazy and dynamic as they want inside of the modules.;0
38077247;HackerNews;2023-10-31;well now that you mention it i think it does all come down to 'separating data from logic'. i was working backwards from the premise of what if we want a monolithic inprocess application to have the same cognitive simplicity as an apibased clientserver model?if you want to enforce a clean interface between an inprocess client and server i.e. a piece of code calling a library interface then the best model is to think of it as a message passing system where once a payload is passed from the client to the server and vice versa the other side should not be able to witness changes to the payload. an immutable payload in this context is the same as the json that goes over the wire between a client and server.if you really wanted an inprocess application to look like a microservice you could take the added step of forcing a serialization deserialization step on both client and server. i've seen frameworks that do this. but i think immutability if it can be enforced is a practical way of solving this problem and far less complex.inheritance is a hazier point i was making in hindsight because you could use inheritance for data modeling which is quite fine in some situations... so i think it's effectively subsumed under the separating data from logic argument which is that if you're passing ibehaviorali inheritance from a server to a client then it gets harder and harder to predict how that client is going to use it and thus it's harder to reason about the functional boundary between two pieces of code. but it's a hazy point because i think the larger and more important point to make as you point out is that you simply shouldn't in most cases pass any kind of behavior between client and serverjust data.another approach to look at besides taking inspiration from smalltalk is the actor model where it's incredibly clear that any communication between modules in an ecosystem is immutable messages. in fact a side effect of the actor model is that it gets pretty easy to move things from inprocess to crossprocess because most activity in the system is already performed through message passing so you can just start channeling messages from actor a to actor b through a serializationnetworking layer rather than inprocess if you want to deploy them separately for reasons of convenience or computational needs.;0
38077175;HackerNews;2023-10-31;having an api gateway sounds nice but thats not how ive seen it. usually the fe has to query and synchronize multiple api endpoints eg auth product billing.in this case microservices really just means let the frontend handle the complexity of synchronizing multiple api endpoints.and then we wonder why the fe is so complex;0
38077086;HackerNews;2023-10-30;microservices don't magically fix shared schema headaches. getting abstraction and apis right is the solution regardless of whether it's inmemory or over the network.instead of microservices you could add a static analysis build step that checks if code in packages is calling private or protected interfaces in different packages. that would also help enforce service boundaries without introducing the network as the boundary.;0
38077075;HackerNews;2023-10-30;this is my gold reference most issues i have seen around microservices circle around bad design decisions or poor implementations. both are also major issues for monoliths but since those issues do not surface early on it is easier to start developing a monolith and take on the technical debt to be dealt with later on.microservices architecture takes time and effort but pays huge dividends in the long run.;0
38076936;HackerNews;2023-10-30;i think it's fair to say microservices increase the need for governance whether manual or automated systems. when you start having more than 1 thing you create the how do i keep things consistent and what level of consistency do i want problem;0
38076926;HackerNews;2023-10-30;this sounds reasonable and correct but my personal experience includes more monolithic messes than microservices ones.;0
38076922;HackerNews;2023-10-30;anytime these discussions come up i always wonder if there are any great examples in the form of a deep technical analysis of microservice architecture?i've built things that i've called microservices but generally have failed to do a complete job or always left with something that feels more like a monolith with a few bits broken out to match scaling patterns.i know there are talks and papers by netflix for example but if anybody knows if any smaller scale easier to grok talks or papers that go into common pitfalls and solve them for real vs giving a handwavey solution that sounds good but isn't concrete i'd love to check it out.;0
38076878;HackerNews;2023-10-30;most places i've worked with microservices had 2 or 3 approved languages for this reason and others and exceptions could be made by leadership if a team could show they had no other options.this works well if you have knowledge redundancy in your organization i.e. multiple teams that are experienced in each programming language. this way if one or more developers experienced in language 'a' quit you can easily replace them by rearranging developers from other teams.in small companies this flexibility of allowing multiple languages can result in a situation in which developers moving to other jobs or companies will leave a significant gap that can only be filled with recruiting then onboarding which takes much more time and will significantly impact the product development plan.more often than not the choice between microservices and monoliths is more of a business decision than a technical one to make.;0
38076765;HackerNews;2023-10-30;ymmv but i think you can only do that if you have a monorepo with the shared library and all the microservices;0
38076540;HackerNews;2023-10-30;microservices are necessary and the best way to architect something new that is going to be used at scale. in my experience working with monolithic architecture with 20 teams at a large tech company i have found it takes multiple years to convert to microservices. rebuilding generally is possible in half as much and gives you the opportunity to hire good talent motivate existing employees and use the latest tech. thoughts?;0
38076411;HackerNews;2023-10-30;microservices don't cost as much if you deploy them everywhere so you get both vertical and horizontal scaling without lookup cost.of course then you need the same stack which allows multiple apps deployed everywhere.;0
38076402;HackerNews;2023-10-30;i think i view the situation in a similar fashion as you. there's absolutely nothing preventing a well architected modular monolith from establishing domainmodulespecific persistence that is accessible only through apis and connectable only through the owning domainmodule. to accomplish that requires a decent application designerarchitect and yes it needs to be considered ahead of time but it's 100 doable and scalable across teams if needed.there are definitely reasons why a microservice architecture could make sense for an organization but we don't have good application engineersarchitects should not be one of them. going to a distributed microservice model because your teams aren't good enough to manage a modular monolith sounds like a recipe for disaster.;0
38075776;HackerNews;2023-10-30;qmail probably counts as microservices as well yes. in that case for security separation of authority in a multiuser environment. nowadays we don't really do multiuser environments and separation would be by container.;0
38075700;HackerNews;2023-10-30;really doesn't make sense to me that people jump to microservices rather than creating module boundaries in their monolith.;0
38075696;HackerNews;2023-10-30;people really underestimate the eventual consistency thing. it's 100 the case your app will behave weirdly while it's processing some sort of change event. the options for dealing with this are real awkward because the options for implementing transactions on top of microservices are real awkward. product will absolutely hate this and there won't really be anything you can do about it. also fun fact this scales in reverse as in the bigger and better your company gets the worse this problem becomes because more services more brains more latency.relatedly you can't really do joins. like let's say you have an organizations service and a people service. you might want to know what people are in which organizations and paginate results. welcome to a couple of unpalatable options make some real slow api calls to both services also implement all the filters and ordering etc. pull all the data you need into this new 3rd service and justify it by saying you're robust in the face of your dependency services failing but also be aware you're adding yet another layer of eventual consistency here too.this is the simplest this problem can be. imagine needing data from 3 or 13 services. imagine needing to to synchronize uuids from one service to 20 others. imagine needing to also delete a userorganization from the 30 other services that have cached it. etc etc.i used to think microservices were an adaptation to conway's law but now i really think it's a response to the old days when we didn't have databases that scaled horizontally. but we do now cockroach big query etc so we really should just move on.;0
38075366;HackerNews;2023-10-30;i tend to call these things distributed monoliths assuming the camera ml and laser driver are integral to the functionality of the system.there is no hard rule that i know of but my heuristic is something like can i bring instances up and down randomly without affecting operations too much. if so id call that a microserviceish architecture.the waters have been muddied though. microservices were imo once associated with netflixlike scalability bringing up and down bunches up instances without trouble. but nowadays what used to be good old serviceoriented architecture soa tend to be also called microservices.soa can also be about scalability but it tended to focus more on how to partition the system on business boundaries. i guess like you did.its all a bit muddy in my experience.;0
38075347;HackerNews;2023-10-30;every company i have advised jumped on the microservice bandwagon some time ago.... here is what i tell them1. microservices are a great tool... if you have a genuine need for them 2. decoupling in and on itself with services it not a goal 3. developers who are bad at writing proper modular code in a monolithic setting will not magically write better code in a microservice environment.. rather it will get even worse since apis be it grpc restful or whatever are even harder to design 4. most developers have no clue about consistency or how to achieve certrain gurantees in a microservice setting fun fact my first question to developers in that area is define your notion of consistency before be get to the fun stuff like raft or paxos 5. you don't have the problems where microservices shine e.g banks with a few thounsands rps 6. your communication overhead will dramatically increase 7. application a that does not genuinly need microservices will be much cheaper as a monolith with proper code seperationright now we have generation of developers and managers who don't know any better and just do what everybody else seems to be doing microservices and scrum ... and then wonder why their costs explode.;0
38075268;HackerNews;2023-10-30;monoliths are isoi much easier to test and deploy!even if one service needs to be developed separately it can still live in the monolith. for dev it's easier to test. for production deploy the isamei monolith but have it only handle a single service depending on how it's deployed. you get all the benefits of a monolith while a little benefit of separate services.microservices are okay but kick up a lot of issues that can be slowawkward to solve. testing being the big one. if the business decides it's worth the exponential complexity then that's fine.;0
38074966;HackerNews;2023-10-30;looking at the costs section and considering the recent developments it seems better tooling will increasingly be helpful in running a software company. see for example nix flakes. you can now have instant and performant declaratively defined identical environments in production and development and across teams.imho widespread use of such technologies as opposed to heavyweight ones like docker could relieve one of the biggest costs of microservices they are expensive to run.;0
38074915;HackerNews;2023-10-30;i've noticed that a lot of industry practices demonstrate their value in unexpected ways. code tests for instance train you to think of every piece of code you write as having at minimum two integrations and that makes developers who write unit tests better at separating concerns. even if they were to stop writing tests altogether they would still go on to write better code.microservices are a bit like that. they make it extremely difficult to insert cross cutting concerns into a code base. conditioning yourself to think of how to work within these boundaries means you are going to write monolithic applications that are far easier to understand and maintain.;0
38074723;HackerNews;2023-10-30;well the point i was making was that the same can easily be true of microservice architectures. if you have people that don't know what they're doing architecting your microservices you'll have a difficult time maintaining them without clear and strict service contracts.it's not clear to me that we're ever comparing apples to apples in these discussions. it would seem to me that everyone arguing left a job where they were doing x architecture the wrong way and now they only advocate for y architecture online and in future shops.;0
38074684;HackerNews;2023-10-30;ideally you would use the same language if it had distributed support. use erlang or elixir for example and you have everything you need for ipc out of the box. might take a little bit more effort if you're on kubernetes.one of my problems with microservices isn't really the services themselves but the insane amount of tooling that creeps in grpc kafka custom json apis protobufs etc. etc. and a lot of them exist in some form to communicate between services.;0
38074617;HackerNews;2023-10-30;microservices not being able to talk to each other the network basically never comes up.what you are saying is outright ridiculous.;0
38074450;HackerNews;2023-10-30;my first gig out of school was a .net monolith with 14 million lines of code it's the best dev environment i've ever experienced even as a newcomer who didn't have a mental map of the system. all the code was right there all i had to do was embrace go to definition to find the answers to like 95 of my questions. i spend the majority of my time debugging distrubuted issues across microservices these days i miss the simplicity of my monolith years;0
38074438;HackerNews;2023-10-30;yep.there are situations where microservices genuinely add net value. in discussions like this one people make valid points for microservices and for monoliths. often words like large and many are used without providing a sense of scale.hers is a heuristic. its not a hard rule. there are likely good counter examples. it does sketch a boundary for the foragainst equation for microservices. would love to hear feedback about whether 100 is that number or a different heuristic would be more accurate.engineering departments with fewer than 100 engineers should favor monoliths and seriously question efforts to embrace microservices. above that theres an increasing chance the microservices could provide value but teams should stick to a monolith as long as possible.;0
38074385;HackerNews;2023-10-30;if the monolithic application is written in a language with sufficient encapsulation and good tooling around multimodule projects then you can indeed have well known and encapsulated interfaces within the monolith. within the monolith itself you can create a dag of enforced interfaces and dependencies that is logically identical to a set of services from different codebases. there are well known design issues in monoliths that can undermine this approach the biggest one that comes to mind is favoring composition over inheritance because that's how encapsulation can be most easily broken as messages flow across a singleapplication interfaces but then i'd also throw in enforced immutability and separating data from logic.it takes effort to keep a monolithic application set up this way but imho the effort is far less than moving to and maintaining microservices. i think a problem is that there's very popular ecosystems that don't have particularly good tooling around this approach python being a major exampleit can be done but it's not smooth.to me the time when you pull the trigger on a different servicecodebase should not be code complexity because that can be best managed in one repo. it is when you need a different platform in your ecosystem say your api is in java and you need python services so they can use x y or z packages as dependencies or when you have enough people involved that multiple teams benefit from owning their own souptonuts codetodeployment ecosystem or when to your point you have a chunk of code that the team doesn't or can't ownmaintain and wants to slowly branch functionality away from.;0
38074384;HackerNews;2023-10-30;wouldn't it be a hell of a lot easier if it was all in one place where each commit is globally consistent?i always find this sentence to be a bit of a laugh. it's so commonly said by either group of people with a dog in this fight but seemingly so uncommonly thought of from the other group's perspective.people that prefer microservices say it's easier to changerewrite code in a microservice because you have a clearly defined contract for how that service needs to operate and a much smaller codebase for the given service. the monolith crowd claims it's easier to changerewrite code in a monolith because it's all one big pile of yarn and if you want to change out one strand of it you just need to know each juncture where that strand weaves into other strands.who is right? i sure don't know. probably monoliths for tenured employees that have studied the codebase under a microscope for the past few years already and microservices for everyone else.;0
38074229;HackerNews;2023-10-30;not sure why youre downvoted but youre right. we heavily use microservices but we have a well defined stack. pythongunicornflaskmongodb with k8s. we run these on kafka or rest api. we even runs jobs and corn jobs in k8s.functional decomp is left to different teams. but the libraries for logging aampa various utilities etc are common.no microservices that dont meet the stack unless theyre already developedopen source eg open telemetry collectors.edit i think the article is a path to a book written by the author. its more of an advertisement than an actual assessment. at least thats my take on it.;0
38074205;HackerNews;2023-10-30;as each team dictates its own release schedule and has complete control over its codebase less crossteam communication is required and therefore decisions can be taken in less time.in my experience it's the opposite. when a feature spans several microservices and most of them do there's much more communication to coordinate the effort between several isolated teams.;0
38074153;HackerNews;2023-10-30;monoliths are like heavy trucks.microservices are like motorcycles.surely you can delivery 15 metric tons of wood with either of them. you will just need ia loti of motorcycles to match capacity.somehow a big part of industry became convinced that iof coursei that approach is better since motorcycles are cheaper easier to scale and solve some managerial problems. they don't imho.its components become increasingly coupled over timethe codebase becomes complex enough that nobody fully understands every part of itif a change introduces a bug like a memory leak the entire service can potentially be affected by it.i believe the only real solution to those challenges is competency or programmer professionalism. uncle bob had some great points on this topic.;0
38073991;HackerNews;2023-10-30;but microservices have nothing to do with scaling or deployment. the main selling point is that it scales across teams etc?;0
38073872;HackerNews;2023-10-30;microservices definitely predate k8s but sure lots of people use k8s. i don't know what penalty you're referring to. there is a minor impact on network performance for containers measured in microseconds under some configurations. maybe kubernetes makes that worse somehow? i think it does some proxying stuff so you probably pay for a local hop to something like envoy. if envoy is on your system and you're not doublewrapping your tls the communication with it should stay entirely in the kernel afaik. in no way is this throwing out performance. it's sort of like saying that kafka is in java so you're throwing away performance when you use it when there are massive performance benefits if you leverage partition isolation. many of these have no desire to communicate over network and your micro or we size services will have to cave in to their demands. simple example want to use docker? say hello to unix sockets. other components may require communication through shared memory filesystem and so on.i'm not sure what you're referring to. why would that matter at all? i mean ignoring the fact that you can easily talk to docker over a network. finally isolation is not a feature of microservicesisolation is a feature of any process based architecture whether it's soa actors or microservices. well you might have functionlevel isolation but you won't have class or module or programlevel isolationyou get isolation at the service layer. i don't see why that would be contentious it's obvious. if you're saying you want more isolation ok you can write your code to do that if you'd like. first doesn't prescribe the size.yep the actor model is very low level. microservice architecture is far more prescriptive. it's one of the reasons why i think microservice architecture has been far more successful than actor based systems.;0
38073799;HackerNews;2023-10-30;when discussing microservices the proponents almost always forget the key aspect of this concept the imicroi part. the part that makes this stand out everyone already heard about services there's no convincing necessary here if you feel like you need a service you just make one and don't fret about it.so whenever someone advocates for this concept they forget to factor in the fragmentation caused by irequiringi that services be very small. to make this more concrete if you have a monolith microservice you don't have microservices because the later implies everything is split into tiny services no monoliths.most of the arguments in favor of microservices fall apart as soon as you realize that it ihas to be microi. and once you back out of the micro requirement you realize that nothing new or nothing deep is being offered.;0
38073768;HackerNews;2023-10-30;open source projects rarely involve live services or providing saas. in those situations i think microservices are much more helpful;0
38073722;HackerNews;2023-10-30;but the work required to factor things out behind an http boundary is a superset of the work required to factor things out into a module as gp describes. so if you iwerei going to do microservices you could do that same factoring and then just stop when you get to the part where you'd add in networking and deployment scripts.;0
38073652;HackerNews;2023-10-30;the reality of this situation is that the tool everyone is using to build microservices is kubernetes. it imposes a huge tax on communication between services. so your aspiration as to improving performance fly out of the window.on top of this you need to consider that most of the software you are going to write will be based on existing components. many of these have no desire to communicate over network and your micro or we size services will have to cave in to their demands. simple example want to use docker? say hello to unix sockets. other components may require communication through shared memory filesystem and so on.finally isolation is not a feature of microservices especially if the emphasis is on imicroi. you have to be able to control the size and where you want to draw the boundary. if you committed upfront to having your units be as small as possible well you might have functionlevel isolation but you won't have class or module or programlevel isolation to put it in more understandable terms. this is where your comparison between the actors model and microservices breaks first doesn't prescribe the size.;0
38073624;HackerNews;2023-10-30;i think the thing people normally miss about microservices is that the goal of microservices is usually to solve organization and people problems and not technological ones. there's some tech benefits like allowing services to scale independently but the biggest benefit is clear ownership boundaries and preventing code from becoming overly coupled where it doesn't need to be.if you're a team small team working on a single product you probably don't need microservices since you likely don't have the type of organizational problems that microservices solve. microservices are likely premature optimization and you're paying the price to solve problems you don't yet have.;0
38073506;HackerNews;2023-10-30;i think this is a false dichotomy. most places i've worked with microservices had 2 or 3 approved languages for this reason and others and exceptions could be made by leadership if a team could show they had no other options.microservices doesn't need to mean it's the wild west and every team can act without considering the larger org. there can and should be rules to keep a certain level of consistency across teams.;0
38073465;HackerNews;2023-10-30;similarly with frontend devs thinking a modern webapp can only be built with frontend frameworkslibs like reactvuesvelte etc lately i feel there's an idea floating around that monolith equals running that scary big black ball of tar as a single instance and therefore it doesn't scale which is insane.another observation is the overall amount of code is much bigger and most of these services are 20 businessdomain code and 80 having to deal with sending and receiving messages from other process over the network. you can hide it all you want but at the end of the day it's there and you'll have to deal with the network in one way of another.just like the frontend madness this microservice cult will only end once the economy goes to crap and there's no money to support all these babel towers of doom.ps microservices have a place which is inside a select few of companies that get something out of it more than the cost they pay.;0
38073437;HackerNews;2023-10-30;found the author of cisco java spring documentation.i honestly expected people used passiveaggressive corposlang only for work ironically. but this reads intentionally obfuscated.but to answer to the substance you for some reason assumed that whoever designed first solution was an idiot and whoever designed the second was at least clairvoyant.the problem you describe isn't a result of inevitable design decisions. you just described a situation where someone screwed up doing something and didn't screw up doing something else. and that led you to believe that whatever that something else is it's easier to design.the reality of the situation is unfortunately the reverse. upgrading microservices is much harder than replacing components in monolithic systems because it's easier to discover all users of the feature. there are in general fewer components in monolithic systems so less things will need to change. deployment of a monolithic system will be much more likely to discover problems created by incorrectly implemented upgrade.in my experience of dealing with both worlds microservices tend to create a mazelike system where nobody can be sure if any change will not adversely affect some other part of the system due to the distributed and highly fragmented nature of such systems. so your ideas about upgrades are uncorroborated by practice. if you want to be able to update with more ease you should choose a smaller more cohesive system.;0
38073345;HackerNews;2023-10-30;i work on low code cloud etl tools. we provide the flexibility for the customer to do stupid things. this means we have extremely high variance in resource utilization.an on demand button press can start a processes that runs for multiple days and this is expected. a job can do 100k api requests or readtransformwrite millions of records from a database this is also expected. out of memory errors happen often and are expected. it's not our bad code its the customer's bad code.since jobs are run as microservices on isolated machines this is all fine. a customeror multiple at once can set up something badly run out of resources and fail or go really slow and nobody is effected but them.;0
38073225;HackerNews;2023-10-30;they are not the same thing! microservices is a discount version of soa with a new coat of paint.;0
38073224;HackerNews;2023-10-30;monolithmicroservice is not a trivial change no matter how wellfactored it is to begin with though being poorly architected could certainly make the transition more difficult! probably just the interface function calls become rpc.this sounds simple but once function calls become rpc then your client app also needs to handle dns server unreachable dns server reachable but rpc hostname won't resolve rpc host resolves but not reachable rpc host reachable but refuses connection rpc host accepts connection but rejects client authentication rpc host presents untrusted tls cert rpc accepts authentication but this client has exceeded the rate limit rpc accepts authentication but says 301 moved permanently rpc host accepts request but it will be x seconds before result is ready rpc host times outeven for a wellfactored app handling these execution paths robustly probably means rearchitecting to allow you to asynchronously queue and rate limit requests cache results handle failure with logarithmic backoff retry and operate with configurable client credentials trust store and resource urls so you can honor 301 moved permanently and log all the failures.you'll also need additional rpc functions and parameters to provide data that had previously been in context for local function calls.then the monolith's ui may now need to communicate network delays and failures to the user that were impossible before network segmentation could split the app itself.refactoring into microservices will require significant effort even for the most well built monolith.;0
38073211;HackerNews;2023-10-30;the biggest negative of microservices is that it creates hard ownership boundaries.this affects planning more effort is needed to understand boundaries that need adjustment or crossing.this affects execution needing to cross a boundary comes with inefficiencies and an automatic need to move with synchronization.this affects future projects service boundary clarity works against flexibility.;0
38073138;HackerNews;2023-10-30;probably just the interface function calls become rpc.network calls introduce new failure modes and challenges which require more plumbing.can i retry this rpc call safely?how about exponential backoff?is my api loadbalancer doing its thing correctly? we'll need to monitor it.how about tracing between microservices? now we need opentelemetry or something like that.how harder is it to debug with breakpoints in a microservice architecture?how can i undo a database transaction between 2 microservices?suddenly your simple function call just became a lot more problematic.;0
38073048;HackerNews;2023-10-30;no one says you can't have all of your microservices use the same language...;0
38073022;HackerNews;2023-10-30;in the java world we've developed recordreplay across microservice boundaries so it's effectively possible to step from a failure in one microservice and into the service that sent it bad data. edit for which by the way any feedback is welcome it's technically quite promising but real world experience is worth a lot!;0
38073011;HackerNews;2023-10-30;a bit over a decade ago i was sold on the concept of microservices. after implementing maintaining and integrating many microservices i have realized how incredibly exhausting it is. sure microservices have their place but understanding the often higher costs associated with microservices should be considered when developing a new service. focus on the costs that are less tangible siloed knowledge integration costs devops costs coordinating releases crossteam communication testing contract versioning shared tooling. i could go on but that's just a sample of some of the less obvious costs.i feel that the collective opinion of microservices has shifted towards being trepidatious of microservices as many have experienced the pains associated with microservcies.;0
38072897;HackerNews;2023-10-30;can you point to a comment on hn saying microservices are never justified?;0
38072730;HackerNews;2023-10-30;youre not wrong here but usually this comes down to having one or a small number of version specific container processors and i do not mean container in the docker sense to host those functions. not microservices.that said almost always if you are seriously trying to keep old unsupported dependencies running youre violating any reasonable security stance.im not saying it never happens but often the issues that the code is not understood and no one is capable of supporting it and so you are deep in the shit already.;0
38072626;HackerNews;2023-10-30;this is why i prefer the old term service oriented architecture over microservices. microservices implies any time a service gets too big you split it apart and introduce a network dependency even if it introduces more problems than it solves.;0
38072594;HackerNews;2023-10-30;i've found that microservices are fine. in fact they're pretty damn neat!but what isn't fine are inanoiservices where a service is basically just a single function. imagine creating a website where you have a registerservice loginservice forgotpasswordservice changepasswordservice add2faservice etc.while i haven't seen it that bad i've seen things pretty close to it. it becomes a nightmare because the infra becomes far more complex than it needs to be and there ends up being iso much repeated boilerplatei.also obligatory;0
38072540;HackerNews;2023-10-30;how the whole open source ecosystem is working fine and delivering software while depending upon each other for almost decades all the while not ever being in the same room and yet having no microservices?i mean take your pick anything open source be it desktop or web has a huge and deep dependency tree all the way down to libc.just wondering.edit typos and desktop.;0
38072355;HackerNews;2023-10-30;monolith first.also call stack can go pretty deep. you can't go deep with microservices. everything has to be first hop or you risk adding latency.also transactional functionalities become lot more challenging to implement across services and databases because it's blasphemous to share database among microservices.;0
38072284;HackerNews;2023-10-30;so where's the costs of monoliths post? they don't show up here because everyone is out there cluelessly implementing microservices and only sees those problems. if everyone were out there cluelessly implementing monoliths we'd see a lot of monoliths bad posts.people don't understand that these systems lead to the same amount of problems. it's like asking an elephant to do a task or asking 1000 mice. guess what? both are going to have problems performing the task they're just different problems. but you're not going to get away from having to deal with problems.you can't just pick one or the other and expect your problems to go away. iyou will have problems either way.i you just need to pick one and provide solutions. if 'what kind of architecture' is your ibiggest hurdlei please let me work there.;0
38072226;HackerNews;2023-10-30;and think of the sheer number of libraries one for each language adopted that need to be supported to provide common functionality that all services need like logging.this is the 1 reason we quit the microservices game. it is simply a complete waste of mental bandwidth to worry about with the kind of tooling we have in 2023 pure cloud native infiniscale faas especially when you have a customer base e.g. banks amp financial instutitions who will rake you over hot coals for ievery singlei 3rd party dependency you bring.we currently operate with one monolithic .net binary distribution which is around 250 megs gzipped. not even the slightest hint of cracks forming. so if you are sitting there with a 10100 meg saas distribution starting to get nervous about pedantic things like my exe doesnt fit in l2 anymore then rest assured your monolithic software journey hasn't even ibeguni yet.god forbid you find yourself with a need to rewrite one of these shitpiles. wouldn't it be a hell of a lot easier if it was all in one place where each commit is globally consistent?;0
38072209;HackerNews;2023-10-30;without getting tied up in the whole every language except assembly python and possibly javascript already solved this problem by forcing people to adhere to modulelevel apis argument i think the crux of the issue is that the article just defines microservice architecture as any architecture consisting of multiple services and explicitly states there doesnt have to be anything micro about the services. which imho is watering down the term microservices too much. you don't have microservices as soon as you add a second or third service.;0
38072155;HackerNews;2023-10-30;i suppose if you do that they will communicate over the network likely via api and have the ability to scale independently.you just invented microservices lol.;0
38072150;HackerNews;2023-10-30;i feel like this article conflates monoliths with monorepos. you can have a more flexible though not as flexible as microservices perhaps for the better engineering by just following the libraries pattern mentioned in the article and splitting each of the libraries into their own repos and then having version bumps of these libraries as part of the release process for the main application server.doing it this way gets you codebase simplicity release schedule predictability and makes boundaries a bit more sane. this should get you a lot farther than the strawmanned one giant repo with a spaghetti mess of code model that the author posits.;0
38072014;HackerNews;2023-10-30;for some reason most of the people i've worked with recently are either fully into monoliths or lots of fine grained interdependent microservices.they don't seem to understand there's a useful middleground of adding fewer larger data services etc. it's like soa isn't a hot topic so people aren't aware of it.;0
38071999;HackerNews;2023-10-30;last time i did a survey of my peers companies that were all in on microservices in the cloud spent about 25 of their engineering time on the support systems for microservices. that number is probably a bit lower now since there are some pretty good tools to handle a lot of the basics.and the author sums up the advice i've been giving for a long time perfectly splitting an application into services adds a lot of complexity to the overall system. because of that its generally best to start with a monolith and split it up only when there is a good reason to do so.and usually that good reason is that you need to optimize a particular part of the system which often manifests as using another language or your organization has grown such that the overhead of microservices is cheaper than the management overhead.but some of the things in this article are not quite right. nothing forbids the use of different languages libraries and datastores for each microservice but doing so transforms the application into an unmaintainable mess.you build a sidecar in a specific language and any library you produce for others to consume is for that languagesidecar. then you can write your service in any language you want. chances are it will be one of a few languages anyway that have a preferred onramp as mentioned in the article and if it's not then there is probably a good reason another language was chosen assuming you have strong technical leadership. unlike with a monolith its much more expensive to staff each team responsible for a service with its own operations team. as a result the team that develops a service is typically also oncall for it. this creates friction between development work and operational toll as the team needs to decide what to prioritize during each sprint.a well run platform removes most of the ops responsibility from the team. the only thing they really have to worry about is if they have built their system in a way to handle failures well chaos engineering to the rescue! and if they have any runaway algorithms. otherwise it's a good thing that they take on that ops load because it helps them prioritize fixing things that break a lot.;0
38071954;HackerNews;2023-10-30;i don't want to get too tied up in the terminology but microservicesfirst does not seem to be the problem the post is describingione way to mitigate the growing pains of a monolithic backend is to split it into a set of independently deployable services that communicate via apis. the apis decouple the services from each other by creating boundaries that are hard to violate unlike the ones between components running in the same processi;0
38071929;HackerNews;2023-10-30;there are many ways to architecture well that doesnt mean prematurely introducing micro services.im a fan of microservices btw.premature optimization and scaling is almost as bad of a form of technical debt as others when you have to optimize in a completely different manner and direction.;0
38071902;HackerNews;2023-10-30;?;0
38071833;HackerNews;2023-10-30;that comes with experience but you can let time be the judge if you factor your monolith early enough. if the factorization proves stable proceed with carving it into microservices.;0
38071755;HackerNews;2023-10-30;are many small applications running as seperate binariesprocesseson different ports talking to one database endpoint also microservices?one database endpoint as in ? you can use different schemas and have no relations between tables used by different services or on the other extreme have services which write to same table.i have read in a book that the most important criteria is independent deployability. i forget the name of the book.;0
38071736;HackerNews;2023-10-30;microservices is a newer term than soa.;0
38071694;HackerNews;2023-10-30;if a monolith is wellfactored what is the difference between it and colocated microservices?probably just the interface function calls become rpc. you accept some overhead for some benefits of treating components individually patching!what is the difference between distributed microservices v.s. colocated microservices?deployment is more complex but you get to intelligently assign processes to more optimal hardware. number of failure modes increases but you get to be more fault tolerant.there's no blanket answer here. if you need the benefits you pay the costs. i think a lot of these microservice v.s. monolith arguments come from poor application of one pattern or the other or using inadequate tooling to make your life easier or mostly if your software system is 10 years old and you haven't been refactoring and rearchitecting as you go it sucks to work on no matter the initial architecture.;0
38071693;HackerNews;2023-10-30;can't we just isolate these two services in containers using different library versions?they don't need to be microservices in order to isolate dependencies do they?in python for instance you don't even need containers. just different virtual environments running on separate processes.;0
38071634;HackerNews;2023-10-30;i do agree with that. microservices are inoti a good idea whatsoever for organizations with weak senior technical people. which is probably 90 of businesses.;0
38071560;HackerNews;2023-10-30;i think that chunking up your application layer into smaller parts is always a good idea. but when do you say its a microservice? when its completely isolated with its own database etc. are many small applications running as seperate binariesprocesseson different ports talking to one database endpoint also microservices?;0
38071531;HackerNews;2023-10-30;we started with a microservices architecture in a greenfield project. in retrospect we really should have started with a monolith. every 23 days we have to deal with breaking changes to api schemas. since were still preproduction it doesnt make sense to have a dozen major versions up sidebyside so were just sucking up the pain for now. its definitely a headache though.we also are running on aws api gateway lambda so the availability and scalability are the same regardless of monolith or not;0
38071415;HackerNews;2023-10-30;speaking from a release management point of view going from a monolith to microservices is often done for the wrong reasons.the only valid reason for actual doing the change seems to be for scaling reasons due to performance bottlenecks. everything else is just shifting complexity from software development to system maintenance.of course developers will be happy that they have that huge alignment with other teams burden off their shoulders. but the clarity when and how a feature is implemented properly tested across microservices and then activated and hypercared on production will be much harder to reach if the communication between the development teams is not mature enough which is often the actual reason from breaking up the monolith.;0
38071156;HackerNews;2023-10-30;wouldn't this just be having one or two services? i don't think that's the same as microservices.correct me if i'm wrong but isn't microservices when you make internal components into services iby defaulti instead of defaulting to making a library or class?;0
38071128;HackerNews;2023-10-30;if you want to change that model there's three things that need to happen1 engineering needs a reason to embrace abstraction. because the only thing that stops a new cowboy engineer is their peers explaining to them in what ways this isn't the wild wesst. one can assume if rules would benefit the team they'd be doing them already so why don't they? maybe they perceive feature output velocity to be too high to risk changing method. maybe decisionmaking power rests in the hands of one system architect who is holding the whole machine in their head so things that look complex to others seem simple to them in that case the team needs to spread around peer review signoff responsibilities on purpose so one engineer ican'ti be the decisionmaker and the architecture itself imusti selfdescribe. maybe this is how i see it usually happen they were a threeperson startup and complexity crept up on them like a boiling frog. whatever the reason if you're gonna convince them otherwise someone's gonna have to generate hard data on how changing the abstraction could make their jobs easier.2 if management has no idea what prioritize quality means meaning no metrics by which to measure it and no real grasp of the art of software engineering the engineers will interpret buzzwords as noise and route around them. management needs to give actionable goals iotheri than release feature x by y date if they want to change engineering culture. that can take many forms i've seen irewardedi fixit weeks and externallyreported issue burndown charts as two good examples.3 engineering leadership needs time and bandwidth to do training so they can see outside their prairiedog hole over to how other teams solve problems. otherwise they get locked into the solutions they know and the only way new approaches ever enter the team is by hires.and the key thing is microservices may not ibei the tool for the job when all is said and done. this is an approach to give your engineering team ways to discover the right patterns not to trick them into doing microservices. your engineering team at the end of the day is still the bestequipped people to know the machinery of the product and how to shape it.;0
38071120;HackerNews;2023-10-30;1. isolationwith a well built monolith a failure on a service won't fail the whole system.for poorly built microservices a failure on a service absolutely does being down the whole system.not sure i am convinced that by adopting microservices your code automatically gets better isolation;0
38071105;HackerNews;2023-10-30;shared mutable state also goes beyond a mutable reference. if you call a function and that function throws an exception you are tying the callercallee's states together. in a soa the callee machine can literally blow up and your caller state is preserved.if your web service is generally lowstate and these problems are manageable for the complexity scale you're solving for microservices aren't really something to even consider i mean you basically have a microservice already it's solving a single problem within a bounded context give or take. it's just... one service and one context.;0
38071033;HackerNews;2023-10-30;small is a relative term and not an ideal one but what it generally means is no larger than is needed that is if you have one concrete solution within a bounded context small is the code necessary to implement that solution. it's not a matter of loc. imo having everything selfcontained to one repositoryi highly recommend keeping all microservices in a single repository. it's even more important in a microservice world to ensure that you can update dependencies across your organization atomically. horrible microservices that violate data boundaries i.e. multiple services sharing a database which is a sadly common mistake is a much harder problem to solve.but that's not microservices. maybe this is in and of itself an issue of microservice architecture the fact that people think they're implementing microservices when they're actually just doing soa but microservice architecture would absolutely inoti include multiple services with a single database that would inot bei microservices.so i think the criticism would be people find it hard to actually implement microservices and not microservice architecture leads to these problems because microservice architecture is going to steer you iawayi from multiple services using one database.;0
38070970;HackerNews;2023-10-30;as with so many software solutions the success of microservices is predicated upon having sufficient prognostication about how the system will be used to recognize where the cutpoints are.when i hear success stories like that i have to ask is there some inherent benefit to the abstraction or did you get lucky in picking your cleavepoints?;0
38070933;HackerNews;2023-10-30;i rarely see anyone claiming that microservices are never justified. i think the general attitude toward them is due to the amount of resume driven development that happens in the real world.;0
38070892;HackerNews;2023-10-30;there should be a distinction between doing a migration of a monolithic system to microservices vs adding functionality to a monolithic system by implementing a microservice that will be consumed by the monolithic system.in some cases microservices are helpful for separation of concerns and encapsulation.but teams often get the idea that their monolithic system should be rewritten using microservice patterns. it's important to question whether the monolithic system is using the correct abstractions and whether spllitting it into different services is the only way to approach the deficiencies of the system.in most systems there are bits that can and probably should be quite decoupled from the rest of the system. understanding this is a more fundamental aspect of system design and does not apply only to monolithic or microservice approaches.;0
38070886;HackerNews;2023-10-30;getting the boundaries right between the services is challenging its much easier to move them around within a monolith until you find a sweet spot. once the monolith is well matured and growing pains start to rise then you can start to peel off one microservice at a time from it.i couldn't agree more. do not optimize your code applies here.;0
38070872;HackerNews;2023-10-30;if your company has a microservice architecture but doesn't have proper knowledge on how should they communicate how should they share code etc then it is the worst thing possible.;0
38070871;HackerNews;2023-10-30;granular performance and team boundaries are both valid points. but i haven't seen yet around me monolith applications so complex to have more teams working on them. i've seen instead applications developed by two persons where some higherups requested splitting them into microservices just because no scaling wasn't needed.;0
38070865;HackerNews;2023-10-30;well i'd say you've seen soa setups that do that maybe. but those don't sound like microservices perhaps that's not a strong point though.let me be a bit clearer on my point because i was wrong to say that you have to treat a service as being totally isolated what i should have said that they iarei isolated whether you treat them that way or not. there is a iphysicali boundary between two computers. you can try to ignore that boundary you can implement distributed transactions etc but the boundary is there if you do the extra work to try to pretend it isn't that's a lot of extra work to do the wrong thing.concretely you can write but under the hood what ihasi to happen physically is that your state has to be copied to the other service the service can return a new state or an update and the caller can then mutate the state locally. there is no way for you to actually transfer a mutable reference to your own memory to another computer and a service should be treated as if it may be on another computer even if it is colocated without obscene shenanigans. you can try to abstract around that isolation to give the appearance of shared mutable state but it is just an abstraction it is effectively impossible to implement that directly.but shared mutable state is itriviali without the process boundary. it's just... every function call. any module can take a mutable pointer and modify it. and that's great for lots of things of course you give up isolation sometimes when you need to.;0
38070807;HackerNews;2023-10-30;the term micro can be misleading though there doesnt have to be anything micro about the services. in fact i would argue that if a service doesnt do much it just creates more operational toll than benefits. a more appropriate name for this architecture is serviceoriented architecture but unfortunately that name comes with some old baggage as well.what baggage is that?because in my experience 90 of the argument revolves around the word micro.if micro is indeed irrelevant to microservices let's name things better yes?;0
38070771;HackerNews;2023-10-30;that depends on the culture of each specific organization. are there topdown engineering decisions? is there a push for more team autonomy?my experience is that many organizations have something of a pendulum swinging between those two positions so the current state of that balance may change over time.also many new developers when they hear microservices will jump straight to that means i can use any language i want right?maybe that's less true in 2023;0
38070749;HackerNews;2023-10-30;network calls are a powerful thing to introduce. it means that you have an impassable boundary one that is actually physically enforced your two services have to treat each other as if they are isolated.that is not too true at all. i've seen microservice setups where one microservice depends on the state within another microservice. and even cases where service a calls into service b which calls back into service a relying on the state from the initial call being present.isolation is good but microservices are neither necessary nor sufficient to enforce it.;0
38070747;HackerNews;2023-10-30;microservices has always been weird to me.people argue for them from two different drastically different points of view microservices become necessary at some point because they allow you to independently scale different parts of the application depending on load. microservices become necessary at some point because they allow you to create hard team boundaries to enforce code boundaries.personal opinion micro services are always thrown out there as a solution to the second problem because it is easier to split a service out of a monolith than it is to put the genie of bad code boundaries back in the box.an application goes through a few stages of growth1 when it starts good boundaries are really hard to define because noone knows what the application looks like. so whatever boundaries are defined are constantly violated because they were bad abstraction layers in the first place.2 after a while when the institutional knowledge is available to figure out what the boundaries are it would require significant rewritesrefactoring to enforce them.3 since a rewritemajor refactor is necessary either way everyone pushes to go to micro services because they are a good resume builder for leadership and we might need the ability to scale or people think it will be easier we can splinter off this service! ignoring the fact that they can splinter it off within the monolith without having to deal with networks and rest overhead.unfortunately this means that everyone has this idea that micro services are inecessaryi for code boundaries because so many teams with good code boundaries are using micro services.;0
38070746;HackerNews;2023-10-30;can you explain the salient distinction between a technical versus architectural solution? candidly i'm not convinced that there is one. but architectural complexity has outsized longterm costas do technical solutions of course. cicd systems are very expensive just from a monetary perspective but also impose significant burdens to developers in terms of blocking prs especially if there are flaky or expensive tests. and in this particular case it doesn't actually solve the problem since you can't successfully enforce those domain boundaries unless you already have them welldefined.ignoring microservices just focusing on underlying soa for a moment the boundary is the process. that is an enforceable boundary. i think what you're saying amounts to in microservice parlance that there is no way to prevent a single microservice from crossing multiple bounded contexts that it ultimately relies on developers. this is true but it's also just as true for good monolithic designs around modules there is no technical constraint for a module to not expand into domains becoming cluttered and overly complex.microservices do not make that problem harder but soa does give you a powerful technical tool for isolation.;0
38070708;HackerNews;2023-10-30;i find it odd that there is this widespread memeon hn not in the industrythat microservices are never justifiedi think the problem is the word micro. at my company i see a lot of projects that are run by three devs that and have 13 microservices. they are easy to develop but the maintenance overhead is enormous. and they never get shared between projects so you have 5 services that do basically the same.;0
38070700;HackerNews;2023-10-30;yeah my last company had 10 microservices the entirety of their codebase managed by a single team when i started. some of them had fewer than 5 api endpoints and weren't doing anything complex to justify that.;0
38070699;HackerNews;2023-10-30;it doesn't lack a definition there's lots of people talking about this. in general you'll find something like a small service that solves one problem within a single bounded context.how small is small? even within this comment section there are people talking about a single developer being the sole maintainer of multiple microservices. i'm a strong advocate of micro?service architecture but i would never recommend doing the all behavior is 100line lambda functions approach.a horrible monolith vs horrible microservices is subjective of course but imo having everything selfcontained to one repository one collection of app servers etc. at least gives you some ihopei of salvation often by building new functionality in separate services ironically. horrible microservices that violate data boundaries i.e. multiple services sharing a database which is a sadly common mistake is a much harder problem to solve. both are bad of course!;0
38070612;HackerNews;2023-10-30;i can understand wanting to split things off so that one team handles one service roughly.there was a recent thread here where someone mentioned he personally was responsible for about four of their microservices...;0
38070587;HackerNews;2023-10-30;yes but the widespread meme as i see it is about microservices not services in general.;0
38070561;HackerNews;2023-10-30;in the robotics world it's pretty common to have something that looks a lot like microservices as an organizing principle. ros1 would probably the robotics framework that everybody cuts their teeth on and in that you have a number of processes communicating over a pubsub network. some of the reasons for organizing this way would be familiar to someone doing websites but you also have factors like vendors for sensors you need providing libraries that will occasionally segfault and needing to be able to recover from that.1;0
38070515;HackerNews;2023-10-30;i'm as much of a build a monolith until you can't person as any but one motivation for using microservices that i haven't seen mentioned here is differing resourceinfra requirements usage patterns.throw the requestresponseoriented api with bursty traffic on something serverless run the big async background tasks on beefy vms maybe with gpus! and scale those down when you're done. run the payments infra on something not internetfacing etc.deploying all those use cases as one binaryservice means you've dramatically overprovisionedunderutilized some resources and your attack service is larger than it should be.;0
38070491;HackerNews;2023-10-30;network calls are a powerful thing to introduce. it means that you have an impassable boundary one that is actually physically enforced your two services ihavei to treat each other as if they are isolated.isolation is not anything to scoff at it's one of the most powerful features you can encode into your software. isolation can improve performance it can create fault boundaries it can provide security boundaries etc.this is the same foundational concept behind the actor model instead of two components being able to share and mutate one another's memory you have two isolated systems actors microservices that can only communicate over a defined protocol.;0
38070479;HackerNews;2023-10-30;i find it odd that there is this widespread memeon hn not in the industrythat microservices are never justified.many hn patrons are actually working where the rubber meets the road.dns is a poor comparison. pretty much everything related to your application or not needs dns. on the other hand the only thing wngman0may or may not do is help with finding the users dob.;0
38070468;HackerNews;2023-10-30;you're certainly misunderstanding me. microservices are definitely justifiable in plenty of cases and services even more often. but they need to be technically justified that's the point i'm making.the majority of soa adoption in smalltomedium tech companies is driven by the wrong type of pain by technical leaders that can see that if they had their domains already split out into services their problems would not exist but don't understand that reaching that point involves solving their problems first.;0
38070463;HackerNews;2023-10-30;it's funny because the term microservices picked up in popularity because previously most serviceoriented architecture the old term implementations in large companies had services that were worked on by dozens or hundreds of developers at least in my experience. so going from that to services that were worked on by a single development team of 10 people was indeed a microservice relatively speaking.now thanks to massive changes in how software is built cloud containers et al it's a lot more standard for a normal service with no prefix to be built by a small team of developers no micro prefix needed.;0
38070455;HackerNews;2023-10-30;it doesn't lack a definition there's lots of people talking about this. in general you'll find something like a small service that solves one problem within a single bounded context. it's definitely preferable to have a poorlybuilt monolith than poorlybuilt microservice architectures.i don't know about definitely at all. having worked with some horrible monoliths i really don't think i agree. microservices can be done poorly but at minimum there's a fundamental isolation of components. if you don't have any isolation of components it was never even close to microservicessoa at which point is it really a fair criticism?;0
38070419;HackerNews;2023-10-30;that may be true but the article describes a services architecture and labels it microservices indeed goes onto to say the term micro can be misleading though there doesnt have to be anything micro about the services;0
38070416;HackerNews;2023-10-30;dns resolution is genuninely reusable though. perhaps that's the test is this something that could concievably be used by others as a product in itself or is it tied very heavily to the business and the rest of the microservices?remember this is how aws was born as a set of microservices which could start being sold to external customers like storage.;0
38070412;HackerNews;2023-10-30;has anyone approached microservices with good old brookes modularization perspective ? when and how to split your app into modules services whatever.;0
38070380;HackerNews;2023-10-30;services are obviously a good idea nobody is arguing something like postgresql or redis or dns or what have you should all run in the same process as the web server.microservices attract the criticism. it seems to assume something about the optimal size of services micro that probably isn't optimal for all kinds of service you can think of.;0
38070361;HackerNews;2023-10-30;i find it odd that there is this widespread memeon hn not in the industrythat microservices are never justified.there's a few things in play imo.one is lack of definition what's a microservice anyhow? netflix popularized the idea of microservices literally being a few hundred lines of code maintained by a single developer and some people believe that's what a microservice is. others are more lax and see microservices as being maintained by small 410 person development teams.another is that most people have not worked at a place where microservices were done well because they were implemented by ctos and software architects with no experience at companies with 10 developers. there are a lot of problems that come from doing microservices poorly particularly around building distributed monoliths and operational overhead. it's definitely preferable to have a poorlybuilt monolith than poorlybuilt microservice architectures.i've been at 4 companies that did microservices in my definition which is essentially one service per dev team. three were a great development experience and devdeploy velocity was excellent. one was a total clusterfuck.;0
38070334;HackerNews;2023-10-30;our team of 300 we can't enforce the clear abstractions. new dev gets hired team feels pressured to deliver despite leadership saying to prioritize quality they are not aware of all the access controls they push a pr it gets merged.we have an org wide push to get more linting and more checks in place. the damage is done and now we have a multiquarter effort to reorganize all our code.this can be enforced via well designed modules. i've just not seen that succeed. anywhere. microservices are a pain for smaller teams and you have to have ci and observability and your pains shift and are different. but for stepping on eachother? i've found microservices to be a super power for velocity in these cases. can microservices be a shitshow? absolutely esp. when they share data stores or have circular dependencies. they also allow teams to be uncoupled assuming they don't break their api.;0
38070283;HackerNews;2023-10-30;i liked this well balanced approach. what i think is necessary is more capability to have hard modularisation within a monolith so decoupling is not a reason to introduce microservices. performance should be the mainonly reason to do it. it's a shame few languages support this.;0
38070234;HackerNews;2023-10-30;unfortunately there are very often bozos in your team or complete teams of bozos working on the same project as you. im sure microservices are easier if you work in a development team of smart competent intelligent developers. however im sure everything would be easier then!;0
38070220;HackerNews;2023-10-30;team velocity is empowered via microservices and controlling their own data stores.bologna. choosing clear abstractions is an enabler of focus but that doesnt necessarily imply those abstractions are a network call away.;0
38070219;HackerNews;2023-10-30;my current job hasn't been a great experience with microservices. it's a industry where i've worked with a monolith that did a lot more but having everything split between like 17 different services makes managing anything not so fun. the other big blocker is small team and only one of us met the original staff who designed this.;0
38070217;HackerNews;2023-10-30;i find it odd that there is this widespread memeon hn not in the industrythat microservices are never justified. i think everyone recognizes that it makes sense that domain name resolution is performed by an external service and very few people are out there integrating a recursive dns resolver and cache into their monolith. and yet this longstanding division of responsibility never seems to count as an example.;0
38070185;HackerNews;2023-10-30;grug not experience large teams stepping on each other's domains and data models locking in a given implementation and requiring large organizational efforts to to get features out at the team level. team velocity is empowered via microservices and controlling their own data stores.we want to modernize how we access our footable for scalereasons by moving it to dynamodb out of mysql unfortunately 32 of our 59 teams are directly accessing the footable or directly accessing private methods on our classes. due to competing priorities those teams cannot do the work to move to using our fooservice and they can't change their query method to use a sharded table. to scale our footable will now be a multiquarter effort providing the ability for teams to slow roll their update. after a year or two we should be able to retire the old method that is on fire right now. in the meanwhile enjoy oncall.compare this to a microservice team realizes their table wont scale but their data is provided via api. they plan and execute the migration next sprint. users of the api report that it is now much faster.;0
38070162;HackerNews;2023-10-30;once the monolith is well matured and growing pains start to rise then you can start to peel off one microservice at a time from it.curious what is considered a growing pain of the monolith vs tech debt that hasn't been tackled. if the issue is the monolith can't scale in performance then a services oriented architecture doesn't necessarily give you that automatically unless you know where the bottleneck of your monolith is.;0
38070146;HackerNews;2023-10-30;the article sees to take for granted that your development org is completely broken and out of control. they can't decide what to work on during sprints they furtively introduce third party libraries and unknown languages they silently ship incompatible changes to prod etc. i guess microservices are easier if your developers aren't bozos.;0
38070129;HackerNews;2023-10-30;interesting article.although one point i'd like to contest is the first pro which is you can use a different language for each service. we tried this approach and it failed fantastically. you're right about the cons it becomes unmaintable.we had 3 microservices that we maintained on our team one in java one in ruby and one in node. we very quickly realized we needed to stick to one in order to share code stop the context switching logging issues etc.the communication piece is something that solid monoliths should practice as well as is it touched on in the article. calling an 3rd party api without a timeout is not a great idea to be it lightly monolith or microservice.thoughtprovoking nevertheless thank you for sharing.;0
38070112;HackerNews;2023-10-30;;0
