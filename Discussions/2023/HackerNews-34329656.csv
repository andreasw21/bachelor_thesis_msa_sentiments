ID;Source;Creation Date;Content;Sentiment
34329656;HackerNews;2023-01-10;Title:Microservices are hard, Content: https://code-held.com/2022/07/28/microservices/;0

34448209;HackerNews;2023-01-20;sure but likely that team is not working on a single service when people say microservices. that could be soa which is more my preference but definitely not a microservice going by the most popular definition which is small enough to rewrite. btw monolith db has its own form of eventual consistency.sure on very large systems. microservices always have this even tiny systems. it gives you a smaller blast radius when something goes wrongat the cost of often having a much harder time fixing things when they do go wrong avoids overstressing a single dbmonoliths can use as many databases as they want! and you can use a single db with a microservice architecture across many microservices tho i think this is an antipattern teams often do it. alleviates single points of human dependency like the db curatori haven't been at a job that has a db curator but it compounds the bob wrote those ten services in rust who... who knows rust? anyone? issues lets you scale separate pieces independentlyyou can do this with a monolith with many technologies though seems easier to do for a microservice as a general rule. but you have to need that scale first! and yes forces you to silo the data. there are several good reasons larger orgs have been doing things this way for a long time.plenty of larger orgs also avoid microservices!;0
34404900;HackerNews;2023-01-16;i find data organization to be a direct consequence of service interface.then you will not like microservices. microservices make it harder not easier to organize data.you have to worry about problems such as eventual consistency and figure out how to join data across multiple data sources.it compounds the problem significantly and the only thing it gives you is that it forces you to silo data. that can be a good thing but it doesn't solve the data organization problem.;0
34385962;HackerNews;2023-01-15;overhead is way worse with microservices once you talk about network latency database cost infra for logging and monitoring labor to manage that and developer cost. way way way more than spinning up ten more identical webapps.;0
34385927;HackerNews;2023-01-15;yeah. agreed. for example i need to ocr things sometimes. i literally have a process running an ocr server. it's basically a microservice.;0
34375178;HackerNews;2023-01-14;thinking through the interservice interface is costlier and more transparent than calling the function in the same monolyth. that said interfaces between services are inherently better than function calls.also making mistake in microservice is more easily isolated fixed and redeployed.other than that microservices are business entities rather than just tech entities. they can be scoped evaluated and managed on business level. after all you can ask another team rewrite the specific microservice. you can't do that with monolyth.and the problem wouldn't be just buried in tech details and opinions.;0
34373680;HackerNews;2023-01-13;well that may be what you intended to say but much of what you put well pretty much all of what you put is simply an attack on the poster's character. what i read from your post boils down to the poster is clearly an elitist who thinks he is right and everyone else is wrong so his opinion isn't worthy of recognition and is wrong.character attacks on the internet are self defeating and foolish in many ways. there are little to no stakes for the attacker if wrong undermines the value of the attack. the attacker is being hostile to someone completely or mostly unknownunfamiliar foolish. the attack does nothing to address the actual argumentpoints being made waste of time for readers.rather than oppose the messenger perhaps lead with opposing the message itself. it is far less hostile and is more productive. you will get better at countering the argumentpoints if you actively practice doing it and it is better for everyone involved more focus on the issue rather than the winning a battle against someone bad. you also might spare yourself counter takedowns like you got here this one being particularly spicy.the article linked doesn't even seem to say that microservices are always bad. it simply says they are difficult to do and the author sees them as over engineering. overall a pretty common opinion.;0
34369622;HackerNews;2023-01-13;if you can't get your monolith right you probably won't get your microservices right. microservices do come with additional overhead in terms of infrastructure integrations and so on. there's a concept of microservices readiness e.g. . many organisations aren't ready to embrace microservices and if they get into microservices before they're ready then it's a lot of pain. there's also this misconception that microservices must be nanoservices. but that's not a problem with microservices architecture it's a problem of using microservices antipatterns. as with everything in technology there's no universally unique solution to all problems everything's contextspecific.;0
34358229;HackerNews;2023-01-12;except each service scales independently can be updated independently e.g. pri0 security bugs that require a breaking change can be applied to public ip facing services first can be written in a different programming language and can be rolled backdeployed independently.working in a microservice environment is nice newly created services get the latest version of whatever tools are needed older services can be upgraded as needed. avoids the problem of being stuck on some ancient version of the jvm or node.;0
34352064;HackerNews;2023-01-12;a monolith is not a giant blob that has to run fully on one instance or else nothing works. although i'm sure plenty of horrible enterprise software works that way it is not a property of a monolith.i maintain a saas written as a monolith and i can absolutely spin instances that only load one part of the code and do a single thing for example some instances only handle mqtt messages while others only serve http endpoints. that does not make it microservices it is all one code base sharing one database.;0
34351313;HackerNews;2023-01-12;what a waste of time. anyone who's not an architect or developer but regularly works with architects and developers intuitively reaches these conclusions. and this has been going on and on for almost ten years.when you watch this from the outside e.g. let's say as a consultant called to advise on a very specific aspect of software architectures it feels like they all follow a secret agreement that instructs them to go full microservices route. questioning this even as a consultant paid to do exactly that is considered unacceptable. it's like questioning your client's religious or political beliefs.i observe a similar trend with cios hired to help institutions digitally transform themselves. many operate on an innovative reasoning that consists in going full cloud and lay off it personnel which inevitably leads to increased operating and maintenance costs without exploiting the actual benefits of cloud computing. but it's already too late mrmrs cio has already left the org when this happens. and selfcongratulating words are already published in their linkedin profile.i often have two thoughts when i attend a presales meeting with a prospect customer that shows us a beautiful microservices architecture1. oh my...2. shut up and just take the money they are throwing at your face.;0
34347741;HackerNews;2023-01-12;i think your position is basically the same position that most people that advocate for monoliths which btw is a bit of a strawman created by microservice architecture advocates in the first place hold. people are objecting to servicenetwork boundaries as a default domain decomposition tool and arguing that it should be used instead when there are clear and immediate technical advantages to do so.;0
34347551;HackerNews;2023-01-12;being able to scale to any specific amount of usage is never a reason to use microservices. plenty of planetscale services and apps are powered by monoliths. and you never run into any kind of ridiculous overengineering when you refactor things into services for scaling reasons and that's not a microservices architecture in the first place.the problem has always been about people deciding that different parts of the app that differ mostly in terms of business logic somehow need to be independently deployable. it's like deciding that instead of having a single database cluster and having multiple databases and tables you need a separate independently scalable cluster for each database table because of some bogus reasons like some tables are queries more than others and different teams work on different tables and we can't let people join tables because it breaks boundaries or something.;0
34347343;HackerNews;2023-01-12;not sure what you're trying to get at here from the standpoint of developers cloud spanner is the opposite of a microservice. a microservice architecture a variant of the serviceoriented architecture structural style is an architectural pattern that arranges an application as a collection of looselycoupled finegrained services communicating through lightweight protocols a microservice is not a layer within a monolithic application example the web controller or the backendforfrontend.8 rather it is a selfcontained piece of business functionality with clear interfaces and may through its own internal components implement a layered architecture. from a strategical perspective microservice architecture essentially follows the unix philosophy of do one thing and do it well.9 martin fowler describes a microservicesbased architecture as having the following properties2a typical monolith would use cloud spanner as a layer not as a microservice.most people's criticism of microservices isn't about never having independently deployable services but rather the service boundary being based on business domain decomposition rather than essential technical characteristics. in other words different types of storage due to their technical characteristics i.e. blob storage for photos vs relational database for transactional entities being served by different services for technical reasons is eminently sensible and not something most people would have issues with and has been around for much longer than microservices. the problem is more around people deciding that for a hypothetical financial website backend that bonds and stocks should be two separate microservices rather than just two endpoints served by the same monolith even though they differ merely in terms of business logic and do not require any special handling from a technical perspective.;0
34346063;HackerNews;2023-01-11;at this point i think microservices architectures don't exist. as if a microservice is a goal on its own. i think any sane organization strives for a healthy tradeoff between manageable code and separation of concerns.;0
34345901;HackerNews;2023-01-11;i agree that i took it a bit far to make a point that just ruined my case.i do think that in a monolith you try to do most things yourself.take auth for example. it's huge. and i think we more and more are excepting that even for a monolith we do not want to do that ourself.if you start from scratch and your spec say that they want oidc and saml then most ppl will look for a saas service to get help.same with storing files we would make use of s3 or similar.but if we go to pre 2010. i think most people would try to both of these themself.im not saying that this is microservice at all but i'm saying we are moving stuff that are commodity's out from the monolith compare to what we did 1015 years ago. because there are services that does a much better job for us.and that was part of my point with the original comment. that trying to keep everything in one place is probably not the right choices.sorry for not being more precise on my previous reply.;0
34345347;HackerNews;2023-01-11;funny you said that since a microservice api is always dynamically typed and its usage cannot be checked by compiler. and the more microservices you use the more dynamically typed the whole project gets overall.i mean this is just not true in the general sense. i've setup plenty of microservices with various typed apis. protobufs are an example of an extremely easy to implement strongly typed api tool.i don't think you have to define a microservice by http requets with json.;0
34345304;HackerNews;2023-01-11;i tend to split things up based on the resources required.we had a decent sized data pipeline that was entirely microservice and serverless and it was a real joy to work with. our nlp code lived in a service that ran on gpus our ingest service used a high ram but relatively simple cpu service to do inmemory joins cheaply and efficiently we had a bunch of specialized query services that were just direct requests to aws services or a light lambda wrapper around a call to a service.coordinated things with airflow and it was very easy to maintain and scaling was pretty efficient since we just scaled the pieces that needed it without wasting money on unneeded compute.;0
34345109;HackerNews;2023-01-11;if thats indeed the most useful general thing that can be said about this question then it means the microservices crowd has iwoni at least insofar as it deserved to win. the point is not that everything needs to be a microest possible service the point is that we all now have applications built out of looselycoupled services as a primitive in our reasoning toolbox.in a world where microservices havent yet won we think rpc is obviously always a good idea and build our web apps as isapi modules and aolserver extensions.i think very similar things when i hear casey muratoris opinions on oop1 which he titled getting rid of the oop mindset but id summarize as absolutely do make an object or two if that fits your problem domain but remember that it doesnt have to and use your judgment thats what oop winning ifeels likei from the inside once youve internalized it. once people can look at a thing and think you know what that looks like an object oop has won even though people wont always be right and not literally all the things are best modelled as objects.in a world where oopor lexical scopehasnt yet won we read papers about actors struggle to understand what the authors could possibly mean and implement a small language in order to have a version of those ideas we can play with. the language ends up being called scheme.the same probably applies to structured programming though it seems that structured programming deserved to win quite a bit more than the others and though i dont have easy access to prestructured programming lore the same way i do to preoop or premicroservices lore.in hindsight old good nowaccepted reasoning frameworks always seem to consist entirely out of trivially right stuff on one hand and outrageously wrong stuff on the other. thats entirely by design and doesnt mean the ancients were stupidthis is culture working correctly and well. it means that iyoui who has before only ever been in contact with the consensus that emerged out of their bitter struggles have such a deep and implicit knowledge of that consensus that the good points that were once revolutionary sound obvious to you. youre only seeing the bad points because those are the ones that didnt find their way into the culture.scott alexanders metaphor of philosophy in the water supply234 is the best explanation of this that i know.1 2 3 4;0
34344749;HackerNews;2023-01-11;microservices are excellent when you have a selfcontained set of apis that need to be updated independently of other code. you must adhere to a contract publish the contract and provide backwards compatibility for all existing clients.perfect example is a payment service. you have api tiers client tiers backend service tiers and likely customer service tiers hitting it and getting payment histories issuing refunds and hopefully requesting payment transactions. this code will likely change constantly and you want to deploy it on your own schedule versus having to match the schedules of all of the clients.other candidates might be an image upload service that crops resizes and creates copies for cdn origin calls or a fraud scanning api that scores text submissions.you definitely want to keep the number of microservices small. at some threshold the number of services becomes unmanageable because you have to support all the old interface versions.;0
34344668;HackerNews;2023-01-11;this article doesn't provide any insight into when monoliths might be a better choice than microservices. it just says that if you do microservices you'll make awful mistakes and end up with a bad result.the word macroservices sort of sums up the whole conversation to me. people are so convinced that microservices can't be done right that when they start to do microservices right they think they need to invent a new name for it.everything that can be done successfully can also be done poorly and unsuccessfully. what's the word for walking successfully? walking. can you imagine what babies would say about walking if they could blog?walking is an extremely popular and hyped activity that has achieved an impressive amount of mindshare in the past several months. caregivers appear to be highly invested in walking as a key to unlock unprecedented mobility. however if you look past the hype to the reality walking is mostly about falling down hitting your head running into things and crying because you suddenly realized you can't see your caregiver. at doodooheadcorp we have developed a new approach that delivers on the promise of walking without miring you in all of its failures. we call it realwalking. realwalking consists of moving from place to place while propelling yourself forward in a dynamically balanced bipedal fashion. note that iby definitioni realwalking involves moving from place to place a crucial distinction that guides you away from one of the biggest pitfalls no pun intended of walking. traditional approaches to walking have often resulted in babies standing up and immediately falling backwards into the same place where they started. horizontal displacement is crucial and too often ignored by babies who have gone down the rabbit hole of walking. this is where realwalking innovates by leveraging the power of dynamically balanced bipedalism.just freakin' say it's hard you should be prepared to learn along the way and at every moment your ambitions should be scoped to your capabilities. there's no alternative that can claim differently.the factors you should consider when considering whether you will be successful with microservices seem to be outside the scope of this blog post so i won't address them either.;0
34344651;HackerNews;2023-01-11;using s3 to store and serve documents rdbms and datadog for monitoringlogs doesn't make a microservice architecture.that's quite typical monolith as the term monolith never means that literally everything is in the codebase.;0
34344092;HackerNews;2023-01-11;you should have a well curated db regardless of whether one or many domain specific services sit in front of it. that is what would enable you to break a monolith up. good code and architecture is the result of discipline. your data is your most valuable asset. what you're describing is a mess.you mentioned rpc's. your service interface has nothing to do with the data organization.but if you think microservices is what would work for you then you should pursue that next time. my original post was a path to a multiple service architecture that approached service expansion with technical rhyme and reason. it really wasn't aimed at your organizations messy database.;0
34343650;HackerNews;2023-01-11;i really do not understand the debate on monoliths and microservice anymore. don't go extreme in any direction. context context contextthat is exactly why debate occurs. all religions be it microservices or tdd are taking some good ideas to an extreme and removing context from the decision making process.otherwise the term microservices wound never be invented people were doing services since the dawn of time. but you can't create hype out of common sense you have to go to the extremes.;0
34343506;HackerNews;2023-01-11;individual microservices are less complex than monoliths ... but the sum of microservices is still as complex as the monolith. but better hope you got your division of domains and services correct!a single developer and work and test it on their local machine ... ok i've never encountered a monolith that couldn't be run and developed locally. i don't say it was never a problem but that there must have been other solutions to it than microservices. surely today's laptops can easily compile and run a million lines of code...and as the counterpint i've encountered cases of having to orchestrate 15 different microservices locally to do anything useful and noncontrived. something to help you gain some understanding of how the whole system work and not rely on other people with the full overview to tell you can evolve your small piece of it.rapid development fix your build and test cachingonly ... testing a small part of the entire architecture again with a monolith surely you can focus on a single test function subcomponent and figure out how that works. with microservices it gets a lot harder to do integration testing across the whole system and people tend to not do it or argue why it isn't needed. but keep in mind that also with monoliths it is entirely possible to simple ideleteiinot writei the system integration tests. it is just that people tend to want to have them for good reasons but with microservices there's a much higher investment needed to get them and they don't execute any faster but slower if you invest in them.this comes down to an argument of we make such perfect code we don't need tests...... just because it is network calls and apis doesn't mean that noone ever messes up and does a backwardsincompatible change.simply dropping system integration tests and discovering bugs like that in production is an option for monoliths too.;0
34343403;HackerNews;2023-01-11;this issue is about microservices because the one alternative to this dblevel data sharing is having proper rpcs or more specialized things like pubsub in some cases between cleanly separated services. if logically separate things are sharing data through the db itself you will get a mess even if you're very careful which they were.;0
34343325;HackerNews;2023-01-11;we were really happy with google app engine for the same reason. it's a product that feels like it was 10 years too early.like you i feel the whole microservice debate turns into a depending on definition kind of thing and feels odd. write stateless code that can infinitely scale is it 1 or 100 services? just depends on the perspective really...;0
34343247;HackerNews;2023-01-11;you mean the few extra imegabytesi of ram for some extra compiled code on each node?if you refer to databases splitting one service into two services can iat mosti give you a 2x scaleup potential usually a lot less and the effect diminishes for 3th 4th service. mathematically and logically. splitting services vertical scaling.if you want 100x 1000x scaling you need to invest in true horizontal scaling anyway and that works pretty much the same way for monoliths as microservices.;0
34343243;HackerNews;2023-01-11;thats still not a microservices vs monolith problem. thats a bad data stewardship problem.if your data is a mess before you decided to break out functionality then its gonna be hard regardless. you should have good schemas and db organization always.;0
34343184;HackerNews;2023-01-11;when going from tens to hundreds do the hundreds manage to produce anywhere near a manyfold increase in performance though?my impression is that microservices is a solution to keep a hundred people happy solving auxiliary problems you create for yourself while producing about the output for the company that the tens would provide.if management insists on scaling from tens to hundreds you can't very well keep the tens occupied on irrelevant side project. so instead you can do microservices. either way you get the speed for the company of tens though.;0
34343108;HackerNews;2023-01-11;i think many including me would still consider an application written in lambda functions a monolith.it's how databases are used etc. that matters for service boundaries.there really isn't that much difference between a stateless monolith deployed in k8s a lambda function and a microservices with one function in each service ... it's all just stateless code anyway.;0
34343023;HackerNews;2023-01-11;microservices are merely just another hype in the it world.everyone ran with it and now we're stuck with thousands of fragile and unmaintainable systems which will ruin companies in the coming decades.;0
34342895;HackerNews;2023-01-11;microservices suck and i hate the it world for hyping it and jumping on the bandwagon to nowhere.we never should've gone with this. it makes things ridiculously difficult with almost no benefit.just stay with the trusty old monolith!;0
34342879;HackerNews;2023-01-11;this doesn't make much sense. interesting business conversations should map 1to1 with microservices but also each microservice must perform a simple idempotent business task ibut alsoi microservices can't be coupled to a database? okay enjoy developing your business with no data persistence whatsoever and where your architectural principles forbid you from ever so much as sending an email.;0
34342838;HackerNews;2023-01-11;when discussing turning our monolith into microservices at a previous jobmy boss i'm convinced this is the right architecture.also my boss now how do we break this app up?he was certain we needed to shatter our monolith into lots of little pieces but had no clear vision as to what those pieces would be. from my point of view the architecture he was certain of wasn't an architecture at all. it was just a general notion of doing what he thought everyone else was doing without considering anything about our app. total cargo cult mentality.;0
34342827;HackerNews;2023-01-11;microservices are analogous to classes from oop an attempt at modularization by bundling function internal state and sideeffects together. so it suffers from the same challenges. its worse in fact as the message passing now involves unreliable io and the internal state is also shared global state.the main reason it exists is because of the availability of cheap commodity hardware for servers and later cloud which breaks the model of programming for vertical scaling afforded by the mainframe model. its out of necessity to scale cheaply that this architecture is followed the rationalizations that this is a superior way for teams to work together or that it improves reliability can be argued.;0
34342630;HackerNews;2023-01-11;if you can solve a problem without a microservice then probably it's not the right tool for the job.;0
34342139;HackerNews;2023-01-11;i keep reading these microservice essays where the author is lost and i really feel their pain. in that spirit let me try to make things as simple as possible.true microservices have no dependencies on anything but unstructured text data. they do not couple to a database the business understanding of what it's doing a domain model or anything else. they perform a simple idempotent business task that can never fail although it can create various error chains.programming at scale is tough. there's no free ride here. all you've done is turn the traditional model of coding insideout and now you've got a ton of work doing all of the wiring.but if you keep your microservice doing one simple useful business thing then all of that insideout work become business decisions. what do we do if the signup fails? how do we move importantthing to those other guys to use? you still have business coupling things change and you have to adapt. but you're not coupled at the coding level. if there's any magic that's it. your business should be able to wander all over the place and your microservices hold up just fine. the old way where we may have coupled every little business need or want with every piece of code in the system was not only a pain more importantly it was impossible to keep organized in any one person's head and aligned with everyone else at scale.what i see is a lot of drift. folks start coupling things up perhaps by trying to create one domain model to rule them all. they start creating microservices to do system activities like flushing a cache. there should be a onetoone correspondence between your microservices and interesting business conversations. that's a hella discipline to maintain. it may force a lot of conversations you thought you could avoid by hiding them in a class hierarchy somewhere. once you start drifting pretty soon you're writing essays like this. and then here we are;0
34342064;HackerNews;2023-01-11;microservices are not a miracle cure or the solution to every problem but they do force divisions within the code base.do they? the code itself may be in entirely separate repos but still be tightly coupled. monoliths can have cleanly separated librariesmodules those modules built from separate repos or at the very least different namespaces.the macroservices i've been seeing are many separate containers all sharing at least one data store. so they have all of the disadvantage of the ball of mud monolith combined with all of the disadvantage of much more complicated infrastructure. yet the people working on them think they're doing microservices because k8!the microservice separation is not just code in separate repos. it's also everything else behind the kimono keep that kimono clasped tightly!;0
34342055;HackerNews;2023-01-11;lucky you that you haven't been hit by the purists.i am currently getting a hard intro into a microservice first architecture. where customers are managed in one service users are managed in a different one user operations are in a third one. all have their own databases and much of the data is copied between them. there are microservices that are used by only one other microservice.that's where we are now arguing about the validity of microservices are the bestfirst approach.microservices are defined as self contained highly granular separately developed and deployed horizontally scalable systems.think about the debates about linux vs hurd that's where we are.;0
34342035;HackerNews;2023-01-11;having run k8s and classical microservices before i am now in a much happier place just using the aws serverless suite lambda api gw cf sns sqs eventbridge dynamodb etc.is my setup microservices? well maybe depending on your definition but in truth i don't really care it works pretty well.we also do ddd with it and have multiple aws accounts with these marking the domain borders. comms between the accounts is via eventbridge or very rarely interaccount api invocation.this allows many of the benefits of microservices without the pain of dealing with k8s. clean separation of domains reduced cognitive loads for teams each of which looks after all the stuff in a single account socalled feature teams where each team designsmanages and runs everything in that accountdomain.the hard bit was defining the domain borders and the interdomain protocolsinteractions but once this is well defined things work pretty well.having come from a k8s world this setup feels so much nicer and lighter and easier to get stuff built in a both fast and performant way.it would be interesting to see trends away from classical cloudnative k8s setups with microservices to true serverless setups. i wonder how much of k8s's lunch serverless has managed to eat so far.;0
34341898;HackerNews;2023-01-11;funny you said that since a microservice api is always dynamically typed and its usage cannot be checked by compiler.not true at all i have a build system in place that when changes are made to typescript the json schema on the endpoints is updated and client libraries are updated.types are validated at both compile time and runtime.this is just one of imanyi solutions to the problem there are a lot of ways to get type safety for service endpoints at both runtime and compile time.;0
34341604;HackerNews;2023-01-11;i don't see that distinction being made. the counter argument is things like libraries vs microservices. those articles ignore the common case that probably is true for 99 of the apps we live in a service based architecture. the internet is service based. everything an app talks to is service based. so quit arguing about it.microservices don't address any of the issues i ever faced or people on hacker news talks about like mixing languages building code around organizational structure isolating faults etc. microservices are way to granular to address those issues well. the only time i ever wrote a microservice is when i had to wrap some stupid siteminder binary apache mod blob.also almost nobody writes a monolith if they say they have a monolith they are probably lying. do they have a database? s3? erp crm blah blah blah. nobody in their right mind would build microservices that is nuts unless they have some really special architecture. so can we quit the endless debates about stuff and instead focus on the real issue how to build robust and maintainable service architectures? how to partition systems properly so you can manage avoiding having conflicting data? eventually consistent systems etc.this is as dumb as the cisc vs risc debate i lived through in the 90s.;0
34341570;HackerNews;2023-01-11;you microservice can be easily tested.but then you may end up with is your whole system testable and how do you do good integration tests?right now i work in a pure microservice architecture where there are no proper system or integration tests. and we had minor bug fixes break things spectacularly.;0
34341499;HackerNews;2023-01-11;the argument against microservices is simple there should be a clear use case for a microservice. don't go we do everything as a microservice. almost 20 years ago we had we do everything using soa... same thing.and your own comment shows that microservice advocacy are inconsistent individual microservices are far less complex than monoliths which allows even a single developer to work on a microservice run and test it on their local machine database system can be considered a microservice and that's hardly simple or tinydbms is as much a microservice as many other microservices are. you cannot just replace a dbms with another transparently just like in many cases you cannot just deploy a different version of a microservice without coordination.;0
34341441;HackerNews;2023-01-11;well i'm of the same opinion as the guy that wrote this short piece in 2018 insisting on always having a separate db for each service is not a pattern it's pure madness.;0
34341364;HackerNews;2023-01-11;well if you use a scalable saas like cloud spanner do you then comfort yourself with the idea that you avoided microservices? because that seems a little hard to defend on the facts.;0
34341275;HackerNews;2023-01-11;start with a monolith that will take you very far.when the organization gets big enough and only then add an additional domain oriented service. fully implement deployment and infra. only once you do that can you think about adding another using the pattern you just built out.micromonoliths.organizations explode the number of services half ass the infrastructure the hard part of microservices and then crumble under the organizational complexity.;0
34340956;HackerNews;2023-01-11;often people think microservices are the right tool for the job but they vastly underestimate the complexity that it entails.and that goes 10x if deploying monitoring or debugging said services is someone else's problem amptrade i'm also cognizant that such a situation is just as much an organizationalpeople problem as the rest of this debate but i have a sore spot around people making decisions where they don't have to suffer the consequences from them;0
34340880;HackerNews;2023-01-11;enough pieces so that 1. your engineers are not afraid of doing changes.i dont really understand that argument and i dont really feel safer making a change to a microservice inside a large system as opposed to making a change to a monolith the consequences of a mistake are equal in both cases although harder to observedebug in a microservice architecture am i missing something?;0
34340827;HackerNews;2023-01-11;yeah i'm saying uber's problem was cultural and organizational not technical.that's the issue currently with microservice architecture zealots microservices for the sake of microservices.;0
34340794;HackerNews;2023-01-11;i'm sorry but as someone that actually works on ml pipelines no ml is a microservice.data space doesn't work well with microservices.;0
34340744;HackerNews;2023-01-11;this ties into the fallacy that microservice architecture is inherently infinitely scalable.microservice advocates championed this fallacy implemented it... but now when it's time for critical retrospective it's not their failure.;0
34340726;HackerNews;2023-01-11;ok so if this is where you come fromthe entire point of the big ball of mud is that there are no meaningful divisions in the code.... everything uses everything willynilly....not a single line of code in the system that you can change without fear of bringing something else down that you may not have even known they existed...then ok perhaps the developers who caused the state you describe above would not cause the exact same problems with microservices but will they really move fast any not cause a mess given any kind of environment?the state you describe is not normal of monoliths by any stretch.it may be normal of old legacy systems with 5 generations of programmers on it. also i believe microservices will have other kind of problems but still deep problems after 5 generations of programmers.if preventing people from running in the completely wrong direction of the goal is your main concern why even be in the race at that point. find new people to work with.if you personally had success rewriting a ball of mud into microservices consider if perhaps the rewrite is the important word as well as quality of developers involved not whetyer the refactor was to a new monolith or new microservices.microservices with boundaries drawn wrong can cause you to need to spend 20 programmers do the job of 1 programmer. perhaps the mud looks different from a big ball but it is still mud.;0
34340670;HackerNews;2023-01-11;common definition of a microservice is basically a module.this is not the first thread on the topic.and considering the number of people actively defending microservices like it's debates about iphone vs android over a decade ago i'm going to say that too many people can't rationally look at this at this point. too many emotions flying around.;0
34340629;HackerNews;2023-01-11;microservice architectures can't have big global variables typing things together structurally.oh sure they can just call it the db. shared state between servicescomponents is the most debilitating mistake ive had to deal with over the years. it doesnt matter if its a monolithic shared memory desktop app or a highly distributed architecture with central storage.;0
34340456;HackerNews;2023-01-11;the hate is directly proportional to the failure of microservice zealots to deliver on the ultimate everlasting universal prosperity and harmony that they promised.;0
34340414;HackerNews;2023-01-11;agreed. i would add an extra thought around try to go monolith until things really breakdown but you get at that in so far as the point where things breakdown is where eithera engineers are afraid of or find making changes difficult b uptime issues result in heavy endpointsservices taking down othersto your point microservices should be introduced expressly to solve those two problems and not before.;0
34340343;HackerNews;2023-01-11;i you're not allowed to have a share db with microservice architecture.ithe law won't prevent you but indeed it is impractical. as i said before things like schema upgrades become impossible if you don't have the ear of other teams. when you can't call up another team you also lack trust so security becomes an issue as well. this is why teams who operate in independent silos must ultimately have their own databases.the practice has nothing to do with performance though. microservices has little to do with technology at all. it is about people.i the more i work with microservices the more i'm convinced that microservice first architecture is garbage.ii personally steer clear of organizations so large that they need to silo their teams internally but i have had a positive experience using services provided by other companies with the only communication between us being api contracts. the concept works well enough. at least so long as the product does what you need of it.if you try to force big business practices into a small organization you're no doubt in for a bad time. that said i don't get the impression you are talking about microservices at all just a bad case of overengineering.;0
34340319;HackerNews;2023-01-11;the discussion of microservices vs. monolith feels a lot like nosql vs. relational one. that is to say microservices are a bad idea right up to the point where monoliths won't work.most services can be successfully implemented with monoliths and relational dbs for that matter. only when that solution doesn't scale anymore that's when microservices come in handy. particularly when a large service has core functionality that must always run and secondary functionality that can tolerate higher rates of failure.;0
34340283;HackerNews;2023-01-11;i think the key point in the article is the conclusion try building things more as modules that can be easily split off into separately running server applications as needed later.so in practice that could look like the interface to your module should use parameter objects 1 for function calls and build in the assumption that most information retrieval or processing requests are async. then when the time comes swap out the local version of the module of the client stub version.to avoid manually writing the serialization those parameter objects should have been code generated already. although the goals of something like trpc 2 are admirable having to manually check inputs with typeof 3 honestly shouldn't be necessary. and allowing nonnullable fields may make field deprecation extremely difficult or impossible. guess what? if you have any native mobile clients they may not upgrade for years! openapi also exists but seems a bit too verbose to read or author manually.so what would i suggest? just use proto3grpc 4. it defines the json encoding if you haven't clients that can't talk native protobuf or don't want to have bikeshedding over what typecasing to use for json serialization. if your cloud provider doesn't do it for you already just drop an envoy with the grpcjson transcoder in front 5. if you can't prove you'd have an actual performance problem due to grpcprotobuf then it probably isn't worth the effort to use a less battletested messaging library.so back to the main topic... it doesn't have to be hard to do microservices when the time comes just make sure your codebase is easier to convert.1 2 3 4 5;0
34340199;HackerNews;2023-01-11;they limit the blast radius to the scope of systems that either directly or indirectly call the microservice which is commonly the same blast radius as a monolith that was replaced by the microservices.;0
34340085;HackerNews;2023-01-11;title has been editorialized? the original post is microservices are a big ball of mud.;0
34340069;HackerNews;2023-01-11;conway's law doesn't apply to microservice architecture.microservice architecture splits the functionality farther than conway's law talks about. when a single team owns 45 microservices that's beyond conway's law.;0
34340057;HackerNews;2023-01-11;this argument is brought forth a lot but it misses the point. often people ithink microservices are the right tool for the jobi but they vastly underestimate the complexity that it entails.;0
34340020;HackerNews;2023-01-11;tbh his definition of module brings it awfully close to microservice.;0
34340006;HackerNews;2023-01-11;but he's replying to an article that says don't use microservices use independently deployable modules. your comment has more depth than the article itself.;0
34340005;HackerNews;2023-01-11;you're not allowed to have a share db with microservice architecture. every microservice is completely self contained...the architecture of my organization was created by ardent microservice advocates that took the definition of a microservice and treated it like a bible. based on the conversations i had here there are still people that treat microservices as sacrosanct.the more i work with microservices the more i'm convinced that microservice first architecture is garbage.the copying of the data is the solution to data access latency.;0
34339932;HackerNews;2023-01-11;i'd rather work on a bad microservice than a bad monolith.that's not the choice. the choice is between a bad monolith or a bad microservices ecosystem.and the microservices tend to come with organizational policies too that may or may not allow you to access see or change some subset of them.;0
34339893;HackerNews;2023-01-11;which is actually unlikely sarcasm aside even the absolute worst systems have more structure than that in a microservice architecturenope the absolute worst systems have the same complex circular dependencies as monolithic bboms the microservices just call into each over the network rather as function calls imagine for example an api request into service a that calls into service b that calls back into service a. you may argue that makes it not a true microservices architecture but one could make the same claim about a modular monolith.;0
34339870;HackerNews;2023-01-11;use the best tool for the job. it's stupid to think of monoliths vs microservices. you can use both if the problem requires it.for example i'm currently working on an audio hosting service. the main app is a monolith where 90 of the code resides but there are a couple of ancillary services.audio encoding which is heavily cpu bound is a serverless microservice that can scale up and down as needed. users don't upload content constantly but when they do you want to be able to encode stuff concurrently without blocking the main app. audio streaming is also a serverless microservice because hey for every user uploading content you can have 1000x consumers or more.;0
34339803;HackerNews;2023-01-11;in my experience most places rearchitect to microservices because they have a shitty monolith that they are dealing with.the monolith has been built over a span of 10 years. it is fragile brittle no one understands how the whole thing works and large scale refactoring without widespread breakage is near impossible. no one wants to touch it because no one understands how the whole thing works. because of this the codebase is also falling behind and isn't staying current with language updates i know everyone here likes working with 10 year old tech but it does affect hiring when you have to say that you're using java 8but it is true that distributed monoliths are very common. one problem is that it's hard to get everyone on board with going all the way. the question do we really need multiple databases is one of the main culprits that spawn distributed monoliths.;0
34339743;HackerNews;2023-01-11;you're right and i think most engineers know it. the debate persists as a proxy for a separate debatee i want to reorganize this because it's ugly and hard to work with as it ism i want you focusing on this list of featuresbugs and not introducing risk by making changes for other reasonssomething doesn't feel right aboute i'm the expert you have to take my word that this change is necessaryso if depending on whether e wants to join or separate they put on their ihateheartmicroservices hat and rehash whichever side of the tired old debate serves them.people who agree or disagree dust off their ihateheartmicroservices hats and we go to town for a while.we're not actually arguing for micro vs macro we're talking about the context specific details we just dress it up in those terms because m is in this meeting and m isn't close enough to the code to keep up with a conversation about the details.if enough energy is not expended in this process whoever lost the debate goes and writes a blog about why they were right. except nobody will read a blog about their specific codebase so it ends up being about whether they hearthate microservices.;0
34339695;HackerNews;2023-01-11;i where user account information is copied to every single microservice's internal db... to minimize access time to that information...iin terms of access time what does that gain you over a bog standard shared database? with careful planning you can likely achieve the lowest access times using a shared database. there is so much more room for optimization at every level.the reason actual microservices teams only communicating via api contracts must carry out this practice of duplicating data is because a shared database requires nonapi communication for various things like enabling schema changes. if you can call up someone on another team to talk about how to upgrade the database and reach a shared understanding what do you need apionly communication for?did your organization become confused about why they are doing that and then invented a performance argument to justify it?;0
34339686;HackerNews;2023-01-11;sure i guess if you completely redefine the word microservice to something completely different from the common understanding it makes more sense.if someone is writing about microservices they are generally talking about the situation where those apis and team boundaries are exclusively or at least primarily composed of separate applications communicating over the network. not what you're talking about.;0
34339679;HackerNews;2023-01-11;it is hubristic in the extreme to sit in judgement over the architectural choices a team has made on a system you dont know or understand and just downright rude to conjecture all the worst failure modes of that architecture and then assume that they constitute what your candidate values.it's more like a cultural fit. microservice oriented people brings too much friction into the process.;0
34339606;HackerNews;2023-01-11;microservices is defined to be extreme decomposition which is not the same as a service. and the biggest pitfall of microservice architecture is the creep of loose coupling.right now i work in an environment where user account information is copied to every single microservice's internal db... to minimize access time to that information...restaurant provides you with a service one single interface.imagine if a restaurant used a microservice architecture? you'd be spending your time going from the fridge to the cooks moving your food from one to anotherbecause no cook will do the whole recipe then going to the dish storage having a separate cook arrange your food on your plate etc.;0
34339603;HackerNews;2023-01-11;often the microservices hate is around sole developers ranting about how a waste they are and how everything would be way better if only everyone was very careful and had good practices totally as second nature.and it's similar in nature as the hate around high level languages if only everyone had decades of experience with c toy languages wouldn't exist and programs would be lighter and faster today.;0
34339573;HackerNews;2023-01-11;microservices can be useful when a single team cant handle a service anymore. you should have as few services as possible not as many as possible eg see team topologiesotherwise use modules or package by feature to prevent the big ball of mud problem. thats useful within a service as well.;0
34339527;HackerNews;2023-01-11;no sorry the field is not ridiculously young. the issue is the technical decision making process is now delegated to ridiculously inexperienced developers. an external dependency is a microserviceregret to disagree again. flip that and you have a leg to stand on at least a microservice is an external dependency. iservicei defines the iarchitectural semanticsi of the dependency. micro iscopesi the services provided.;0
34339491;HackerNews;2023-01-11;you can have comparable problems with microservices. those bbom problems you highlight occur when good development practices are ignored. so if good development practices are ignored under microservices what can happen?multiple different services sharing the same database seems comparable to global state under bbom. this shared database is a back channel.furthermore as the article describes if you don't define your domain boundaries correctly then changes are inoti necessarily confined to a single microservice.as for blowing up a service three layers away of course this can still happen. just because you inserted the network between those layers doesn't mean that layer 1 can't produce outputs that triggers an edge case in layer 3 that wasn't properly tested. similar failure modes are mostly all still there it's just ieasieri to violate certain good practices in a monolithic system. maybe that means it happens more often in the bbom but that doesn't mean it doesn't happen at all with microservices.i think the article broke this all down exactly right. microservices pushes complexity into infrastructure and sometimes that's good but often you want that complexity in code and encapsulated in welldesigned abstractions that are enforced by the language like a good module system.;0
34339484;HackerNews;2023-01-11;i a library is not a considered a microservice.iquite right. as before ipeoplei provide service. a library is something that people can produce as part of their service perhaps but a library is not a person itself.;0
34339417;HackerNews;2023-01-11;so a library is a microservice now?get with the program. the world of software consists of one domain web apps and two species microservices and monoliths. older cranky and ultimately useless software zoologists insist this is all wrong and that there are all sorts of taxonomical layers and creatures yet unseen by the avid readers of blogs. but that's not what the internet says and hey white hair? hmm. that's a red flag right there.;0
34339354;HackerNews;2023-01-11;funny i was thinking of linking to that page myself in support and decided against it. i particularly was thinking ofwhat does this muddy code look like to the programmers in the trenches who must confront it? data structures may be haphazardly constructed or even next to nonexistent. everything talks to everything else. every shred of important state data may be global. there are those who might construe this as a sort of blackboard approach buschmann 1996 but it more closely resembles a grab bag of undifferentiated state. where state information is compartmentalized it may be passed promiscuously about though byzantine back channels that circumvent the system's original structure.andsuch code can become a personal fiefdom since the author care barely understand it anymore and no one else can come close. once simple repairs become all day affairs as the code turns to mud. it becomes increasingly difficult for management to tell how long such repairs ought to take. simple objectives turn into trench warfare. everyone becomes resigned to a turgid pace. some even come to prefer it hiding in their cozy foxholes and making their two lineperday repairs.superficially it may seem like these criticisms apply but they don't.microservice architectures ican'ti have big global variables typing things together structurally. even if everything talks to everything which is actually unlikely sarcasm aside even the absolute worst systems have more structure than that in a microservice architecture it does it through a defined mechanism of rpc. state can't be passed through back channels because no back channels exist you imusti go over the network which is the front channel not a back channel.by structural necessity a microservice confines the scope of changes in the microservice code itself. there are then of course still scopes of changes that are even harder with microservices at the global level but for refactorings that aren't behavior changes a microservice inecessarilyi confines the scope of changes to the microservice itself a small fraction of the whole. as long as the api accepts the same input and returns the same output it ican noti blow up another service three layers away because it has no access. but that's a distinguishing characteristic of a big ball of mud.big ball of mud isn't just a slur it's a distinct pattern as described in that paper. at best a microservice architecture can be a lot of smaller balls of mud hooked together and that's still a problem but it is its own problem. this is proved by the fact that the solution to a big ball of mud won't work for an microservices architecture disaster... indeed they aren't even isensiblei. if two problems require separate solutions and the solution to one is not even conceivably applicable to the other that is not even a bad solution but simply no solution at all they are clearly not the same problem.;0
34339340;HackerNews;2023-01-11;any time you lean on code in a random github repository where you never speak to the author and just use the api you're given you're doing microservices. this works well enough so long as the product does what you need of it.no. that's not what a microservice is.i understand you are trying to draw analogies but a library is not a considered a microservice.;0
34339328;HackerNews;2023-01-11;i've found the nuance is in the middle somewhere. we've all seen the madness with web scale infrastructure for a personal blog but one gigantic compilation unit will eventually bite you in the ass too i.e. rebuilds get very slow.what you probably want is something where everything lives in the same repository but as separate modulesdlls which can be included in some common execution framework the team previously agreed upon.if you have something approximating microservicesasdlls then you are essentially eating cake while having cake when you really think about it. function calls are still direct sometimes even inlined but you could quickly take that same dll and wrap it with a web server and put it on its own box if needed.establishing clear compilation unit boundaries without involving network calls is the best path for us and i suspect it's the best path for ianyonei to start with. we take this don't involve the network philosophy into our persistence layer too. sqlite is much easier to manage compared to the alternatives.;0
34339326;HackerNews;2023-01-11;...and if you've had a team of developers eagerly using microservices for pretty much everything in production code for any significant period of time microservices become like a big ball of mud iheld together by a lot of hairi. i shudder in horror when i think about how impossible it will be to maintain all that code in the future.;0
34339316;HackerNews;2023-01-11;there are a few gripes i have with microservices.i think most places rearchitect to microservices because its the new shiny. they dont do the engineering necessary to create a detailed costbenefit analysis they just feel it will be better and so they jump in.for the same reasons the companies dont do the costbenefit analysis they dont spend much time thinking about how they could benefit from rearchitecting their monolith into various libraries modules packages and interfaces.because they dont think much about these code boundaries they end up turning their monolith into a distributed monolith. in doing so they dont get the major benefits microservices are meant to provide such as independent code deployment. they also lose the benefits of a monolith such as less ancillary complexity. this situation is the norm and is evidenced by deployment parties where you cant just deploy one microservice because 11 of them need to go to prod together.what i have seen a lot of over the past few years is a push to get off main frames and into the cloud. this is a valid driver for rearchitecting but microservices are just one of a number of solutions as the cloud is very flexible these days.i assert that a lot of rearchitecting to microservices can be attributed to the fact that our industry as alan kay has said is a cargo cult.;0
34339303;HackerNews;2023-01-11;that's... a bit more metacognition than maybe my snarky reply warrants.i didn't claim to be the only person who is smart enough to spot that a lot of online architectural opinionwriters structure their opinionpieces as strawmantakedowns of 'popular wisdom' and that this is another in that genre which appears to add nothing particularly further to the discussion.i never claimed that there is no such thing as objective truth or that there might actually be better or worse ways of solving some problems.all i'm saying is that 'microservices are a bad choice when applied badly to the wrong problem' is tautologically true and gets us no closer to understanding the objective criteria by which we can determine what 'bad' or 'good' mean.;0
34339299;HackerNews;2023-01-11;i everything is a microservice even linux kernel modules are... apparently.ia microservice is comprised of people. not a whole lot different than a service but narrower in what is offered such that the service doesn't provide something useful on its own and is meant to be integrated with other services to achieve its full utility hence the 'micro' moniker. in the world of physical products we often call these people suppliers.it is possible that a microservice may produce linux kernel modules.;0
34339277;HackerNews;2023-01-11;i worked for a company that did microservices well and this was the norm too. the term in my head is golden path or sandbox. the languages were go and python speaking protobufs over grpc.developing software outside that sandbox was not disallowed but you were on your own in terms of infra support if you chose to do so.fwiw the main tricks we found were 1 using a good build tool 2 use a good cicd tool 3 use a monorepo.there were some minor downsides and it took a long time for tooling capabilities to line up with our ambitions. but when i left we had 200300 engineers happily deploying to main across 100ish services every day.;0
34339241;HackerNews;2023-01-11;i've been on both sides of this debate. i've seen codebases from teams that want monorepos and macroservices that fit all of the falling criteria the codebase had three primary responsibilities none of those functions overlapped in functionality and didn't share any significant code they were all written by different people with subtly different styles they used infrastructure code for talking to third party services in subtly different ways that made upgrading dependencies difficultin theory they were all within the same business domain so the types that think one business domain equals one service clumped them together. this made little sense.on the opposite side i've seen microservices where all the little services depended on one another in complicated ways that made them all a brittle mess.finding the right solution to each problem is always the real challenge.;0
34339223;HackerNews;2023-01-11;i don't agree. almost every candidate during interview likes to talk how their team of 35 people manages multiple microservices. it's pretty much hype driven approach to develop a backend application.;0
34339218;HackerNews;2023-01-11;i really do not understand the debate on monoliths and microservice anymore.context matters so much. should you have absolutely everything in 1 system. no. and i think no one thinks that anymore.should you spilt your system into as many pieces as possible?no of course not.you are prop. storing files one place and have a data in a database another place. and most likely none are on the webserver receiving request. or maybe you are because context matters and i'm wrong in your particular case. could be.my advice would be to split your application up into enough pices so that1.your engineers feels like they have control over the code and are not afraid of doing changes.2. if you get uptime issues. get the heavy unrealiable services over to new node. don't let one serviceendpoint take down other endpoints.think and act according to the problems you have in front of you. don't go extreme in any direction. context context context;0
34339216;HackerNews;2023-01-11;worked on both monoliths and micro services.i'd rather work on a good monolith than a bad microservice and vice versa.the problem is working on a bad monolith is almost impossible. i'd rather work on a bad microservice than a bad monolith. now... tbh this could be survivorship bias where i've never had to help with a wellrunning monolith fair... but at the end of the day i find microservices much easier to manage scope change and scale.;0
34339209;HackerNews;2023-01-11;well the efficiency and granularity is the crux of the issue. it's what defines a microservice.;0
34339199;HackerNews;2023-01-11;a common pattern in microservices architecture is that each service has its own database that's what the person is referring to.;0
34339193;HackerNews;2023-01-11;every single endpoint in a monolith can be deployed and scaled independently. in a single such deployment the rest of the endpoints are just dead code not costing anything except larger image.also in many cases work should not be performed synchronously in response to http requests but in a background queue to keep your service robust and responsive. when taking a new order you should just place it in some queue and respond asap so there is zero chance you miss a customer order because of some error. in that case there is no difference in scaling a monolith or microservice as you can indepedently deploy 25 consumers for module x events or 10 consumers for module y events and so on.;0
34339185;HackerNews;2023-01-11;no they aren't. the entire point of the big ball of mud is that there are no meaningful divisions in the code. everything uses everything willynilly at the smallest possible level of abstraction. there is metaphorically if not always entirely literally not a single line of code in the system that you can change without fear of bringing something else down that you may not have even known they existed.this is bit of a strawman. the equivalent strawman criticism for microservices is that every function runs in its own networked service. is that truly representative of the reality? of course not and neither is your breakdown of big ball of mud.i think this is a fair analysis of the bbom;0
34339161;HackerNews;2023-01-11;trying to keep it simple to a degree. first of all i would say that its ok to still have a monolith and even build a whole product as a monolith and break it down as the need for microservices arises.my understanding of whether or not you should take a monolith and cut it into pieces is that it depends on what you want to achieve.every monolith is specific or are they? without knowing what your product does i bet you have an api a ui layer or two some business logic and maybe throw emailing or a payment service. well guess what? we all have those!how to decide. for myself ive tried to boil it down to 3 questions1. will i need to scale this part of the monolith more often than others? 2. does this part of the monolith handle an entire process on its own from start to finish? 3. does this part of the monolith require a lot of different code or resources than the other parts?the questions are simple. they aren't philosophical. they dont have a hidden meaning. rather a series of simple booleans. if something needs to be a microservice it'll most likely hit 3 out of 3 of those.;0
34339150;HackerNews;2023-01-11;there is nothing about microservices that require them to be distributed over the network it's just something that they enable.most of the pain points i hear about microservices are to do with versioning and deploying them independently. but again this is just enhanced flexibility you don't have to use it.;0
34339147;HackerNews;2023-01-11;yes?so many people have very little respect for the effects of the fact that this field is so ridiculously young including the fact that all of these definitions are incredibly wishy washy.being able to take a statement like an external dependency is a microservice and not completely discounting the point being made is incredibly valuable.;0
34339099;HackerNews;2023-01-11;if you plan your architecture carefully and modularize a lot there is very little that will prevent you from branching out modules of a monolith into microservices when the time comes.if you produce spaghetti code with tightly coupled components well then you are going to have a problem.;0
34339094;HackerNews;2023-01-11;i that's not what microservices means. you're intentionally equating all services to microservices which is not the case.ieventually everyone provides a service to someone i guess but there is a clear division between those who serve end users and those who serve the servers. the service that places your food down on the table at the restaurant is not thought of in the same was as those who get to the food to the restaurant. the latter camp is often known as a supplier but we in tech call them a microservice instead. there is no suggestion that all services are microservices.;0
34339090;HackerNews;2023-01-11;it may be the sloppiest crappiest definition every with dynamic typesfunny you said that since a microservice api is always dynamically typed and its usage cannot be checked by compiler. and the more microservices you use the more dynamically typed the whole project gets overall.while you can opt into a free for all everything importing everything all languages do also support creating modules which define apis for consumer and maintain compile time type checking.;0
34339068;HackerNews;2023-01-11;all of these articles against microservices are so annoying because i rarely see a good argument against microservices. often the arguments are purely anecdotal and without substance.there are only two good arguments i can make against microservices. first it's not the right architecture choice for all projects. second microservices don't magically solve the problem of complexity.but i can name countless benefits of a microservices architecture. individual microservices are far less complex than monoliths which allows even a single developer to work on a microservice run and test it on their local machine whereas monoliths may require dedicated test servers because they're too large and complex to run on a developer's machine. microservices simply dependencies because each microservice has exactly the dependencies it needs as opposed to a monolith that becomes a huge tangled mess of dependencies locked to specific versions and incredibly complex environments to ensure all these dependencies don't interfere with one another where any little change or misconfiguration will bring down the entire service. microservices allow for more rapid development since you're only rebuilding and testing a small part of the entire architecture without interfering with others work allowing many independent teams and individual developers to work in parallel. without elaborating too much i'll reiterate what is said many times over microservices are generally easier to scale horizontally with less downtime.a common misconception i see is microservices have to be simple and tiny. but your database system can be considered a microservice and that's hardly simple or tiny. the point is the database serves a single purpose in the overall architecture of the application and it can be managed independently of all the other microservices. what you shouldn't do is say combine your database and message broker into a single microservice.yes microservices are hard and there's so many ways to do it wrong. but you know what? software engineering is a hard problem in general and it's unlikely there's ever going to be a great solution that magically solves all our problems only incremental improvements that allow us to manage ever greater complexity.;0
34339050;HackerNews;2023-01-11;the extremely oversimplified reason backing your apparent hate for microservices makes you about as bad as the people youre arguing against. the og proponents of microservices acknowledge that theres a world of nuance and trade off. youre really just arguing against the outer most few circles of cargoculting magpie architects.someone unfamiliar with the concept of cost and benefit shouldnt be making architectural decisions in the first place.;0
34339020;HackerNews;2023-01-11;too many microservice advocates argue about the simplicity of their precious tiny codebase meanwhile there is always a gigantic ball of mud that does all of the orchestration... and most often very badly.;0
34339010;HackerNews;2023-01-11;cloud microservice system is just flawless for this purpose is it harder to debug than a monolith? sure.doesnt sound flawless to me;0
34339002;HackerNews;2023-01-11;if your microservices are hard to test you've designed shitty microservices. period.;0
34338989;HackerNews;2023-01-11;it is not true that you can incrementally modify that architecture to handle more users and traffic. one must carefully judge such things before committing to either the costs of a distributed system or the limitations of a monolithic system.i'm a little confused by this microservices or monoliths can both be distributed systems. a monolithic architecture eg a rails app still usually has a separate database. you can even deploy that monoloth in different configurations web vs worker.you can then deploy many nodes of that same monolith pointed at many different shards of a database to handle huge scaling needs. this is especially easy to do if the problem domain lends itself to horizontal scaling like b2b saas.i feel like the definition of microservices has gotten a bit murky here.;0
34338975;HackerNews;2023-01-11;microservices are about fine granularity not just talking to other things. there's an enormous difference between talking to a database and having to figure out how to roll back transactions because your write to lastnameservice failed after you already wrote to firstnameservice when updating a username. the kinds of problems you run into with microservice based architectures aren't a result of having services.;0
34338939;HackerNews;2023-01-11;in my experience the citadel pattern is a good alternative to microservices for small to medium teams. i have seen it emerged as a natural evolution of a monolith in several places where i worked where it served us well.;0
34338925;HackerNews;2023-01-11;now i'm not a fan of microservices but i'll be the first to admit that whenever i finish anything i look at it proudly and mutter hmm this sucks;0
34338920;HackerNews;2023-01-11;the main reason is to stop crap developers using globals all over the place or passing around hash maps stuffed full of config that aren't clearly defined in one place just continually mutated and similar bad issues.still crap devs will just find their own ways to mess up with microservices but at least they limit the blast radius.;0
34338872;HackerNews;2023-01-11;youd need a 1000x engineer to turn a microservice into a milliservice.;0
34338866;HackerNews;2023-01-11;everything is a microservice even linux kernel modules are... apparently.and also nothing is a microservice because it's not separated strongly enough.;0
34338858;HackerNews;2023-01-11;maybe the only good reason to use a microservice is so you don't need to build and maintain it yourself.databases are microservices s3 keycloak sentry all sorts of stuff. also goes for other teams in your company building and maintaining the service.;0
34338853;HackerNews;2023-01-11;no. that's not what microservices means. you're intentionally equating all services to microservices which is not the case.this substitution is what is commonly known as a strawman argument. you misrepresented an argument to discredit it easier.;0
34338805;HackerNews;2023-01-11;if the boundaries are not drawn correctly to start with fixing that can be much harder in a microservice architecture with corresponding separation of teams than a monolith.therein lies the problem. inobodyi draws these boundaries correctly on the first try and the correct boundaries can shift rapidly over time as new features are added or requirements change.;0
34338804;HackerNews;2023-01-11;what i learned since the 90ies is that software engineers don't learn from previous years... let alone from previous decades.this microservices are better argument was made in the 90ies and top dog is still linux kernel the one that was on the monolith side of that debate.so yeah microservice advocates haven't learned anything since the 90ies or from the soa era etc... but i suspect they were in secondaryhigh school thenan anecdote when i joined my current company had more code to orchestrate services than the actual business value generating code in the services. we still produce an inordinate amount of code that exists just to facilitate microservice architecture. it's also untested code because we just don't have the money to spend time on testing it;0
34338794;HackerNews;2023-01-11;i just sit back sipping coffee and chuckle.we went from services should be no more than 100 lines of code to testing and maintaining thousands of interconnected microservices is terrible it turns out.the secret here is that all simple answers are wrong. your services are too small and too big at the same time. finding balance is hard. zen buddhists call it the middle way.the best design is always an uneasy intersection of many approaches and concerns and also it's the concept of what you decide not to do so you have more resource to focus on what to do.also we keep overanalyzing how we do services in isolation when the complexity comes not from each of them alone but how they interact. to solve this complexity you need clear aligned flows. more like laminar flow. less like turbulence.;0
34338786;HackerNews;2023-01-11;microservices lets replace as many interfaces as possible with the slowest flakiest most complex mechanism the network layeryou do realise that most calls to block storage in aws result in network traffic right?the point is abstraction is your friend.;0
34338763;HackerNews;2023-01-11;not having to upgrade in lockstep is great though the downfall of many monoliths is the forced death match to port to new version of the platform because we put this off so long its about to leave lts.being able to use different stacks where appropriate is also great but needs care. e.g. if you are a java shop but you want to deploy an ml pipeline you should at least consider carving out a pathway for deploying python microservices.;0
34338736;HackerNews;2023-01-11;microservices is not the same though.;0
34338722;HackerNews;2023-01-11;i get the feeling he really misses the point.the most dangerous thing about microservices is that many people squee when they hear you can write 45 different microservices in 35 different languages. writing a new microservice? what a great opportunity to learn a new language!now it is true that by decoupling the address spaces microservices do let you take advantage of different runtime systems you might really want access to scikitlearn in python for instance certain libraries available in java but also like the speed of go. that's alright to a point.if a microservice system is going to be maintainable you need to minimize the excessive complexity of using different libraries and frameworks for build configuration serialization logging database access and other cross cutting concern. to the extent that that stuff is standardized the programmer who works on service q can do some work on service b and be focused on the application instead of having to do a research project on where to put a configuration variable or log a message.it's hard to do because in the microservice environment people seem to get a lot of joy out of not being disciplined will make endless excuses why they can't update the version of the language they are using etc. it's the kind of freedom that orwell warned you about.;0
34338719;HackerNews;2023-01-11;disagree. at wellrun companies with highly available services that you have certainly heard of i have routinely discovered microservice backends that are just crashing all over the place with no consequences to the user whatsoever. you can never say that about crashy monoliths.;0
34338699;HackerNews;2023-01-11;microservices solve many problems to those that understand the virtues and deficiencies of it everyone else is just cargoculting and committing themselves too much to something they don't understand see kubernetes.;0
34338688;HackerNews;2023-01-11;you could say this about any criticism of mainstream practice. this is not a rebuttal and contains no new information.actually i lied this post is actually a strawman it contains the information that you actually didnt understand the point of the article. he is referring to people who have deployed microservices when they needed modules not people who deployed microservices when they needed microservices.;0
34338682;HackerNews;2023-01-11;this post reads more like i created an overengineered microservice architecture once and i'm now jaded because of my bad experiences. see 10 years ago i wanted modules but i as well found microservice architectures.it's in the same genre as i nearly wrapped myself around a tree and now i drive slowly when it's wet not i am perfect and everyone else is wrong.;0
34338677;HackerNews;2023-01-11;no they aren't. the entire point of the big ball of mud is that there are inoi meaningful divisions in the code. everything uses everything willynilly at the smallest possible level of abstraction. there is metaphorically if not always entirely literally not a single line of code in the system that you can change without fear of bringing something else down that you may not have even known they existed.microservices are not a miracle cure or the solution to every problem but they do iforcei divisions within the code base. every microservice defines an interface for its input and its output. it may be the sloppiest crappiest definition every with dynamic types and illdefined apis and bizarre side effects but it is isomei sort of definition and that means if necessary the entire microservice could be entirely replaced with some new chunk of code without affecting the rest of the system cleanly cut along the api lines. this microservice may sloppily call dozens of others but that can be seen and replicated. it may be called by a sloppy combination of other services but the incoming api could be replicated.however bad the architecture of the microservice may be however bad the overall architecture of the microservicebased system as a whole may be this will be true by structural necessity. the network layer defines some sort of module.they can create big balls of spaghetti certainly. they can in total create a big mess they are not magical architectural magic by any means. while a full replacement of a given microservice is practical and possible if the boundaries are not drawn correctly to start with fixing ithati can be much harder in a microservice architecture with corresponding separation of teams than a monolith.but they fail to create the situation that is what i would consider the distinguishing characteristic of a big ball of mud where there are no partitions between anything at all. big balls of mud have no equivalent of replace this microservice. microservices by necessity to be microservices have partitions.;0
34338649;HackerNews;2023-01-11;it is perhaps unfair to compare with google since the question of how will we store the web clearly calls for a distributed system whereas the microservice haters are often speaking of systems with an ultimate user base in the low single digits. it is true that with modern hardware you can monolith your way to serving thousands of users at 1 query per second. it is not true that you can incrementally modify that architecture to handle more users and traffic. one must carefully judge such things before committing to either the costs of a distributed system or the limitations of a monolithic system.a reason this succeeds at google is that many of the microservice counterarguments boil down to yes but what if i am a jackass? if you are afraid of having to reimplement your structured logging framework for 11 different languages i suggest you simply do not do that. initially everything at google was in c alone then python java and go were slowly added. even after 25 years of being google they are not out there trying to diversify languages. you don't need to be google to exercise good taste and restraint. you needn't correct me regarding the niche languages that popped up here and there because i am aware.;0
34338625;HackerNews;2023-01-11;don't you find it strange that you live in a world where everyone else but you thinks that everyone else around them is over engineering or under engineering things?you're not the guy who thinks everyone else is a maniac and is driving too fast or too slow. you're the guy who thinks everyone but you is under this delusion of thinking that everyone else is a maniac and you think you are an exception to the delusion because you can see it in other people.i am here to tell you that there is a higher plane of understanding. this higher plane of understanding is thiseven when you are aware that others are prone to biased and fallacies this awareness does not make you immune to those same biases and fallacies. because what you understand is also cliche. you are voted up because your awareness is also shared by others. others observe the biased and fallacies of other people and think that they themselves are above it when in actuality everyone is just looking at each other. we are all mirrors.there is an even higher plane of understanding. i am not on this level and neither are you. this plane of understanding is the realization that one of us is not delusional. someone is actually right. someone sees the reality of how something should work and he is right and he is actually surrounded by straw men.the tragedy of the design of computer programs is that we have no theory of efficiency no theory of what is most optimal. so if someone is right we have no way of knowing. we are doomed to forever live in a world of blog posts where one of those blog posts is right but we can't know for sure.you obviously wrote this because you think that the author of the blog post is not that man. but because we have no theory to prove otherwise you simply state common tropes of human fallacies and biases and you use that analogy to discredit his post. it's pointless. analogies aren't proof they are themselves delusions but weaponized and used to seemingly prove a point or discredit one. they are convincing but manipulative. your post can actually discredit every blogpost in the universe and that is why it is useless pointless and manipulative.rather then write sweeping analogies of human biases which can actually disprove every single blog post on the face of the earth... offer evidence and example scenarios about why you disagree. because personally i think the blog poster is right. his thoughts on microservices is correct. convince me about why he isn't that one guy who is actually right but know that the argument is endless because none of us can actually verify anything.;0
34338612;HackerNews;2023-01-11;im honestly mainly reacting to the part where they judge interview candidates on the basis that they worked on systems that implemented microservices.iit is hubristic in the extremei to sit in judgement over the architectural choices a team has made on a system you dont know or understand and just downright irudei to conjecture all the worst failure modes of that architecture and then assume that they constitute what your candidate ivaluesi.the only thing you can extract from talking to a candidate about their past projects is itheiri impression of that project. what did they learn? what architectural choices did itheyi like and why? what choices do they regret? just because they made a choice you wouldnt have does not mean they are irredeemably broken.oh you worked on imicroservicesi. bet it was a big ball of mud. then you ask a bunch of questions to confirm that suspicion youre just dumping your prejudice against an approach onto someone who might have ilearned something useful from their experience of working on that thing!iand if they did work on a badly architected micro service system maybe they learned micro services often turn into a big ball of mud ive seen it happen. maybe through that experience they learned something about how to avoid that fate? or maybe they now share your opinion that microservices are a terrible idea and if you like hiring people who agree with all your ideas then they would be a great add to your team.we have ialli worked on systems that had architectural flaws. we have all ibuilti systems with architectural flaws. what matters is how we took those lessons and incorporated them into our understanding and taste for what makes good architecture.;0
34338579;HackerNews;2023-01-11;yeah it's crazy the hate microservices get. i happen to work on a product that needs to scale to handle millions of transactions distributed all over the world and the cloud microservice system is just flawless for this purpose. is it harder to debug than a monolith? sure. you need a team that has a good understanding about distributed systems most coworkers have degrees and the ones without are really good at selfteaching kudos to them. could you easily develop our system in a monolith? no it would be a nightmare if even feasible given the same availability security and performance constraints. i totally agree not everyone works on stuff i love to work on huge scalable systems but google and co didn't engineer this tech because they felt like it but because there was a clear need for it.;0
34338535;HackerNews;2023-01-11;microservice are a way to organize teams. modules and services also serve that purpose.;0
34338530;HackerNews;2023-01-11;the move to microservices is often more about scaling change management when an organization grows from tens to hundreds of engineers.change management becomes the bottleneck when organizations exceed dunbar's number and a reverse conway maneuver is needed to counter excessive cost of coordination.;0
34338526;HackerNews;2023-01-11;your x is a shit and it crashes every second?companies that repeatedly fail to detect and solve this type of problem using automated testing and qa are exactly the companies that lack the sophistication to do distributed microservice architecture.learn to do proper cicd endtoend testing and loggingmetrics on your monolith before you decide to transition to microservices.;0
34338523;HackerNews;2023-01-11;that api is usually a web api right. essentially library restgraphqletc is a microservice.;0
34338504;HackerNews;2023-01-11;in some sense it is. it has an interface that your program communicate through. it might be loaded separately in memory or even shared between several programs. thats kinda of a local microservice.;0
34338480;HackerNews;2023-01-11;i don't know... perhaps a bit harsh but article seems reasonable to me. i'm also yet to see wow what an engineering! application that heavily depends on microservices. mostly it does feel like an unnecessary complex pile of mud.;0
34338470;HackerNews;2023-01-11;cloudflare microservices aka worker dont inccur an extra network cost when they call one another. good enough?;0
34338439;HackerNews;2023-01-11;this happens a lot. otoh sometimes you come across cases where you wonder if you accidentally landed on a different planet. mid sized project 500 microservices 800 repositories...;0
34338427;HackerNews;2023-01-11;a service is something someone provides. a microservice is much the same but serves those who offer services to the end user roughly analogous to a supplier in the physical goods space. a module may be the product of the service rendered.;0
34338413;HackerNews;2023-01-11;microservices is a collection of independent teams who only communicate using well defined apis. those teams may produce libraries perhaps. that's up to conway.;0
34338391;HackerNews;2023-01-11;any time you lean on code in a random github repository where you never speak to the author and just use the api you're given you're doing microservices.so a library is a microservice now?;0
34338355;HackerNews;2023-01-11;i find scs 0 as a very pragmatic and functional alternative to microservices which usually fits better to most organizations.0;0
34338339;HackerNews;2023-01-11;deployment is done with kubernetes on our side.if the repo builds a container and the service provides a health endpoint we are good.my company has 10 15 developers and we are at about 10 macromicroservices.one should definitely not create a new service for every function call but some seperation works quite well on our side.;0
34338317;HackerNews;2023-01-11;i just use microservice whenever i can't embed many languages inside each other wasi is a solution.no need to run a microservice just to make some function call.;0
34338297;HackerNews;2023-01-11;monoliths can also scale horizontally and be restarted automatically when they fail. no need for microservices for that.;0
34338229;HackerNews;2023-01-11;so using your definition what is the difference between a module a service and a microservice ?;0
34338197;HackerNews;2023-01-11;scalability and stability. you need to process more requests? launch more virtual machines easy. your microservice is a shit and it crashes every second? don't care it will be relaunched automatically.;0
34338185;HackerNews;2023-01-11;yup. i always tell people that if they cant write and manage decent libraries microservices wont help them.;0
34338180;HackerNews;2023-01-11;most people create nanoservices not microservices if they did microservices they would have a fraction of the number of services.;0
34338157;HackerNews;2023-01-11;linux distributions are essentially a bunch of microservices running together managed by e.g. systemd. it works well most of the time of course until it doesn't. not sure what a better approach would be though.;0
34338141;HackerNews;2023-01-11;microservices lets replace as many interfaces as possible with the slowest flakiest most complex mechanism the network layer. why call a function when you can wrap that function in an entire application and call it via api? why have a single database when we can silo our data across 200 mini databases? why have a single repo when we can have 200 tiny repos?;0
34338135;HackerNews;2023-01-11;no standardizing these things makes them hard to change for devops. how many breaking deployment changes have you seen in reality?you're right that microservices shift burden onto infra. but that does not make it a big ball of mud infra has gotten progressively easier over the past two decades. if you want me to create the 'ball of infra mud' mentioned in your article i can do it and make it repeatable in a few hours. it will come with dashboarding out of the box.this is why microservices have become more appealing to more businesses. the technology allowing you to provision this infrastructure and deploy your code has changed immensely allowing you to shift some of that burden over to infra.people don't need to be given freedom for everything. like the parent mentioned with this standardization people writing application code are able to move quickly and understand how the pieces work under the hood without shifting their mental model.;0
34338124;HackerNews;2023-01-11;microservices is a team organization technique whereby disparate teams ionlyi communicate by well defined apis. any technology choices that come out of that are merely the result of conway's law.any time you lean on code in a random github repository where you never speak to the author and just use the api you're given you're doing microservices. this works well enough so long as the product does what you need of it.the problem is that when the product doesn't do what you need. if the microservices teams are under the same organization umbrella there is a strong inclination to start talking to other teams instead of building what's needed in house which violates the only communicate by well defined apis. this is where the ball of mud enters.if your organization is such that you can call up someone on another team you don't need microservices. they're for places so big that it is impossible to keep track of who is who and your coworkers may as well be some random github repository.;0
34338103;HackerNews;2023-01-11;i think the problem with microservices is the same as the problem with oo programming and i say this as a pure oo rubyist ... what you are doing is shifting the complexity out of your code where at least it's under source control and hopefully readable. and moving it into the order and timing of the interactions between your servicesobjects which isn't readable unless you start hunting through log files.;0
34337653;HackerNews;2023-01-11;the problem with standardizing these things is that it makes them hard to change. a breaking change in the way you deploy must also work for all other solutions otherwise you immediately loose your standardization. and this will happen eventually. for all this different kind of problems it is near impossible to avoid inconsistency and force rules on them.so imo you either have a very large organization with independent teams that work on independent services and give them the freedom for everything or you develop a proper modulized monolithic software and extract services only as a last resort. i would avoid to use a microservice architecture with a small team of developers;0
34330566;HackerNews;2023-01-10;i'd say it doesn't have to be.there is a certain kind of freedom that is really slavery but people feel so free when they hear about it is they often squee and hurt themselves with uncontrolled movements.microservices can be that way. now that you have 25 different services in 25 different address spaces you can write them in 11 different languages and even use 4 versions of python and 3 versions of java. i got driven nuts years ago in a system that had some java 6 processes and some java 7 processes and it turned out the xml serialization worked very differently in those versions.if you want to be productive with microservices you have to do the opposite you have to standardize build deployment configuration serialization logging and many little things that are essential but secondary to the application. if a coder working on service 17 has to learn a large number of details to write correct code they are always going to be complaining they are dealing with a large ball of mud. if those little things are standardized you can jump to service 3 or 7 and not have it be a research project to figure out how do i log a message?;0
