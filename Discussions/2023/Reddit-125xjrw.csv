ID;Source;Creation Date;Content;Sentiment
125xjrw;Reddit;2023-03-29;Title:You Want Modules, Not Microservices, Content: https://blogs.newardassociates.com/blog/2023/you-want-modules-not-microservices.html;0

je7bhux;Reddit;2023-03-30 00:49:07;i've been involved in a variety of projects from large enterprise .net projects that had a lot of modules clr assemblies to incredibly overengineered microservice projects. i will always prefer the module route. it maintains the separation of concerns but does not include all the headaches intertwined dependencies bandwidth transaction issues and other footguns that come with microservices. i'm sure at even larger scales where microservices are properly engineered they have a positive benefit but in the smalltomid sized companies i've worked with it was always a disaster. every time i think about microservices now it always leads me back to the infamous youtube video. and i've seen worse than this! microserviceshttps;0
je75e6x;Reddit;2023-03-30 00:04:20;i inherited a project made by a programmer who was in love with microservices. the microservices were a cluster of docker containers. he used it to start creating a web app. that would be used by a small number of users hosted from a laptop. after spending weeks trying to continue his code it ended up being a lot easier to delete his entire project and recreate it as a simple standalone web app. it was also a ton easier to debug and maintain. honestly as we gain experience programming we learn use the right tool for the job is the most important criteria. that is only sometimes the newest shiniest languagetoolsetapproach;0
je6hwwt;Reddit;2023-03-29 21:29:39;if you do not need horizontal scalability modules are superior to microservices but they take very experienced developers. yes there are ways to automatically test for some modularity but all of those tests are not perfect. and it's still not very widespread. it takes a lot of trust and skill to keep a modular architecture as such. microservices meanwhile make it painfully obvious if you break their modularity low performance difficult synchronization of transactions and data and a nontrivial setup. it's pretty hard to ignore any of those for long. this is what makes microservices pretty good if you do not have tons of trust. if the system is built by multiple teams this gets pretty clear you trust your team. you don't trust other teams. so if you have multiple teams make the boundary between them painfully obvious. that's where microservices shine. but if you only have one team never want to scale horizontally except in rare cases you don't need them. but for heaven's sake use tooling to guarantee your modularization is actually there. archunit is great for java projects as an example. if you don't verify your architecture you don't have a specific architecture. besides wasn't this posted in some other form a long time ago? i feel like i've seen the paragraphs many times.;0
je8iduj;Reddit;2023-03-30 06:32:53;the vast majority of the proposals i've seen for microservice architecture has just been a collection of services. the micro of microservice is supposed to represent the amount of responsibilities the service has not the amount of effort you've put into building it.;0
je6o78c;Reddit;2023-03-29 22:09:44;yes a lot of the time you want modules. for sure. 100. microservices are a good way to define and enforce modularity. many developers are very very bad at truly separating concerns but microservices are a great forcing function that creates the necessary pressure to define and enforce module boundaries.;0
je8t92t;Reddit;2023-03-30 08:41:35;daily reminder that microservices are a solution for scaling organisations not code. they help create boundaries between teams that are clearly defined and embed a contract in the form of the interface. they are an awful architecture to use for anything other than solving the problem of having at minimum dozens of independent teams working on related areas concurrently. the complexity and overhead of building operating and understanding microservices is way higher than other architectures. they are fundamentally not worth the investment unless you have multiple teams actively complaining that their blockers are collectively working on the same code base. always start with a modular monolith. if a particular piece of functionality requires scaling that is orders of magnitude different than the rest of the app then separate only that part out. move towards soa as the number of teams grow. only consider microservices after going through each of these phases in order.;0
je8wgoj;Reddit;2023-03-30 09:25:45;the problem isn't microservices. the problem is that our trade has no collective learning ability and every single company is just making the same damn mistakes again and again. monoliths have pros and cons. microservices have pros and cons. and all we're getting is people fighting for either 'camp' without understanding there are no camps everything is an 'it depends' and which one you chose should depend on actual knowledge and experience. the way we have people at a junior level 'fighting' over this is just dumb and a waste of energy. it doesn't matter whether they're going the microservice or monolith route because they're just going to fuck it up because the right way simply isn't the path of least resistance.;0
jeah4ar;Reddit;2023-03-30 18:27:14;our java monolith takes 30 minutes to boot features no unit tests only runs in eclipse contains 20k warning s and 200 errors and regularly fails for random reasons that have useless or misleading error messages. count me in team microservice.;0
je9imaq;Reddit;2023-03-30 14:11:51;the largest problem with microservices is the same problem with any subjective thing distilled to a singular word that becomes a hype driven mandate people are more obsessed with claiming affinity with the word than actually internalizing any guidance that it was meant to provide. also there aren't methodology bandaids for low quality work. as an example of 'hype word means nothing once it becomes a mandate' i dealt with a team that had a mess of a big monolithic java application. they were given the mandate of 'microservices' so basically i got pulled in to teach the ins and outs of kubernetes. the end result? they had a virtual machine with kubernetes that ran a singular container of their monolithic application and proudly declared to management that they had microservices architecture now. basically just wanted to wrangle the container environment to meet exactly how their application expected to work without modification. perhaps even worse are the teams that receive the mandate and proceed to comply by randomly rip and tear of codebase until it is done. a mess of disorganized random components held together by baling wire and crossed fingers. i get pulled in to try to figure out failures in other people's codebase when they themselves have lost track of it and can't navigate it in microservices context...;0
je9rfoc;Reddit;2023-03-30 15:26:02;but also sometimes you want microservices;0
je6z12z;Reddit;2023-03-29 23:20:18;you may want modules and not microservices.;0
je6wf9u;Reddit;2023-03-29 23:02:45;well microservices are modules so this is like saying you want cutlery not knives.;0
je8abdi;Reddit;2023-03-30 05:16:27;having come from microservice to modular architecture i have few reasons to prefer microservices. a modular architecture would be better suited for security as all external libraries are managed by a single team. in a microservice architecture we would consult the security teams to scrutinise our tiny little application to find security issues. but if some team hasnt updated their code in eternity the entire project slows down. eg. my modularised monolithic project is still using java 8 that too i cant use stream api. not all developers respect even the 3teir architecture and would create a single call from the repo layer to access data from multiple tables. some data is just way too sensitive. business clients user data etc. its easiercheaper to anonymise a smaller dataset rather than taking a 400gb database snapshot. youre never bound to external teams for enablement. you can create your own db schema dont always need dba because the complexity is reduced you will work with the schema and voila feature shipped in 2 weeks instead of a quarter. non linear scaling we dont add customers daily but we transact multiple times a day so the customer sign up application can be a slower vm compared to other businesses applications.improves efficiency;0
je74vz4;Reddit;2023-03-30 00:00:42;yes but still it may be part of an evolving architecure to evolve into microservices. i believe the real problem is start building a microsercicr when you will only see its benefits 10 years down the road or stay with a monolith for 10 years until it is too late to change it. i have a feeling that many people who are really into microsercices are just hyped up and enjoy overengineering while the ones who are super against it never really worked on a big software that got so complex it bace a behemoth that slowed everything down.;0
je8oqcp;Reddit;2023-03-30 07:43:59;can't agree with author those two technologies are bit of an apples and oranges situation. microservices can be scaled horizontally and offloaded from main stack if done correctly. modules are something else.;0
je8skex;Reddit;2023-03-30 08:32:25;weird how this constantly changes as time passes by. weren't microservices hipster after containers? and now we want modules instead. hmmmm......;0
jeanr7m;Reddit;2023-03-30 19:09:37;as someone in a team of 3 devs using microservices architecture that are tightly coupled over the same model structure and the same database and will never scale to more than 3 instances of each services and not handling that big of a load microservices are still great. our biggest requirement is stability and resilience we can't allow the service to come offline ever. kubernetes offers much more feature wise. deployments do wonder for 0 downtime updates offer easy load balancing offer a clean infrastructure structure makes sure that if a process goes crazy another is always ready to take over. containers keeps everything sandboxed and secure. i would never go back to manually copying binaries overwriting the ones on the server and restarting the executable.;0
je8x6ku;Reddit;2023-03-30 09:36:13;microservices are meant to solve an organizational problem. if you're a 3 person team and you're not expecting to grow and you're still doing microservices you got it all wrong.;0
je9pp76;Reddit;2023-03-30 15:12:17;microservices will fade when project loom ships.;0
je9uyzl;Reddit;2023-03-30 15:52:42;i put together an experimental but fully functional architecture that exemplifies this modules over microservices concept. microservices are really solving a human problem not a technical problem and really suited only for large dev teams. startups and smbs should probably not be using them due to the increased overhead you get from eventual consistency. i'm generalizing of course. there are always exceptions to this. anyway this modulith project doesn't really invent anything but it combines a lot of ideas in a novel way. httpserikdreyer.medium.commodulararchitectureformonoliths156368d9653chttpserikdreyer.medium.commodulararchitectureformonoliths156368d9653c it takes advantage of the following languagesframeworks and features contained therein 100 kotlin with arrow.kt this combo gives you a new toolbox to use to approach problems solving in a new way. in my experience these tools are superior to traditional approaches you get with even modern java. spring boot with webflux but using kotlin coroutines instead of reactor primitives which have a lower cognitive load to readunderstand. the app is fully nonblocking. domain driven design in addition to each bounded context existing in separate maven modules each bounded context also runs in it's own spring application context to ensure your beans are truly isolated from other bounded contexts. hexagonal architecture provides the guardrails for how to do module separation but also how each module is internally structured. the internal structure is fully enforced by archunit functional programming we introduce a notion of a usecase. the use cases of most spring boot apps are implicit. that is they are spread out over many services. formalizing a usecase a simple concept makes each use case of your app explicit and concrete. a usecase is loosely just a function with an inputoutput. algebraic data types each module's domain is modeled using adts which allows you to move business invariants from runtime checks to the type system. an extremely powerful concept. kotlin context receivers arrow.kt primarily used for error handling this greatly simplifies application logic by baking in error handling without having to write error handing code. you write your happy path code uncluttered by error handling everywhere. and lots more;0
jeb7okq;Reddit;2023-03-30 21:16:25;modules do allow for composable transactions so they're closer to what microservice designs typically end up wanting lacking.;0
jebzh8r;Reddit;2023-03-31 00:15:56;no. i really want microservices so that i can put it in my cv. because every damn places want microservices now.;0
je91s43;Reddit;2023-03-30 10:44:44;unironically this sounds more reliable than some of the buzzwordy microservice architectures out there.;0
jedscrg;Reddit;2023-03-31 10:06:07;microservices are a solution to organizational problems not technical ones. small companies trying to mimic larger ones without the organizational complexity to justify the technical complexity of microservices is always a recipe for a disaster. microservices are a necessary evil to solve large scale organizational problems but never a better solution if youre at a scale that doesnt justify them.;0
je7qmno;Reddit;2023-03-30 02:42:20;sounds like he was doing resume oriented programming.https had that happen in our shop. whadda... the microservices were a cluster the next word should start with an f.;0
je8eilc;Reddit;2023-03-30 05:54:41;honestly as we gain experience programming we learn use the right tool for the job is the most important criteria. that is only sometimes the newest shiniest languagetoolsetapproach this is the biggest thing i learned and why i typically ignore the message in articles like this. that's not to say there's not some good tidbits to pick up in these kinds of articles but these wide sweeping do things this way arguments fall on deaf ears to me. i've watched it backfire too many times where someone reads some article's suggestion to take up some methodology and it ends up biting them in the ass later sometimes quite spectacularly. for example someone on this thread somewhere was endorsing going to monorepo structures. i've seen the worst of that approach just like that person was saying they've seen the worst of microservices and why they switched to said monorepo. i've watched the monorepo structure explode in a group's face and be a huge maintenance nightmare that takes months upon months of work to get out of. it's very easy to create a massive web of nonsense that can build into modules but behind the scenes is all interdependent because the monorepo structure allowed for it easily. all it takes is excessive project references as an easy example. a few lines of seemingly harmless code in a project file going uncaught for one reason or another and six months later you're fucked. the reality is the reason people are constantly trying to find a new solution is because none of them are perfect. they all have flaws. the job is partly determining which flaws you can accept or mitigate and which ones you cannot to help you make a decision. in a few years or maybe even less we'll have some articles about why you should stop using modules and use some other solution. it's the same problem rehashed. there isn't a right answer without more details that the article author quite simply cannot have because every situation is different. as developers and engineers the best we can do is know all of the options and make the best decision we can at the time. sometimes it just doesn't work out and you need to salvage the situation that's just part of the job.;0
je8r6oq;Reddit;2023-03-30 08:14:23;i thinks this disregards some other positive factors of splitting your system higher resilience if one service fails the entire system does not necessarily go down with it easier deploymentsupgradesmaintenance by deploying different applications you can stop fail change parts of the entire system more easily or even sidebyside while keeping other parts isolated to guarantee a certain area of possible mistakes easier failure domain distribution without multiple instances per service you can distribute different services over many failure domains. reducing the risk of a crash of all parts together less generality if your application needs internal dependencies those can be more specialized for each microservicebounded context thus reducing the need to make your lower layersinternal dependencies more generalized complex. there is a certain now possible tradeoff between simplicity and dryness by having the need to develop in a way that scales to multiple services it becomes more obvious why adhering to common patterns is helpful eg the 12factor app. and since you probably develop your system more cleanly it becomes probably easier to integrate with the rest of the application landscape of your customers isolating external failure domains becomes easier too using an external service makes the entire system using it dependent on it. if the external system goes down you have a stronger isolation of failure to just the dependent microservice instead of your entire system. all those points have nothing to do with actually writing code in a good way. you have to architect your software with good inner modularization nonetheless. but microservices can help in making the operations way easier and system architecture way more stable. i dont say its always the solution. but that you cant interchange inner and outer modularization directly.;0
je7loyr;Reddit;2023-03-30 02:06:03;yeah but the overhead of maintaining microservices should always be measured against the cost of developers not adhering to modularity. you factor the cost of refactoring in there too;0
je6qsub;Reddit;2023-03-29 22:26:19;imo modules are easier than microservices if they're kept in a single monorepo.;0
je8j19w;Reddit;2023-03-30 06:39:30;if the system is built by multiple teams this gets pretty clear you trust your team. you don't trust other teams. so if you have multiple teams make the boundary between them painfully obvious. that's where microservices shine. yes and the bigger the organization is the more beneficial this is. at a huge org you don't know or care what everyone else is doing. if you ever see something like a big monolithic rails project with too many cooks you appreciate the case for microservices pretty quickly.;0
je78w9b;Reddit;2023-03-30 00:29:44;well its not really hard to scale horizontally with a monolithic application. so i dont personally consider scalability to be a reason to use micro services. the benefit to microservices is more about ownership and the more obvious boundary that you describe the horizontal scalability becomes a challenge with a modular monolith at the data store level but you could always separate dbs by module as opposed to by microservice when you get there;0
je8w1y3;Reddit;2023-03-30 09:19:54;if you do not need horizontal scalability modules are superior to microservices microservices were never about scalability in performance. they are about the scalability of your organization. microservices are not magically more scalable than monoliths when it comes to performance. it's really not a tough choice. are you going to be working on a system with more than 2 or so teams splitting it up will probably make deployments easier. are you going to be working on it with less a monolith is probably going to be the most efficient setup. don't know yet? either way is a gamble.;0
je85f1d;Reddit;2023-03-30 04:35:28;no. the performance issues that bad microservices cause affect your end users. that is not a justifiable trade off for code organization.;0
je7a34h;Reddit;2023-03-30 00:38:35;if you do not need horizontal scalability modules are superior to microservices but they take very experienced developers. experience does not guarantee wisdom. it's pretty hard to ignore any of those for long. companies find a way. if you do it well it's a huge boon. if you do it poorly it's a massive and possibly invisiblesemitransparent problem. most of the time it will be done poorly. most of the time these things do not fail in some spectacular explosion. it takes longer for bug fixes modifications and new features to be developed. more bugs are generated. it's frustrating for developers to work with. these accumulated effects are a slow and hard to discern downward pull on your businessapplication.;0
je9t8n8;Reddit;2023-03-30 15:39:51;horizontal scalability does not sound like something that get solved by microservices by themselves nor like something hard to do with a monolith. just add more servers with the same monolith on all and use a fast db. you might want a db cluster but you may need that for the microservices too. yes there are some edge cases where you might for example gain more scalability by having each microservice using its own db but you could do that with modules too. you may also need caching and fall into some caching challenges but once again you may have the same challenges with microservices. regarding trust you may want to look into tools that clearly verifies that everyone is following the rules instead of just trusting them. and and some point microservices may be the best solution but i personally think that has more to do with the number of developers. if you have 50 developers then a few services handled by different teams may be the best. if you have 310 developers it may not be the best.;0
je8mve1;Reddit;2023-03-30 07:21:49;i think it always depends on the team size company structure and culture. whatever buzzword is flying around will not solve your internal communication problems. having said that most people say microservices but don't build micro services. instead they build a distributed monolith.;0
je95wdh;Reddit;2023-03-30 11:44:52;you seem to assume a very specific meaning to the word module. modules is a very generic name for any kind of decomposition of software into more manageable subparts. microservices are one particular way to implement modules. the boundaries between modules are the things that certain assumptions are not allowed not cross.;0
je6u0c6;Reddit;2023-03-29 22:46:59;separation of concerns is not a free lunch. realworld things naturally interweave on concerns dimensions such that clean delineations are nearly impossible. the lines are drawn to help humans manage a big system but are often not ideal nor natural. if you over separate then you spend a lot of time building and managing interfaces instead of focus on direct domain logic. you became a slave to the architecture which becomes an ebureaucracy. kiss still matters. modules are useful but obsessing on independence creates interface management tasks that wouldn't have existed otherwise. also using the rdbms as an interprocessinterapp communication mechanism is often simpler than jsonoverhttp. smaller tasks can also be implemented as stored procedures. most small and medium shops settle on a preferred brand of rdbms which is a good. gluing a potpourri of languages and rdbms together via microservices is a recipe for disaster in such orgs. perhaps it's a necessary evil at a big org but what works best for netflix may not for bob's discount tires bagels. your ego may want to be at a netflixsized org but look around and wake up. typo's fixed;0
je96j1o;Reddit;2023-03-30 11:53:44;microservices are a great forcing function that creates the necessary pressure to define and enforce module boundaries. so are libraries.;0
je86hlx;Reddit;2023-03-30 04:44:03;they are absolutely not a good way to enforce modularity because the tradeoff youre accepting is the needless introduction of network latency and complexity which ultimately affects your end users. if your developers are actually that bad at separating concerns you either need to fix your trainingmentorshiporg structure or fire them. if you have to architect the whole system around their incompetence then how can you trust them not to fuck up their microservice?;0
jeaekhv;Reddit;2023-03-30 18:10:48;my take on microservices was that they were not a solution to anything but a tool for layeringisolating stability and security concerns. kind of a clumsy version of erlangelixir's processes.;0
je7btwo;Reddit;2023-03-30 00:51:37;microservices are more about organizational scaling than application scaling. while context specific doubling the number of programmers will produce closer to twice the output over time with microservices than more tightly coupled solutions. of course if you microservices are only microservices in name and tooling that won't help. independent deployability culture and the org structure need to be in place for that to happen. adding microservices without respecting conway's law often just adds complexity and fragility. note that decoupling is a scale invariant goal. it needs to happen at all levels where possible. thus microservices vs modules is a false dichotomy.;0
je8dwyy;Reddit;2023-03-30 05:49:05;modules microservices only if the language interface is sufficient to enforce some sort of clean design with good separation of concerns. this is not possible in all languages where the curious module consumer may decide to dig into the details of your struct in c that can't be hidden because the compiler needs to know how big the struct is unless you use one of the idioms to hide that but those come with overhead. in python you can have someone yeet random stuff into your dict of the object you're giving them via your interface etc. that's not to say microservices are a panacea especially when it comes to troubleshooting and debugging but it really puts up a strong barrier that you can't reach around.;0
je7ag4o;Reddit;2023-03-30 00:41:15;the benefits of microservices are operability. my codebase had 5000 commits yesterday would you like to redeploy to every host 5000 times each day or would you like to just deploy to a few dozen hosts at a time with 95 of the fleet not needing any?;0
jedsh6u;Reddit;2023-03-31 10:07:53;its basically a smell that you dont actually have the organizational scale to require microservices. if your entire business can still be run off a single database your service can still be a monolith. if youre using microservices your business should be large enough and complex enough that those teams all have their own datastores behind their services otherwise there was no reason to break them apart in the first place.;0
je7tzmw;Reddit;2023-03-30 03:07:16;that'd be the least of my concerns. my problem with it is your scaling issues are likely going to happen a lot sooner because you need to start dealing with sharding or what have you far sooner than you would if separated concerns were split into separate data stores. if you're going to go microservices half assing it makes things so much worse. personally i'm in the camp who believes they are overused but if i'm doing them i'm going alllllll the way.;0
jeasy26;Reddit;2023-03-30 19:42:40;microservices is a way of structuring teams not code. one of its fundamental tenants is that each team needs to have their own database so that each team is free to control their data independently. event sourcing isn't incongruent with that. each team may maintain their own event source.;0
jeb9nic;Reddit;2023-03-30 21:29:07;you'll be able to run millions of green threads scaling with memory rather than with separate machines. microservices scale but they come with a lot of pain when you have many machines to handle web requests where any one of them could go down or have other issues. not to mention the hell off ssl management.;0
je7d81q;Reddit;2023-03-30 01:01:58;how is it a false dichotomy to say modules are easier than microservices if they're kept in a monorepo? separating the product at the module level is a completely reasonable way to facilitate organizational scaling depending on the organizations size and their short medium and long term goals.;0
je8rdhv;Reddit;2023-03-30 08:16:51;microservices ideally model the organizational structure of multiple teams hating each other. much easier to divide and conquer them than finding talented people getting along with each other. s;0
jeambje;Reddit;2023-03-30 19:00:25;microservices are more about organizational scaling than application scaling. nobody agrees on the definition of microservices. i've asked many times and have been in many contentious debates over the definition. the candidate definitions often have fuzzy lines between specified technology languageindependent communication1 general goals good modularity and organizational concerns independent decision making. microservices should get a messy definition award 🏆 critics defending the mess often say if you study it enough you'll eventually just feel it. alchemy returns. this is it not bathsoaps. 1 which is impossible by the way because every communication protocol is a language be it json xml csv sql etc.;0
je7axz4;Reddit;2023-03-30 00:44:57;not necessarily. one module or multiple modules could be a monolith but one module could never be microservices. the closest it could be is an application with functionality turned off in certain deployed 'tiers'. modules in a monorepo also makes easier the transition of moving modules into a microservice when the horizontal scalability becomes necessary.;0
je7p084;Reddit;2023-03-30 02:30:31;why do you have to redeploy them all? compile them as separate binaries so you can have microservices but the codebase is kept as a monorepo so you get the benefit of typechecking and all that.;0
jeeme7v;Reddit;2023-03-31 15:37:17;if you work with a reasonably huge event sourced system within one business domain keeping all subaggregates in sync becomes financially infeasible very quickly. it's much easier to have one event stream with all the application events scale the database horizontally of necessary and then have different functions call them microservices or whatever in the query model each of which operating in its own subaggregate context to replay their current state. each of those queries can be a group of lambdas owned by their own team of it makes sense for their subaggregate responsibility say the billing team only cares about events relevant to billing the payments team only cares about events relevant to the payments to customer etc. if you need to consume other events from other contexts because an unexpected requirement came in it's just a matter of changing your own replay mechanism no need to consult other teams. i can always think of real life constraints where the best practice is actually the wrong solution to the legible problem.;0
jejavb3;Reddit;2023-04-01 15:43:42;that feels odd. the fashionable language for microservices at the moment is go which has had mn scheduling e.g. loom since its first release. this suggests that there is a demand for microservices regardless of such scheduling.;0
jebhnlv;Reddit;2023-03-30 22:19:44;i think every paradigm fails without strong technical leadership. microservices modules monoliths... they're all as weak as the worst team in the organization.;0
jebdvl2;Reddit;2023-03-30 21:55:53;if the components of the system have that degree of interdependencies than one should not break them apart to different services. different services should have minimal unidirectional dependencies between them. real domains have a lot inherent interdependence. and even if something starts out being independent it often grows dependent over time as the stakeholdersusers ask for more features. in that case a safe use of microservices using your criteria would be far and few between. i think we need to look at actual examplesscenarios to see where our differences lay.;0
je7g4oh;Reddit;2023-03-30 01:23:46;the monorepo doesn't even apply because you can use one with microservices. there is often a shift in complexity not an increase in complexity. decoupling deployments often simplifies coding because there are fewer interteam communication requirements to make enhancements or changes that don't impact the contract. but this is context specific. microservices may appear superficially more complex but it is often large teams and interteam communication that is far more complex. the technologies are not mutually exclusive either.;0
jeak2cz;Reddit;2023-03-30 18:46:08;how is it a false dichotomy to say modules are easier than microservices if they're kept in a monorepo? this is one of those 'devil is in the details' type of thing. the problem with modules in a monorepo is it can erode clear ownership. clear ownership can help drive consistency and limit the responsibilities of sections of code. the friction that microservices bring over modules can also align as friction to enforce good practices. for example on a modularised monolith i once worked on different teams were encouraged to work on any part relevant to their work. after two years a lot of the code had become messy. due to different teams working on the same sections of code with different approaches in mind. this is why people often say modules are great but you need to be disciplined. you can be a tad less disciplined with microservices.;0
jeb4mwz;Reddit;2023-03-30 20:56:57;nobody agrees on the definition of microservices the lack of a precise definition isn't really a problem and actually a specific definition would probably cause more issues due to being leaky etc... independently deployable services modeled under serviceoriented architecture works fine. in both systems and physical building architecture styles are sets of characteristics and features and not precise proscriptive definition. what constitutes a service domain is context specific and there is no universal definition of what a serviceoriented architecture is so how would a subordinate form like microservices have an exact definition. under soa you can safely assume the formal definition of a service as 'a selfcontained unit of software that performs a specific task'. you can extend that concept to a personal definition of microservices as a selfcontained independently deployable unit of software that performs a specific task the only time i have run into situations where those definitions weren't sufficient as someone at the systems architect level was vendor was trying to sell us something typically under the claim that their product would magically move our products to the microservice model through some magical feature of their product that once purchased will solve all of our problems. to be clear almost all the advantages of adopting a microservice model are on the human side. not only does individual deployability allow for uncoordinated work it also strongly encourages programers to write and maintain stable contracts at the edge. this helps maintain a separation of concerns decoupling and information hiding. which also avoids small dev groups from being blocked waiting for approval review and testing from other groups as long as they honor the interface contract. there is a spectrum between completely loose and completely tight coupling and all systems will have some coupling. but minimizing coupling to avoid accidental complexity is the important part. other architecture design goals like the ports and adapters pattern may be a portion of that or soa may be a guide or perhaps microservices are the tool that makes sense in a specific context. while i can only speak to my own experiences most soa systems tend to become tightly coupled over time not due to a lack of microservices but because of a problem they help with. the developers are uncertain if they should prioritizecode reuse or low coupling when adding new dependancies and often add coupling complexity by trying to be too dry and not respecting moduleservice barriers. with microservices if you maintain the concept independent deployability it is more difficult to error on the side of adding coupling complexity which is a form of computational complexity. note that i do not think that microservices are always the correct tool in fact i spend a significant amount of effort trying to control my own human cognitive errors and use more empirical forms of choosing a path. but i am human so... i am sorry that this reply is so long but i am trying to help because i do realize how difficult this can be especially after a concept has been targeted by the industry for productization at the cost of the original idea.;0
jeeqjx5;Reddit;2023-03-31 16:07:20;it's much easier to have one event stream an event stream is a valid way for teams to communicate with each other. teams do have to communicate with each other at some point! but we are talking about event sourcing. event sourcing and event streaming are very different things. there is no reason for event sources to be shared. i can always think of real life constraints where the best practice is actually the wrong solution of course. there is no onus to do microservices just because you like the name or whatever silly reason you've come up with. in fact microservices isn't something you should actively choose only be something observed in hindsight when looking at how your organization came to organize in the face of having tens of thousands of people all trying to work on the same product.;0
je854ij;Reddit;2023-03-30 04:33:10;the problem with microservices that you are overlooking is that youre needlessly introducing network latency at the boundaries. you can have decoupled deployments and all the other benefits of microservices in a multitude of different ways without any of the drawbacks and to do otherwise is as close as you can get to malpractice in this industry.;0
je839xl;Reddit;2023-03-30 04:18:37;what? just keep doing kubernetes or whatever network of microservices setup you have going at runtime. the only difference is that all that generated binaries webservers or whatever are generated from a single monorepo. that's it. instead of having 100s different repos that all basically talk to each other anyway why not just have everything in a single repo? then you can share stuff like database table types or whatever. i used to work at a heavily microservices shop and they have 10s of microservices that talk to each other and this obviously require some kind of knowledge about each other like what endpoints are there? what is the requestresponse body look like?. so they are basically just one massively connected application anyway. and the way they dealt with these types is by having openapi docs. why bother doing this? it's not like each microservices are entirely independent anyway.;0
jef9pmp;Reddit;2023-03-31 18:13:38;event sourcing and event streaming are very different things. there is no reason for event sources to be shared. no they are not. i'm talking about event stream in the context of the application of event sourcing not the act of streaming events as in eventdriven messaging patterns. the event stream represents the record of events that were sourced and you read that stream using functions say lambdas owned by separate teams and you have a shared databasecanonical table reference. you can store the events in dynamodb if you're on aws postgres etc. each with their own tradeoffs. if you're using monorepo you're essentially doing the same only that the event stream is the git history and the database is inside .git folder. each separate team owns certain root folders representing different applications which is analogous to lambda microservices mentioned before;0
jewkess;Reddit;2023-04-04 13:16:15;well it's certainly possible that in the java ecosystem microservices are used instead of async concurrency because java doesn't have a standard scenario for easytouse async yet. it feels a bit odd because iirc there have been reflectionbased techniques that essentially implement c's asyncawait since 2018 but i have been away from java for a while so i may be wrong.;0
je8ja28;Reddit;2023-03-30 06:42:03;but is it needless? there are advantages you're overlooking like the fact that microservices present a much clearer picture of where the issue is if some runaway performance issue causes an outage. without that you can spend a lot of time arguing who should fix it. undoubtedly there is a performance penalty but we accept performance penalties for engineering easecorrectness all the time or else why would we ever use anything but c?;0
je84932;Reddit;2023-03-30 04:26:18;why are you assuming that microservice means everything is in a separate repo? those are completely orthogonal concepts. why bother doing this? it's not like each microservices are entirely independent anyway. the point is not they are completely independent the point is that they are completely independently deployable. service a does not need to know what version service b is running. we have dozens of services whose source lives in the same repo.;0
jefay5b;Reddit;2023-03-31 18:21:44;no they are not. they are. but if you are talking about event sourcing then the event sources would be necessarily separate under microservices. microservices is the same pattern you use when interfacing with completely external thirdparties just brought inhouse. if you use the chatgpt or stripe api for example you don't know or care if they are using event sourcing behind the scenes. you would never try to integrate with stripe's event source for example. that breaks the logically distinct boundaries that are necessary to keep the organizations separate. of course again microservices isn't something to choose and if you try to choose it you're not actually going to end up doing it. it is hindsight observation and nothing more.;0
je8myj6;Reddit;2023-03-30 07:22:48;to e mike acton people like you are why i have to wait 30 seconds for word to boot. nearly every piece of web based software i use is 100x slower than it should be despite running on what would have been a super computer 20 years ago. and asking for a benchmark in this circumstance is absurd unless youre somehow bending the laws of physics doing needless computations and server hops is always going to be slower than literally just not doing that. my whole point is that there are simpler and more effective ways to organize your code than microservices and reaching for that tool inappropriately is just wasted overhead.;0
je9tfw5;Reddit;2023-03-30 15:41:21;shouldn't that be used the other way too? people saying that microservices results in faster systems have to prove it?;0
je8ly2x;Reddit;2023-03-30 07:11:08;like the fact that microservices present a much clearer picture of where the issue is if some runaway performance issue causes an outage this just isnt true? profilers exist. debuggers exist. logging exists. there is nothing about microservices that provides any additional insight into your code beyond what those provide. without that you can spend a lot of time arguing who should fix it. if programmers are arguing about who should program then they should simply not be programmers. we accept performance penalties for engineering easecorrectness all the time or else why would we ever use anything but c? so this is a pretty transparently fallacious statement. why dont we just do the most extreme possible version of what youre proposing? but the issue with microservices isnt the general concept of making performance trade offs for the sake of convenience its that with microservices in particular those who advocate for them are just wrong about what the trade offs actually are. they almost universally use microservices to solve problems that they arent meant to solve while ignoring the root causes of their problems and the multitude of unambiguously better solutions.;0
jeantrb;Reddit;2023-03-30 19:10:04;microservices present a much clearer picture of where the issue is paint me skeptical. i'd like to explore a specific sample scenario.;0
jefblui;Reddit;2023-03-31 18:25:58;i'm talking about the architecture of the back end and you're talking from a web client perspective which is just one type of client. microservices don't need to communicate only via http and apis there are other protocols too. they can talk via an event stream in which case it's ok to share a database or via an event bus in which case you can pass the state in the message itself or via rpc or via sockets or via rdbms or via html forms etc etc etc using http is not a requirement to be a service microservice or whatever you call it;0
jeao95c;Reddit;2023-03-30 19:12:48;if services a b and c are required for an application to run there's an outage and b is not responding to calls then we have a picture of where the problem is and who needs to investigate right? yes there are ways to do this with a big monolith but the microservice approach forces everyone's hand. the service owners have to either improve their operational stance or deal with the outages.;0
jetfh4k;Reddit;2023-04-03 20:27:01;i'm talking about the architecture of the back end cool but we are collectively talking about microservices which has essentially nothing to do with technology as it is about people and how they organize. microservices is often how teams in large organizations end up assembling in order to daal with the commutation at scale problem treating other teams in the same organization as if they work for other companies sharing nothing between themselves other than what different teams at different companies might share. this is different to how teams in smaller organizations normally assemble where they feel more leeway to work together have meetings together etc. generally this means sharing only api contracts. how the api defined by the contract is implemented is immaterial but what is certain is that it would be unusual to share a data source as the contract. that is a recipe for disaster for a multitude of reasons. as such it is a practical necessity for teams under microservices to maintain their own sources even if that means duplicating data.;0
jeb2imf;Reddit;2023-03-30 20:43:30;i actually exclusively use libreoffice or latex. i was ing someone else you see. and the issue is that microservices don't actually contribute to deliverability in any meaningful way. people use them because they have an unjustified belief that they will contribute to deliverability but there's just no evidence that that is true. there isn't any reason to bring deliverability performance tradeoffs into the discussion because there isn't a trade off to be had.;0
jean9b8;Reddit;2023-03-30 19:06:26;hitler used microservices!;0
je95d2d;Reddit;2023-03-30 11:37:12;you have it backwards. you're thinking of the effort it would take to remove the httpjson layers and replace the microservices by regular modules. but the mistake was to put effort into microservices in the first place. i mean nobody would wittingly put any effort putting stuff into their program that makes them slower for no benefit.;0
jeaolda;Reddit;2023-03-30 19:14:58;if microservices are mostly meant of very large companies vlc then please say so because the amount of discussion all about implies it's used or being promoted for way too many shops to be just vlcs. note i don't dispute it may be a good option for vlc for i haven't worked in any long enough to really judge. but i see suspicious buzzword pushers in small and medium orgs. seems they wish to work for a vlc and unwittingly use us as a free university of microservices training ground by selling it as great magic modular legos that hook up everything nice and smooth. i just see tangled rubber bands with importantsounding names but are mostly just repetitiously marshalling stuff around. the justification is often well if we expand this way we'll be ready. yagni was given cement galoshes and tossed into the hudson river.;0
jeb4jgr;Reddit;2023-03-30 20:56:21;there are reasons to use microservices it's just that the most vocal advocates of them never seem to understand what they are. the issue isn't microservices exactly the issue is people claiming that they will solve problems they aren't meant to address. and as an aside and this truly isn't meant as an insult but are you intentionally speaking exclusively in logical fallacies? like are you genuinely attempting to have a good faith discussion or are you trolling for the sake of trolling?;0
jeux1ug;Reddit;2023-04-04 02:33:58;a service that holds data is still a service which is also called a database. the api in case of postgres is the query language. there are legit reasons why you would use a shared database and other kinds of shared services and saying otherwise is creating as much harm as the cargo cult nature of pain json over http using rpc and splitting teams without looking at the cohesion of their domains. microservices is not just about teams split per domain that comes from domain driven design and one of the ways you discover the domains is to run the stakeholders in an event storming session. microservices was an attempt to cut the cargo cult nature of soa at the time. its muddy a stupid buzzword that creates cargo cult thoughts like every microservices should have its own database duh you shouldnt say each service should have a database you should say each service should own the data relevant to their subdomain regardless if you query the events from the same logical table or not. its still decoupled. thats why event sourcing disagrees with that if you are deploying microservices but they all point to the same database you're probably doing it wrong;0
jeagj9v;Reddit;2023-03-30 18:23:31;yeah same. but you'll have to concede that pandoc is definitely an example of deliverabilityperformance. it's just glue for a bunch of different tools and they didn't rewrite it all to operate as one codebase for the most integrated and fast fashion possible. when you render that latex template xelatex is handling it completely outofband which is the opposite of what op is preaching. in fact mdlatexpdf can be quite slow as well several seconds to render a final artifact it just doesn't matter much from a usability perspective as long as the markdown editing preview is fast. which it is although all previewers i know of are just a web page and an ide extension talking to each other via http on localhost so... not a point in op's favor either lol. performance sometimes matters but not always at least not to the point that engineers like us like to think it does. and even when it does matter sufficient performance gains can almost always be gotten even with inferior architectures like microserviceshigh level languageswhatever else the assembly goblins rant about. when something is slow e.g. word it's not because muh design is bad rewrite it all in rust. it's because the po didn't prioritize the performance track for two years straight despite the low hanging fruits causing 90 of the slowdowns for maybe a week's worth of work to fix. my favorite example of this is the gta v online loading screenhttpsnee.lv20210228howicutgtaonlineloadingtimesby70 taking 70 longer than it should because of shitty parsing of huge json files. that would have been a 1day fix if anyone at r had bothered to run a profiler and even though that bug pissed everyone off they still made billions so who's to say that the po was wrong to prioritize the mtx track instead?;0
jebb9rv;Reddit;2023-03-30 21:39:23;i mean nobody would wittingly put any effort putting stuff into their program that makes them slower for no benefit. nobody using microservices is using them because they have no benefit.;0
jeapjkj;Reddit;2023-03-30 19:21:07;i'm not sure exactly what the tipping point is but i'd say that a true microservice approach makes no sense on a small team though multiple services might and is the only sensible way to operate on a very large one. as a rule of thumb are there engineers in your company who don't know who you are or what your team does? if so then there's a good chance it makes sense and if not i'd think twice before accepting the overhead. when i say a true microservice approach i'm thinking not just that there are multiple services but that the services don't share a data store interaction is entirely through a defined api maybe not everyone has write access to the repository etc.;0
jex3s0j;Reddit;2023-04-04 16:06:03;there are legit reasons why you would use a shared database in the wide world of software absolutely. under microservices specifically no. the database is much too precious to give up control to other parties whom you don't know or trust. that preciousness means that any time you want to do anything with the database you're going to have to have meetings with people and the whole reason for microservices is to remove the need for cross team meetings. again microservices is a team scaling solution. when you have tens or hundreds of thousands of developers all working under the same umbrella there simply isn't enough time in the day for them to meet with everyone so you have to create tight api boundaries that are communicated via api contract and halt all other communication to make working at that scale practical. if you don't have that kind of scale there is no reason to be doing microservices in the first place. small organizations are better served by having meetings. as i said before microservices isn't something to choose. it is something large organizations end up in out of necessity and is only labelled in hindsight. the api in case of postgres is the query language. postgres' frontend isn't the database. but postgres is not the place where you want to maintain backwards compatibility and strict control while retaining your sanity leaving it not terribly useful to expose to uncommunicative teams. in a small organization you can talk about changes with everyone before committing to them leaving backwards compatibility needs largely off the table but under microservices you simply can't have that. once the api contract is defined it must live forever or such time as you are certain nobody is using it anymore. anything else will require directed communication and such communication is what you are trying to avoid. microservices is not just about teams split per domain no doubt. it says nothing about how teams are split only that they are and that they don't communicate with each other beyond api contracts. just like how you don't communicate with developers at stripe. if you want to use stripe you have to read their api documentation. that's the only line of communication you have with the developers. like it or lump it. if stripe also starts offering a cloud file storage solution that you want to use that's fine. nothing says that they can only provide a payment service. the domain matters not. you shouldnt say each service should have a database the service is what the team provides. they need their own database to protect their work. the technical details of that are immaterial. microservices is not a technical solution.;0
jebbaqj;Reddit;2023-03-30 21:39:32;i posted a somewhat specific scenario herehttps we can analyze.;0
jebfeih;Reddit;2023-03-30 22:05:28;you are still not explaining why. walk us through a scenario something like nonmicroservice org has to run through steps x y and z to troubleshoot the db while a microservices org only has to do step x.;0
jf0ituj;Reddit;2023-04-05 06:41:21;each service should own the data relevant to their subdomain regardless if you query the events from the same logical table or not. its still decoupled. i'm not sure which part wasn't clear that having a single physical database doesn't mean the data relevant to that domain is logically coupled. event sourcing decouples that using a single database. and yes microservices is a technical solution built by programmers in a tech environment that leverages conway's law supported by domaindriven design. it's just a buzzword to supersede soa. i'm not the one saying that it's all the authors i know who actually invented the goddam concept and elaborated on top of the buzzword of microservice. it sounds like that talk where alan kay who invested oop was correcting the speaker about the use of oop and the speaker tried to correct alan kay. this is ridiculous.;0
je7y1uf;Reddit;2023-03-30 03:38:20;my intention was not to say that no other system can work. my intention is to point out that the main gain of microservices is that your services are independently deployable and transparent to all other teams. i think that if you dont run into friction along those lines you are better off with a monolith. yeah sure.;0
jf1ruzm;Reddit;2023-04-05 15:32:13;i'm not sure which part wasn't clear that having a single physical database doesn't mean the data relevant to that domain is logically coupled. if i can't trample on your data and you can't trample on mine you don't have a single database. you have multiple databases. if you truly have a single database then you need trust and trust requires meetings and meetings are what microservices is to avoid. if you need cross team meetings you're doing something but it is decidedly not microservices. it sounds like that talk where alan kay who invested oop was correcting the speaker about the use of oop and the speaker tried to correct alan kay. okay but for better or worse said speaker was correct. kay's definition is not widely accepted. he who coins the term doesn't get to define it. the users of the term do. similarly microservices being just another word for soa is not widely accepted as soa is already like right there. indeed microservices is the product of conway's law just as i said before it is not something you choose. it is something you end up with at scale because you have no other choice. you are right that soa is often the technical solution to facilitate microservices. it need not strictly be so but for practical reasons it is the most likely approach. as such soa is typically assumed when talking about microservices. but the human aspect is not removable. obviously you can also do soa with shared databases and meetings but with such coordination you would only have a single service on offer.;0
jeib4e7;Reddit;2023-04-01 08:20:30;that's an orthogonal concern. your microservice can even be backed by your favorite relational database if you want. the point is only exposing operations you intend to support which becomes impossible if you just give someone free rein over the database. the point of this is the same as the point of mapping objects to viewmodels or dtos rather than passing them along as they are in the database or of having private functions or any other kind of encapsulation. then you don't have to worry about mavericks anyway. everyone communicates with the agreed upon interface and sla and each team can maintain their service in a way that makes sense for that service.;0
jec5ivo;Reddit;2023-03-31 00:58:40;i mean what about them. the larger the team gets the greater the degree of separation that is desirable and microservices are the most selfcontained.;0
jf2dohb;Reddit;2023-04-05 17:59:42;no need for special access as were talking about inner company communication across sub domains not company to company communication we're talking about microservices which emulates the world of interacting with various 'real' services except done within a single company. the need is there because that's what microservices is. under microservices you are pretending that coworking teams exist at other companies. hence the name microservices... services in the micro rather than the macro. you don't have to work that way in most cases. in fact if you are working that way you're probably doing something wrong. in extremely niche circumstances though it can help with organizational efficiency. ive seen it working really well yes of course. there is nothing about microservices that implies anything else won't work well. i'm not sure where you got that idea. microservices isn't something you would even want to voluntarily do only rarely ending up there because you have no other choice when an organization has a massive scale of people. it is not a desirable model. it is a model of last resort. there are much better ways of working 99 of the time.;0
