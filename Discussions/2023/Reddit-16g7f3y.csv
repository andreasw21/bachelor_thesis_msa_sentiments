ID;Source;Creation Date;Content;Sentiment
16g7f3y;Reddit;2023-09-11;Title:Death by a thousand microservices, Content: https://renegadeotter.com/2023/09/10/death-by-a-thousand-microservices.html;0

k07axll;Reddit;2023-09-12 04:23:14;microservices are obviously not the promised land we were looking for. we need subatomic femtoservices.;0
k07emqn;Reddit;2023-09-12 04:48:47;microservices were turned into nanoservices the actual antipattern by the time most teamscompanies started adopting it. this is because serverless and similar technology became popular around the same time. everyone adopted billing based design where engineers figured the supposed ease of managing infrastructure and runtimebased billing should have a say in critical technological decisions. microservices were not meant to be functions. and functions were never meant to be microservices. but here we are with hundreds and thousands of microservices which are just a bunch of functions serverless or otherwise. they're the worse of both worlds.;0
k06udp5;Reddit;2023-09-12 02:33:17;just write monoliths with well structured code. if your code is designed well its simple to break functions out into separate microservices as needed when scale or decoupling calls for it. but unless you have a good reason yagni kiss.;0
k08n67u;Reddit;2023-09-12 12:54:05;two words bounded context. most of the microservices being created do not repect their bounded context and either are way too small which forces multiple services to existevolve together within that bounded context or they are too big and cross the bounded context which makes them unmaintainable. usually its even a mix of the two. put some time in bounding your contexts get to know the different business domains you're working with and then decide on where to split your services.;0
k083gu1;Reddit;2023-09-12 08:42:26;reminds me of a company i worked at. 5 yr old messy legacy web app running with 5 layers of cache in prod. development and maintenance was a hell especially since we were given no time nor permission to refactor. all dev time was allocated to 90 bug fixing and debugging routinely including earlier fixed bugs and 10 new features. disregarding the advice a friend and i gave who joined the company simultaneously they hired a friend of the boss as a consultant who became cto soon after. microservices is the solution! he preached to the 4 developers. completely disregarding our constructive counteradvice as negativity that we should clean up the monolith instead and educate people on using the right coding patterns and paradigms. nono it had to be done in microservices because that will solve all our problems! we soon left after that. last i checked a few years after they hired a dozen of offshore ftes to deal with the workload and we're still looking for a lead dev who could help them move to microservices. i.e. they already made the decision to use microservices but didn't know how to implement it.;0
k073s1w;Reddit;2023-09-12 03:34:21;aside from the nodebashing i don't get the beef with observability either integration testing a distributed setup is a nearlyimpossible problem so we pretty much gave up on that and replaced it with another one observability. just like microservices are the new distributed systems observability is the new debugging in production. surely you are not writing real software if you are not doing. observability! this reminds me of people who say you shouldn't need automated testing at all because a good type system should be able to catch all bugs. yes obviously integrationtest what you can and static tooling including types can be incredibly useful. but it's still going to break you're still going to have to debug production and observability is still going to help.;0
k073hfc;Reddit;2023-09-12 03:32:22;i've used microservices previously the use case was that the clients of a monolithic saas applications had different requirements in terms of their integration points. some clients used an erp other's had excel files some had their data on an ftp server others had api's etc. we used microservices to retrieve data from those integration points and then forwarded them to the monolith. they definitely have their uses but yeah some go overboard with it.;0
k07ff6s;Reddit;2023-09-12 04:54:25;when it comes to microservices dont solve problems you dont have is a pretty good rule. prove you need it like actually prove you need it;0
k070qoh;Reddit;2023-09-12 03:14:28;one heuristic for deciding whether to implement something as a microservice is to ask if i do this as part of a monolith will it be doing io? io is slow. microservices are slow. but if the thing it does is io it would be slow anyway. another is whether more than one app would benefit from having such a service. say a database interface.;0
k0a0eab;Reddit;2023-09-12 18:36:45;jesus christ i would tattoo this article on my back. the part about what happened to dry really resonated with me. this was a great read! at my job we juggle with around 8 java microservices. and while our development team is great there are so many red flags that we've grown kind of accustomed as the codebase grew. i specially noticed how every microservice has so much boilerplate that is repeated across repos and that if one is updated then the other ones must be updated as well. but there's nothing to remind you that you have to update the other ones other than your good judgment and trusting that mental note you wrote fast while you made the original change. a small change say adding a single new attribute to a mongodb document becomes a big task of updating a handful of classes across 2 or 3 microservices. and there are so many duplicated collections!;0
k0690lz;Reddit;2023-09-12 00:08:43;the tldr of the article is that unskilled people who can't think for themselves a.k.a. morons are morons. and now we have a guy who took the time to write pages and pages of obvious things if you know what you do greatly simplified so that morons can understand. the problem is that this will be misconstrued in weird ways just like microservices often are. to be clear that's pretty fun to read and that's not a slight towards the author. i'm just saying most people they are trying to educate are lost to the world so the exercise is mostly futile.;0
k086nmb;Reddit;2023-09-12 09:22:42;what about event driven microservice with async comunication instead of distributed apis;0
k0873pl;Reddit;2023-09-12 09:28:37;microservices can be great in my experience if you can state what their api is and forever will be before you start building. if your communication needs are larger than that you're setting yourself up for a ton of pain with request format synchronizing and versioning that will rarely be worth it.;0
k08ecfv;Reddit;2023-09-12 11:06:12;start with a monolith but it does bring benefit to split domains into seperate modules and then services. a too big monolith has a number of issues in term of deployment dependencies release cadence testing and so forth. however separate services are not as tiny like microservices seems to be nowadays. a business can scale parts of its solution and get a degree of isolation and separation of concerns with a few servicesdomains that map what the business does. in my opinion the 2 extremes are not the answer. neither a monolith with a growing number of teams working on it or a complex microservices architecture made of myriad of small bits that we need to manage and monitor.;0
k15tkz9;Reddit;2023-09-18 20:32:24;i believe microservices are most effective for wellfunded companies that prioritize hypergrowth as a key metric for scaling their business. this implies the necessity of recruiting a mythical '10x engineer' and gleefully setting fire to your investors' cash reserves. üöÄüí∞;0
k07uydo;Reddit;2023-09-12 07:06:16;man i'm sorry but this sub just rehashes the same damn topics every week. microservices bad cloud bad managers bad meeting bad agile scrum bad.;0
k07307s;Reddit;2023-09-12 03:29:12;there is a lot of truth in what he said but it is also missing some scenarios. b2b sass often have a need to do isolated multitenancy especially with enterprises. this is very hard with monoliths and easier with pertenant micoservices. also micro is just a word. it has no correlation to loc or binary size. he has also missed the biggest reason in my opinion and that is the explosion of public cloud and their 1000s of services that developers could easily provision. just see the cloud architecture designs that aws publishes full of lambdas event bridge kinesis cloud watch and all sorts of serverless services. the other thing he glosses over is security. in a monolit if you have security vulnerability the impact is huge as the attacker gets access to the full kingdom. a properly secureddesigned microservices should contain the impact to that service alone.;0
l2rtfqp;Reddit;2024-05-06 03:51:40;the division that microservices argue so much about is a fallacy in some cases. for example when you work on an erp you realize that in the vast majority of modules you are going to need accounting or budget information and you will not be able to simply avoid having that information. in general it is very difficult to find true divisions that allow you to correctly divide microservices and not create dependencies between them.;0
k06pl86;Reddit;2023-09-12 02:01:24;its how people who cant really code try to hide the fact as long as they can. i worked on a team with a bunch of guys who couldnt write a for loop. no way they were finishing that project. i also suspect the microservices craze is from people who dont have what it takes to learn sql. sql is so hard lets do something else! you end up with a million microservices that dont work or a big giant nosql mess. then they all band together and fire the developers who are actually doing the work. you are using sql?!?!? what?!?!? get with the times man. omg wtf for loops are so archaic you're fired! everything that has worked for ages is old and stupid now. they want to use that new thing that has never quite worked right. reminds me of a guy graduating from an overseas professional culinary school and later find out he cant make a decent bowl of spaghetti. plate after plate of pure poison but in neat shapes with pretty flowers and gold flake on it.;0
k08mfg5;Reddit;2023-09-12 12:46:23;if only there were a way of organizing code that was neither a monolith or a large number of microservices.;0
k08yaza;Reddit;2023-09-12 14:33:35;but what if you take a whole bunch of microservices functions and the object they operate on and bind them together? heck you could attach the functions to each instance of the object they operate on so as soon as the object is created all the functions are available!;0
k0d5c4e;Reddit;2023-09-13 06:50:25;calling foo with microservices 1. perform dns lookup for foo.api.mydomain 2. setup tcp connection to foo 3. setup tls connection to foo 4. serialize the input we want to sent to foo out as eg json 5. put json in http request body 6. tls encrypts with aes the http request 7. sent out from the nic 8. over at best a few cables to some other server in your datacenter at worst across many miles of the earth to some other data center 9. foo api server receives this 10. aesunecrypts the encrypted http message with the session key from tls 11. takes the request body derserialize the json perform request validation 12. finally run the business logic calling foo with a monolith 1. call foo 2.. ????? 3. you're done 4. oh and btw literally any reasonable language that is to say statically typed language will do typechecking for your input here too at compile time. i agree that microservices certainly have uses when there is a particular and actually profiles performance bottleneck in a monolith. but like. yeah;0
k0gtx35;Reddit;2023-09-13 23:55:39;maybe this is rare but ive worked on two separate systems built from scratch that followed micro service architecture at two different companies and they were fantastic to work on. my team got the hard things out of the way first like observability and really good cicd pipelines. after that it was all plain sailing so long as we thought carefully about the boundaries of each service and the aggregates within we followed ddd. id done a lot of learning and research about using the architecture before we wrote anything and then made sure everyone else understood too so we didnt fall into the trap of making them as small as possible so i didnt really appreciate why theres such a backlash against them until now. ive changed companies and im working with a customer thats already written their microservices. this customer has created hundreds of them with no consistency over how they worked out the boundaries poor observability incredibly coupled they even share code files. and not owned by specific teams. if they hadnt built these micro services im sure theyd be in a better place but its debatable how much better. some of the mistakes theyve made show that they clearly dont spend any time actually learning how to do anything well. im convinced that they love the complexity of what theyve built. it makes them feel like theyre google devs.;0
k09bc60;Reddit;2023-09-12 16:06:31;you joke but at my last place we spent about 3 months dividing all our microservices into nanoservices. that was the actual word we used. senior dev thought he was blazing a trail.;0
k08a1qm;Reddit;2023-09-12 10:08:26;microservices are so out of date! you need serverless lambda functions because they can run on the edge! s;0
k08b6j2;Reddit;2023-09-12 10:23:55;the problem is that microservices have turned into entity services. data architects modeled all of these entities and then entity services got written on top of them without understanding the use cases they were meant to support. the result is distributed monoliths that require an app to integrate with 15 different entity services just to serve a single use case.;0
k087p6a;Reddit;2023-09-12 09:36:33;for me its about the domain and ownership. like owning a whole problem so you know where to go to change features owning the datastores i.e. one project reads and writes from a database owning the business so its easy to find in the code and so on. when you work on projects which dont modularise well and dont follow microservices it becomes obvious why microservices are a good idea.;0
k093659;Reddit;2023-09-12 15:10:30;all of the downsides in the article apply to non function based microservices too. faas is just one implementation option it isn't the key enabler of the issue.;0
k0990mz;Reddit;2023-09-12 15:51:15;monoliths do not make your code automatically cleaner and better. ditto microservices. microservices do not force you to have a better discipline but they require more of it.;0
k071v3c;Reddit;2023-09-12 03:21:36;the most frustrating pattern i've encountered is when the microservices are so tightlycoupled that you've lost the main reason to have them in the first place. if you have to doublecheck with a bunch of other services before you rollout a new version of yours or if you can't roll back a bad release without risking breaking a bunch of other services then you're paying all of the costs of microservices for none of the benefits.;0
k084o2h;Reddit;2023-09-12 08:57:22;this is like saying to someone playing tennis just get the ball to the other side. yes not wrong but kinda myopic. the whole point of a microservices architecture is to force people to maintain independence of unrelated parts of their codebase. if someone cannot do it when using microservices where coupling is harder you can guarantee they will not be able to do it a monolith where coupling is easy.;0
k07l0xu;Reddit;2023-09-12 05:36:07;just write monoliths if it were so easy everybody would do it. writing simple monoliths is just as difficult as writing good set of microservices. the complexity of the domain the competency of the developers and a myriad of other factors prevent success.;0
k071te2;Reddit;2023-09-12 03:21:18;years ago after work i walked by a microservices dev conference. ive never seen so many stressed out smokers in my life. ill stick with monoliths thanks.;0
k07nsrg;Reddit;2023-09-12 05:58:59;i think the main takeaway from the post is that we should be careful not to overcomplicate our systems with microservices. we should always be mindful of the cost and complexity that comes with microservices and try to use them only when it makes sense. we should also be aware that observability and integration testing are still important even when using microservices. and lastly it's important to remember that microservices are not a onesizefitsall solution and that there are scenarios where monoliths are still the best option.;0
k07j06i;Reddit;2023-09-12 05:20:37;all i know is that i worked on two monolith projects and it sucked ass. build time was about 30 minutes. getting those things to run took days and debugging was an enormous pain. hundreds of boilerplate classes with generic names hundreds of warnings during startup. so much anxiety. and god forbid you try to run the unit tests. took about 1 hour and failed because some genius put integration tests there. then i worked on 4 projects with microservices. build and local setup of a microservice is like 10 minutes. set four env vars and you are good to go. i guess monoliths can be good but i personally haven't experienced it.;0
k074tp5;Reddit;2023-09-12 03:41:27;monoliths always tend to eventually be not well structured in my experience edit note that this isn't an indictment of monoliths but more an indictment of the management or lack thereof of tech debt and failure to consistently adhere to good design practices. i'm actually often in favor of going monolith first and then perhaps pulling parts out as microservices when it makes sense.;0
k07ba1b;Reddit;2023-09-12 04:25:37;can you give an example of when a microservice is needed?;0
k07su7j;Reddit;2023-09-12 06:45:07;exactly. ideally every microservice can be based on something that can be in its own packagedll with only the communication interface changed. too much loose coupling and that latency builds up!!;0
k07t9o2;Reddit;2023-09-12 06:49:23;this is quite important part that many people seem to forget. if you are using microservices it doesn't mean that everything has to be microservice. and especially with new software it's fine to start with monolith and split it into microservices if needed. very rare software in the end needs those good things of microservices. they are just so hot right now that everyone does microservices no matter if they need it or not.;0
k089wi2;Reddit;2023-09-12 10:06:30;we gave all our loosely coupled microservices simple apis which allow the other services which use them an easy way to test. and a staging environment for full system integration testing. and we have logs. and we have great observability with a few lovely dashboards. it just takes a bit of time to set up and get right. it's an overhead but it's like tidying up before you cook common sense and makes life easier. but imho as a dev it's easy not to see the value in all these things unless you've stayed with the same system for many years. it takes time to see the tradeoffs play out and impact the overall business.;0
k078pp0;Reddit;2023-09-12 04:08:01;the real answer is it depends it really depends on what your application is doing and how much of it is doing the more expensive operations in aws. an entire monolith that runs on ec2 could be drastically more expensive than a series of microservices running as lambdas for instance. its a hard question to answer without looking at the application itself.;0
k0883l5;Reddit;2023-09-12 09:42:03;my answer would be yes most of the time... but it doesn't really matter because aws is super cheap compared to wages. it does require fewer developers to maintain one monolith instead of 10 microservices. not just the overlap in code syncing of databases but also the communication required between the 10 different teams a massive overhead that is often overlooked. and don't get me started on microservices written in an obscure hobby language of a developer that no longer works for the company.;0
k07qc7b;Reddit;2023-09-12 06:21:24;it depends this answer is based on my experience with azure but i think similar applies to aws microservices let you do more fine tuning in terms of compute cost. for example an app service in azure only allows you to more or less scale in increments of 2x which means it's easy to overscale when you need say 20 more compute. microservices can scale just that service to meet the workload but microservices add other costs there can be more networking costs from services talking to each other as opposed to in memory. you also have to weigh out the development cost of that fine tuning if you make fully scalable software when you're still in the startup phase it's a big opportunity cost for example there's also some compute cost every time you start up a new microservice. if the microservice is only spun up for a short period of time that cost might be as much as the cost of the actual processing it does. this is where so people have been burnt by having bad autoscaling so you have to account for that in theory microservices can be more cost effective but it all comes down to how you architect for cost savings though. amazon for example recently moved back to monolith to save a lot of costs on amazon prime microservices.;0
k07unk1;Reddit;2023-09-12 07:03:13;it was for amazon prime. they moved from microservices to monolith and they reduced their costs by 90. there is a screenshot in the article about that;0
k06wn4u;Reddit;2023-09-12 02:47:48;what he's really looking to define is the hypedriven developer. those who get excited by new tech and apply it recklessly. nosql microservices opinionated good design js framework of the week etc. all a mark of this kind of developer. i think these things all got popularized around the same time so in my observation i would say that js devs are a bit more used to moving fast and ready to make a reckless decision like this. however nobody should be treating js devs as a monolith. one thing i find a little interesting is that js and java are both first languages in college and both are old and have cruft. so you will find a lot of newbie code written in both against abundant bad choices of languageapis. i think js devs being used to moving fast will save them from getting quite as bad as java got but it will introduce its own unique issues;0
k071ta3;Reddit;2023-09-12 03:21:17;in fact most java devs that i know today always think about microservices and complex solutions. hell i saw python code made by java people and was overly complex for something that really didn't need all that.;0
k0a5ma9;Reddit;2023-09-12 19:07:04;i even did this with c when i was learning web development. i thought writing a web server from scratch would be a good way to learn which it was and decided on microservices that are separate processes for security reasons. that way if someone get's access to the static file serving process they won't be able to just see the memory of the user credentials process. it worked but the microservices were such a huge pain that it definitely wasn't worth it. now i'm just using a node.js monolith so basically the opposite of what the author said. i do still wish there was a good c webserver though.;0
k06p62i;Reddit;2023-09-12 01:58:29;i disagree the exercise is futile. despite the common sense knowledge that microservices contribute to bloat and complexity compared with inmemory function calls the massive number of articles hyping up microservices is a huge driver of misguided adoption of this luxurious software architecture principle. in comparison there isnt that much material examining microservices in a negative or objective light so people think microservices are only good and cost nothing. more articles need to be written about how engineering teams get choked by microservices and how its an antipattern for almost everyone but the most well capitalized companies in the world.;0
k07hprk;Reddit;2023-09-12 05:11:28;the value add of microservices just wasn't well described when the concept first became popular. my first swe job was at an f100 bank. the corporate tech literature loved talking about how great microservices were but they didn't really describe the benefits. lots of inexperienced devs were left to reason it out for themselves. at one point i came to the conclusion that smaller services must be better because they're easier to understand and maintain. that's not an overly wrong conclusion but does not really describe the major benefits and is a viewpoint that can lead to more problems than it solves since if you follow it as your major design principle you could wind up in a situation where you have many services that don't need to be separate an architecture which is very hard to maintain. it's only when i got more experienced that the major benefit of microservices are that they allow different teams to deploy their code asynchronously and that service boundaries should largely fall on team boundaries. code within your own team should probably be deployed to a single service unless you have a good reason not to.;0
k06n6op;Reddit;2023-09-12 01:44:49;i like how you call down anyone leery of microservices as morons. it's elitism but it's very insidious. nicely done. covering your back with a 'misconstrued' comment is just chef's kiss elitism. you've got this schtick rolling so well i bet it's just second nature.;0
k07e0i1;Reddit;2023-09-12 04:44:32;there is a lot of truth in what he said but it is also missing some scenarios. b2b sass often have a need to do isolated multitenancy especially with enterprises. this is very hard with monoliths and easier with pertenant micoservices. also micro is just a word. it has no correlation to loc or binary size. im sorry but looks like you are confusing multisingle tenancy with microservices. microservices extremists advocate for one database per microservice because kafka! i worked in a multi billion dollar energy company not long ago that had bazillions of microservices and trillions of micro sites. guess what? the staging database had unmasked data from production and everyone could see every single piece of information for every customer. who gives a shit about customer pii was that companys motto i suppose. the only reason shit had not hit the fan was due to the fact that everyone was being ethical about how they were using the database. i for one almost never opened the damn staging database. regarding security banks have been using decades old monolithic systems and security breaches have been quite rare. a counter argument to your point is that securing a thousand different services is far more complex and error prone than securing a single monolithic system.;0
k08t56s;Reddit;2023-09-12 13:50:43;personally i tend to disagree when it comes to the security aspect of a monolith. if components are designed in a consistent manner security concerns become a one size fits all kind of deal. in this situation security measures can even be subjected to proper tests to assert their effectiveness. in such a system one can use an ocap type of approach to pass information about the authorization context onwards together with the operation itself. this way each component can validate whether the correct access rights are in place and denyrollback an operation when not. it creates a rather small security scope right in the core of the system rather than on the boundaries of the system like currently often happens with rbac type of approaches. i see where the perception comes from that a monolith is more insecure than microservices though i think this mostly applies in situations where the monolith had become a big ball of mud over time. in those the execution paths can be hopelessly opaque which makes it significantly easier to miss security vulnerabilities. transparency is your friend when it comes to security.;0
k08pog8;Reddit;2023-09-12 13:19:10;microservices already have quantum properties they both work and don't work simultaneously and you don't know which is exhibited until it's deployed to production.;0
k0l5g66;Reddit;2023-09-14 20:34:06;i see this happen a lot with people who try and do ddd without a full grasp so they go at it bottom up and suddenly a whole group of your domains are too small to actually do anything useful. some domains are larger and more complicated than others. it doesn't mean you have to try and break those down into even smaller domains. and you really have to work from the top down and consider what the business domains are before you even start looking at implementation. i've worked with some systems that use graphql openapi kafka grpc in the microservice setup and i'm like... fucking why? it's a god damn startup that fundamentally boils down to ecommerce. poor leadership has a hand in this problem.;0
k089a23;Reddit;2023-09-12 09:58:00;that's all part of good management of code. i look after a bunch of microservices and we've got scripts tools ci checks etc which make it pretty simple to handle. imho as with all things related to programming it's easy for anyone to rush and do it badly. but it's possible for anyone to do it right with patience skill and a tiny amount of pitty for the next dev who'll have to work on the code.;0
k08lzz7;Reddit;2023-09-12 12:41:45;well microservices aim to mitigate that exact issue. you just rewrite the microservice in a technology that your developers are familiar with.;0
k0b5get;Reddit;2023-09-12 22:32:34;yeah i remember when they first came out i intuitively thought they would be very useful for longer running jobs that would run occasionally. but everyone around me thought i was an idiot. then everyone started using them in place of microservices and event processors to the point that not only were they running all the time but of course the ubiquitous startup delay problems and state management became a thing so aws was like oh shit we need keep alive and step functions. uhh no you don't. you're just pandering to the people who adopted your new tool incorrectly perpetuating the problem!;0
k08ptfk;Reddit;2023-09-12 13:20:29;owning the business so its easy to find in the code that's if you was lucky and your randomly picked micro service is the one holding the code. if not try the next best guess. and here the other side of medal why microservices are a bad idea becomes obvious too. separating domain and ownership is hard for developers in general it's not always clear and it's not always possible to their defense. it's same old wrong abstraction mistake just on a different scale. but at some point of project life it's already too late to change it then it snowballs and snowballs and snowballs because there is no one to say stop and oh boi;0
k07500u;Reddit;2023-09-12 03:42:38;thats why microservices are not necessarily bad but tightly coupled microservices miss the whole damn point;0
k087762;Reddit;2023-09-12 09:29:54;this ends up being a distributed monolith. ive seen microservices that use databases and other data stores for communication. im talking straight postgres as an api layer between services. it doesnt scale well.;0
k08jwim;Reddit;2023-09-12 12:17:56;when someone asks how do i do transactional microservices to rollback an effect in one service if the other fails is a good sign that it's too tightly coupled to be separate services.;0
k07dc8z;Reddit;2023-09-12 04:39:53;hilariously a huge percentage of facebooks infrastructure and business logic is powered by a monolith called www. theres very little microservice stuff going on.;0
k08fzx7;Reddit;2023-09-12 11:28:27;by this logic how is a microservice architecture any easier to manage? if you can make a microservice architecture simple modular and decoupled you can do the same for a monolith. the latter is actually easier. so if you can do the former you can definitely deal with the latter.;0
k09ftqi;Reddit;2023-09-12 16:34:54;no things that are easy don't take very many people to do. so hardly anyone is doing them. most engineers work on difficult jobs. the primary problem microservices solve is that there aren't always enough difficult tasks to keep a large engineering team busy. attaining a similar staff count with a monolithic architecture requires dropping quality which is less easy to recover from.;0
k087thu;Reddit;2023-09-12 09:38:10;all i know is that i worked on two monolith projects and it sucked ass. build time was about 30 minutes. getting those things to run took days and debugging was an enormous pain. that's not specific to monoliths. if your microservices was tested as comprehensively it would take longer.;0
k092mfy;Reddit;2023-09-12 15:06:35;sounds like those teams didn't invest in their build systems. that is not a microservicesmonolith problem in a microservices architecture the equivalent question is how long does it take to build and test every service for this product functionality that i need to verify. hundreds of boilerplate classes with generic names hundreds of warnings during startup instead with microservices the boilerplate and warnings are spread across hundreds of individual service builds! hooray! independent services solve a few problems very well but any notion that they improve the builddevex of a system is lunacy.;0
k06y30u;Reddit;2023-09-12 02:56:54;if you can't maintain a clean monolith you are going to make a real mess of microservices. breaking it up requires way more discipline than you might expect. just because it's a microservice does not mean it needs less care and feeding. it fact it needs more because it's part of a complex distributed system.;0
k07seuq;Reddit;2023-09-12 06:40:56;i spent five years working on modernizing rotten microservices. i had to use version numbers such as 4.x or 5.x to referred to which types of issues hasn't been corrected yet.;0
k08p76e;Reddit;2023-09-12 13:14:33;observability is needed because you unfortunately cannot just look at the stack trace or your log file. of course you just have aggregate your logs with another microservice Ô∏è;0
k07rfkc;Reddit;2023-09-12 06:31:37;amazon for example recently moved back to monolith to save a lot of costs on amazon prime microservices. interesting. they don't really have to pay for it though since they would be paying for themselves ?. so i guess they have some internal measure of how much resources they are using and because they sell similar services to paying customers they know the cost. their expenses would not include the overhead amazon charges its customer however. and if even accounting for that overhead they still save money with a monolith then that is saying something.;0
k0cqedd;Reddit;2023-09-13 04:43:27;even though the savings must depend on the applicationarchitecture that is a good datapoint. i wonder are there examples where using microservices instead of a monolith make it 90 cheaper?;0
k08l3k4;Reddit;2023-09-12 12:31:41;in comparison there isnt that much material examining microservices in a negative or objective light so people think microservices are only good and cost nothing. no one needs a phd in microservices to understand their main benefits is enforcing encapsulation clear apis and provide entrypoints that appear stateless. if all these are well followed you can scale your microservices easily. the limits are an increased cognitive burden and the major friction caused by making the service appear stateless secure configuration sharing is the major pain point people have. as i said in another answer a divideandconquerbased sort will be algorithmically more complex than a bubble sort whatever you do... if you know what you do that should not be impossible to reason about. and people make mistakes me included it's just that some are making the same mistakes over and over and over again and never learn. my point is if some people are using microservices without being able to think for themselves about it they are incompetent and morons to keep going without trying to get a better understanding of what they are supposed to do. if you ask a surgeon who has only treated skin cuts so far to perform an openheart surgery you'd expect the surgeon to understand much more than what scalpel manufacturers are telling them about this kind of surgery. so while i can't disagree to what you say about there being hype and the need for something to counter that a bit i am just saying that practically in real life most of the offenders here won't give a flying shit about it. they won't understand it anyways.;0
k08jomn;Reddit;2023-09-12 12:15:19;the corporate tech literature loved talking about how great microservices were but they didn't really describe the benefits. that's exactly the kind of things i am talking about if that literature cannot tell what the benefits and the limits of the technology are it's probably been written by a moron as in a person moronically writing about something they don't understand. at one point i came to the conclusion that smaller services must be better because they're easier to understand and maintain. that's only true when done reasonably and even then it is still a tradeoff. even a divideandconquer approach used to sort elements in a list is more complicated than a bubble sort... i don't want to throw stones we all make mistakes we all get the wrong impression we all think we know more and better than we actually do myself included naturally. what baffles me is not making mistakes especially not when as you mentioned the environment is filled with incompetent marketers whose purpose is to trick you into buying into what they are eventually selling. no what baffles me is that the same mistakes are done over and over and over again by the same people who i'm sorry to say have to have no understanding of what they are doing to keep using a losing strategy. code within your own team should probably be deployed to a single service unless you have a good reason not to. actually what you describe is not really a benefit of microservices it is a benefit of proper encapsulation with a clear apiinterface between capsules and it naturally forces you to reduce state coupling. if you just code like that it can be provided equivalently with different libraries or objects in your code but it does not have to be a microservice. microservices only force you to do those things. if you apply the same principles to normal code you'll get the same benefits plus very easy split points the day you actually need to scale a subpart of your code either within your main codebase in different threads or outside as microservices.;0
k07hbp4;Reddit;2023-09-12 05:08:33;what you are reporting is an anecdote and poor security culture in the energy company. microservices are by definition independent sharing dbs makes them not this is not extremism. modern banks are not monolithic i work in one. yes there is a mainframe somewhere in the bowels to act as the system of record transaction ledger but interface to that from various channels is through layers of microservices. breaches are rare because the db storage are network segregated and firewalled to eternity with all sorts of ipsids systems to protect the network.;0
k07gfut;Reddit;2023-09-12 05:01:50;nothing you can do that in theory. but in practice you will find that not all of the monolith needs full isolation some portions can be shared. microservices makes it easier to carve out sections isolate and scale independently as needed. this will also make your infrastructure bill smaller.;0
k09mz3n;Reddit;2023-09-12 17:18:09;i'm sorry to tell you this but you may be a bit behind on the latest research. it's now known that there are many possible notworking states but at any given moment most production systems using microservices are stable in one of those states.;0
k08o91j;Reddit;2023-09-12 13:05:08;yeah nothing like having to re write microservices into a new flavour of the month language all the time to create value for customers.;0
k07nkw5;Reddit;2023-09-12 05:57:05;the polylith. yeah people have largely forgotten the whole original logic of microservices. it started as our organizational structure is chaotic and we don't communicate well so we gave up on high lever architecture that and this is just sorta what happened. we only talk to other departments through an api. we have no idea if they even still work here. and a bunch of orgs were like we should use our top down organizational control structure to get everybody simultaneously working in coordination on making tightlycoupled trendy new microservices. and nobody knows why they did that.;0
k075sut;Reddit;2023-09-12 03:48:04;a more measured version of op's article would be microservices are not free. make sure you're actually getting some benefit out of them that's worth the very real costs you are paying.;0
k08m58b;Reddit;2023-09-12 12:43:21;everything has its pros and cons same goes for microservices. the main problem is that people often don't understand cons of microservices and end overusing them...;0
k08kdjq;Reddit;2023-09-12 12:23:23;exactly. there are even some bad advices that you could read in books about microservices. e.g. to code logic in the api gateway. imo an api gateway is not necessary until it's inevitable. it's a coupling point and you want to avoid as many coupling points as possible. if you start to code logic into it that requires maintenance by different teams you are even in a deeper pit of shit. it becomes everyone's shit bucket. another example is an authorization service that's doing... ü•Åü•Åü•Å authorization logic. even the simplest one! like checking if a tokensession id is valid. one of the things you will often hear about microservices is that some parts of your system should continue to work if others fail. but in this case the authorization service becomes a single point of failure since all authenticated requests will fail. admittedly decoupling authorization service is hard to achieve...;0
k08y12w;Reddit;2023-09-12 14:31:24;the logic was that an individual who thinks they can just write good code has very little control in reality over a codebase thats several years old and is worked on by 20 devs. wasnt talking about with respect to microservices personally i tend to agree wellstructured monoliths are way easier to write and maintain. anecdotally devs seeking microservces as a solution to messy monolith are misguided because theyll end up making something even worse.;0
k08dpeo;Reddit;2023-09-12 10:57:33;a microservice has a couple dozen classes. what kind of tests take half an hour for that?;0
k07epmt;Reddit;2023-09-12 04:49:22;microservices are many big companies' go to because it's far easier to have teams of cheap offshoreonshore developers working on individual services than to try and have them all working on the same monolith code at the same time. it's all about completing sprints and showing progress to upper management and business partners vs actually doing smart sustainable coding.;0
k06zxik;Reddit;2023-09-12 03:09:06;100 this. if you can't manage a monolith you can't handle microservices. especially if you are a small team. every microservice adds overhead and release complexity all of that effort could be spent improving the monolith.;0
k070laf;Reddit;2023-09-12 03:13:29;that also makes microservices appropriate for complex distributed enterprises. they're already bought the complexity and need to handle operations distributed across multiple independent teams and hopefully the organizational discipline needed to reduce the dependencies across microservices. on the other hand it's usually way overkill technically for applications under the control of a single team of developers and going microservice when you could much more easily have done a monolith just invites additional complexity you don't need. a small team has a good shot at keeping the monolith structured enough to provide an expansion path should one become needed so it's still a good idea to have that discipline.;0
k07jaoa;Reddit;2023-09-12 05:22:42;let's just say refactoring a microservice after indian colleagues' input is easier than trying not to kill yourself while refactoring a giant gordian knot of a codebase;0
k06y7n0;Reddit;2023-09-12 02:57:45;im not saying i cant maintain a clean monolith im saying the average enterprise cannot. i disagree that microservices is going to be worse.;0
k07evnq;Reddit;2023-09-12 04:50:35;a lot of the advice for one way or another assumes it's a brand new system. the reality is that a lot of decisions to move to microservice or vice versa are made to try to fix a system with problems. most of the time people aren't wanting to make a move with a system that is already in a great state. it's one of the most hilarious aspects of the great monolith vs microservice debate. i legitimately believe there are probably situations in the industry where big monoliths were migrated to tons of small microservices and then somewhere down the road someone was like we should condense all of this together in one application. and thus the circle of life continues.;0
k07shyp;Reddit;2023-09-12 06:41:47;rotten code is rotten seen it in both microservice and monolith flavor;0
k07xqak;Reddit;2023-09-12 07:35:36;i actually agree with you and a lot of improvements related to that the last years is not necessarily connected to monolith vs microservices. having these insights is great. it was more a tongue in cheek comment that you need to do a lot to just mimic the stack trace you always had with a monolith. even if tooling has made that much better but i remember this classic joke from some years ago we replaced our monolith with micro services so that every outage could be more like a murder mystery. httpstwitter.comhonestupdatestatus651897353889259520;0
k0dahdl;Reddit;2023-09-13 07:43:47;probably where microservices uncover and remove a lot of inefficiency hidden away in the monolith and the overhead of running each service is lower than the inefficiency removed.;0
k07tspi;Reddit;2023-09-12 06:54:37;here you go https;0
k07ulku;Reddit;2023-09-12 07:02:39;i once worked somewhere where a past engineer who in the name of independent scaling decided to copypaste a python project from an old api repository into a new repository delete all the functions write a bunch of new code with a different purpose then deploy the new api on a separate server behind its own load balancer. then he refactored the original api to remove some of the overlapping functionality and replaced it with http requests to the new api. voila the microservice architecture started to take shape. this happened a few times until there were about two dozen different microservice apis each effectively its own little monolith with a developer guardian watching over it sre provisioned a separate database for each microservice so they could each get data independently and never share data with each other for security and principle reasons this part is important... eventually someone else came along determined that http requests weren't robust and so he decided that for different services to communicate they needed to use kafka message queues to communicate with each other. so they did. and all the projects needed to be updated with the latest kafka tooling they needed to properly handle all of the topics have some retry logic baked into consumers processing the messages dead letter queues etc. database tables became bloated with request status or processing status columns entire tables devoted to tracking a queryable state for all the kafka messages. tens of thousands of loc in each project were copypasted across the multiple repositories utilities to encodedecode data and handle messages configuration for the topics etc. when it went to production messages would regularly get stuck at some microservice and block all of the rest of the processing on that messageitem causing outages for days and sending engineers scrambling. in order to debug it was unbelievably messy as you had to track down the request across multiple databases and logs this was where they introduced expensive logging and search solutions elk and all of the maintenance costs of rolling your own stack because hosted elk is a racket. unfortunately for these guys they also dealt with tons of customer deposits and transactions so not only were requests hard to debug they now had a monumental financial and tax reporting task ahead of them. but what's so hard? databases are made for that right? not in this case with the data spread out across independent databases there was no way to join the data. the only way you could get any sensible joins out of the data was if you performed some kind of etl from the microservice databases unified them into a common database and did the joins there. this was when they decided to hire an entire data team staffed with 5 engineers to build an etl engine to do just that and etl on a schedule too so you can't even get realtime data a task that required several new codebases to maintain parity between the database schemas index the data migrations to fix improperly ingested data etc. not to mention it was extremely heavy on the cloud services bill and staff budget and then they still had to write the damn queries! which was super difficult because you rarely had foreign key references in the reporting databases between services so you had to stitch them together yourself with possible loss of integrity and then wait forever for the data to be returned. not to mention the completeness of the data was not guaranteed! because the etl may have lost some data along the way the reporting databases were sometimes incomplete and you had no idea if you had all the records you needed to report money and balances accurately. ok so you know what the next bright idea was? they were going to build yet another microservice that would consume data reported by the other apis over kafka messages stitch together the data into its own database and then report balances from there via an api so they could get a realtime operational picture. then they had to deal with reconciling the discrepancies between the auditor's team's reports from the reporting databases and the operational numbers returned by the balances service which ultimately proved impossible despite hiring an external team of contractors to do so they just arbitrarily discarded one record and submitted the other to the auditors. this ultimately put their plans to merge with another company in jeopardy. at the end of the day these guys would have had a much easier time if they just stuck to a monolith. they would have saved all that effort trying to guarantee the robustness of the message processing by relying on good ol' trycatch. requests would be either resolve with success or failure rather than stuck. they would have had a complete set of data with full data integrity that they could 11 replicate instead of needing etl and a whole engineering team to manage. debugging the damn thing wouldn't be an ordeal. their reporting issues wouldn't be so severe they wouldn't have needed to spend well over a million dollars on contractors to deal with reporting problems. they had a mountain of data but only 150k users. traffic and load balancing would have barely been a problem. maybe would have felt expensive but it would have been cheaper than maintaining a microservice architecture. instead of microservices what they got was a forest of monoliths. you can argue that they made several design mistakes along the way that they didn't follow the true spirit of microservices their services weren't micro enough? that they weren't disciplined enough that their codebase organization was bad whatever but tons of misguided engineers make this same expensive mistake of believing that microservices will magically grant their software scale with no expense in terms of complexity. managing the complexity of a microservice architecture is not trivial it requires skill and discipline and even then it's hard to get right. and when you get it wrong there are so many extremely perverse outcomes that you never considered at the outset especially if you already have an existing monolith. this company had 50150m market cap and they got it dead wrong. you really need to be extremely wellcapitalized and attract the best and brightest talent to be able to afford a microservice architecture.;0
k07u0je;Reddit;2023-09-12 06:56:48;in the vast majority of cases microservices do not help with scalability. rather they make your performance problems even worse because now you're adding a bunch of unnecessary network hops. all web servers start infinitely scalable. if you can resist the urge of putting stateful pieces into your web server they stay that way and you can spin up as many instances as you want. the problem that microservices solve is either stateful processes which should be isolated or organizational issues at your company.;0
k08otvf;Reddit;2023-09-12 13:10:54;microservice maintenance ultimately becomes a social enterprise as individual engineers become experts of specific services or teams are built around specific services. you can select against stupidity in individuals but as a group they will make costly mistakes because of political and organizational reasons that have nothing to do with scaling. microservice interfaces end up being defined by political divisions in the company instead of logical divisions of data and automation. work and data is duplicated across services lots of common utilities or config may not be available across all of your services unless you build all your services in a common codebase. if you truly isolate each microservice and its data you often end up with difficult data management and reporting tasks database schemas see duplication and nonindexed foreign keys loss of crosssystem data consistency guarantees. you cant even commit database transactions for updates being done by multiple services so you lose atomicity and have to deal with outoforder updates too gotta make sure your system is eventually consistent. not to mention if youre trying to implement proper messagebased microservice architecture you turn all of your restful http endpoints into message producers and consumers that contain so much more boilerplate and data marshalling logic and create new recoverability concerns compared to simple passfail requests async state management problems etc. yes you get scaling but there are so many other costs and perverse consequences you are not considering that will come back and bite you. you dont need to be a moron to suffer from microserviceitis. people need to calm the fuck down and use microservices in justified cases mostly performance use cases only. all other divisions of interfaces into separate services is too arbitrary to prevent people from making bad design decisions and each arbitrary division amplifies the complexity of your codebase. otherwise good luck hiring your team of geniuses and making sure they dont collectively make bad decisions. at least with a monolith you can refactor function calls without rearchitecting your infrastructure. monoliths are morontolerant which id argue is what 99 of all software companies need.;0
k0cg77h;Reddit;2023-09-13 03:31:31;if you just code like that it can be provided equivalently with different libraries or objects in your code but it does not have to be a microservice. you can't deploy a libraryobject to production without deploying the monolith process. that's the difference.;0
k07ulet;Reddit;2023-09-12 07:02:36;the smug dismissive attitude that pervades this sub gets really gross tbh. it's the same 5 topics every week that get regurgitated microservices bad cloud bad meetings bad agile scrum bad managers bad developer good!;0
k07tpil;Reddit;2023-09-12 06:53:43;the vast majority of time the problems that microservices solve are not the problems the people using microservices have. for example they are great when you need to segregate various processes that are stateful. but in most cases they're downright silly for stateless things like web servers. yet who are the people most pushing for microservices? backend web developers!;0
k07gwz1;Reddit;2023-09-12 05:05:31;this veers into arguing semantics but when do microservices become micro? my expertise lays elsewhere but i'm thinking several bigger services would.work as well might even save you some money by reducing overheads.;0
k08pi2w;Reddit;2023-09-12 13:17:29;there's no have to. it's about ease of maintenance. a system based on microservices you can gradually rewrite. much better than having to maintain a single massive java 8 codebase.;0
k076qvl;Reddit;2023-09-12 03:54:37;yeah the real takeaway is not everything is a nail so don't always use a hammer. microservices and monoliths both have their place and their best use cases. more often than not people choose one or the other over perceived benefits in a vacuum instead of looking at what they need and then using that to make the best choice.;0
k08ha0z;Reddit;2023-09-12 11:45:17;if your microservices was tested as comprehensively it would take longer. a microservice has a couple dozen classes. what kind of tests take half an hour for that? your microservices aren't being tested as comprehensively as the monolith. that's why they run so fast. in a monolith every single caller of the function you just touched is checked for type matching. i can all but guarantee that your microservice code never runs the tests for all current callers before you deploy. still not convinced? here is a single situation that you don't have to test in a monolith because the monolith won't build if these situations exist. does bar respond with the correct error when given incorrect parameters? does foo output the correct response when bar returns incorrect parameters? do the callers to foo know what parameters are incorrect in your microservice those things need to be tested. in a monolith foo and bar are checked at compiletime to ensure that all the parameter types and return types match what foo and bar both expect. even if you're using a shitty language that doesn't do these type checks before execution javascript python php ruby etc you at least can throw and catch exceptions for this single situation. and that's just one situation. here's a few more that doesn't get tested in a monolith because all calls are direct function calls and still doesn't get tested in a microservice 1. missing remote host. 2. slow remote host. 3. wrong remote host. 4. all typechecking. 5. all callers. 6. wrong credentials ro vs rw. 7. all errorchecking paths. there's many more but i am short on time.;0
k071s13;Reddit;2023-09-12 03:21:03;i think monoliths are great if you are a small team with low turnover. otherwise microservices all the way.;0
k09b4hp;Reddit;2023-09-12 16:05:09;i think the first part of this is perfectly right and the second part is completely wrong. if you have an actual functioning microservices architecture your releases should be easy and low risk because they should be very small compared to a monolith. if you have a capable team microservices plus components is much easier. you might have very good reasons for building a monolith and for many in some domains all applications it will be the right choice but if your reason is simply that it is harder and more expensive take that as a sign of your own ignorance and your organization's general low skill level where this topic is concerned.;0
k071x5f;Reddit;2023-09-12 03:21:59;trying to refactor and maintain a monolith once you have 10 prolific developers working in the same application is nearly impossible. everyone always has a reason to be changing everything and trying to create a roadmap of feature releases in that situation is way more complicated than microservices in my experience because you need to explain all the technical issues to product managers who just will never get it.;0
k072swh;Reddit;2023-09-12 03:27:49;nothing sounds worse than architectural and technical decisions made by someone who makes those decisions based on microservices bad;0
k0725l3;Reddit;2023-09-12 03:23:29;how can microservices be better? any of the seperation of concerns can be done exactly the same in a monolith eg. modular monolith as you can architect your monolith exactly the same the only differences then are that microservices adds more infrastructure to manage more complex cicd more monitoring to configure etc.. and if you cut your bounded contexts wrong you're going to have a cluster fuck web of dependencies that's going to require you to overhaul your infrastructure in addition to your code;0
k08xlja;Reddit;2023-09-12 14:27:55;instead of microservices what they got was a forest of monoliths thats not microservices then. sorry you had a bad experience.;0
k0ckpjt;Reddit;2023-09-13 04:02:52;the full citation is actually what you describe is not really a benefit of microservices it is a benefit of proper encapsulation with a clear apiinterface between capsules and it naturally forces you to reduce state coupling. if you just code like that it can be provided equivalently with different libraries or objects in your code but it does not have to be a microservice. with further mention that when those principles are applied to the code splitting to different threads or proper microservices is pretty easy. you can't deploy a libraryobject to production without deploying the monolith process. that's the difference. you can't deploy a microservice to production without serialization and updating your favorite outofband state synchronization machinery at best. that's the difference. do you perceive how little this bring to the conversation to cite things out of context and answer out of context? i thought that what i was talking about was sufficiently clear having taken the time to spell it out...;0
k08lrcv;Reddit;2023-09-12 12:39:07;not really. i love microservices actually. they have lots of architectural and social benefits. the topic is more about people mindlessly using they for everything splitting the code in nonsensical places and leading to the current pendulum swing. if those people who are criticized for making code bases unmaintainable by grossly misusing microservices understood what they were doing and why or if after trying they had the intelligence to learn from their mistakes the pendulum would not swing. the microservice architecture would just be one extra tool people would use in cases it makes sense and all would be well. so i think you miscontrued the discussion.;0
k07jd6l;Reddit;2023-09-12 05:23:12;i am of the school of thought that microservice doesn't have any expectation of small size. it is a term used in the industry so i will use it too. it is a well encapsulated service that can be built deployed and scaled independently.;0
k0b9hzx;Reddit;2023-09-12 22:55:13;no it's much better to pick a long lived language framework that provides well supported upgrade parts and continually upgrade it as you go. we have both monolith and microservices in the ecosystem the majority of microservices are in a worse operational support position after 35 years of life time than the monolith is after 20.;0
k0791vw;Reddit;2023-09-12 04:10:15;that might be too reductionist. i think there's something to the idea that way too many people are building microservices for the hype and that maybe monoliths should be the default until you actually need to split things up. i'd apply similar logic to databases. your default should be a single postgres server scaled vertically until you can't or until you have a very good reason to add something else. i don't see the opposite problem so often anymore where people have a monolith that should've been split up ages ago.;0
k07rsmc;Reddit;2023-09-12 06:35:03;if you can't create a roadmap then you aren't ready for microservices. start by carving out parts of the monolith into libraries that are tightly controlled. not just code reviews but actually having to ask permission before making changes to them. over time ratchet up the minimum quality requirements for these libraries. later if you find a specific need for a microservice you can pull one of those libraries out and put it into your separate service.;0
k07a6wq;Reddit;2023-09-12 04:18:06;its the exact same problem only with less visibility and focus. yes you need discipline and a product plan if you have more than a few developers. changing to microservices will not magically solve that just delay fixes and increase overhead.;0
k07w1i4;Reddit;2023-09-12 07:17:34;you are making the logical fallacy of assuming monoliths and microservices are two answers to the same problem. if your microservices are designed in a way to make overall deployment more complex and fraught with problems you are doing something very wrong or using the wrong architecture approach.;0
k07x3bt;Reddit;2023-09-12 07:28:41;lived that life recently giant monolith with double digit teams all working on the same code base. it can be a nightmare when something bad happens for sure. there are pitfalls to both approaches and youll never have a great experience if the architecture or best practices are shit. the microservices vs monolith debate hides the real issue which is youll never have a good experience if your architecture sucks or you dont enforce good development practices.;0
k06zy1k;Reddit;2023-09-12 03:09:12;i think the less than ideal choices of one individual only affect the scope of one service. one thing i like about micro services in my own experience is that a micro service is better about ensuring single responsibility principal. meaning developers are better about keeping code that is related to the original intent of that service inside just that micro service. in monolithic worlds i see crime scenes where changes are dragged and distributed in all the structurally wrong places. moreover people can absorb the understanding of microservices like a black box. i just need to know that coffeeapi gets coffee. in a monolith coffeeshopapp absorbing how it works is easy until the first broken window and then it all goes to hell from there. people see trash so they dont feel bad about adding more under tight deadlines.;0
k080de6;Reddit;2023-09-12 08:05:03;why do you need to understand the other microservices unless you have to make changes to them? you only should be worrying about input and output. rest of the implementation could be wildly different as long as the result is the same why would you care?;0
k0fn5vg;Reddit;2023-09-13 19:44:13;yup its super easy to get that. in fact never in any of our load testing was kafka a bottleneck. one of the finest pieces of engineering ever. and keeep in mind this was with consistency which mean that write to the kafka topic needed to be acked by at least 1 other replica before it was written so that means it did that network io that fast as well and the consumer also pulled it and wrote it to it db in the that time. but i am supposed to believe that network is the reason microservice is slow. no. the assertion being made was false.;0
k0atqfw;Reddit;2023-09-12 21:26:05;thats like talking about hard life in the soviet union and saying thats not communism then bro sorry you had a bad experience. when companies make microservices for the sake of microservices forest of monoliths is what you get. you gotta be smart enough to know microservices arent general painkillers like they are touted by the hype articles.;0
k0e8usr;Reddit;2023-09-13 14:20:21;i'm just elaborating on what the previous poster mentioned when using microservices if the api is well designed such that it is stable and breaking changes can be avoided then the microservice implementation can be modified and changes can be deployed by the owner team without requiring involvement by any other team and without having to deploy the whole system. which is a clear benefit of microservices versus monoliths. notably it dramatically reduces the blast radius of changes. admittedly this is all predicated on the assumption of good design but good design is a requirement regardless of the architectural style.;0
k08xsrm;Reddit;2023-09-12 14:29:33;the topic is more about people mindlessly using they for everything but what is really happening is just an antimicroservice circle jerk with very sparse actual technical arguments.;0
k07pz74;Reddit;2023-09-12 06:18:11;that's just a service not a microservice architecture.;0
k0eq3fc;Reddit;2023-09-13 16:22:50;not really. if you had some monolithic backend in java 8 and wanted it all rewritten in rust you'd have to do it in one go. discord is build on microservices. you receive messages via a socket gateway send messages via rest. and the backend does image compression via some internal microservice. that compression microservice was too slow so they rewrote it in go. which is as simply as rewriting it and then making sure it still passes all tests. then you can continue to deploy it without worrying about having changed anything else. imagine if they had one single codebase responsible for the whole backend...;0
k0eqlge;Reddit;2023-09-13 16:26:00;you can also just write microservices in a long lived languageframework. and upgrading it is easier as well. let's say you're upgrading your java version you will start by upgrading the microservices that can benefit from the upgrade the most. now you don't have to rewrite and retest your whole codebase at once.;0
k079n85;Reddit;2023-09-12 04:14:20;unfortunately i literally am working on a big monolith that should have had big parts pulled apart for years and were just now starting to do this work. but i work in an org where there might exist 10 different monoliths that have a lot of overlap with each other in functionality and it makes more sense to pull these parts into a single microservice for each shared feature. that can then be utilized by each as an independent service that doesnt need to be updated in ten places when we need to make major changes to it for instance when required for pci compliance.;0
k0do27o;Reddit;2023-09-13 10:33:11;these things just aren't very time consuming. testing function calls takes milliseconds. testing endpoints is slower but still not a big problem. well with the monolith the callstack is getting run. with the microservices no call stack is being run. if you test your microservices as thoroughly as the monolith is being tested i guarantee that it will take longer to complete. the only reason the microservice test appears to be faster is because it skips all of the tests that the monolith is doing. what really takes a lot of time is for the monolith to be set up in a testing context to create embedded databases and content repositories for testing. for a comprehensive test that's tablestakes. the microservice msa isn't seeing this cost as even if it isn't working on mocked dals it's only testing the local changes to the local msa so the other tables and interactions between various components is never tested. the monolith test can complete as quickly as the microservices tests if the testing excluded all the things that microservices don't test for.;0
k07zjyc;Reddit;2023-09-12 07:55:40;no because if you can't get decoupling of your code done right in the first place adding the complexity of microservices deploymentsversioning isn't going to help you;0
k070qgb;Reddit;2023-09-12 03:14:25;imho thats a company culture problem not exclusively a microservices problem. you can absolutely enforce standards in microservices development.;0
k07xteh;Reddit;2023-09-12 07:36:32;coffeeapi might start with just getting coffee but after a few sprints someone wanted hot chocolate. well not too different not worth making a new service for. then someone wanted vanilla syrup. easy. cream. easy. sugar. boom easy. now someone wants green tea and damn it sure. it takes longer to brew but it's a core feature now. so now coffeeapi is also responsible for brew times tracking metrics also just keeps a list of customers with tick marks next to their names for how many times they've bought each product and variation thereof. oh and it's still useless without baristaservice deliveryapp and coffeeroast.er. but now it's all tangled and they can't even keep up with their own supply chain. that's how microservices become distributed monoliths though. if you don't do any sort of design planning they grow into mountains that depend on other mountains and everyone on the outside assumes that all your service does is this tiny easy task.;0
k07kl6l;Reddit;2023-09-12 05:32:41;if you want that kind of control just add permission to different folder paths in git. again nothing that monoliths can't already solve. the black box doesn't magically fix problems and if you're developing like it is then you're just slinging a dog turd over the fence at that point and saying not my problem if you have devs ruining architecture on monolith those problems will be magnified in microservices;0
k099k0e;Reddit;2023-09-12 15:54:46;what? i and many others are saying it is mostly a human problem. folks that use microservices claim that it helps keep things organized due to limited scope and size of each service. however each microservice requires overhead and unless you are doing something fairly simple i find that the whole architecture requires a lot more discipline and resources to keep organized. regardless of which approach you take keeping things clean and organized is something you need to allocate actual resources to on a continuous basis.;0
k07zwjs;Reddit;2023-09-12 07:59:41;complexity of microservices deployment? you and i mustve worked on vastly different microservices. one of the big selling points of properly architected microservices is that they are decoupled including deployment. i would argue that microservices done right makes deployment far easier. you dont have to deploy a massive system every time you make some changes or big chunks if its a modular monolith. instead you typically do small easy to test and easy to roll back deployments instead. i think you are just clouded by perhaps bad experiences with poorly architected microservices in which case i can understand your bias. but what you describe sounds like bad design decisions which will be bad regardless of the choice between monolithic or microservices;0
k071x12;Reddit;2023-09-12 03:21:57;a lot of companies are under the impression that dong microservices solves those problems automatically like it's a magical pattern that just works out of the box for everyone.;0
k080xfl;Reddit;2023-09-12 08:11:28;sure they're easy to deploy when done right but it adds complexity multiple build pipelines to maintain configs etc.. so yeah they're a solution to being able to deploy more frequently but getting there has a complexity cost. for context i have worked on one system that did microservices bad. they had messy code that was hard to release so split it into microservices but it ended up being a distributed monolith because the bounded contexts were cut poorly. so if done wrong you end up having to deploy many microservices at once which is hard. it just made things more of a mess. so all i'm saying is if they're looking at them for a solution to keep code clean you're looking at the wrong solution and probably going to make things more complex for yourself. get your monolith and code clean first before you go microservices but they aren't a magic fix for messy code and tight coupling;0
k0745j1;Reddit;2023-09-12 03:36:55;i have seen stellar teams write good microservices code. that's all they did. not product code microservices code. there was no time left for anything else.;0
k0727kb;Reddit;2023-09-12 03:23:50;i mean the truth here as it is with all things is that you should architect based on your environment. im just saying in the average environment microservice architectures are my preference for the reasons stated above. however obviously there are cases where monoliths are the best choice.;0
k07n1yq;Reddit;2023-09-12 05:52:37;dong microservices there's a joke in there somewhere....;0
k0agx9h;Reddit;2023-09-12 20:12:13;when did i ever say microservices keeps code clean? can you point to where i said that. you are inferring something i never said.;0
k07uars;Reddit;2023-09-12 06:59:37;yeah thats not really true for a well designed microservice. and what you really need are contracts not shared libraries. well agreed upon contracts help solve a lot of the problems you infer whichever approach is chosen. microservices should never be dependent on another service being rigid. thats a disaster waiting to happen.;0
k08s4u6;Reddit;2023-09-12 13:41:49;your microservices should not be communicating synchronously via an api. that is not microservice architecture. they should be keeping their database uptodate by consuming events from other services and should be publishing their changes via events for other microservices. you can add information to an event but never remove this maintains compatibility.;0
k07wet6;Reddit;2023-09-12 07:21:28;the big mistake is often assuming an entire monolith needs to be converted to microservices or vice versa when a hybrid approach might be a better use of resources and bandwidth. ive seen virtually zero successful full conversions whereas ive seen more than one successful scenario where certain aspects were either pulled apart to form microservices or melded together to create a monolithic application typically more often the former;0
k09whxa;Reddit;2023-09-12 18:13:57;that's a pretty severe set of restrictions and an unnecessary one. if it only counts as a microservice architecture if you can't ever reduce the amount of data you store and process then i agree with op and no one should ever do that. but that very clearly isn't what's meant when people talk about microservices vs monoliths.;0
k0ayawz;Reddit;2023-09-12 21:52:11;yeah code being clean is a factor solely of good design principles a well thought out architecture and developers keeping to best practices. also it takes constant attention like a damn house plant to keep in order. if that's not happening they will fuck it up whether it's microservices or monolith and in both cases it will be bad. i've seen it happen in both neither is going to save you if the code isn't clean;0
k097wqj;Reddit;2023-09-12 15:43:44;what i mean with conversions is any major change that requires many things to be rewritten. i dont exclusively mean breaking down a monolith to a microservices architecture.;0
k07yub2;Reddit;2023-09-12 07:47:48;youre assuming that the consumers dictate the design in that scenario. thats a good way to paint yourself into a corner and probably shouldve just stuck with a monolith in that case. i said it somewhere else you will always use a hammer if all you see are nails. a microservice has its place just as a monolith does but the focus should be less on one or the other and more on good and well intentioned architecture and best practices. shape your chosen approach to the problem being solved.;0
k08sin7;Reddit;2023-09-12 13:45:12;microservices dont communicate synchronously via an api. if they do that is nothing more than a distributed monolith which gives you none of the benefits of microservices.;0
k09fhiq;Reddit;2023-09-12 16:32:47;a microservice will already have the data in its own database because it has kept its database in sync by listening for events from other services.;0
k09ika9;Reddit;2023-09-12 16:51:43;... says people who know nothing about database design or microservice architecture.;0
