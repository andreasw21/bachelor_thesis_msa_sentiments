ID;Source;Creation Date;Content;Sentiment
17qr9vp;Reddit;2023-11-08;Title:Microservices aren't the problem. Incompetent people are, Content: https://nondv.wtf/blog/posts/microservices-arent-the-problem-incompetent-people-are.html;0

k8fousn;Reddit;2023-11-09 01:33:22;can we just get rid of the word microservices and just call them services? services are an abstraction and there is no reason to be prescriptive about how to apply it. just freaking let engineers decide what granularity they want their services to be given their unique context and situation. we don't have microclasses or microfunctions so why should we have microservices?;0
k8e93qw;Reddit;2023-11-08 20:11:18;the main problem with microservices is people are unwitting building a distributed system but without a working understanding of consensus;0
k8e2vj2;Reddit;2023-11-08 19:33:55;the concept is good it's just that you require your teams to have a consistently aboveaverage talent level to make it work right isn't a great argument. people tried that same argument with functional programming vs oop a while back. development is fast and we have few bugs and coincidentally we always only hire the absolute best and most expensive developers. great people can make anything work but there aren't enough great developers to go around. you need a system that you can actually hire people to work on and sometimes that means not going with the most complicated solution. the reason why i like microservices over just regular services is that you can't be watching every piece all the time. you need to have some components in your system that are just solid correct and reliable so that you aren't constantly having to go back and fix things or tweak things to keep the whole enterprise running smoothly. a component which is small simple and tested out the wazoo means you can confidently set it and forget it and move on to other areas of need. there's a certain amount of discipline and experience required to make something so simple and reliable but it's far from impossible.;0
k8egddw;Reddit;2023-11-08 20:54:59;i'd argue this is the other way around. microservices are often a solution for incompetent people. by narrowing the scope of what any one individual can fuck up you make it easier for an incompetent person to be productive. or at least limit the scope of their fuckery to one component.;0
k8h6lce;Reddit;2023-11-09 09:18:06;this post reads like a thoughtbuffet. there are lots of points some connect with each other most are just streams of consciousness. maybe i'm just really fucking dumb it's incredibly difficult for me to see the theme of what you're trying to expound on. given that i'll give you a playbyplay reaction video of me reading this. microservices aren't the problem. incompetent people are what a title i better buckle up the real problem i think is the lack of engineering competence and the lack of giving a shit in companies. thats what creates complex systems nobody can efficiently work on. i've worked at giving a shit type of teams and companies and wrangling poorly designed complex systems is the bread and butter of senior eng and tls there too. i think it's easy to romanticize about this platonic ideal of the perfect environment with the perfect mix of competent personalities that can create the justperfect system that can stay in its perfection in perpetuity. here's my take if you're chasing for ways to wrangle your existing environment into perfection you're fighting the wrong battle. shitty systems and shitty code is a reality that we as experienced senior engineers have to learn to live with and manage. we can fantasize about our personal projects that can momentarily achieve that platonic ideal but you better still snap out of those daydreams and get the real work done at least from time to time. being smart doesnt guarantee that you can solve any problem. experience is probably the most valuable asset and the experience itself needs to be of the high quality which is a rare gem too 1000 we give it up when adopting new technology. we willingly make ourselves incompetent. i don't think this is the right take. in my experience an experienced competent senior engineer knows how to rapidly ramp up on new stacks. it's that ability to adapt and that unearned confidence of well shit i have no idea what's going on but i'll blindly assume that i'll figure it out that distinguishes the ones with the high quality experience from the rest. if someones used hammers and nails all their life and you give them screws and a screwdriver theyll simply say oh thats a pretty crappy hammer but the job is a job and proceed to smashing the screw into the wood with the handle. if you want them to use it properly invest in their education or at least handhold them until proficient. do people do that? not really unless its a very small engineering team where everyone works closely together and even then its not necessarily a thing. and dont forget teams where the tech leads have no idea what theyre doing either. this is a great analogy for lots of things in our profession. i don't see how this connects with competency unless the argument is that as a profession we're hopelessly lost to hammering screws with screwdrivers we're so blindsided by our past experience that we treat every problem through the frame of what we're most used to even if it's the wrong approach to the task. i think this is just a matter of opinion i don't see this trend among people i work with your mileage may differ. having a no fucks given culture is a disease. it poisons everything around it. at some point everyone stops trying to improve things. they simply go with the flow. just like shit in the sewers as my teacher used to say. thats one of the reasons why i always recommend junior people to change jobs at least once a year. its better to learn bits and pieces from different places rather than getting stuck at one. this is a great point. that said i disagree with your assessment here that no fucks given culture is primarily due to individual actions. there are all kinds of causes. the most common ones i see at large corporations are related to lack of scope opportunities mismatch of expectations bureaucracy etc. if this is a cultural problem within a single team and you're in a position to affect change you should try. if this is an endemic cultural problem in the org or you're not in a position to affect changes there's only so much you can do. i think you're really underestimating the power of entrenched institutional problems it'll take competent and motivated people and grind them down to dust. having the lets call it smartass complex oftentimes will make us ... these are also great points it's a rite of passage towards becoming a senior engineer who can keep the whole team focused and motivated. solid systems these are also great illustrations. again i don't see how this ties to the previous sections. i dont trust other people so id rather not let them touch my stuff. to be honest coming from my own experience this seems like a very problematic take. there are ways to collaborate with stakeholders that doesn't require an allornothing approach to code ownership. what if you left the company what happens to all of these services that only you were able to writetouch? beyond just a poor busfactor this is a great way to start shipping your org chart or even your team structure in the code that you write. sure it's great that you can basically optimize for the sme of the service to respond to issues easily but i'll argue being able to develop these smes isn't as valuable as being able to reskill any random joe on your team on any random component your team owns. to this end i think this is a really bad team development strategy. think about developer experience 100 but this is very nuanced. i disagree somewhat that developer ergonomics are the most important aspect of developer experience. this is true if your developer customers are faceless 3p devs that do not have direct access to you. in the scenarios that you describe working with peers i would optimize for how to make high bandwidth collaboration easy and then work backwards from there to figure out the proper architecture interface boundaries and how to documentnotify folks of major design decisions. when working on teams components should be relatively low cogload to understand and anything that's more complex should be easy to attribute to a group of folks you can ping and ask questions of and regardless of how competent your team is the gradual enshittification of codebases will always cause even the most pristine codebase to become unnecessarily complex if you always let them dump urgent stuff on you theyll keep doing that. take a stand from time to time. making compromises all the time will simply slow down the work in the future and the company wont be able to scale seen plenty examples of that. i think a really important distinction should also be made here. do you have the power to push back? there's a difference between pushing back on random scope creep by asking do we really need it now if you need it now we will slip these items get deprioritized otherwise you go on my backlog vs pushing back on legitimate product requirements. ultimately i wouldn't frame this problem as don't be a pushover that's putting too much personal attachment into the problem. understand where the ask is coming from and whether or not you have the bandwidth. you should always pushback on every request but it doesn't mean that you should default to no and you should be consistent in how you handle these frs. therere 3 different teams working on my repos. what the actual fuck? recently i took a look at the code and didnt recognise some parts of it. some changes even screwed our team over not too much luckily. i think there are other ways to solve this issue. and i can see it from these other 3 team's point of view. they want to do things there's this one random engineer who bottlenecks a critical component and they see too much friction working with this engineer. that's a legitimate organizational issue to solve. it doesn't mean you're the person who can affect change but it doesn't mean that the other teams are out of line either. my main reaction here is 1. why is the bus factor so low here that a component needed by 3 teams is being gatekeptcompletely owned by 1 person you need to spread this domain out. 2. if there are requirements that you want to enforce work with these 3 teams and align. setup a codereview process where you'll need to lgtm but also be reasonable about not turning every code review into a turf war that said in either case your pristine code base will eventually become shitty despite your best efforts. but and i can't stress this enough it does not become shitty because you let these 3 incompetent teams go rampant on your code. it becomes shitty because it get critical work done within it. at the end of the day hoarding total ownership of a critical path component doesn't sound right to me but that's just my intuition tingling. if you dont care about the company care about yourself. and speak up 100 but this comes with the caveat that you may likely get an answer that you don't like back. there's only so much that you can do as an individual and changing the team culture is incredibly difficult impossible if you don't have the powerinfluence to affect change and you don't have the sponsorship to shake things up for a bit in order to make the future better. it doesn't mean you shouldn't try but it doesn't mean it'll work. conclusion you make great points and as you say these are your opinions and i obviously disagree with some. that said i still don't understand how all of these topics tie together.;0
k8ishlz;Reddit;2023-11-09 17:47:21;remove the word microservices and you've got a template for most of the evils in the world ever;0
k8ft2p4;Reddit;2023-11-09 02:01:54;i don't know anything that requires a lot of data shipping will not be the most performant on microservices;0
k8h8ozr;Reddit;2023-11-09 09:46:35;working towards improving code processes and organization is one of the most difficult things a software engineer has to deal with...and that's why 99.99 of us don't do it. i have tried to raise my concerns many time over code quality patterns tools architecture but the average joe doesn't take it well. you have to be extremely careful in your wording so as that the other part doesn't feel offended or doesn't translate your words as 'do you think i am stupid?'. i am really tired after 25 years in the field to try to be a politician trying to convince people that what they doing can be improved in such and such way. i have a life to live children family obligations etc. i can no longer afford lengthy talks about what is good and what is not and i can no longer tolerate smartasses that do as mentioned in the article. the end result is that i take care of my part of the code and the rest i.e. other people's code can burn in hell. and here is where microservices help...we agree in specific apis between the teams and then the teams can do their code in any quality imaginable and it is never our team's problems! i.e. it helps with separation of concerns...and managers recognize this and that's the reason they want microservices...microservices isn't so much about the code but about the teams and how to build a product in a manner that doesn't bring down the company...;0
k8ebvkl;Reddit;2023-11-08 20:27:53;the microservices architecture doesn't help either.;0
k8ft7ky;Reddit;2023-11-09 02:02:49;the kafka bit was really onpoint. i have worked in that organization where the way you prove youre one of the smart ones is to turn every problem into a kafka problem. even worse than the devs is when that attitude starts to infect the managers. the most toxic incompetent manager i ever worked for shot down straightforward and efficient solutions in order to bully devs into unnecessary kafka solutions because just saying kafka in that org was in theory a career boost. on microservices i am of two minds. on one side it forces separation of responsibilities when devs arent disciplined enough to do it on their own. on the other microservices give you the opportunity to scale different parts of your solution independently and you dont have to get super big for that to represent a measurable reduction in resource costs. but i also look at it like this its one thing to complain about rampant incompetence and another to recognize how little time we spend teaching juniors to separate responsibilities in the first place and how little time we are given to do so in the face of pressure to deliver fast. at best we give them the training wheels of microservices and just sort of hope they eventually get it. but then you just as easily end up with teams that accrue a cultural microservice bias where juniors copy the established pattern of spinning off a new service just because without thinking about responsibilities at all. ive worked in that org too. basically its hard for me to focus too much on what devs dont know without ending up wondering exactly when and how theyre supposed to start knowing when we spend so much time building engineering orgs defensively around anticipated gaps in their knowledge. perhaps its that we think of incompetence as a terminal character flaw instead of simply the state of having not yet attained competence.;0
k8ftvxr;Reddit;2023-11-09 02:07:27;microservices amplify cracks of incompetence they require a much higher bar for engineering maturity tooling monitoring documentation tracing and engineering effort. this means that microservices are in fact a problem because to do them right the skill engineering effort is multiples of a good monolith which less skilled engineers can still easily work within.;0
k8eb0ew;Reddit;2023-11-08 20:22:43;no microservices are definitely a problem. they are how incompetent people reinvented distributed systems with zero actual pros from distributed systems but all the cons. httpsrenegadeotter.com20230910deathbyathousandmicroservices.html;0
k8fuvrc;Reddit;2023-11-09 02:14:10;expecting people to master all languages all deployment targets all databases all cloud providers all nuances of iaac all the details of networking as well as their application domains the specifics of their stack as it accrued complexity over the years is just not realistic. i have ok devs when they hear microservices they don't think about transactions. you can't ask most people to learn ten times as much after school as they did during it. you are not google.;0
k8g810v;Reddit;2023-11-09 03:43:24;we try to use a new programming language for each new microservice. it gets really boring following the same pattern every time.;0
k8grwdy;Reddit;2023-11-09 06:26:20;one of the reasons i prefer serviceoriented architectures is the fact that id rather own a few small services nobody outside my own team can touch so well have complete control over them. i dont trust other people so id rather not let them touch my stuff. when everyone owns everything and thats what often happens in monolithic codebases nothing gets done. he found the answer yet still believes in the wrong thing. microservices are for scaling teams not tech. it's conway's law a company's product mirrors its organizational structures. if you have five discrete teams your product will have five discrete modules where each team owns their module and have full control over it without worrying about other team's grubby hands touching it. in that vein it's nigh useless for a single team to own multiple microservices because why would you take hardest problem factoring system correctly and introduce network call toohttpsgrugbrain.devgrugonmicroservices. again stop using microservices to organize clean code or whatever nonsense. at the end of the day it's about scaling with people. you have too many people working on one thing you need to split it up into services not necessarily micro and for the love of god don't split what your team owns into separate services as well.;0
k8h0uy1;Reddit;2023-11-09 08:04:56;isnt one of the larger reasons for microservices is resiliency and scale? if a component goes down in monolith it can take down the entire application. but in a microservice it might just break a few features. monoliths can only scale vertically while microservices can scale horizontally and vertically. while you can make more instances in a monolith youll be making it really hard on the database and your practically using microservice techniques. i used to work on a tenanted monolith where we ended spinning a bunch of monolith instances and it was tough. it was one of the largest hr systems in the world and every feature after that ended up a micro service.;0
k8h3wc9;Reddit;2023-11-09 08:42:59;microservices are push to be like assholes every project should have microservices.;0
k8h9fg3;Reddit;2023-11-09 09:56:34;microservices aren't the problem. incompetent people are whenever you end up blaming the multitude of individual contributors then you've failed. you can fix maybe one person. you can hire one better person. you can educate a person. but you can't change people as a whole. if your design rests on working with perfect people with perfect knowledge then your design belongs in the garbage bin. actually burn it with hellfire! it needs to be destroyed before someone actually believes that they need to invest resources in this crap. design should be simple and foolproof. not by splitting the problem into smaller isolated ones that are simple and foolproof while forgetting to look at it all together. but by looking at it all together first. if you do have a simple design that allows incompetent people who don't talk to each other and don't count on unreliable networks lags race conditions failing nodes etc then for sure push it.;0
k8hjs5e;Reddit;2023-11-09 12:12:28;for me micro or macro it's about these values can you develop with as few merge conflicts as possible not stepping on toes all the time what things do you want to deploy independently from others get things to prod quickly without risking the deployment of something that isn't ready how easy is it to onboard devs to the point they know exactly how and where to change code to make something happen. the first two i think lead to more smaller services so that teams can maintain and deploy them independently from others. the last point puts the opposite pressure of keeping code in one easy place. i haven't programmed a monolith since my java days and it was a terrible system back then hours to run tests never knew what you were breaking. but i've also never done pure tiny microservices. i've always ended up with moderately sized services or rather let's say repos with their own deployment pipelines focused on some chunk of domain. curious though if others have different values they care about or how mine resonate with you and how your micro or mono architecture ends up supporting them.;0
k8k3ew0;Reddit;2023-11-09 22:26:41;microservices grug wonder why big brain take hardest problem factoring system correctly and introduce network call too seem very confusing to grug grug;0
k8ley1h;Reddit;2023-11-10 03:44:24;if something is too hard to get right compared to viable alternatives then it's worth questioning promoting it as a general tool. there are many simpler techniques to split apps up that don't need microservices usually by leveraging the wonderful power of rdbms instead of reinvent it badly. i see microservices heavily influenced by the antirdbms craze born around the late 2000's. the article implies it's either onebigexe app or microservices. no! that's false. a smarter article would list and compare all the common ways to split an app. as far as being overcomplicated for need css and web ui's are also like this. they require rocket science to get right when stretchzonegrids and other simpler techniques are nearly as powerful but have 110 the learning curve. that's no exaggeration. something about cssdomwebui's are just plain focked in the ess. we need new web standard that's crudguibizfriendly. agile has a similar property also it's possible to get right but requires lots things to go right both organizationally and educationally. being you can't tell up front if you will be the lucky few shops who can get all the ducks to line up properly it's often wiser to either skip it or selectively borrow bits and pieces to try out.;0
k8eq992;Reddit;2023-11-08 21:53:42;we will always have devs of varying degrees of competency. microservices require more competence than monoliths and therefor result in more problems since it's largely the same people working on either system.;0
k8izka7;Reddit;2023-11-09 18:29:35;lol this is probably even more true than microservice;0
k8h92zj;Reddit;2023-11-09 09:51:54;in the olden days there was serviceoriented architecturehttpsen.wikipedia.orgwikiserviceorientedarchitecture soa. but in the minds of people that was associated with esb soap etc. decidedly uncool technologies i still miss the wsdls we still haven't reached that level with restopenapi so to be cool again and sell some training you needed a new term. but the microservice pattern as the name suggests prescribes a more granular approach to services than what soa prescribed and what is imho reasonable.;0
k8h9rhv;Reddit;2023-11-09 10:01:13;so that you can oneup someone by proposing nanoservices. and of course i have a wonderful medium articlehttpsmedium.comido.vapnerunlockingthepowerofnanoservicesanewerainmicroservicesarchitecture22647ea36f22 to reference that i obviously didn't read.;0
k8hwiyg;Reddit;2023-11-09 14:14:10;we use services in a rails monolith that does not have any separate microservices. services dont have to be detached and encapsulated i think that is the difference.;0
k8hm3kd;Reddit;2023-11-09 12:38:37;can we just get rid of the word microservices and just call them services but that's a different thing. the word micro prescribes that they want them to be small. i'm not a fan of micro services either but if the proponents see smaller as universally better the name won't change. we don't have microclasses or microfunctions sure we do we just don't call them micro. the main point of the book clean code was to break out everything into smaller functions. there is no reason to be prescriptive about how to apply it. just freaking let engineers decide what granularity they want their services. that only works when you have programmers that know what they are doing. i suspect the micro service movement came about because some engineers were let to decide and they chose enormous monoliths. and as usual some people see a trend and take it way too far because they don't see the negatives of their newfound religion. leading to micro service all the things and then we get code filled will problems caused by micro services instead of code filled with problems caused by monoliths.;0
k8j4soo;Reddit;2023-11-09 19:00:33;i think there are some orgs that really do subscribe hard to the microservices idea and have many hundreds of services involved in every part of the system. my sense is that its a nightmare to work at such a company.;0
k8kr71i;Reddit;2023-11-10 01:00:21;i think there is something to calling them microservices. especially when you work on a distributed monolith you find yourself saying 'why can't we have a service that just does x nothing else and owns the datastore for x?' it's the simplicity that's really key for when microservices work well.;0
k8gaarf;Reddit;2023-11-09 03:59:23;no the main problem with microservices is that people are unwittingly building a distributed system but without a working understanding of consensus.;0
k8eegp9;Reddit;2023-11-08 20:43:26;having simple solid welldocumented components is important in any design oo or functional included. how is this special for microservices?;0
k8g6ge5;Reddit;2023-11-09 03:32:33;i have rarely seen microservices that fit that bill. most of the time people seemingly just end up building yet another monolith just more awkwardly. the best services and possibly microservices i've seen are stuff like databases or other stuff you don't normally think of as such. stuff that's sufficiently general that you won't be moving goalposts every day. they can be bigger or smaller but they need to be designed properly not making stuff up as they go. so yeah i'm more than suspicious of designs that involve hundreds or thousands of microservices for one application. sure you can pretend to hire teams and sandbox them but they'll be spending something like 80 of the time on interfacing scaffolding waiting for dependencies and other nonsense instead of working on actual problems. not to mention that you literally never gain any of the purported benefits of microservices such as gradual rollouts or avoiding downtime if you have complex dependencies. is it worth it from a business perspective?;0
k8egsmk;Reddit;2023-11-08 20:57:33;i agree. in fact i actually mentioned in the essay that it's why i personally prefer services. however even in this case it's easy to fuck up with the lack of governance ultimately i don't mind either. i just want my scope to be neat. and unfortunately neither architecture guarantees it monoliths encourage shared ownership but microservices are just too easy to get wrong;0
k8hewub;Reddit;2023-11-09 11:11:19;yep. people are the focus it was like a response to the recent trend of criticism towards soa when actually people who use it are at fault mainly. the awesome death by a thousand microservices was the sorta final triggersource of inspiration.;0
k8lg41c;Reddit;2023-11-10 03:52:42;dunno about anti rdbms but definitely agree with everything else. i don't think services failed tho contrary to the popular belief. i just think the migration to microservices failed. most companies started doing it for no reason willingly going back to the minefield. if i already have a monolith i don't see any reason to migrate can introduce services on top of it but definitely no point in migrating for the sake of it.;0
k8f3gcw;Reddit;2023-11-08 23:11:40;the nice thing about microservices is the team can wall assholes off in another room and only deal with them through api calls.;0
k8ha14q;Reddit;2023-11-09 10:04:57;probably the other way around. microservices limit the blast radius of 1 bad dev and reduce the frequency of butterfly effect bugs.;0
k8haz6i;Reddit;2023-11-09 10:17:49;microservices require more competence than monoliths i really hope that your monolith can have proper vertical concerns isolation with clear air tight interfaces because the incompetent side effect is to actively entangle with wrong assomption anything that is within reach of every line of code.;0
k8fei0x;Reddit;2023-11-09 00:22:27;i politely disagree some people try to implement microservices without having a scaling problem. they only have an ego problem. unfortunately monoliths don't work for such issues...;0
k8fanwn;Reddit;2023-11-08 23:57:01;in fairness i chose a microservices architecture for one of my startups not just for scaling concerns but for no real idea what the finish line looks like concerns. in that respect it worked exceptionally well as we were able to plan and implement bitesized pieces with essentially zero risk of negatively impacting the whole or even other services that were stable. and sure enough we ended up with some services that just chugged along and worked others that were deploying multiple times per day and many that went through the mad dash to stable and boring transition along the way. from an agility and flexibility perspective it was awesome. it definitely was more work and planning up front but besides a few missteps that was all relatively smooth. much of my motivation to bite the bullet with microservices came from being involved in the catastrophic final throes of a 1m loc monolith as a younger dev. yes wellarchitected monoliths can be just as maybe even more! flexible than a soa but i think soa makes it easier to keep that separation clear all the time. except for the front end that is still dumb.;0
k8fw1da;Reddit;2023-11-09 02:21:57;sure you might also use external services from from aws as well and have small background workers running in parallel i.e. microservices. the point for me is more about whether you are fighting to keep things modular and in the monolith and only making it an external service as last resort or if you are fighting to making everything a separate service and integrating it as a last resort.;0
k8erh7i;Reddit;2023-11-08 22:00:44;fair. what is a microservice precisely? it's just like any other service except people tend to expect them to be a bit smaller and more simple. the point i'm trying to make is that it's easier to have something that you can ignore if that service is smaller and simpler. the less it's doing the more confidence you have that it's probably doing those things correctly and reliably.;0
k8lhr1g;Reddit;2023-11-10 04:04:22;code libraries can be locked from other teams changing them. and one can use the database to share services via request queues. the devil's in the details how about we pick a specific typical bizcrudadministrative scenario to explore with pseudocode etc. we can compare it under 1. monolith 2. microservice 3. shared service via rdbms using a queue table consumed by an app or a stored procedure if smaller..;0
k8ffabz;Reddit;2023-11-09 00:27:47;lack of governance ..my second favourite sin in the world of implementing microservices without having a clear business case.... you are so right with this!;0
k8ifwww;Reddit;2023-11-09 16:29:50;hmm i can see why i'd go with microservices with large traffic from an enterprise perspective. i've only worked on highly trafficked apps but i see ofc why if you run a smaller saas a monolith should be fine. erlang is a language? sounds like vertical scaling in that case still unless i am missing something?;0
k8fuawu;Reddit;2023-11-09 02:10:16;the nice thing about microservices is the team can wall assholes off in another room and only deal with them through api calls. this is a good example as to why microservices are hell because of communicationworkplace incompetence that adversely affects microservices. httpsen.wikipedia.orgwikiconway27slaw you need a unified approach or it's just a distributed monolith that no one can reason about. all the cross cutting concerns still apply regardless. monitoring tracing debugability mockability tooling global log aggregation documentation....etc;0
k8fiyb7;Reddit;2023-11-09 00:52:50;and trouble shoot issues that can be isolated to specific services hard disagree. microservices are awful to debug because it can be nearly impossible to simulate interactions with all of the other microservices in the chain and even harder to do so with production like data in a non production environment.;0
k8h8hn2;Reddit;2023-11-09 09:43:46;the issue is that problems often can't be isolated to a single service. a single business transaction can involve many microservices and the problem very often happens in the communication between them their composition responsibilities.;0
k8ffkm0;Reddit;2023-11-09 00:29:45;shopify use a modular monolith which is distinct from monolith and distributed monolith yuck. the principles that shopify applied to their approach also broadly apply to microservices as well though. strict boundaries between components implicitly this means well defined interfaces. lots of tests. clear service ownership and domain driven application structure from business stakeholders. the latter is very important and yet not particularly technical. if we're talking about competence then having shopify's budget and staffing levels go a long way to solving that. it also requires buyin from the nontechnical parts of the business to collaborate meaning they have to be competent enough to recognise the value of such work. which really is the takeaway from this essay. dumbasses make work hard.;0
k8fgl75;Reddit;2023-11-09 00:36:47;shopify does not screen their customers and as a consequence the platform is a haven for scam stores. what does tis have to do with monolithic or microservice architecture? not a damn thing.;0
k8ixxyx;Reddit;2023-11-09 18:20:00;microservices almost always use http;0
k8gki78;Reddit;2023-11-09 05:18:08;it's weird because really the difference between microservicrs and monoliths is just their execution model and the flow on implications such as how they communicate. sure microservices enforce boundaries in code structure because they're physically separated from other microservices but you can absolutely get that inside a monolith. additionally if you share a lot of common libraries and interfaces between your microservices you can unintentionally couple them just because you have a separate project for each microservices it doesn't guarantee you'll avoid all the pitfalls of a monolithic system either.;0
k8epv75;Reddit;2023-11-08 21:51:23;but you said you prefer microservices over regular services for reasons of reliability. in what way is well tested and documented code more reliable when wrapped in a microservice?;0
k8llhyo;Reddit;2023-11-10 04:31:48;what is a microservice precisely? randomly turning 15 of all app classes into json web services. i agree this is probably not correct but i've seen no clear definition that fails it. it's a thought experiment that is also a monkey wrench into the definitions.;0
k8gcg2w;Reddit;2023-11-09 04:14:59;sounds like a service boundary problem. given a specific api call a microservice should be atomic to itself. if a bug arises it's either in the individual microservice or the call to that service is incorrectly done. determining that is usually easy. if you have bugs that are only reproducible by firing separate services in a specific sequence that's a symptom of poorly defined services dipping their toes in each other's data in inappropriate ways. i work at a company with around a hundred services and we don't have this type of problem you describe at all.;0
k8fz5v3;Reddit;2023-11-09 02:42:55;trashing tracking data and giving facebook problems sounds okay to me! seriously would microservices have made the issue impossible?;0
k8gzsp1;Reddit;2023-11-09 07:52:08;i think this is mostly true but has important ramifications. if you have those boundaries in a monolith they are so much easier to change since you just have to change the monolith and deploy. if you separate those boundaries at the physical level as in microservices it becomes harder to iteratively change without downtime since you must keep everything backwards compatible which usually requires an expansion and contraction of api surface. that's also ok in theory but in practice due to business forces usually beyond your control the contraction phase never happens. also the separation pretty much forces you to deal with a distributed system with failing calls latency which is much harder. in return for dealing with the pain and increased cognitive andor communicative load this puts on your developers you get separated independently released and independently scalable systems with hopefully limited blast radius. sometimes it works out but not sure i've seen that so far.;0
k8gj450;Reddit;2023-11-09 05:06:22;lol.. thats not just passive aggressive its exactly why microservices fail. you need communication and alignment to succeed. i'm sure the other team was thrilled with this behavior and even learned to respect you more for teaching them that lesson!;0
k8gtx54;Reddit;2023-11-09 06:46:44;given a specific api call a microservice should be atomic to itself. should it? let's imagine you're using micro services for retail. you have a customer doing a return. i'm guessing you'll want some kind of service to look up the original invoice to get a list of returnable items items on the original invoice and for each item you'd want to know the price the items were sold for the discounts applied the taxes paid etc. you can imagine building a service that gets back a list of item ids for an invoice and then for each item asking a service for item details name price at sale time taxes in location discounts or maybe each of those is its own micro service. you can also imagine getting back an invoice that already contains the invoice details bc your microservice to get an invoice called other services to do its job. i think the second approach is better since it means clients don't have to keep reimplementing logic to call a bunch of separate services to accomplish some task. it sounds like you'd disagree since this creates a nonatomic service or a service with dependencies on other services. am i understanding you correctly?;0
k8g8tg6;Reddit;2023-11-09 03:48:56;seriously would microservices have made the issue impossible? yes actually. it would have not coupled the liquid page caching mechanism to the url redirection mechanism. that was the cause of the bug that crushed the service. they did decouple them in a later release after the first patch knock the service out lol. it more or less blew out the caching and yea the whole thing went belly up from my understanding from them.;0
k8et1hd;Reddit;2023-11-08 22:09:57;ultimately it doesn't matter what i prefer. my point was that architecture really doesn't matter if your people are incompetent i think incompetent people will cause problems either way but the problems will be worse in the more complex system which i think it microservices. to use an analogy a novice skier is going to have a bad time on a black diamond run or a double black diamond run so you could say it doesn't matter they're going to have a bad time either way. but i think the choice of double black diamond is much worse for the novice skier.;0
k8e4x0p;Reddit;2023-11-08 19:46:06;i wish people learned to write simple scripts and applied that knowledge for more serious stuff like microservices haha;0
k8h89rk;Reddit;2023-11-09 09:40:44;the trouble with microservices is that each product use case workflow is split among many microservices. often you can't trace one bug to a specific microservice but to interactions between several of them or to the larger architecture. it's often claimed that microservices better encapsulate complexity which is imho misleading they mostly pull the complexity outside of the microservices themselves into the interactions between them which is imho more complex than dealing with such interactions inside a monolith.;0
k8h9buz;Reddit;2023-11-09 09:55:13;you may not be able to ensure that the thing works without essentially taking on the other team's entire workload in addition. if your attitude to your teammates really is just do extra work to make up for someone else's failures you now have two teams fucking up. if your team doesn't implode immediately because everyone leaves because you suck to work with they'll end up being just as much an drag as the team that was a problem to begin with. microservices are an organisational solution to an organisational and therefore political problem.;0
k8hbiv4;Reddit;2023-11-09 10:25:11;yep. i'm a big advocate for microservices but i've experienced a number of cases where i've had to painstakingly track a bug back through several undocumented and poorly logged nodes often with unhelpfully obfusicated names which would be significantly easier with a monolithic implementation. i feel that microservices put a much higher demand on good documentation being present not that that's a bad thing.;0
k8iekvs;Reddit;2023-11-09 16:21:24;if you're part of design discussions where this matters how i started my comment you should be 1. able to provide designs that will work 2. if it's truly a problem able to talk to your management including skipping levels about the underperformance i think x team may need some additional help.... microservices aren't going to fix your problem. the system still won't work. they'll just add extra ways for it to fail and require more work to run.;0
k8mv5fz;Reddit;2023-11-10 12:55:08;right not for production but imo at least there should be a way for us to run the whole application all the microservices locally on the one machine. this wasnt google or something. we had under a dozen total microservices.;0
