ID;Source;Creation Date;Content;Sentiment
34230641;HackerNews;2023-01-03;Title:Modules, not microservices, Content: http://blogs.newardassociates.com/blog/2023/you-want-modules-not-microservices.html;0

34284642;HackerNews;2023-01-07;i would never claim that our setup uses microservices. probably just more plainly named services.and yes that is correct we agree that once we expose a view we won't remove columns or change types of columns. theoretically we could effectively deprecate a column by having it just return an empty value. our use cases are such that changes to such views happen at an acceptable rate and backwards incompatible changes also happen at an acceptable rate.our views are also often joins across multiple tables or computed values so even if it's often quite close to the underlying tables they are intentionally to be used as an abstraction on top of them. the views are designed first from the perspective of what form of data do others services need?;0
34279551;HackerNews;2023-01-06;this only works if you apply backward compatible changes all the time. sometimes you do want to make incompatible changes in your implementation. database tables are an implementation detail not an api which you're trying to expose as a view etc.but hey every team and company has to find their strategy to do things. if this works for you that's great!it's just not a microservice by definition.;0
34279318;HackerNews;2023-01-06;i apologies for the delay in a reply.inot at all. i'm in no rush.i secondly what i think actually happens is that most companies using microservices aren't this disciplined and just end up bodging or implicitly coupling services.iif an organization is sufficiently large you may have no way to get another team on the line to even try. at that scale the other teams may as well work for other companies and that is what microservices models. if your organization is small i tend to agree that you won't succeed. you can't beat conway's law.i i find little value in providing that specification through the tdd approach or associated ceremony.ibut ultimately what's the difference between writing your spec in an executable way or writing it in a word document beyond the superficial differences in the languages? what is communicated to other developers ends up being the same.i i prefer as few tests as possible at as high a level as possible with as few mocks as possible. i'll take a single test that takes 15 seconds to run over 1000 tests running in milliseconds.iseemingly not all that common interestingly but go comes to mind as a language that provides constructs to define separation between specification tdd and developer tests. conceivably you could exclude your tdd specs from execution only running the tests that help in your development process.the value of tdd isn't in the execution but in what is communicated to other developers. that the specs are executable is merely a nice side benefit to help with confirming that the implementation conforms to the spec. you still get 90 of the benefit of tdd even if you never run the executable albeit granted at that point it iisi just a fancy word document.i i think there's a lot of healthy debate to be had about how much testing is needed. iperhaps but tdd isn't about testing. tdd is about providing documentation. i think there is less room for debate there. i'm not sure anyone who has ever inherited a codebase has wished it gave less insight into what the 'business needs' of the program are. again a word document can provide the same documentation but if you're going to write that word document anyway why not go the extra mile and gain the additional benefits that come with execution?;0
34271446;HackerNews;2023-01-06;i really miss the old days where when an app was down it was obvious... now apps just go unresponsive because of connectivity issues between services... we used to have frameworks that could communicate errors in one log it was a beautiful thing. as cloud infrastructure became more powerful to better host so called monolithic systems it was all scrapped to move to microservices which were made for less powerful infrastructure. everything was refactored to the point where it's expensive to go back... pretty crazy how much money the industry wastes on refactoring...on top of that the tendency to get complacent with unstructured data in a lot of systems is really creating a very complicated lockin when systems are developed for unique services on each cloud provider... bowls of spaghetti.hire solutions architects for dev projects make your apps future proof... i warn you. too much microservice customization leads to vendor lock in and expensive operational costs... this is why a lot of apps get sunsetted early.;0
34270797;HackerNews;2023-01-06;unfortunately people keep forgetting that microservice also requires organizational change. otherwise it's just a heavy overhead.;0
34267860;HackerNews;2023-01-05;the argument is simply the empirical observation that the vast majority of microservices deployments don't operate anywhere near the scale that actually requires microservices and is not going to operate at that scale in the foreseeable future. when scalability is the primary argument in favor of microservices how is that absurd?;0
34266531;HackerNews;2023-01-05;the ability to load balance across nodes is not as you claimed a particular advantage of microservices.are you replying to the right comment? i made no such claim.;0
34266165;HackerNews;2023-01-05;i'm comparing specifically against a monolith where you have an uber executable doing literally everything.i doubt that anyone here is advocating for a system that it literally everything in one os process. i bet even you would say that a process with a rdmbs connection is a monolith even though it doesn't fit your definition.as for modules they can run as a separate process on the same machine to isolate security critical elements.conversely i doubt that any reasonable microservices architecture has every instance of a microservice in its own subnet with a firewall and strict network access permissions... including one off generated api keys.most at best use a static api key per microsoervice inside one large secure network... which leads me back to my point they're not exactly easier to secure. methods may differ a little bit but the techniques are the same.then your example of a buffer overflow is going to be as bad for microservices as for monolith.unless you're going to invest in a variety of systems programming languages and oses in your stack your one buffer overflow turns into buffer overflow on every other microservice... making your claim of easier to isolate a little bit delusional. classic example of log4j bug where monolith or microservices once you're breached game over;0
34258675;HackerNews;2023-01-05;his point was that the comment was unclear if you'd also read it hastily i imagine his logic was something like how can ooms happen less often if you run more processes possibly on the same machine? while your comment actually wants to say if a specific service is affected by an oom with microservices only that specific microservice goes down since it's probably running on its own hardware.;0
34256170;HackerNews;2023-01-05;right i'm not advocating for one over the other i was just explaining issues solved by microservices. now instead of the oom killer taking your service down you have a flaky nic on another microservice box and now you need to figure out how to gracefully degrade.i love working with microservices at the scale of work but we're big tech. i can't imagine why a 5 person startup would want k8s and microservices. you don't need that scale until you have more than 2 teams and you're pushing at the very least 15 engineers at that point and usually the sales and marketing staff to make that investment worth it.;0
34254600;HackerNews;2023-01-05;i started at amazon in 2001 when we had around 400 servers running the website it was large but it was around the scale that most fortune 500 companies operate at.i'll agree that a team of developers with 20 microservices sounds obviously wrong which is really my point that the site should be divided around data and the orgs should probably reflect the needs of the datanot the other way around. and amazon back then didn't have that problem.;0
34252742;HackerNews;2023-01-04;i was part of a project that did exactly this same monolithic code base with config flags that transformed it into web server worker or scheduler. it allows scaling all parts separately but i can confirm it's easy to introduce bugs if you're not careful. since you're sharing the same db migrations also need to be backwardscompatible.a cool sideeffect is that you can usually run the whole thing in one app for development by just enabling all profiles as opposed to some microservice architectures where you need dozens of containers and dbs for replicating interservice bugs.;0
34250197;HackerNews;2023-01-04;no because that's not the service api. that's just a view over a table an internal data structure used to represent some business domain model which should be properly exposed through some implementationagnostic api. service b should not care how service a implements it.and the fact you must keep backward compatibility see the op answer above at the implementation level shows how fragile this approach is you will never be able to change a database schema ias you wishi just because you have consumers that rely on the internal details of your implementation a table. if you want to change a field from char to int you can't. how is it important for service b to know that level of detail? an api could still expose a domain model as char if you want to and maybe introducing new fields new methods whatever way. or maybe nothing at all maybe it's not necessary because the database field is never exposed but only used internally !!.on the other hand if you expose a database agnostic api e.g. http rpc ... whatever you can even swap the underlying database and nobody will notice.a good rule of thumb is if i change the implementation do i need to asktell another team? if the answer is yes that is not a microservice.;0
34250116;HackerNews;2023-01-04;i was arguing the opposite coordinated deployments already presumes more maturity than i was considering. i've only been at one company with sameday deployments. all the other places have been freeforalls where each group determines their own release schedule with their own pipelines. managing deployments between dependent services thus requires significant coordination overhead or none because you are stuck with what you get until the other teams deliver your needs on their own timeline.in chaotic environments like that microservices help with defining clear ownership of operational responsibility though at the cost of clear responsibility for the overall distributed system. this comes at the cost of making it hard to develop let alone ship changes that impact multiple microservices outside the scope of a single team or closely related sibling teams.the main point i was making was that with a more monolithic system managing that kind to organization disfunction necessitates topdown waterfall like control. so moving to microservices enables noncoordinated agility removing one layer of coordination problem a the cost of other problems.;0
34249775;HackerNews;2023-01-04;i do think using something like flatbuffers or capnproto where the serde is removed aside from the travel over the network could be a huge win. another thing i have always wanted to try is to develop a system using microservices with a rpc layer that uses immutable objects so you can later combine the services and convert rpcs to function calls.;0
34249558;HackerNews;2023-01-04;separate process vaults hsms and other techniques of offloading security credentialshow do give one module access to the vaulthsm without also giving any other code in the same process access? even in the event of a security compromise. and that still doesn't address the problem of a vulnerability anywhere in the monolith potentially exposing any sensitive data in processes memory such as user data including password. the implication that anything other than a microservice architecture must be exclusively an uber executable doing literally everything is naive.ok replace microservices with service oriented architecture. i'm comparing specifically against a monolith where you have an uber executable doing literally everything.;0
34248958;HackerNews;2023-01-04;yeah... the issue lies in cases where the decomposition is so extreme that you end up not able to deploy independently.and any benefit of a microservice owning it's own rdb is still that schema changes aren't easily reversible. specially when new non predefined data has been flowing in.stateless microservices are great in the sense that you don't have to build multiple versions of apis... but stateful microservices are just a pita.;0
34248862;HackerNews;2023-01-04;apologies for the delay in a reply. i think this has been a constructive discussion certainly for how i think about things. interfaces don't change under microservices. communication by contract enshrines a contract. you must ensure that your api does not break legacy users no matter what changes you want to make going forward. you have committed to behaviour forevermore once you submit the contract to other teams.i think this entails a couple of things.firstly it's a tradeoff. if we discover some incorrect assumption is baked in to both sides of an interface we're kind of stuck and have a hard time with the migration path going forward. this isn't unsolvable and paths exist to correct it but they're substantially harder than just updating both parts in the same commit. it moves coordination overhead as a tradeoff.secondly what i think actually happens is that most companies using microservices aren't this disciplined and just end up bodging or implicitly coupling services. probably the pattern i'm talking about is distributed monolith. not the good kind where you just scale out your monolith but where you drink the microservices koolaid and create microservices by adding network boundaries at random. this is the realworld application of microservices i have seen where i've seen it. i don't doubt some people can use it correctly with proper rigour. but my theory is the pattern took hold because using distributed monolith appears to help helps tame the complexity of a dynamic monolith. i find it incredibly hard to believe the niche pattern of microservices done correctly would have become so popularized otherwise. you find little value in writing a specification for your work or you find little value in automatic validation that the program works according to your spec?i find little value in providing that specification through the tdd approach or associated ceremony. i prefer as few tests as possible at as high a level as possible with as few mocks as possible. i'll take a single test that takes 15 seconds to run over 1000 tests running in milliseconds.again for me this is a question of what popularized this pattern?.i think there's a lot of healthy debate to be had about how much testing is needed. i think tdd appeared to provide the kind of guarantees that are really helpful in a dynamic language and gained a lot of advocates that way. when i had to write some type hint free python i naturally defaulted to writing tdd since keeping a large system in your head and error free is basically impossible without an exhaustive suite of tests. it's an approach that works very well in one context that applied to other contexts unquestioningly delivers a lot of pain.maybe you're lucky to have only worked with very deliberate and rigorous engineers in your career. outside the top tier we're working with architecture astronauts and people who jump on whatever hype cycle happens to be passing which explains my anger with these concepts.;0
34248600;HackerNews;2023-01-04;giving me an example that is created to work explicitly at systemcontainer level isn't the gotcha you think it is.iam profiles have their own limitationsseparate process vaults hsms and other techniques of offloading security credentials are the same for microservice architecture as monolith.the implication that anything other than a microservice architecture must be exclusively an uber executable doing literally everything is naive.;0
34248267;HackerNews;2023-01-04;hey we have a system like that at my company. microservices are self contained and responsible for exposing their interface via sdks created with a trpc like library. jump to definition works across the entire monorepo like a charm. could you take a look and give me any feedback?;0
34248216;HackerNews;2023-01-04;every organisation i've worked at that had microservices has had all of them released every other thursday at the same time by the same pipeline because they are tied to the organisation scrum schedule. also most changes are part of epics that span multiple microservices. if you are gonna argue that properly done microservices don't have that problem you are free to practice your perfect microservices alongside perfect scrum oop and communism.;0
34247639;HackerNews;2023-01-04;boring tech club ftwas a cto i couldn't agree more. for our internal product we use 100 boring technologies. the most modern you'll find is a react spa.i sigh when clients want to go the microservices route for a team of just a few developers. when you want to use nextjs for their tablesampforms app. when they choose to use kubernates instead of a couple ec2 instances.don't get me wrong these technologies are great for us because we can charge more for the wasted human time developing these overengineered solutions. but i always for my peace of mind try to talk them out of them. sometimes works sometimes doesn't at the end of the day it's their money.;0
34247592;HackerNews;2023-01-04;a monolith can also scale vertically with mechanisms to redeploy on fatal errors. if all starts failing you may have a problem. but you can get the same problems with a microservices that is in the critical pathnetworks could have unexpected delays routing errors and other glitches. at least with a monolith you can often find a stacktrace for debugging. i have seen startups that have limited traceability and logging when using micro services.when a small startup has to manage scalable k8s infrastructure in the cloud distributed tracing and monitoring is often not prioritized when you are a team of 5 developers trying to find a product market fit.i am not against microservices i work with them daily but you just trade one type of stability problem with another;0
34246539;HackerNews;2023-01-04;sorry you misunderstood.when you book a cruise your expectation is to get everything including hotel stays before or after the cruise along with flights to and from it as a single package provided by the cruise vendor or a travel agency. so the reservation system must take care of all of that.when i said 45 different websites i was trying to explain the point that a 60 yo highincome guy is usually not interested in getting the cruise itself on carnival.com then go look for excursions on carribeansexcursion.net and to book flights on lufthansa.de or airfrance.fr.it was a remark on the way the cruise business works and why it is so not about architecture.but once again i really believe that we are way off topic... personally i do not really feel like creating a ask hn are microservices a good choice for the cruise industry? but if someone feels like submitting one i will try to contribute.;0
34245487;HackerNews;2023-01-04;not necessarily. but if the solution in this case is to start breaking up the monolith into smaller services owned by specific product teams then you are moving towards microservices.;0
34245126;HackerNews;2023-01-04;couple of calls is normal. but if you make everything a microservice. and there are dependencies between them then by design its destined that some hotter loop eventually will contain rpc.;0
34244974;HackerNews;2023-01-04;rewriting a module from one tech stack to another is not much harder when that module was a part of a monolith and not a separate service except that you haven't paid the upfront cost of bootstrapping a new service putting in rpc calls etc. and in any case starting a project as microservices is already a bad practice due to a number of reasons the most important for me is that it's hard to change module boundaries which you will most likely get wrong in a new project.;0
34244775;HackerNews;2023-01-04;if you have many app servers and they all run copies of the same app you can roll out new versions to a few servers at a time. you just have to handle the db update first but you need to do that with microservices anyway they might use smaller databases and therefore making it somewhat easier.;0
34244741;HackerNews;2023-01-04;i think amazon and google and other faang entities work at another scale than 99.9 of the rest of the world. the problems they face are different including the impact of data locality.i've seen many systems where there are a few hundred to a few thousand users not hundred of millions or billions of users. there can also be teams of 510 developers who manages 20 microservices. i still don't think those projects have the same needs and could have done something else.;0
34244732;HackerNews;2023-01-04;there are so many misconceptions about what microservices are or what problems they are trying to solve. most people don't even experience the problems yet or ever they are meant to solve and they go straight to micro. 5 person teams making 5 services to power their product faceplam. a relatively simple b2b web application without any serious traffic also does not need microservices to handle its load.people just read up on whatever seems to be the newest coolest thing. the issue is that ms articles are usually coming from faangexfanng. these companies are solving problems that 99 of others do not.as engineers we should be looking for the most effective solutions to a given business problem. sadly i see engineers with seniorstaff titles just throwing cool tech termslibs around. boring tech club ftw;0
34244505;HackerNews;2023-01-04;so all your microservices implement sagas or other synchronisation patterns that ensure 100 data consistency?;0
34244230;HackerNews;2023-01-04;i'm not making a case in favor of starting with microservices for your startup that'd be insane to say the least. i'm just disagreeing with scalability is a feature. a feature is every addition on top of your minimum viable product. if at some point it becomes apparent that the business needs scalability then scalability becomes your minimum viable product.;0
34243670;HackerNews;2023-01-04;you can horizontally scale a monolith without going full microservices.;0
34243643;HackerNews;2023-01-04;id love for a language framework that allows for an application to be composed of modules that can either be run in a single process or deployed as multiple independently scalable processes with a mostly transparent rpc system requiring minimal boilerplate.my ide should be able to easily traverse the call graph. my development environment should be simple to setup.ive worked on microservices that required an insane amount of boilerplate to do simple things. like 7 layers of controllers clients services data services etc just to fetch a simple piece of data. and the developer experience of running dozens of services in a kubernetes cluster running on my dev machine was awful.does anything like this exist?i only dabbled many years ago but erlangotp comes to mind.and trpc for typescript calls in browser and server.;0
34243505;HackerNews;2023-01-04;i don't completely agree here.yes if you can't scale fast enough as you need to it can hurt your business. not being able to keep up with demand is a luxury problem that every business faces not just in tech. they would often be called 'growing pains' in a business and though they are bad they rarely contribute to the failure of a company.starting a startupserviceplatform with microservices before you even understand the bottlenecksmarket fitcustomers is usually not a good idea. you can come a very very long way with a monolith before you hit performance and scalability limits. and once you do you can always start breaking things up into smaller services for scalabity. obviously you need to make sure you are scaling on time to keep up with demand.'nail it then scale it' and 'premature optimization is the mother of all fups' are popular sayings for a reason.;0
34243492;HackerNews;2023-01-04;a benefit of microservices is that you can use specialised languages for different parts of the system. the core of your system might be written in java but you might one to use python for an ml heavy module. nonetheless i tend to agree that in an organisation with 100 microservices probably the ideal way would be to have 4 or 5 based on exceptions where you have modules that need a specific hardware profile e.g. a lot of ram or a different programming language than your core system. everything else could go into modules in a megaservice.;0
34243084;HackerNews;2023-01-04;servers can only get so big. if your monolith needs more resources than a single server can provide then you can chop it up into microservices and each microservice can get its own beefy server. then you can put a load balancer in front of a microservice and run it on n beefy servers.i've almost never seen situations where a single request would need more resources available than the entire server has outside of large gpt models for text though maybe that's because i couldn't afford beefy machines for that myself.instead if your monolith needs x resources to run overhead and y resources to serve your current load then in case of increased load you can just setup another instance of your monolith in parallel with another set of x y resources same configuration and it will generally ialmosti double your capacity.now there can be some issues with this such as needing to ensure either stateless apis or sticky sessions but both are generally regarded as solved problems with a little bit of work. monoliths themselves shouldn't be limited to running just a single instance and aren't that different from a scalability perspective than microservices.where microservices excel however is that you can observe individual services e.g. systemd services or them running in containers better and see when a particular service is misbehaving or scale them separately as well as decrease that x overhead since each service has a smaller codebase when you have lots of instances running. this does come at the expense of increased operational complexity and possibly noisy network chatter especially if you've drawn your service boundaries wrong.however at the same time i've seen actual monoliths that can never have more than one instance running due to problematic architecture so therefore i propose the following wording that i've heard elsewhere of course there can be more nuance to it like modular monoliths that still have one codebase but can have certain groups of functionality enabled or disabled. i actually wrote about that approach a while back calling them moduliths i don't actually expect anyone to use these particular terms but i dislike when someone claims that monoliths have the issues of these singleton applications when in fact that's just because they've primarily worked with bad architectures. sometimes they wouldn't need to shoot themselves in the foot with microservices if they could just extract their session data into redis and their task queues into rabbitmq. other times microservices actually make sense.;0
34242884;HackerNews;2023-01-04;i was initially quite enthusiastic about microservices as i saw unix philosophy ingrained in it. especially that each service would be lightweight and small. instead what i see is each service tending towards more complexity and code mass because people started adding more ideas to them like ddd. so on top of the network and authentication code that now need to be added to each service people started defining classes for each domain object adding validation code and unit tests for them layering each service like application infrastructure domain etc. now we are building systems that are more complex both as individual services and aggregates. much of that complexity does not serve any functional purpose and its utility is difficult to measure in other respects.i'm glad that this post was written so that we can look at widely accepted ideas a little more critically.;0
34242517;HackerNews;2023-01-04;you have fifty or 10000 servers running your critical microservice in multiple azs. you start a deployment to a single host. the shit hits the fan. you rollback that one host. if it looks fine you leave it running for a few hours while various canaries and integration tests all hit it. if no red flags occur you deploy another two etc. you deploy to different azs on different days. you can fail over to your critical service in different azs because you previously ensured that the azs are scaled so that they can handle that influx of traffic didn't you?. you've tested that.and that is iif it makes it to productioni. here is your fleet of test hosts using production data and being verified against the output of production servers.;0
34242502;HackerNews;2023-01-04;microservices are one of the many abstractadaptervistorfactories of this generation of programmers.just because you can doesn't mean you should.;0
34242443;HackerNews;2023-01-04;as for slow startup a server reboot can be quite excruciating when all these processes are competing to grind amp slog through their own copy of that 200 mb and get situated.you are writing microservices and then running them on the same server??;0
34242416;HackerNews;2023-01-04;modules vs microservices january 2023 editioni've done monoliths and microservices. i've worked in startups smes and at faangs. as usual nothing in this article demonstrates that the person has significant experience of running either in production. they may have experience of ifailurei.in my experience microservices are simply one possible scaling model for modules. another way to scale a monolith is to just make the server bigger the one giant server model.if you have a fairly well defined product that needs a small lt30 number of engineers then the one giant server model might be best for you. if you have a wide feature set that requires 50 engineers then microservices is probably the way to go.there is no noticeable transition from a well implemented monolith with a small team into a well implemented giant server with a small team. possibly some engineers are worrying about cold start times for 1tb of ram but that's something that can happen well ahead of time and hardware qualification is something one needs to do for microservices too. some of the best examples of giant servers are developed by small teams of very well paid developers.the transition from a monolith to a set of microservices however is a very different affair. unfortunately the kind of projects that need to go microservices are often in a very poor state. many such adventures one reads about are having to go to microservices because they've already gone to one giant server and those are now unable to handle the load. usually these stories are accompanied by a history of blog posts about moving fast and breaking things yolo or whatever is cool. the transition to microservices is difficult because there are no meaningful modules no modules or modules that all use each other's classes and functions.i don't believe that once a particular scale is reached microservices are a choice. they are either required or they are not. either you can scale successfully with one giant server or you can't.the problem is that below a certain scale microservices are a drag. and without microservices it's very easy for inexperienced teams to fail to keep module discipline.;0
34242144;HackerNews;2023-01-04;we are now attempting to solve this with caches and doing batch requests but all of this created additional overhead that could have all been avoided by not using microservices. especially since some of these services are not even in the same data center.i think you need to answer why? if you can't put all of the services in one data center then by definition you can't write a monolith either. if the monolith would happily run in one datacenter then you should have all instances of your microservices in that one datacenter.it surprised me that you would conclude that this is a problem with microservices. it's like if a particularly architect always punches you in the groin in every meeting and you've concluded that architects are bad people rather than this one architect is a bad person.;0
34242108;HackerNews;2023-01-04;that makes sense. i am still trying to understand why does it differ between a monolith and microservices. the app in the monolith can make the call to noncritical functionalities timelimited and faulttolerant just like a network call has a timeout and can return nothing in a simplified manner it can wrap that call with a timer and an exception handler.i agree that microservices are suitable for large organization where the organization practically has multiple products which could be purchased from a vendor or sold to another company.;0
34242106;HackerNews;2023-01-04;each set of upstream hosts in nginx is a single instance of load balancing. you aren't load balancing across services you're splitting traffic by service and then load balancing across instances of that service.the split is inessential. you can just as easily have homogeneous backends amp one big load balancing pool. instances within that pool can even have affinity for or ownership of particular records! the ability to load balance across nodes is not as you claimed a particular advantage of microservices.;0
34242049;HackerNews;2023-01-04;i don't see the affinity between microservices and locality. any kind of distributed storage including cache is going to include a choice about how data are partitioned ordered and indexed. if you want certain records to be in memory on the same nodes you should not need a separate cache cluster to accomplish that let alone a separate cache service implementation.;0
34242018;HackerNews;2023-01-04;meta deploys as microservices with multiple monorepos...binaries are deployed and scaled independently as thrift services.tons of rpc.;0
34241952;HackerNews;2023-01-04;scalability being able to increase the amount of compute memory and io to the specific modules that need it.i would like someone to spell this out. it seems to me people are claiming that if a single binary serves some cpubound requests and some memorybound requests and you give it more memory then the memory gets wasted on the cpubound part. or if you give it more cpu the cpu gets wasted on the memorybound part. but this kind of assignment of resources to code paths seems to be a iconsequencei of microservices. in a single computer single binary situation resources should not get used up unless the workload actually wants to use them. a computeheavy thread doesn't cost heap. a big heap doesn't slow down a computeheavy thread. what am i missing?;0
34241199;HackerNews;2023-01-04;i think all your points are correct but none of them address scalability. what do you do if your one efficient machine is too small for your problem? to be fair not a lot of problems reach that point in practice definitely not every problem a microservice is written for.it might still be completely viable to rewrite something so that it's only 10 as efficient but you can scale it horizontally easily.;0
34241063;HackerNews;2023-01-04;most features in a modern app are not critical functionality though.for instance in a shopping site why should a crash in the recommendations engine result in a nonfunctional webpage rather than a working purchase page with no recommendations?personally i think microservices start to make sense when you have several hundred developers an environment i'm currently keen to never enter again work has 5 devs and might one day have 6.;0
34240461;HackerNews;2023-01-04;honestly a small shop probably shouldn't be doing microservices as a standard pattern outside of specific cases anyway thoughand yet that is exactly what gets done;0
34240449;HackerNews;2023-01-04;man i wish my colleagues would read your comment and at least question their believes for one brief moment i disagree in my opinion microservices hinder scalability of deploymentand of anything related to testing want to fire up the application in your pipeline to run e2e tests? congratulations you must now spin up the entire landscape of microservices in k8s. first however you need to figure out which versions of all those microservices you want to test against in the first place since every service is living in a separate repository and thus getting versioned separately. want to provide test data to your application before running your tests? well you're looking at 100 stateful services good luck with getting the state right everywhere.;0
34240439;HackerNews;2023-01-04;however there's another bonus here is that you have integration tests that have a better coverage.microservices don't make builds radically faster for the majority. people still split systems into larger services.;0
34240417;HackerNews;2023-01-04;with microservices you have to have a tradeoff a monolith is inherently more testable at integration level than a microservice based architecture.there's a significant overhead to build and run tests at api level that includes api versioning... and there's less of a need to version api inside a monolith.;0
34240273;HackerNews;2023-01-04;microservices is a different perspective than modules there is a business perspective referencing ddd there is a data perspective there is also an operations and maintenance perspective there is also a technical architecture perspective;0
34240223;HackerNews;2023-01-04;how so? if functionality a is critical to functionality b how will wrapping it in an http call microservices reduce the damage from breaking functionality a?i can see an advantage regarding resource hogging but the flip side is the extra point of failure of network calls in microservices.not saying which is better but deployment is orthogonal to logical dependence and correctness.;0
34240197;HackerNews;2023-01-04;the same techniques used to restrict intrusion can be applied to a monolith.microservices aren't inherently more secure.;0
34240144;HackerNews;2023-01-04;i'm not saying it is worth it but yes sometimes you can just inefficiently throw hardware resources at scaling problemsmicroservice scaling is also an inefficient hardware scaling option.;0
34240091;HackerNews;2023-01-04;not worshiping the microservice doesn't mean that you avoid services in different languages.not all engineers need to move around ds and mles are generally useless on the frontend and vice versa.;0
34239713;HackerNews;2023-01-04;you design your microservices so that they gracefully degrade.so if a database service is not available you simply return stale cached data until the service is back up.;0
34239678;HackerNews;2023-01-04;i think microservices turn this around the idea is that if we ignore them as technical units and treat them as iorganisational unitsi we can invert conway's law it's much easier to change how microservices talk to each other than it is to chnage how people do.but if you chnage the dataflow in a few microservices so that the accounts team no longer deals works directly with the sales team you have chnaged the organisation.plus it's way easier to monitor activity etc;0
34239265;HackerNews;2023-01-03;sometimes. if the services are all interrelated youre as dead on the water with microservices was you would be in a monolith.;0
34239236;HackerNews;2023-01-03;those human scaling problems are also security scaling problems the unix process model and in fact the von neumann architecture doesn't separate modules in security capabilities nor is it practical to do so.microservices allow your permissions to be clear and precise. your database passwords are only loaded into the process that uses them. you can reason about if there's an rce in this service here's what it can do. trying to tie that to monoliths is hard and ugly.;0
34239214;HackerNews;2023-01-03;i disagree in my opinion microservices hinder scalability of deployment and development at least the way i see most businesses use them. typically they break out their code into disparate repositories so now instead of one deployment you have to run 70 different cicds pipelines to get 70 microservices deployed and repo a has no idea that repo b made breaking changes to their api. or lib b pulled in lib d that now pollutes the classpath of lib a who has a dependency on lib b. often you need to mass deploy all of your microservices to resolve a critical vulnerability think log4shellthe solution to this is to use the right tool a build system that supports monorepos like bazel. bazel solves this problem wonderfully. it only builds tests containerizes deploys rulesk8s rulesdocker what needs to be rebuilt retested recontainerized and redeployed. builds are much faster developers have god like visibility to all of an organizations' code and can easily grep the entire code base and be assured their changes do not break other modules if bazel test ... passes. it is language agnostic so you can implement your services in whatever language best suits it. it allows you to more easily manage transitive dependencies manage versions globally across your org's codebase.of course bazel has a steep learning curve so it will be years before it is adopted as widely as maven gradle etc. but in the banks i've worked at it would've saved them tens of millions of dollars.also git would need to catch up to large codebases. i think meta released a new source control tool recently that is similar to git but could handle large monorepos.;0
34239211;HackerNews;2023-01-03;this is something folks have been doing long before the microservices hype.yes and that's the point. server bottlenecks are not the only thing microservices are trying to address.the only other real advantage is scale of network throughput and isolation from other processes in case some service is particularly volatile or prone to errors. even those are a stretch as they're both solvedsolvable by modern infra and just isolating code into its own job server technically a microservice.;0
34238591;HackerNews;2023-01-03;a sane thing to do.this is incredibly subjective and contingent on the size and type of engineering org you work in. for a small or firmly midsized shop? yea i can 100 see that being a sane thing to do. honestly a small shop probably shouldn't be doing microservices as a standard pattern outside of specific cases anyway thoughas soon as you have highly specialized teamsorgs to solve specific problems this is no longer sane.;0
34238498;HackerNews;2023-01-03;tech zoo sometimes considered to be an antipattern in microservices. by introducing a different language into your organization you decrease the mobility of developers between code bases and dilute technical knowledge.;0
34238326;HackerNews;2023-01-03;when you move to microservices or rather when you split your data across several dbs you sometimes end up basically reimplementing db synchronization in business logic layers that icouldi sometimes and depending on scalability constraints be solved by using db transactions.so instead of a single db transaction often with a single sql roundtrip microservices can sometimes force through coordination of separate transactions to several dbs.;0
34238290;HackerNews;2023-01-03;you can have more than one server per monolith.i don't think you actually understand what microservices are. you don't put a load balancer to load balance between different services. a load balancer balances trafic between servers of the same service or monolith.microservices mean the servers of different services run different code. a load balancer only works together with servers running the same code.;0
34238239;HackerNews;2023-01-03;how does exception capture protect from all failures? the most obvious one i don't see it relating to is resource utilization cpu memory threadpools db connection pools etc etc. were trying to compensate bad designno i think we're trying to compensate for developer mistakes and naivety. when you have dozens to hundreds of devs working on an application many of them are juniors and all of them are human and impactful mistakes happen. just catching the right exceptions and handling them the right way does not protect against devs not catching the right exceptions and not handling them the right way but microservices does.maybe you call that compensating for bad design which is fair and in that case yes it is! and that compensation helps a large team move faster without perfecting design on every change.;0
34238151;HackerNews;2023-01-03;unless you apply a large degree of discipline and engineering excellence to only rebuild changed modules while making sure no api contracts are brokenisn't that exactly what's required when you're deploying microservices independently of each other? with the difference of the interface not being an abi but network callsrpcrest.;0
34238093;HackerNews;2023-01-03;however one of the unexpected consequences is that we are now doing a lot of network calls between these microservicesi wouldn't call that entirely unexpected. it's a rather wellknown issue from;0
34238052;HackerNews;2023-01-03;most companies will never experience the level of scale of 2013 twitteri fully agree with your argument. then again as mentioned elsewhere in this discussion microservices are often not introduced to solve a scalability problem but an organizational one and there are many organizations that have more engineers than twitter had.personally i still don't buy that argument because by solving one organizational problem one risks creating a different one as this blog post0 illustrates uber has grown to around 2200 critical microservicesunsurprisingly that same post notes that in recent years people have begun to decry microservices for their tendency to greatly increase complexity sometimes making even trivial features difficult to build. we experienced these tradeoffs first handi'm getting very strong wingmangalactus1 vibes here.0 1;0
34237943;HackerNews;2023-01-03;this is something folks have been doing long before the microservices hype.that said server bottlenecks are not the only thing microservices are trying to address.;0
34237804;HackerNews;2023-01-03;if you have a truly modularized monolith you can have a directed graph of dependent libraries the leaves of which are different services that can start up. you can individually deploy leaf services and only their dependent code will go out. you can then rationalize which services can go down based on their dependency tree. if email is close to a root library then yes a regression in it could bring everything down. if email is a leaf service its code wont even be deployed to most of the parallel services.you can then have a pretty flexible trade off between the convenience of having email be a rooted library against the trade off of keeping it a lead service the implication being that leaf services can talk to one another over the network via service stubs rest what have you.this is soa service oriented architecture which should be considered in the midst of the microservice monolith conversation.;0
34237725;HackerNews;2023-01-03;one other thing they give you at a large organization is flexibility in your stackif a team wants to try out a different language or hosting model or even just frameworktooling those things can be really hard to do within the same codebase much easier when your only contract is handling json requests. and if your whole organization is totally locked into a single stack it's hard to keep evolving on some axesi'm generally against microservices but this is one of the more compelling arguments i've heard for them though it still wouldn't mean you need to eagerly break things up without a specific reason;0
34237677;HackerNews;2023-01-03;scalability being able to increase the amount of compute memory and io to the specific modules that need it.i gave a talk 1 about scalability of java systems on kubernetes and one of my recommendations is that javabased systems or any system on a runtime similar to the jvm like clr or even go should be scaled diagonally. efficiency is the word.while horizontal scaling can easily address most performance issues and load demand in most cases it is the least efficient way for java and again i risk saying .net and go as these systems struggle with cpu throttling and garbage collectors.in short and exemplifying one container with 2 cpus and 2gb of ram will allow the jvm to perform better in general than 2 containers with 1 cpu1gb ram each. that said customers shouldn't be scaling horizontally to any amount more than what is adequately reasonable for resiliency or unless the bottleneck is somewhere like disk access. for performance on the other hand customers should be scaling vertically.and kubernetes vpa is already available. people just need to use it properly and smartly. if a kubernetes admin believes a particular pod should double in number of replicas the admin should consider would this microservice benefit even more from 1.5x more cpumemory than 2x more replicas? and i bet to say that in general yes.1;0
34237654;HackerNews;2023-01-03;they force alignment of dependencies and their versionsa sane thing to do. better yet to do it in a global fashion along with integration tests.but brutally difficult at scale. if you have hundreds of dependencies a normal case what do you do when one part of the monolith needs to update a dependency but that requires you update it for all consumers of the dependency's api and another consumer is not compatible with the new version?on a large project dependency updates happen daily. trying to do every dependency update is a nonstarter. no one has that bandwidth. the larger your module is the more dependencies you have to update and the more different ways they are used so you are more likely to get update conflicts.this doesn't say you need microservices but the larger your module is the further into dependency hell you will likely end up.;0
34237493;HackerNews;2023-01-03;i whether it's your http api interface changingiinterfaces don't change under microservices. communication by contract enshrines a contract. you imusti ensure that your api does not break legacy users no matter what changes you want to make going forward. you have committed to behaviour forevermore once you submit the contract to other teams.this may be another reason why ipc is often preferred over straight function calls as some languages particularly those with static types make extending functionality without breakage quite hard. an http api can more easily resort to tricks to return different results to different callers.i i think the redgreenrefactor loop of tdd doesn't bring much.iyou find little value in writing a specification for your work or you find little value in automatic validation that the program works according to your spec?redgreenrefactor is a little more specific in that it says that you should write a spec only for the work you know you are going to work on in the short term whereas tdd in general leaves room for things like writing the entire application's spec before getting down to business. i think this is most practical in the real world generally speaking. often you don't know what your entire application should do in the beginning making writing a full spec unrealistic.i i've never seen it applied well on a statically typed codebaseiinteresting as i have only ever seen specifications be it tdd or word documents written for work that is done in statically typed languages. in my experience the dynamic programming languages tend to attract the cowboy coders who don't understand why other future developers need more complete documentation or why specs are important and have no care to see that those things are done.;0
34237473;HackerNews;2023-01-03;proper design in a monolith would also protect you from failures of nonvital services e.g. through exception capture.so it seems like were trying to compensate bad design with microservices. its orthogonal imo.;0
34237287;HackerNews;2023-01-03;i don't really think microservices are fundamentally more scalableit depends on what you are scaling. i think microservices are fundamentally more scalable for deployment since changes can be rolled out only to the services that changed rather than everywhere. unless your language and runtime support hotloading individual modules at runtime.;0
34237184;HackerNews;2023-01-03;microservicesagreed the same database gets difficult but i guess where two things need to change dependently there's coordination overhead that's inescapable. you can in general use e.g. schemas to keep domains fairly separate. whether it's your http api interface changing or the change needs to be coordinated in the same process i don't think you have a way to avoid these meetings. or like the 3rd party team i work with you just change your http api and break production without telling us shrug.i guess my point is languages like java and c are much maligned for their boilerplate and it doesn't let 10x genius programmers go brrrrrr etc. but that boilerplate serves a purpose. projects in c i can't speak to java but i believe it has a similar concept compile to separate .dll's or .so's. in general a project will publicly expose interfaces i.e. contracts and keep its internals encapsulated. crucially projects all live in the same codebase in the same monolith they're folderdirectory level separation but on steroids. there are tricks with attributes and reflection that can break this separation but with the additional constraint that dependencies cannot be circular you're forced to make decisions about where exactly things live. this is where the dynamic crowd throw up their hands and say there are so many layers of pointless abstraction!. i'd agree these languages tend to too many layers but the layers provide the foundation which can support a project growing from 12 devs all the way through to 50.i'm maybe finally becoming a grumpy old programmer and i'm glad much of the consensus is swinging away from the notypes no schema no rules position of the past decade. people forgot chesterton's fence and decided the layers didn't provide anything then they added them back as network boundaries which was indescribably worse and more of a headache. testingi guess it's a semantics debate really. i think the redgreenrefactor loop of tdd doesn't bring much. i've never seen it applied well on a statically typed codebase and where i've seen advocates try and apply it i've seen them tunnelvision to suboptimal outcomes in order to fulfil the ceremonial needs of the process.i think a few tests that take place at the projectdllso boundary and use as much of the real dependencies as possible are far preferable to high coverage. this is probably a notruescotsman area of debate. maybe tdd has been done properly and productively by some groups i've never seen it and no one i've met ever has check out my confirmation bias!.;0
34237089;HackerNews;2023-01-03;what it is is using the wrong solution for a problem. viceversa the number of devs who justify monolithic apps is absurd. the justification of microservices is just as problematic.it is about striking a balance. no reason should something be overly compounded or overly broken up.;0
34237080;HackerNews;2023-01-03;another benefit of microservices is it allows you to have a permission boundary which can restrict the scope of damage if a single serverservice is compromised.and for that matter it can but not necessarily limit how much damage a bad code release can do.of course you don't get those benefits for free just by using microservices but impleminting those kind if boundaries in a monolith is a lot harder.;0
34237051;HackerNews;2023-01-03;answer is no.it is about where the shoe fits. if you become too heavily dependent on modules you risk module incompatibility due to version changes. if you are not the maintainer of your dependent module you hold a lot of risk. you don't get that with microservices.if you focus too much on microservices you introduce virtualized bloat that adds too much complexity and complexities are bad.modules are like someone saying it is great to be monolithic. noone should upright justify an overly complicated application or a monolithic one.the solution is to build common modules that are maintainable. you follow that up with multicontainer pods have them talk low level between each other.stricking that exact balance is what is needed not striking odd justifications for failed models. it is about what does my application do? and answering with which design benefits it the most.;0
34236913;HackerNews;2023-01-03;doesn't monolith usually refer to one really heavy app?no. backend server clusters are around almost as long as the internet exists.i would guess most of the time there's a high expense lots of memory in duplicating the entire monolith?that's right but there's a gotcha. everytime you split your monolith into parts that doesn't mean that each part will consume 1n of original monolith startup resource. there will be a floor of memory usage. consider 1 monolith that eats up 1gb to startup vs 4 microservices that uses 512mb each. right from start you doubled the wasted memory from 1gb to 2gb. that only gets worse the more services are created. another problem is that microservicecloud folks loves to create anemic machines. usually setting up 512mb ram and half a core cpu to a service that needs 380mb minimum thats 75 overhead and 25 of working memory. it's bonkers.;0
34236910;HackerNews;2023-01-03;why would using microservices reduce the chance of outages? if you break a microservice that is vital for the system you are as screwed as with a monolyth.;0
34236899;HackerNews;2023-01-03;it sounds like creating problem then spending timemoney on fixing it and calling it a win?there is a point when it all starts to make sense. but that point is when you go into billions worth business hundreds of devs etc. and going there has large cost especially for smallmedium systems. and that cost is not one off it's a daytoday cost of introducing changes. it's orders of magnitude chaper and faster head cound wise to do changes in ie. single versioned monorepo where everything is deployed at once as single working tested migrated version than doing progressive releases for each piece keeping it all backward compatible at micro level. again it does make sense at scale hundreds of devs kind of scale but saying your 5 devs team moves faster because they can work on 120 micoservices independently is complete nonsense.in other words micoservices make sense when you don't really have other options you have to do it it's not good startwith default at all and frankly sam newman says it in building microservices and so do people who know what they're talking about. for some reason juniors want to start there and look at anything nonmicroservice as legacy.;0
34236872;HackerNews;2023-01-03;i am a front end dev so microservice architecture is not something i am super familiar with my daytoday but i occasionally do work in our back end project which is a serviceoriented java project. the project is broken down into different services but they are aggregated in parent projects where the parent declares the modules in the pom.xml in the modules xml declaration.i like that architecture the services are abstracted with clearly defined boundaries and they are easy to navigate discover. not sure if java modules satisfy the concerns of the author or other hn users but i liked it.;0
34236859;HackerNews;2023-01-03;unexpected?!either way one of my biggest pet peeves is the nearubiquitous use of http amp json in microservice architectures. there's always going to be overhead in networked servies but this is a place where binary protocols especially ones like cap'n proto really shine.;0
34236840;HackerNews;2023-01-03;i think microservices are fine for businesses which have a general idea of how 'big' things could get with respect to their platforms. but if you're more in a company that has many oneoff programs scripts and the like then maybe microservices aren't a thing that you need. better organization is good but that shouldn't be just a microservices thing everyone benefits when you've organized not just individual projects and their source code but also just organizing what does what with external documents that can be updated to explain their purpose is useful. there's nothing worse than looking at source code or an program by name only to ask what is this thing?;0
34236753;HackerNews;2023-01-03;i have done a lot of service development for what would be called microservices.the article gets it right in ny opinion.1. it has a lot to do with organisational constraints.2. it has a lot to do with service boundaries. if services are chatty they should be coupled.3. what a service does must be specified in regards to which data it takes in and what data it outputs. this data can and should be events.4. services should rely and work together based on messaging in terms of queues topics streams etc.5. services are often data enrichment services where one service enrich some data based on an eventdata.6. you never test more than one service at a time.7. services should not share code which is vibrant or short lived in terms of being updated frequently.8. conquer and divide. start by developing a small monolith for what you expect could be multiple service. then divide the code. and divide it so each coming service own its own implementation as per not sharing code between them.9. iaas is important. you should be able to push deploy and a service is setup with all of its infrastructure dependencies.10. domain boundaries are important. structure teams around them based in a certain capability. e.g. customers bookings invoicing. each team owns a capability and its underlying services.11. make it possible for other teams to read all your data. they might need it for something they are solving.12. don't use kubernetes or any other orchestra unless you can't it what you want with cloud provider paas. kubernetes is a beast and will put you to the test.13. services will not solve your problems if you do not understand how things communicate fail and recovers.14. everything is eventually consistent. the mindset around that will take time to cope with.a lot more...;0
34236715;HackerNews;2023-01-03;it's not really about what's better it's about whats been standardized upon.i'm sure i could gain many of the advantages of microservices through an osgi monolith however an osgi monolith is not the hot thing of the day i'm likely to be poorly supported if i go down this route.ideally i also want some of my developers to be able to write their server on the node ecosystem if they so choose and don't want updating the language my modules run on in this case the jvm to be the biggest pain of the century.besides once my mau is in the hundreds of thousands i probably want to scale the different parts of my system independently anyway so different concerns come in to play.;0
34236555;HackerNews;2023-01-03;sure poorly implemented solutions rarely solve problems well.but implementing microservices is not an unsolvable problem. it's a problem that 1000s of organizations have solved.;0
34236348;HackerNews;2023-01-03;while we are on the topic i would like to point out that the decoupled nature of microservices is governed by queuing theory. microservices are especially susceptible to positive feedback loops and cascading failures.going back to systems thinking flow control concurrency and rate limiting and api scheduling weighted fair queuing are needed to make these architectures work at any scale. open source projects such as aperture0 can help tackle some these issues.0;0
34236339;HackerNews;2023-01-03;yeah it's bin packing not straight efficiency. also people seem to exaggerate latency for rpc calls. i often get the feeling that people who make these latency criticisms have been burned by some nominal microservices architecture in which an api call is made in a hot loop or something.network latency is real and some systems really do run on a tight latency budget but most sane architectures will just do a couple of calls to a database same performance as monolith and maybe a transitive service call or something.;0
34236336;HackerNews;2023-01-03;another way to look at this is microservices reduce the blast radius of problems.;0
34236326;HackerNews;2023-01-03;how do microservices help here? you can deploy a monolith 10 times and have the same risk distribution.;0
34236280;HackerNews;2023-01-03;so tell me who is making microservices for calls that could be done wholly in memory? how are you handling rollbacks and such for this in memory logic?aren't you still writing out to external data stores? if that's the case then its really not a comparison of in process to a rpc it just two rpc hops now no?;0
34236212;HackerNews;2023-01-03;there's two technical problems that microservices purport to solvethere's a third technical problem that microservices solve and it's my favorite isolation. with monoliths you provide all of your secrets to the whole monolith and a vulnerability in one module can access any secret available to any other module. similarly a bug that takes down one module takes down the whole process and probably the whole app when you consider cascading failures. in most mainstream languages every module even the most unimportant leaf node on the dependency tree needs to be scoured for potential security or reliability issues because any module can bring the whole thing down.this isn't solved at the language level in most mainstream languages. the erlang family of languages generally address the reliability issue but most languages punt on it altogether. the real reason that microservices may make sense is because they keep people honest around module boundaries.agreed. microservices like static type systems are rails. most organizations have people who will take shortcuts in the name of expedience and systems with rails disincentivize these shortcuts importantly they don't iprecludei them.;0
34236200;HackerNews;2023-01-03;you'll need to support loading two versions of each dll into memory and invoking both on some percentage of servers to be able to replicate a microservice though.the important part of microservices isn't just api boundaries it's lifecycle management. this can be done with a dll or jar but it's much harder today.;0
34236158;HackerNews;2023-01-03;that's just a microservice enabled by configuration.;0
34236123;HackerNews;2023-01-03;if done right microservices is a way to transform part of your organization challenge into a technical one which for many organizations is the right move.famous last words if done right... or you just multiply your organizational issue with a technical one.;0
34236106;HackerNews;2023-01-03;how the hell... like... who decided to do microservices in the first place if they didn't know this?microservices can have both design utility and simultaneously been a major fad.lurking reddit and hn you can watch development fashions come and go. it's really really profoundly hard to hold a sober conversation on splitting merits from limitations in the middle of the boom.tldr gartnerhypecycle.png;0
34236075;HackerNews;2023-01-03;microservices enable independent scale domains. this means they can be more scaleable and dense but it's not necessarily true.;0
34236052;HackerNews;2023-01-03;a better rule is for one service to own writes for a table and other services can only read that tablebeen there how do you handle schema changes?one of the advantages that having a separate schema per service provides is that services can communicate only via apis which decouples them allowing you to deploy them independently which is at the heart of microservices and continuous delivery.the way i see it today everyone complains about microservices 12 factor apps kubernetes docker etc. and i agree they are overengineering for small tools services etc. but if done right they offer an agility that monoliths simply can't provide. and today it's really all about moving faster than yesterday.;0
34236043;HackerNews;2023-01-03;but i don't see how monoliths can keep up with developer velocity when an organization reaches thousands of developers.you're likely right.i think what most detractors of microservices are pointing to is that most companies don't reach thousands of devs in size. or even hundreds.;0
34235959;HackerNews;2023-01-03;thats a really interesting point something that could probably be addressed by modulelevel logging and metrics. that said even as a promonolith advocate i can see why its preferable to not allow any one moduleservice to consume all the resources for your service in the first place. the service boundaries in microservice architectures can help enforce resource limits that otherwise go unchecked in a larger application.;0
34235849;HackerNews;2023-01-03;i was working at amazon when they started transitioning from monolith to microservices and the big win there was locality of data and caching.all of the catalog data was moved to a service which only served catalog data so its cache was optimized for catalog data and the load balancers in front of it could optimize across that cache with consistent hashing.this was different from the front end web tier which used consistent hashing to pin customers to individual webservers.for stuff like order history or customer data those services sat in front of their respective databases and provided consistent hashing along with availability providing a consistent writethrough cache in front of the sql databases used at the time.i wouldn't call those areas where it makes things more efficient rare but actually common and it comes from letting your data dictate your microservices rather than letting your organiation dictate your microservices although if teams own data then they should line up.;0
34235714;HackerNews;2023-01-03;if they wrote that using a bunch of labview microservices you could replace the services onebyone with cada until the whole thing was no longer labview.this is generally what i think the best part about microservices are an easy way to improve upon the mvp in any dimension. rewriting a whole monolith can take forever and probably will introduce a ton of bugs. but incrementally rewriting microservices won't stop feature development and is easy to ab test for correctness.;0
34235675;HackerNews;2023-01-03;as a general rule of thumb fully explore and exhaust your monolith options before you switch to microservices. they quite often create more problems than they solve.;0
34235624;HackerNews;2023-01-03;servers can only get so big. if your monolith needs more resources than a single server can provide then you can chop it up into microservices200 threads 12tb of ram with a pipe upwards of 200gbs. this isn't even as big as you can go this is a reasonable off the shelf item. if your service doesn't need more than this maybe don't break it up. i believe that this level of service can no longer accurately be described as micro.;0
34235493;HackerNews;2023-01-03;microservices are less efficient but are still more scalable.not at all. you can run your monolith on multiple nodes just as you can do with microservices. if anything it scales much better as you reduce network interactions.;0
34235466;HackerNews;2023-01-03;i didn't get this article. it seems like it contains two things 1. it was already invented before 2. all the wrong reasons why people decide to use microservices.but author clearly avoided the real reasons why you actually need to split stuff into separate services 1. some processes shouldn't be mixed in the same runtime. simple example batchstreaming vs 'realtime'. or important and not important. 2. some things need different stack runtimes frameworks. and is much easier to separate them instead of trying to make them coexist.and regarding 'it was already in simpsons' argument i don't think it should even be considered as argument. if you are old enough to remember ejb you don't need to be explained why it was a bad idea from the start. why services built on ejb were never scalable or maintainable. so even if ejb claimed to cover the same features as microservices right now i'm pretty sure ejb won't be a framework of choice for anybody now.obviously considering microservices as the only right solution is stupid. but same goes for pretty much any technology out there.;0
34235432;HackerNews;2023-01-03;i don't understand the argument around microservices purporting to fix scalability. say your system has modules a b and c in one app and that a requires more resources while b and c are relatively unused. won't b and c just irun lessi and thereby use appropriately fewer resources from within the same system as a? are microservices just an aesthetic separation it feels nice to know you're only scaling up a?;0
34235390;HackerNews;2023-01-03;you are absolutely right you do not know much about cruises.the things you listed are ... 45 different iapplicationsi mostly running directly on the ships and what is conspicuously missing are the parts that are managed shoreside likeitinerary planning your product is one or more cruises therefore you need to preplan the itineraries which ships to use when you will enter each port and when you will leave it and so on... try to imagine this like a mix between hotel management and flight company management inventory management i.e. reservation.you mention bookings like a microservice. this could work for iferryi line where you are basically selling a ticket for a single trip most of the time with no personal accommodation except maybe for the car.a cruise booking usually comes with a ton of ancillary services e.g. i live in berlin and i want to take a cruise in the caribbeans... therefore i need a flight to get there and back. this could be provided by a charter flight or a normal airline ... in either cases the ticket will be part of the booking itself take in account that cruise customers are mostly middleaged or older and relatively affluent therefore the last thing they would like to do is to create their own itinerary by booking services on 45 different websites.but i suppose it is better to stop there we are really ot now;0
34235273;HackerNews;2023-01-03;i why can't the teams work on the same codebase and the same database?ithe same database is tricky because one team might want to change the schema breaking another team's work. you then need to have meetings to discuss the changes that will work for all parties and you've broken communicate only by contract and therefore no longer doing microservices. if you can ensure that there is no way for teams to trample over each other then you could use the same database.the same codebase is more feasible as long as the team boundary separation is clear. you are likely already doing microservices with other teams when you import thirdparty libraries. in practice though much like the database problem maintaining boundary separation is difficult if you can easily reach into other team's code so often each team's work will be parted into distinct codebases using ipc between them to ensure that the separation is unbreakable. this certainly isn't a requirement though just one way to keep people in line.i testing is certainly a way to provide a selfverifying application. tdd is a toxic hypedriven messitesting is a development tool to help test the functionality of a feature. if you are faced with a dynamic language you very well might write tests to ensure that types are handled correctly. static types can indeed relieve the need for some tests.tdd on the other hand is a documentation tool to relay to other developers what functionality is intended to provide and how it is meant to be used. it is strange to think that documentation is toxic. before tdd we wrote word documents containing the same information but often found that the code didn't do what the documentation said it did. what tdd realized is if the documentation is also executable then you can have the machine prove that the application behaves according to spec. it's not exactly magic.;0
34235204;HackerNews;2023-01-03;my take do microservices all you want but don't organize teams around the services!exactly. in order to reap the benefits of modularmicroservices architecture you need teams to be organized around productfeature verticals.imo its not about the internals of a productservice architecture but about encapsulating isolating and formalizing interorganizational dependencies.;0
34235159;HackerNews;2023-01-03;mostly valid but...on the ram front i am now approaching terabyte levels of services for what would be gigabyte levels of monolith. the reason is that i have to deal with mostly duplicate ram the same 200 mb of framework crud replicated in every process. in fact a lot of microservice advocates insist ram is cheap! until reality hits especially forgetting the cost is replicated in every developmenttesting environment.as for slow startup a server reboot can be quite excruciating when all these processes are competing to grind amp slog through their own copy of that 200 mb and get situated. in my case each new amp improved microservice alone boots slower than the original legacy monolith which is just plain dumb but it's the tech stack i'm stuck with.;0
34235125;HackerNews;2023-01-03;layers not modules not microservices like donkeys onions caching networking my feelings and perceptions.;0
34235087;HackerNews;2023-01-03;you know i don't really think microservices are fundamentally more scalable. rather they expose scaling issues more readily.when you have a giant monolith with the load the world endpoint it can be tricky to pinpoint the the load the world endpoint or as is often the case endpoints is what's causing issues. instead everyone just tends to think of it as the x app having problems.when you bust the monolith into the xyz and x and z got the load the world endpoints that starts the fires of x is constantly killing things and it's only doing this one thing. how do we do that better?that allows you to better prioritize fixing those scaling problems.;0
34235045;HackerNews;2023-01-03;microservicesi think at the root this idea that microservices provide this technical solution to a social issue coordinating teams at scale hides the driving motivation.why can't the teams work on the same codebase and the same database? again note my edited in disclaimer in the gp post that maybe at certain rare scales it's necessary. what is a well defined specification and why is it only a restprotowhatever network api? why not a defined interface or projectlibrary? why aren't teams at this scale working in languages that support defining these things in code without adding a complicating latency and errorinducing network call?statically typed languages are just superior at encoding this well defined specification. it's a large part of their reason for being. sure you can still bypass it and do reflection or other naughtiness but we shouldn't pretend a network call is the only solution. tdditestingi is certainly a way to provide a selfverifying application. tdd is a toxic hypedriven mess that has led many good developers astray. static languages have their own devils here mocking being chief among them not to mention the java clown brigade and their own enthusiastic adoption of originally smalltalk conceived tdd.i added tdd both to annoy people but also to illustrate the general point. these are both concepts derived from the obvious drawbacks of dynamically typed languages that are then treated as generalist answers to complexity in software.if you'll allow me some pseudointellectual waffle the complexity of a software system cdynamic csoftware ctotal that is complexity of dynamically typed languages and their lack of rigour plus complexity of software and the domain as a whole gives you total complexity. these approaches primarily target the dynamic complexity. therefore introducing them and all attendant drawbacks in places where total complexity doesn't include the dynamic complexity because tools and approaches to remove this source of complexity are used actually worsens the entire field.;0
34235038;HackerNews;2023-01-03;if you really require that sort of isolation then microservices are a bugridden ad hoc implementation of half of erlang.;0
34235011;HackerNews;2023-01-03;any way you slice it it's hard to managealigncoordinate a 100 devs.if done right microservices is a way to transform part of your organization challenge into a technical one which for many organizations is the right move.the biggest issue is if you aren't large enough to have challenging organizational issues it's much easier to just solve the very solvable organizational issues than implement and use microservices.;0
34234991;HackerNews;2023-01-03;at the heart of microservices we often find... ... the fallacies of distributed computing.i feel like im taking crazy pills but at least im not the only one. i think the only reason this fallacy has survived so long this cycle is because we currently have a generation of network cards that is so fast that processes cant keep up with them. which is an architectural problem possibly at the application layer the kernel layer or the motherboard design. or maybe all three. when that gets fixed there will be a million consultants to show the way to migrate off of microservices because of the 8 fallacies.;0
34234977;HackerNews;2023-01-03;managers arranging work is not why conway's law is true though. i think it behooves one to look at the actual text of the law any organization that designs a system defined broadly will produce a design whose structure is a copy of the organization's communication structure.it doesn't matter who defines or does the work the coders themselves in a team or the manager. it matters how communication is arranged. and communication naturally aligns itself along organizational and team boundaries.when a grouppersonwhatever writes an api they are mostly writing a document for other human beings. that is an act of communication. if you meet with someone everyday in a standup you're likely to put a less structured api between yourselves than if you meet with someone once a month or once a year. you're also going to create a finer grained subdivision of the api for them as you're likely working on closely related posts of the problem.organization creates communication and communication creates architecture. therefore organization creates architecture. plus conway is just a ... neat idea not a bound fateit is in fact bound fate. code is written to communicate with others.people come together they decide to solve a problem. they divide up that problem and create functions an api objects an api modules an api and servicesmicroservices an api. at each later they've written something that communicates with others. the structure of that code reflects the necessary communication to the other parties for their part of the problem. this the code is structured following the lines of communication in the organization.organization is how we structure communication that's it's primary point and thus organization architecture some wiggle room for communication paths defined outside that say a safe feature team.;0
34234905;HackerNews;2023-01-03;from what i can tell github transitioned over to microservices 2020 . by this point it had already grew to a scale that very few companies will ever reach.i'm not sure at what point the monolith codebase became absolutely enormous but i would bet that github grew to 1m active users with a monolith just fine.microservices might be necessary for the companies like github twitter google that grow to be huge but monoliths seem to work just fine for the vast majority of other companies.;0
34234904;HackerNews;2023-01-03;microservices are less iefficienti but are still more iscalablei.servers can only get so big. if your monolith needs more resources than a single server can provide then you can chop it up into microservices and each microservice can get its own beefy server. then you can put a load balancer in front of a microservice and run it on n beefy servers.but this only matters at facebook scale. i think most devs would be shocked at how much a single beefy server running efficient code can do.;0
34234879;HackerNews;2023-01-03;the best experience i've had with modular code in the java space was osgi. very cool to be able to upload a new jar and have it start working just like that. microservices and eda... not really a fan. yes you can release faster but operationalizing is a massive nightmare to me. of course one size doesn't fit all but i'm pretty convinced this is only a popular solution for now.;0
34234857;HackerNews;2023-01-03;microservices by definition do not share a db. if they do then you just have multiple processes in the same larger service.;0
34234840;HackerNews;2023-01-03;i've been thinking for a while about how to architecture systems and i wonder if perhaps we could generalize something like fuchsia's device driver stack design 1 for arbitrary systems and eliminate this monolithic vs microservice applications debate altogether.in fuchsia the device driver stack can be roughly split into three layers drivers which are components libraries with added metadata that both ingest and expose capabilities a capabilityoriented ipc layer that works both inside and across processes driver hosts which are processes that host driver instances.the system then has the mechanism to realize a device driver graph by creating device driver instances and connecting them together through the ipc layer. what is interesting however is that there's also a policy that describes how the system should create boundaries between device driver instances 2.for example the system could have a policy where everything is instantiated inside the same driver host to maximize performance by eliminating interprocess communication and context switches or where every device driver is instantiated into its own dedicated driver host to increase security through process isolation or some middle ground compromise depending on security vs performance concerns.for me it feels like the dockerlike containerization paradigm is essentially an extension of good old user processes and ipc that stops at the process boundary without any concern about what's going on inside it. it's like stacking premade lego sets together into an application. what if we could start from raw lego bricks instead and let an external policy dictate how to assemble them at runtime into a monolithic application running on a single server microservices distributed across the world or whatever hybrid architecture we want with these bricks being none the wiser?heck if we decomposed operating systems into those bricks we could even imagine policies that would also enable composing from the ground up with applications sitting on top of unikernels microkernels or whatever hybrid we desire...1 2;0
34234831;HackerNews;2023-01-03;without the organizational benefits of a microservice you are just just making intermodular calls really slow and fail intermittently.;0
34234813;HackerNews;2023-01-03;i don't think microservices are the answer to everything but i don't see how monoliths can keep up with developer velocity when an organization reaches thousands of developers.monoliths are way slower to deploy than microservices and when you have hundreds or thousands of changes going out every day this means lots of changes being bundled together in the same deployment and as a consequence lots of bugs. having to stop a deployment and roll it back every time a defect is sent to production would just make the whoe thing completely undeployable.microservices have some additional operational overhead but they do allow much faster deployments and rollbacks without affecting the whole org.maybe i am biased but i would love an explanation from the monolithevangelist crowd on how to keep a monolith able to deploy multiple times a day and capable of rolling back changes when people are pushing hundreds of prs every day.;0
34234796;HackerNews;2023-01-03;idk i feel like one of the benefits to uservices is isolation not in design or architecture as many comments say but isolation from one service affecting another.if i run a monolith and one leastused module leaks memory real hard the entire process crashes even though the mostusedmore important modules were fine.of course it's possible to run modularised code such that they're sandboxedresources are controlled but at that point it's like...isn't this all the same concept? managed monolith with modules vs microservices on something like k8s.i feel like rather than microservices or modules or whatever we need a concept for a sliding context from one functionone group of functionsone featureone servicedependent servicesall servicesetc.with an architecture like that it would surely be possible to run each higher tier of context in any way we wanted as a monolith containerised as lambdas. and working on it would be a matter of isolating yourself to the context required to get your current task done.;0
34234790;HackerNews;2023-01-03;i just want to point out that for the second problem scalability of cpumemoryio microservices almost always make things worse. making an rpc necessarily implies serialization and deserialization of data and nearly always also means sending data over a socket. plus the fact that most services have some constant overhead of the footprint to run the rpc code and other things healthchecking stats collection etc. that is typically bundled into each service. and even if the extra cpumemory isn't a big deal for you doing rpcs is going to add latency and if you get too many microservices the latency numbers can start really adding up and be very difficult to fix later.running code in a single process is much lower overhead because you don't need to transit a network layer and you're generally just passing pointers to data around rather than serializingdeserializing it.there are definitely some cases where using microservices does make things more cpumemory efficient but it's much rarer than people think. an example where you'd actually get efficiency would be something like a geofence service imagine uber doordash etc. where the geofence definitions are probably large and have to be stored in memory. depending on how often geofence queries happen it might be more efficient to have a small number of geofence service instances with the geofence definitions loaded in memory rather than having this logic as a module that many workers need to have loaded. but again cases like this are much less common than the cases where services just lead to massive bloat.i was working at uber when they started transitioning from monolith to microservices and pretty much universally splitting logic into microservices required provisioning many more servers and were disastrous for endtoend latency times.;0
34234696;HackerNews;2023-01-03;i always love that circular logic.hey our developers can't make modules correctly! let's make the api boundaries using http calls instead then they'll suddenly know what to do!and that unsupervised junior? at one place i joined that unsupervised junior just started passing data he needed via query string params in ginormous arrays from microservice to microservice.and it wasn't a quick fix because instead of using the lovely type system that tells you where the stupid method has been used you've got to go hunting for http calls scattered over multiple projects.all you've done is make everything even more complicated if you can't supervise your juniors your code's going to go sideways whatever.microservices don't solve that at all and it's pure circular logic to claim otherwise. if your team can't make good classes they can't make good apis either. and worse still suddenly everything's locked in because changing apis is much harder than changing classes.;0
34234357;HackerNews;2023-01-03;you don't want to fracture knowledge and make hiringtraining more difficultthese are not maxims of development there can be reasons that make these consequences worth it. furthermore you can still use just a single language with microservices nothing is stopping you from doing that if those consequences are far too steep to risk.you can also use several languages with modules by using ffi and abis probably.;0
34234324;HackerNews;2023-01-03;dynamic typing microservices unit tests just blows everything out of the water on development speed time to market.most important thing for lots of startups and companies is time to market.traditional static typing based approachs are just a bad joke 3 times slower on average in comparsion.that's why we have the whole microservices and dynamic typing thing going on because businesses that use it beat up businesses that don't. it's pretty simple really.;0
34234243;HackerNews;2023-01-03;as a senior software engineer the most tiresome type of software dev to deal with is not the junior developer it's the highly opinionated intermediatelevel dev. they say things like we'll obviously build the system using modern microservices architecture using node.js before they even know the requirements.;0
34234192;HackerNews;2023-01-03;yes it's very common design. sometimes called a distirbuted monolith. it's not microservices because the number of additional services is usually small and the codebase is still tightly coupled to itself even if well factored in terms of modules. i.e. everything is still tested together and there's still a single monolithic build and deployment process and no team can go off and decide to write a service in a different language.;0
34234146;HackerNews;2023-01-03;it's called conway's law .;0
34234111;HackerNews;2023-01-03;perhaps we should coin the phase 'embedded microservices'.;0
34234072;HackerNews;2023-01-03;it's easy to crap on ejb lots to disagree with but vendors like weblogic were trying to do interesting things with them when they were ascending. i recall they had a nifty feature where if you were trying to call a remote ejb and the container knew it was deployed locally it would automatically do a cheaper local call instead of rmi. it was awkward as hell but it did do that and it was faster. j2ee also had the concept of people roles as part of its prescribed sdlc something we could benefit from exploring especially the deployer role.ideally we could flexibly deploy servicescomponents in the same way as weblogic ejb. discovery of where components live could be handled by the container and if servicescomponents were deployed locally to one another calls would be done locally without hitting the tcpip stack. i gather that systems like kubernetes offer a lot of this kind of deployment flexibilitydiscovery but i'd like to see it driven down into the languagesframeworks for maximum payoff.also the right way to do microservices is for services to own all their own data and not call downstream services to get what they need. no n1 problem allowed! this requires inverting the arrowsdon't call me i'll call you and few organizations have architectures that work that way hence the fallacies of networked computing reference. again the services languageframework needs to prescribe ways of working that seamlessly establish and can periodicallyondemand rebroadcast data feeds that our upstreams need so they don't need to call us n1style.microservices are great to see even with all the problems they do solve organizational scaling problems and let teams that hate each other work together productively. but we have an industry immaturity problem with the architectures and software that is not in any big players' interest in solving because they like renting moar computers on the internet.i have no actual solutions to offer and there is no money in tools unless you are lucky and hellbent on succeeding like jetbrains.;0
34234052;HackerNews;2023-01-03;but i am itryingi to feel my way towards the idea that ithat was true when managers arranged systems for workers to followi and then we came along to automate the current process. but if we have a system where the workers are the cpus then the people doing the managing are the coders.the point ebing is that if workers are cpus and coders are managers then why worry about how the imanagers of the codersi are arranged. get rid of that management layer. conway is not implying the financiers of the organisation affect the architecture.this basically means that the microservices a company is built out of should more readily align to the realities of the business model. and instead of shuffling organisations around it would behove executives to look at the microservices.one can more easily measure orders transferred etc if the boundaries are clearer.plus conway is just a ... neat idea not a bound fate.there is a caveat with the architecture reflecting the organisation of the software teams but that usually follows the other tobeautomated structure as well.;0
34234043;HackerNews;2023-01-03;is this a common nomenclaturedesign? how does a monolith that makes ipcrpc calls to submodules not basically microservices?;0
34233968;HackerNews;2023-01-03;whilst i don't know much about cruises. let me make up an example for you.let's suppose we are acme cruise lines running a cruiselinermicroservice national coastguard ship arrival system feed handlerdatabase logs incoming messages on the feedmicroservice asian and australian joint ship monitoring systemdatabase logs incoming messages on the feedmicroservice cruiser arrival and departure timesdatabase cruiser arrival and departures times in a standard formatmicroservice customer bookings and paymentsdatabase customer bookings and paymentsmicroservice fuel management systemdatabase ship fuel levels amp costs of fuel at various ports.it's that high level of split up.aws lambdas aren't quite the same thing as microservices.;0
34233917;HackerNews;2023-01-03;as far as i know there's no way to granularly scale up a monolith. if the monolith has 20 or 50 or 100 modules and you need 1 or 2 of them scaled you have to scale up the entire thing which is huge expensive etc.not necessarily. yes you do pay for executable bloat and some memory overhead from loading code into memory but the argument here is that you can still deploy a service b from the same deployable that only services certain kinds of requests in order to scale parts of the application horizontally. this is interesting. a monolith with some form of ipc? why not do microservices at that point? that sounds like microservicesish?no because again you're still deploying the same single codebase it's just the instance on the other end of the queue is configured just to consume and process messages.;0
34233916;HackerNews;2023-01-03;just wait until you decide you need some kind of distributed transaction support across multiple microservices you should aim to spend a considerable amount of time in the design and discovery phases.;0
34233912;HackerNews;2023-01-03;the way it usually works if 1 of your 100 modules needs to be scaled it probably means the overall monolith only needs a small amount of extra resources since that module is only using 1 of the total. so it's not like you need to double the instances of the whole thing.the benefit though is you get a bit of 'free' scaling. most of the modules don't even have to consider scaling at all as long as they are growing average or slower. so this saves a lot of operational burden for many teams. conversely with microservices ieveryi team ihas toi consider scaling no matter how simple their service is.if you do have 1 module out of 100 that takes up 40 of the resources then it may be appropriate to split it up. monolith doesn't literally mean exactly one service after all just a small number of big ones.;0
34233829;HackerNews;2023-01-03;we've done the round trip of splitting up a monolith into microservices and then going back the other way. network api overhead being the biggest reason. this kind of hell is totally unnecessary until it iabsolutelyi is i.e. hard information theory requirements demand you spread your app across more than 1 physical computer.monolith is better in almost every way. the only thing that still bothers us is the builditeration time. we could resolve this by breaking our gigantic dll into smaller ones that can be built more incrementally. this is on my list for 2023.;0
34233788;HackerNews;2023-01-03;you have to scale up the entire thing which is huge expensive etc.yes yet people still do it that way. this is tradeoff against the costs of microservices. i'm not saying it is worth it but yes sometimes you can just inefficiently throw hardware resources at scaling problems. this is interesting. a monolith with some form of ipc? why not do microservices at that point? that sounds like microservicesish?because you are incrementally changing an existing monolith but still getting some of the benefits of scaling distinct workloads independently. if you do this right it does lend it self to reworking the new service to be become its own microservice. or you can just keep going with the shared codebase.;0
34233675;HackerNews;2023-01-03;which is irrelevant as many microservices do the same inside of them and the libraries that they consume.;0
34233672;HackerNews;2023-01-03;bring back the monoliths! divided up into modules and each of those modules being developed by another team but essentially still the same deliverable binary.you only need to agree on an api between the modules and you're good to go!microservices suck dick and i hate the it industry for jumping on this bandwagon hype without thoroughly discussing the benefits and drawbacks of the method. debugging in itself is a pain with microservices. developing is a pain since you need n binaries running in your development environment.;0
34233650;HackerNews;2023-01-03;1 microservice. it's up to the software engineer to scope out the microservices properly.;0
34233646;HackerNews;2023-01-03;we keep regurgitating this because most microservices are the 2nd coming of big data that fits into a usb stick.;0
34233595;HackerNews;2023-01-03;the maintenance cost is a debt that must be paid by all means. and microservices may be the cleanest solution if there are teams that develop businesses completely independent of each other.;0
34233557;HackerNews;2023-01-03;then why cannot you have separate repos and review processes for modules? this has nothing to do with microservices vs modules.;0
34233480;HackerNews;2023-01-03;i felt suspicious as soon as i saw jon carmacks website being mentioned in a conversation about microservices.;0
34233370;HackerNews;2023-01-03;you never want code with shared ownership to tolerate feature creep. thats impossible to keep on the rails. if youre going to use solid anywhere its in shared code.if your org doesnt suffer feature creep willingly i believe that means you can have a lot more flexibility with respect to conways law. a lowchurn project can maintain a common understanding. not all of them will of course but its at least possible. feature factories absolutely cannot and you shouldnt even try.what really kills a lot of projects though is an inverted dependency tree. and by inverted i mean that the most volatile code is at the bottom of the call graph not the top. in this case every build every deploy or in the microservices scenario every request can have different behavior from the previous one because some tertiary dependency changed under you. now you need all sorts of triggers in your cicd pipeline to guarantee that integration tests are rerun constantly to figure out where the regressions are being introduced. your build pipeline starts to look like one of those server rooms with loose wires everywhere and a bucket under the ac unit. nothing is stable and everything is on the verge of being on fire at a moments notice.;0
34233260;HackerNews;2023-01-03;yeah i think this is one of the very few places where splitting out something as a microservice makes sense. for example you mostly never want to openprocessexamineglance at userprovided pdfs on a box with any sort of unfiltered network access. ideally you do what you need to do within a sandbox that has no network access but that's really hard to do performantly.the primary reason for this is that pdfs can contain executable code and the common tools used to process them are full of unpatched cves.;0
34233233;HackerNews;2023-01-03;people keep regurgitating this you aint going to be google mantra but i worked there and in reality generic microservice stack is in a totally different league of complexity and sophistication of what google and co have. this argument is basically reductio ad absurdum;0
34233200;HackerNews;2023-01-03;monoliths r hard. microservices r hard. pick your poison and get good.;0
34233198;HackerNews;2023-01-03;the technical and organisational measures you need in place to do it safely are an extra step you need to take whereas with microservices they're built inthey aren't built in it's just that the need for them is impossible to ignore. developers and management can't help but recognize and respect modularity in microservices because the separation of services and the apis between them make the modularity obvious. when the separation between modules only exists in code and even then only when seen through the eyes of someone who understands the modular architecture of the codebase it is easily ignored inevitably forgotten and might as well not exist at all.;0
34233175;HackerNews;2023-01-03;yes and no. the central part of data flowed naturally through services i.e. passed in requests and webhooks not in responses. microservices maintained local state as well though it was mostly small and disposable due to wholeintra crashonly design. for example we didn't hesitate to shut something down or hotfix it except for busfactor periods when there's only few of them. they could also go down by themselves or by upstream and routers avoided them automatically.;0
34233153;HackerNews;2023-01-03;there is no need to have the microservices built along conways lawthis is a misunderstanding of conway's law. your code will reflect the structure of your organization. if you use microservices so will their architecture. if you use modules so will the modules.if you want a specific architecture have your organization reflect the modulesmicroservices defined in that architecture.;0
34233138;HackerNews;2023-01-03;but there are rules of blame.with microservices as long as you maintain the contract with caller services you can deploy whenever you want. if you have some kind of issue your team is solely responsible. if the caller services do weird things they are responsible for fixing them.if you are pushing changes to a module as part of a more monolithic or wrapper service if you do a deploy and break the whole big service you are now responsible for the entirety of any issue which is now more likely due to integration risk and unrelated changes from others especially because now there need to be coordination across many teams integrating hopefully via tests and observability. but this requires a highdegree of maturity for automated quality assurance and site reliability. if you don't have that the operational risks are very high. so that alternative is having some opslike function or other integration team responsible. or doing more topdown waterfall coordination.given the service maturity needed is rare microservices distributes that operational ownership in a way where there is more accountability.;0
34233097;HackerNews;2023-01-03;for code modularity to serve the same purpose i think there needs to be explicit languagelevel support because on a mediumsized or larger project when the modularity exists only in the minds of developers it might as well not exist at all. you need virtually all of your developers to understand the design and respect the seriousness of violating it and beyond a certain project size that isn't possible.developers do a much better job with microservices. i think it's easy for them to respect the seriousness of designing and changing the api of a microservice. in contrast they often don't respect or even realize the seriousness of making a change that affects the modular design of code.languagelevel support for defining and enforcing module interfaces might help developers invest the same level of care for module boundaries in a modular monolith as they do in a microservices architecture but i've yet to work in a language that achieves this.;0
34233020;HackerNews;2023-01-03;microservices has little to do with tech. it is a way of organizing teams of ipeoplei funnelling all communication between teams through well defined specifications instead of adhoc meetings. it is not clear where static typing or lack thereof comes into play here.tdd is a method of documenting your application in a way that happens to be selfverifying. you icouldi use a word document instead but lose the ability for the machine to verify that the application does what the documentation claims that it should. static typing does provide some level of documentation as well but even if you have static typing available static typing isn't sufficient to convey the full intent that your documentation needs to convey to other developers.;0
34233016;HackerNews;2023-01-03;devil's advocate a few ways the easiest being to scale up the whole monolith with more instanceas far as i know there's no way to granularly scale up a monolith. if the monolith has 20 or 50 or 100 modules and you need 1 or 2 of them scaled you have to scale up the entire thing which is huge expensive etc. another way is run multiple services using the same codebase so you have workload segmentation either via synchronous network calls or async worker systems.this is interesting. a monolith with some form of ipc? why not do microservices at that point? that sounds like microservicesish?;0
34232952;HackerNews;2023-01-03;i think it runs a bit deeper than that. microservices are how the business views its self.look once upon a time managers designed the system that iworkersi implemented. the factory assembly line or the policy manual.but now the iworkersi are cpus and servers. the managers designing the system the workers follow are icodersi. i say coders are the new managers.now this leaves two problems. the first is that there are a lot of managers who are now doing the wrong job. and explains perfectly why steve jobs gets involved in emails about hiring coders. but that's a different post.for me the second problem is microservices represent the atomic parts of a business. they should not be seen as a technical solution to anything and because the first problem managers arent managing workers anymore there is no need to have the microservices built along conways law.and so if you want to build a microservice it is not enough to consider the technical needs it is not enough to automate what was there you need to design an atomic building block of any your company. they become the way you talk about the company the way you think about the processes in a company.an mostly the company becomes programmable. it is also highly likely the company becomes built mostly of interchangable parts.;0
34232927;HackerNews;2023-01-03;while i mostly agree i don't think it's so black and white on the enforcement part and i actually think that a lot of recent developments actually put holes into this.the typical example is that when you have to explain something is the job of x and y. usually this means that x and y are breaking those boundaries. just make a semiprivate or even public api only used for that thing and you have a broken boundary again. or push it on a message queue etc.i think it certainly helps but then again it doesn't prevent it. having modules you have the same effect.so in the end you get more spots where things can get wrong and more operational complexity. if you stick to using them right i think you can also stick to using modules right with less complexities better performance easier debugability fewer moving parts.hackers will find a way to do hacky things everywhere. also this whole discussion reminds me of linus discussing how he thinks micro kernels add complexity a very long time ago. not sure if they should be considered modules or microservices though.sharing global state and so on while maybe it shouldn't be done lightly without thinking about it can and does make sense. and in most modern environments it's not like the most ed issues can happen too easily.also i strongly agree with pointing out that this is actually a niche topic. it's mostly big because that niche is where probably the majority of hn and startup people spend their time.;0
34232865;HackerNews;2023-01-03;100 true for certain classes of problem.if i want to calculate the price of a stock option that's an excellent candidate to package into a module rather than to expose as a microservice. even if i have to support different runtimes as presented in the article it's trivial.a different class of problem that doesn't modularize well in shared library terms is something with a significant timing component or something with transient states. perhaps i need to ingest some data wait for some time a process the data and then continue. this is would likely benefit from being an isolated service unless all of the other system components have similar infrastructure capabilities for time management and ephemeral storage.;0
34232847;HackerNews;2023-01-03;and also with modules you need the business processes to coordinate deployments across teams because they all live in the same wrapper application. that's what stops them being independent.if we're being technical some languages support hot swapping modules so no restart would be needed. setting that aside restarting an application isn't anything that needs coordination today. you wouldn't even restart the application. you'd deploy a new version swap over and shut down the old version.you don't restart the network every time you deploy a microservice.no but something changes in the network configuration so that the other microservices are aware of the deployment.;0
34232836;HackerNews;2023-01-03;that backplane is not an implementation but a set of understood guiderails for intermodule communication.then why is the author even discussing microservices in the first place? following your logic they are an implementation detail just like modules.;0
34232817;HackerNews;2023-01-03;but most people need it a lot less than they think. normally the database is your bottleneck and if you keep your application server stateless you can just run lots of themat my last job there were quite a few times where being able to scale some small microservice instance up from 2 4 instances or 4 8 or 8 12 was a lot easierquicker than investigating the actual issue. it'd stop production outageshiccups. it was basically encouraged.not sure how that can be done with a it's all modules in a giant monolith.;0
34232689;HackerNews;2023-01-03;the biggest appeal to me for microservices which might be in the list in terms of maintainability but isn't explicitly called out is that it ienforcesi the modularization. yes i want modules. but no i don't have the discipline to actually keep a code base modular. platforms and languages have evolved for rapid development and convenience and realities for modularization that aren't architectural for example compilation units or deployment.a failed lookup of a function is greeted by do you want to import x so you can call foo?. having a battery of architectural unit tests or linters ensuring at module foo doesn't use module bar feels like a crutch.now it might seem like making microservices just to accomplish modularization seems like a massive overkill and sa huge overhead for what should be accomlished at the language level and you'd be right.but that leads to the second largest appeal which is closely related. the one thing that kills software is the big ball of mud where you can't ireallyi change that dependency move to the next platform version or switch a database provider. even in wellmodularized code you still share dependencies. you build all of it on react or all the data is using entity framework or postgres. because why not? why would you want multiple hassles when one hassle is enough? but this really also means that when something is a poor fit for a new module you shoehorn that module to use whatever all the other modules use postgres entity framework react.... with proper microservices at least in theory you should be able to use multiple versions of the same frameworks or different frameworks all together.it should also be said that modules vs microservices is also a dichotomy that mostly applies in one niche of software development websaas development. everywhere else they blur into one and the same but sometimes surfacing e.g. in a desktop app offloading some task to separate processes for stability or resource usage like a language server in an ide.;0
34232681;HackerNews;2023-01-03;i have to believe these antimicroservices articles tend to be written by people who just don't need microservices and maybe who also don't have much experience applying them to useful effect. amazon cited in the article as an originator of the practice is a perfect example of where microservices are virtually unavoidable and central to the success of the company. there is no way to amazon could have been built on on a small number of monoliths. none.;0
34232656;HackerNews;2023-01-03;modules aren't an alternative to microservices in a reasonable way though. and for all modules solve the modularization problem at the code level they don't really solve modularization at the service level. the main alternative to microservices is monoliths and for many applications i far prefer microservices to monoliths. i want modularization in how i scale my app i don't want to spin up a whole bunch of servers that can serve almost any possible function in production. i'd prefer more delineated responsibilities. i don't think modularization solves this if after the modules you just throw all your modules in one big bucket and serve that up.;0
34232623;HackerNews;2023-01-03;transaction boundaries are a critical aspect of a system.i've often noticed that these boundaries are not considered when carving out microservices.subsequently workarounds are put in place that tend to be complicated as they attempt to implement two phase commits.;0
34232568;HackerNews;2023-01-03;and also with modules you need the business processes to coordinate deployments across teams because they all live in the same wrapper application. that's what stops them being independent.you don't restart the network every time you deploy a microservice.;0
34232504;HackerNews;2023-01-03;you need to do additional steps in both caseswith modules you need some sort of wrapper application to bring it all together.with microservices you need some sort of network layer so that the microservices can talk to each other.;0
34232472;HackerNews;2023-01-03;i'm not so positive on every microservice maintaining its own copy of state potentially with its own separate data store. i think that usually adds more ongoing complexity in synchronization than it saves by isolating schemas. a better rule is for one service to own writes for a table and other services can only read that table and maybe even then not all columns or all nonowned tables.ill go one step further and say that you should treat your data stores as services in and of themselves with their own wellconsidered interfaces and perhaps something like postgrest as an adapter to the frontend if you dont really need sophisticated service layers. the readwrite pattern you recommend is a great fit for this and can be scaled horizontally with read replicas.;0
34232456;HackerNews;2023-01-03;the biggest draw of microservices to those just adopting them is not scalability or separation of concerns but independent deployability move fast and deploy new features in a particular area unencumbered.good luck getting that property with a monolithic or modular system. qe can never be certain and let's be honest they should be skeptical that something modified in the same codebase as something else does not directly break another unrelated feature entirely. it makes their life very difficult when they can't safely draw lines.two different modules sharing even a database when they have disparate concerns is just waiting to break.there's a lot of articles lately dumping on microservices and they're all antiquated. news flash there is no universal pattern that wins all the time.sometimes a monolith is better than modules is better than microservices. if you can't tell which is better or you are convinced one is always better the problem is with iyoui not the pattern.microservices net you a iloti of advantages at the expense of way higher operational complexity. if you don't think that trade off is worth it totally fair don't use them.since we are talking about middleground one i'd like to see one day is a deploy that puts all services in one pod so they all talk over unix socket and remove the network boundary. this allows you to have one deploy config specify each version of each service separately and therefore deploy whenever you want. it doesn't have the scalability part as much but you could add the network boundary later.;0
34232439;HackerNews;2023-01-03;or hardware. i worked on an hpc product which used microservices of a kind but many of them were tied to specific hardware nodes. so much of what we think of as microservices relies on a fairly narrow set of assumptions and mostly makes sense in specific contexts i.e. cloud apis etc.;0
34232422;HackerNews;2023-01-03;microservices as a named architectural pattern are over a decade old at this point. anyone jumping on them because they're the new hotness is more than a little behind the times. i have exactly the opposite problem though the kind of problems i have worked on so far would not be solved by leveraging large number of developers that can independently work on an equally large number of small modular programs with a very well defined concise interface.if you don't have multiple teams working on it and you don't have specific chunks of functionality that you need to scale orthogonally then you don't have the problems microservices solve. so don't use them. that seems uncontroversial to me. i still think that these scenarios are prevalent in any company which existed before the 90s but i might be wrong or biased on thisthis is survivorship bias in a sense. microservices only make sense where access to cpu and network is cheap and ondemand largely. that's only started to be an assumption you could really make since amazon's ec2 convinced the world's cios that fungible tin was better than their own racks.that means you don't see microservice architectures in older companies and you don't see problems being solved with them ieven where it might have made sense retrospectivelyi because it ops would never have been set up to enable it.today you don't need a big rewrite to justify introducing microservices where they're needed. that's a straw man. all you need is a team that will be able to move faster if their deployment is decoupled from everyone else's.but fundamentally if your problem area smells like bunch of business rules and a database then again if you don't have the problem that the architecture solves don't use it.;0
34232365;HackerNews;2023-01-03;time to throw the cat amongst the proverbial pigeons and start the year 2023 off with discord and disharmony.microservices are a solution to a problem. tdd is a solution to a problem the same problem. both are solutions that themselves create more and worse problems. thanks to the hype driven nature of software development the blast radius of these 'solutions' and their associated problems expands far beyond the people afflicted by the original problem.that problem? not using statically typed languages.tdd attempts to reconstruct a compiler poorly. and microservices tries to reconstruct encapsulation and code structure poorly. maybe if you don't use a language which gets hard to reason about beyond a few hundred lines you won't need to keep teams and codebases below a certain size. maybe if you can't do all kinds of dynamic nonsense with no guardrails you don't have to worry so much about all that code being in the same place. the emperor has no clothes he never had.edit to reduce the flame bait nature of the above a bit. not in all cases i'm sure there are a very few places and scales where microservices make sense. if you have one of those and you used this pattern correctly that's great.and splitting out components as services is not always bad and can make a lot of sense. it's the micro part of microservices that marks out this dreadful hypetrend pattern i object to. it's clearly a horrible hack to paper over the way dynamically typed codebases become much harder to reason about and maintain at scale. adding a bunch of much harder problems distributed transactions networks retries distributed state etc in order to preserve teams sanity instead of just using tooling that can enforce some sense of order.;0
34232248;HackerNews;2023-01-03;instagramdoes anyone have a microservice map of instagram? i feel that would be helpful here.;0
34232220;HackerNews;2023-01-03;same thing with microservices unless you do a blue green deployment have a planned shutdown load balancer in between releases...;0
34232166;HackerNews;2023-01-03;no personal project has any business using microservices unless it's specifically as a learning toy. use a monolith. monoliths can scale more than you can provided you manage not to limit yourself to the singlethread singleprocess version of a monolith. microservices are an iorganisationali tool for when you need to release chunks independently.i first wrote a program which ran on a web server about 25 years ago. in that time computers have experienced about ten doublings of moore's law i.e. are now over a ithousandi times faster. computers are very fast if you let them be.;0
34232096;HackerNews;2023-01-03;this has been my major criticism of them you cement the design of the app by creating an organizational structure around your software components.conway's law is basically you don't have a choice. you iwilli cement the design of your app around your organizational design. at least beyond a certain org size. if you have only 4 engineers you don't really have the sort of structure in question here at all. je42 narrowly beats me to the point that if this is a problem you can try to match your organization to your problem but that takes a fairly agile organization.what happens if you need to redesign the architecture to meet new needs? that's right it's not going to happen because people will fight it tooth and nail.unfortunately in the real world this is not so much a disadvantage to the microservice approach as simply an engineering constraint you will have to work around and take account in your design.despite what you may think after i've said that i'm inoti a microservice maximalist. microservices are a valuable tool in such a world but far from the ionlyi tool. as with everything the benefits iandi the costs must be accounted for. while i've not successfully rearchitected an entire organization from my position as engineer i have had some modest but very ireali success in moving little bits and pieces around to the correct team so that we don't have to build stupid microservices just to deal with internal organizational issues. i don't mean this to be interpreted as a defeatist you're doomed get ready for microservices everywhere and just deal with it there are other options. or at least there are other options in relatively healthy organizations.but you iwilli have code that matches the structure of your organization. you might as well harness that as much as you can for the benefits it can provide because you're stuck with it whether you like it or not. by that i mean as long as you are going to have teams structured around your services whether you like it or not go in with eyes open about this fact and make plans around it to minimize the inevitable costs while maximizing the benefits. belief that there is another option will inevitably lead to suboptimal outcomes.you can't engineer at an organizational level while thinking that you have an option of breaking the responsibility and authority over a codebase apart and somehow handing them out to separate teams. that never works long term. a lot of institutional malfunctioning that people correctly complain about on hn is at its core people who made this very mistake and the responsibility amp authority for something are mismatched. far from all of it there are other major pathologies in organizations of course. but making sure responsibility amp authority are moreorless in sync is one of the major checklist items in doing organizationlevel engineering.;0
34232094;HackerNews;2023-01-03;you can deploy modules independently but the technical and organisational measures you need in place to do it safely are an extra step you need to take whereas with microservices they're built in. modules live in the same execution context so you need a good shared ownership model for that context itself.the point is that parnas never conceived of doing it because he was writing about a world where the interfaces between modules were known ahead of time and were static.;0
34232062;HackerNews;2023-01-03;i usually say that microservices are a good concept. do everything to enable the split of your monolith then ..don't.;0
34231991;HackerNews;2023-01-03;huh? they can and will just add the things they want to the rest api of the microservice a and then call them from b. that doesn't change with microservices.look up a thing called distributed monolith.;0
34231903;HackerNews;2023-01-03;there is a high amount of correlation between people that start with microservices instead of using them to solve specific problems after they have the problem and people that lack any awareness about the resources they need.and both are way more common than they should be.;0
34231882;HackerNews;2023-01-03;microservices are an optimization. do not premature optimize.;0
34231863;HackerNews;2023-01-03;organizing teams around microservices makes ... a lot of sense?also talking of redesign should be a imajori lift for any productservice that has real paying clients. the risk of breaking is huge and the fact that during that time you won't be delivering incremental value is also going to look bad.;0
34231860;HackerNews;2023-01-03;the tweet is obviously wrong. i was told 1200 rpcs independently by several engineers at twitter which matches of microservices. the exemployee is wrong. same app in us takes 2 secs to refresh too long but 20 secs in india due to bad batchingverbose comms.rpcs are on the server side. why would they app take longer to refresh in india than in the us?some more explanation;0
34231850;HackerNews;2023-01-03;are there similar tools for modules like microservices for observability discoverability and documentation? i'm thinking something like backstage 1 that was featured on hn lately but for modules.1;0
34231817;HackerNews;2023-01-03;you know what's missing from all microservices discussions? an actual definition. at what point does a microservice stop being micro? 5kloc of python equivalent? 10k? 25k?;0
34231810;HackerNews;2023-01-03;could this be solved by consolidating service a and service b into one unit while maintaining the overall architecture? i know it's just an example but the whole point of microservices is to have the flexibility to rearchitect pieces without having to rewrite the entire project so potentially poor initial choices can be reworked over time.;0
34231733;HackerNews;2023-01-03;twitter seems to have adopted microservices in 2014 and in 2013 they had 200m mau presumably using a monolith architecture.even if microservices are better for scale most companies will never experience the level of scale of 2013 twitter.are microservices beneficial at much smaller levels of scale? ex 1m mau;0
34231678;HackerNews;2023-01-03;can you explain why you can deploy microservices independently but not modules?;0
34231677;HackerNews;2023-01-03;i really like modular designs but this article is missing some key limitations of monolithic applications also if they are really well modularized this is written mostly from the perspective of a java developer they force alignment on one language or at least runtime they force alignment of dependencies and their versions yes you can have different versions e.g. via java classloaders but that's getting tricky quickly you can't share them across module boundaries etc. they can require lots of ram if you have many modules with many classes semirelated fun fact i remember a situation where we hit the maximum number of class files a jar could have you loaded into weblogic they can be slow to start again classloading takes time they may be limiting in terms of technology choice you probably don't want ot have connections to an rdbms and neo4j and mongodb in one process they don't provide resource isolation between components a busy loop in one module eating up lots of cpu? bad luck for other modules. they take long to rebuild an redeploy unless you apply a large degree of discipline and engineering excellence to only rebuild changed modules while making sure no api contracts are broken they can be hard to test how does db setup of that other team's component work again?i am not saying that most of these issues cannot be overcome to the contrary i would love to see monoliths being built in a way where these problems don't exist. i've worked on massive monoliths which were extremely well modularized. those practical issues above were what was killing productivity and developer joy in these contexts.let's not pretend large monoliths don't pose specific challenges and folks moved to microservices for the last 15 years without good reason.;0
34231658;HackerNews;2023-01-03;yes. if you design a distributed system you need to consider the network traffic very carefully and choose your segmentation in such a way that you minimize traffic and still achieve good scalability.for this reason i've been trying to push for building a monolithic app first then splitting into components and introducing libs for common functionality. only when this is all done you think about the communication patterns and discuss how to scale the app.most microservice shops i've been in have instead done the nave thing just come up with random functionally separate things and put them in different micro services voting service login service user service etc. this can come with a very very high price. not only in terms of network traffic but also in debuggability having a high amount of code duplication and getting locked into the existing architecture cementing the design and functionality.;0
34231640;HackerNews;2023-01-03;here is an analogy that can inform the implications of this socalled imo architectureimagine if you are responsible at runtime for ilinkingi object files .o where each object is a just the compilation of a function.now why would anyone think this is a good idea as a general solution? because in software organizations the linkers job is supposed to be done by the unnecessary weight software architect.microservices iprimarilyi serve as a patch for teams incapable of designing modular ischemasi. because designing schemas is not entry level work and as we know se are not as effective after they pass 30 years of age. monolithunless monolith now means notmicroservice then be aware that there are a range of possible architectures between a monolith and microservices.;0
34231638;HackerNews;2023-01-03;you shoot yourself in the foot pretty hard regarding point 2 scalability if you have your microservices share a db.;0
34231564;HackerNews;2023-01-03;i agree that monoliths are the way to start many times especially if you're not actually sure you'll ever need to scale. one reason we do sometimes plan on microservices from the start with projects is separation of isecurityi concerns. easier to lock a publicfacing microservice down tight and have what's ostensibly a non publicfacing monolith call out to it.lots of ways to solve a problem though.;0
34231532;HackerNews;2023-01-03;this has been my major criticism of them you cement the design of the app by creating an organizational structure around your software components.what happens if you need to redesign the architecture to meet new needs? that's right it's not going to happen because people will fight it tooth and nail.you also cannot produce any meaningful enduser value without involving several teams.microservices is just backend frontend and database team reincarnated.my take do microservices all you want but don't organize teams around the services!;0
34231520;HackerNews;2023-01-03;at the heart of microservices we're told we'll find...well in our 20 product teams with all serving different workflows for 3 different user types the separate micro services are doing wonders for us for exactly the things you've listed.my comment should just stop here to be honest.;0
34231519;HackerNews;2023-01-03;are organizations ever capable of enforcing coding standards even remotely close to that of what microservices should provide? because i have not seen it.however this is muddied by the fact that i almost never see microservices i see a lot of distributed monoliths tho.;0
34231490;HackerNews;2023-01-03;microservices might be a hack to gain modularity when nothing else works.;0
34231468;HackerNews;2023-01-03;i agree and yet most microservice zealots seem to have a different opinion on this.e.g. 2.1. fundamentals by definition microservices should be loosely coupled scalable and independent in terms of development and deployment. itherefore the database per service is a preferred approach as it perfectly meets those requirements.i lets see how it looksplease understand that i have worked only on monoliths and will probably retire while still working on monoliths. this kind of absurd positions only come up when someone comes to my office with some grand plan to convert the application i work on to something more microservice oriented.;0
34231466;HackerNews;2023-01-03;yeah i've always thought that microservices shine when the org chart defines them. i've been on teams where we were responsible for multiple microservices and it was so annoying to have to bounce back and forth between code bases and deployments and then it was super easy to intertwine different microservices when you were in the them so often. i feel like if you don't have a team dedicated full time per microservice then you probably shouldn't be using that architecture.;0
34231438;HackerNews;2023-01-03;modules can not constrain resource boundaries microservices can. this is often overlooked.;0
34231408;HackerNews;2023-01-03;in theory microservice is cool. in practice it's not.microservice and modularity is orthogonal it's not the same.modularity is related to business concept microservice is related to infrastructure concept.for example i could have a module a which is deployed into microservide a1 and a2. in this case a is almost abstract concept.and of course i could deploy all modules a b c using 1 big service monothlic.moreover i could share one microservice x for all modules.all confusion from microservice is made from the misconception that microservice module.worse most of expert advice which i've learnt actually relate domain driven design to microservice. they're not related again.microservice to me is to scale. scale the infrastructure. scale the team management concept.;0
34231406;HackerNews;2023-01-03;ah come on there is a reason why we start most estimates with it depends.it's on the same page as yes we could have written this in assembler better or this could simply be a daemon why is it a container?as if an agile gitops based rootlessly built microservice oriented worldwide clustered app will magially solve all your problems dif i learned anything it's to expect problems and build a stack that is dynamic enough to react. and that any modern stack includes the people managing it just as much as the code.but yes back when asp.net mvc came out i too wanted to rebuild the world using c modules.;0
34231394;HackerNews;2023-01-03;those boundaries also increase the cost of development. if you are institutionally incapable of enforcing coding standards such that you can't prevent juniors from coupling your modules perhaps it's worth it. but there are more efficient ways to build and run an engineering organization.the best place for such boundaries is at the teamdivisionorg level not teaminternal or single devinternal like microservices implies with its name. embrace conway's law in your architecture and don't subdivide within a service.;0
34231388;HackerNews;2023-01-03;did you have a common centralized data store or did each and every microservice manage their own instance?because this is at the same time one of the defining elements of this architecture... and the first one to be opted out when you actually start using it for real.;0
34231375;HackerNews;2023-01-03;ive never seen that in practice. you dont have a database for each individual lambda. thats insanity. you can have multiple microservices point to a shared datasource its not illegal.;0
34231355;HackerNews;2023-01-03;well this is a surprisingly common case in my experience except that the people were not right out of high school but right out of a company funded seminar on microservices.;0
34231353;HackerNews;2023-01-03;there are two things that people often misunderstand about microservices there is no single definition about what they actually are and arguably more importantly there exists no single rationale about why you would want to move to microservice architecture in the first place.take for example gartner's definition a microservice is a serviceoriented application component that is tightly scoped strongly encapsulated loosely coupled independently deployable and independently scalable.that's not too controversial. but... as a team why and when would you want to implement something like this? again let's ask gartner. here are excerpts from should your team be using microservice architectures? in fact if you arent trying to implement a continuous delivery practice you are better off using a more coarsegrained architectural model what gartner calls mesh app and service architecture and miniservices. if your software engineering team has already adopted miniservices and agile devops and continuous delivery practices but you still arent able to achieve your software engineering cadence goals then it may be time to adopt a microservices architecture.for gartner the strength of microservice architecture lies in delivery cadence and it shouldn't even be the first thing you look at to achieve this. for another institution it could be something else. my point is that when people talk about things like microservices they are often at crosspurposes.;0
34231335;HackerNews;2023-01-03;i have exactly the opposite problem though the kind of problems i have worked on so far would not be solved by leveraging large number of developers that can independently work on an equally large number of small modular programs with a very well defined concise interface.and this is not because my stuff is complicated and your stuff is a toy either. it's more like erp or banking systems were deployed decades ago started as monoliths and nobody can really afford to rewrite these from scratch to leverage microservices or whatever the next fad will be. i am also not sure it is a good idea in general for transactions that have to handlepersist lots of state but this could be debated.the problem in fact is that new guys think that microservices will magically solve that problem too want to use these because they are cool and popular this year and waste and make me waste lots of time before admitting something that was clear from day 1 microservices are not a good fit for these scenarios.i still think that these scenarios are prevalent in any company which existed before the 90s but i might be wrong or biased on this.;0
34231327;HackerNews;2023-01-03;parnas was writing under an assumption of bduf bigbang releases and expensive hardware instances. as soon as you want to decouple module deployments and accommodate changing requirements over time you need something else. that something else might be making sure your modular monolith has a good enough test suite that any team can deploy it with only their changes or it might be microservices for all but parnas' assumption that independently verified modules will need to be built once by independent teams then function correctly when assembled has been comprehensively squashed in the last 50 years.he's right as far as conway's law goes though.;0
34231271;HackerNews;2023-01-03;i think most criticisms around microservices are about good practices and skills beating microservices in theory.and the virtue of microservices is that they create hard boundaries no matter your skill and seniority level. any unsupervised junior will probably dissolve the module boundaries. but they can't simply dissolve the hard boundary of having a service in another location.;0
34231267;HackerNews;2023-01-03;would be interesting to learn how your or any other team defines borders of a microservice. iow how micro they are and in which aspect. i guess without these details it will be hard to reason about it.at my last job we created a whole fleet of microservices instead of a single modular projectrepo. some of them required nontrivial dependencies. some executed pretty longrunning tasks or jobs for which network latency is insignificant and will remain so by design. some were few pages long some consisted of similarpurpose modules with shared parts factored out. but there was no or little processes like ah ill just ask m8 and it will ask m11 and it will check auth and refer to a database. i.e. no calls as trivial as foobarbaz but done all over the infra.;0
34231258;HackerNews;2023-01-03;ino you don't use separate microservices for writing out that text message.ibut in order to find out that genua is the name of the port from where the cruise is departing the appropriate time converted to the timezone of the port or the timezone of the client who will see this message depending on what business rule you want to apply and that genua is in ititaly... how many microservices do i have to query considering that port data timezones iso country codes and dep.datetime of the cruise are presumably managed on at least four different data stores?;0
34231251;HackerNews;2023-01-03;couldnt agree more.the way i usually describe my preferred heuristic to decide between modules and microservices isif you need to deploy the different parts of your software individually and theres a cost of opportunity in simply adopting a release train approach go for microservices.otherwise isolated modules are enough in the vast majority of cases.;0
34231223;HackerNews;2023-01-03;they solve specific problems. if they don't solve a problem you have then using them is probably a mistake.the thing is that the framing of the problems we use computers for misses the entire domain of problems that microservices solve. they solve organisational problems not computational ones.;0
34231222;HackerNews;2023-01-03;both modularization and microservices solve scaling problems.modularization allows development to scale.microservices allow operations to scale.;0
34231180;HackerNews;2023-01-03;unfortunately this is also partly correct the team was young and people were eager to play around and learn how to work with microservices.;0
34231177;HackerNews;2023-01-03;in which case the next step for your org is a mandate that all microservices be available in all datacenters.let each microservice owner figure out how to achieve their latencyreliability sla's in every location whether replicating datastores caching being stateless or proxying requests to a master location.;0
34231140;HackerNews;2023-01-03;the distinct elements are they compile separately and have versioning on their api calls.no you don't use separate microservices for writing out that text message.the idea is pretty simple instead of writing one big program you write many smaller programs.it's useful around the 3 to 4 separate developers mark.it avoids you having to recompile for any minor change allows you run the tests for just the part you changed and allows you to test the microservices in isolation.if you a production issue the exception will be in a log file that corresponds to a single microservice or part of your codebase.microservices are a hard form of encapsulation and gives a lot of benefits when the underlying language lacks that encapsulation. e.g. python.;0
34231135;HackerNews;2023-01-03;this article nails it but i still like microservices because ive yet to see a team doing a modular architecture in memory keep from creating a spaghetti mess of interdependence.yes the same often happens in microservices but the extra complexity of a distributed system provides a slightly stronger nudge to decouple that means some teams at the margin do achieve something modular.im something of a skeptic on modular monoliths until we as an industry adopt practices that encourage decoupling more than we currently do.yes in theory theyre the same as microservices without the distributed complexity but in practice microservices provide slightly better frictionincentives to decouple.;0
34231129;HackerNews;2023-01-03;someone must have read a blog post about microservice and decided it would look good on their resume.;0
34231128;HackerNews;2023-01-03;one of the unexpected consequences is that we are now doing a lot of network calls between these microservicesnot trying to be harsh here but inoti expecting an increase of network call in a system where each component is tied together with... network calls sounds a bit naive. we are now attempting to solve this with caches and doing batch requestsso you have built a complex and bottlenecked application for the sake of scalability then having to add caching and batching just to make it perform? that sounds like working backwards.obviously i have no clue on the scale of the project you are working on but it sure sounds like you could have built it as a monolith in half of the time with orders of magnitude more performance.scalability is a feature you can always add it in the future.;0
34231126;HackerNews;2023-01-03;totally agree. also microservices shines if you need different release schedule for two services. if they are managed in the same projectteam the effort you pay is high the advantage could not pay your bill so be careful in such scenario.;0
34231121;HackerNews;2023-01-03;some of the services not being in the same datacentre seems orthoganal. if that solves a problem you have wouldn't it still be an issue in a nonmicroservices design?;0
34231113;HackerNews;2023-01-03;microservices .. actually solve for a human problem in scaling up an organization.so does modularity.the benefits expected of modular programming are 1 managerialdevelopment time should be shortened because separate groups would work on each module with little need for communication...ion the criteria to be used in decomposing systems into modulesi d.l. parnas 1972.;0
34231112;HackerNews;2023-01-03;this article is all over the place. the author acknowledges that microservices are about organizational clarity then writes in theory anyway without elaboration and itheni goes on to talk about the latency impact of networklevel ipc.why do we care about network latency when we just established that microservices are about scaling large development teams? i have no problem with hackers ranting about slow bloated and messy software architecture...but this is not the focus of discussion as presented in the article.and then this conclusion the key is to establish that common architectural backplane with wellunderstood integration and communication conventions whatever you want or need it to be....so like grpc over http? last time i checked grpc is pretty well understood from an integration perspective. much better than enterprise java beans from the last century. isn't this ironic? and where are the performance considerations for this backplane? didn't we criticize microservices before because they have substandard performance?;0
34231090;HackerNews;2023-01-03;i think a lot of microservices are defined as separate apps and code repositories. this sounds good for initial build and deployment but the long term maintenance is the issue. developers like the idea of independence of other teams writing parts of the overall solution but that tradeoff can mean a lot of overhead in maintaining different code repositories of the same stack.when a critical vulnerability comes out for whatever language you are using you now have to patch test and deploy x appsrepos vs much fewer if they are consolidated repositories written modularly. same can be said for libraryframework upgrades breaking changes in versions deprecated features taking advantage of new features etc.keeping the definition of runtimes as modular as the code can be instrumental in keeping a bunch of related modulesfeatures in one applicationrepository. one way is with k8s deployments and init params where the app starts specific modules which then lends itself to be scaled differently. i'm sure there are homegrown ways to do this too without k8s.;0
34231053;HackerNews;2023-01-03;however one of the unexpected consequenceshow the hell... like... who decided to do microservices in the first place if they didn't know this? this is such a rookie mistake. it's like somebody right out of high school just read on a blog the new way is microservices and then went ahead with it.;0
34231050;HackerNews;2023-01-03;imo the real problem with microservices comes from dealing with distributed state going from one data store with usually strong consistency guarantees to many distributed stores that have no way of ensuring they are in sync is the hard part.rpc vs local calls is trivial in comparison and you can get that level of transparency out of the box with functional programming it's just data in data out.;0
34231022;HackerNews;2023-01-03;i am working on a project that uses a microservice architecture to make the individual components scalable and separate the concerns. however one of the unexpected consequences is that we are now doing a lot of network calls between these microservices and this has actually become the main speed bottleneck for our program especially since some of these services are not even in the same data center. we are now attempting to solve this with caches and doing batch requests but all of this created additional overhead that could have all been avoided by not using microservices.this experience has strongly impacted my view of microservices and for all personal projects i will develop in the future i will stick with a monolith until much later instead of starting with microservices.;0
34231020;HackerNews;2023-01-03;microservices while often sold as solving a technical problem usually actually solve for a human problem in scaling up an organization.there's two technical problems that microservices purport to solve modularization separation of concerns hiding implementation document interface and all that good stuff and scalability being able to increase the amount of compute memory and io to the specific modules that need it.the first problem modules can be solved at the language level. modules can do that job and that's the point of this blog post.the second problem scalability is harder to solve at the language level in most languages outside those designed to be run in a distributed environment. but most people need it a lot less than they think. normally the database is your bottleneck and if you keep your application server stateless you can just run lots of them the database can eventually be a bottleneck but you can scale up databases ia loti.the real reason that microservices may make sense is because they keep people honest around module boundaries. they make it much harder to retain access to persistent inmemory state harder to navigate object graphs to take dependencies on things they shouldn't harder to create prs with complex changes on either side of a module boundary without a conversation about designing for change and future proofing. code ownership by teams is something you need as an organization scales if only to reduce the amount of context switching that developers need to do if treated as fully fungible owning a service is more defensible than owning a module since the team will own release schedules and quality gating.i'm not so positive on every microservice maintaining its own copy of state potentially with its own separate data store. i think that usually adds more ongoing complexity in synchronization than it saves by isolating schemas. a better rule is for one service to own writes for a table and other services can only read that table and maybe even then not all columns or all nonowned tables. problems with state synchronization are one of the most common failure modes in distributed applications where queues get backed up retries of bad events cause blockages and so on.;0
34231014;HackerNews;2023-01-03;as someone who has personally dealt with files as large as 60k lines i disagree completely. i believe instead that structure and organization should be added as a business and codebase scales. the problem i think most orgs make is that as they grow more successful they don't take the time reorganize the system to support the growth so as the business scales 100x in employee account employee efficiency is hampered by a code organization that was optimized for being small and nimble.it gets worse when the people who made the mess quit or move on leaving the new hires to deal with it. i've seen this pattern enough times to wonder if it gets repeated with most companies or projects.i do agree that microservices andor modules aren't magical solutions that should be universally applied. but they can be useful tools depending on the situation to organize or reorganize a system for particular purposes.anecdotally i've noticed that smart people who aren't good programmers tend to be able to write code quickly that can scale to a particular point like 10k100k lines of code. past that point productivity falls rapidly. i do believe that part of being a skilled developer is being able to both design a system that scales to millions of lines of code across an organization and to operate well on one designed by someone else.;0
34230950;HackerNews;2023-01-03;this article seems to have missed 16 years of eventbased architectures domain driven design bound contexts cqrs and pretty much every reason we use microservices.;0
34230947;HackerNews;2023-01-03;you scale the component containing your module to multiple nodes same with microservices same with monoliths. the only reason it might be hard is if some other module in the component is aggressively preallocating resources even when lightly used and that is a problem to be solved by itself orthogonal to the deployment strategywith a good branching strategy;0
34230923;HackerNews;2023-01-03;the article above and most if not all the comments i read right before posting this seem to be very quiet about what i thought was one of the main distinctive elements of microservices.i.e. the idea that each microservice has direct access to its own dedicated maybe duplicated storage schemainstance or if it needs to know for example the country name for iso code uk it is supposed to ... invoke another microservice that will provide the answer for this.i always worked in pretty boring stuff like managing reservations for cruise ships or planning production for the next six weeks in an automotive plant.the idea of having a federation of servicesmodules constantly crosscalling each other in order to just write your cruise departs from genova italy at 1215 on may 24th 2023 is not really a good fit for this kind of problems.maybe it is time to accept that not everyone has to work on the next version of instagram and that microservices are probably a good strategy... for a not really big subset of the problems we use computers for?;0
34230920;HackerNews;2023-01-03;you want to get away from sweeping generalisations because once the buildtestpackagedeployment tax of a modules approach bites you do want to go monorepo microservices its free clawback of time wasted building and deploying all the parts of a huge system that you didnt change in your pr.;0
34230910;HackerNews;2023-01-03;i can't say i agree with all your okays although if you prefix them with in some cases it's okay then i understand where you're coming from.the problem is when it's ok and for how long. if you have a team of people working with a codebase with all those okays then they have to be really good developers and know the code inside out. they have to agree when to refactor a business login out instead of adding a hacky if condition nested in another hacky if condition that depends on another argument andor state.i guess what i'm trying to say that if those okays are in place then there's a whole bunch of unwritten rules that come in place.but i agree that microservices certainly aren't free i'd say they are crazy expensive and modules aren't free either. but all those okays can end up costing you your codebase also.;0
34230907;HackerNews;2023-01-03;yes generally that's what we want modularity. i think the article touches upon a key truth that there is nothing new under the sun we always deal with complexity and we always find the same ways of structuring our responses to it.one thing i've observed in a microserviceheavy shop before was that there was the preferred language and the preferred best practices and they were the same or very similar across the multiple teams responsible for different things. it lead to a curious phenomenon where despite the architectural modularity the overall saas solution built upon these services felt very monolithic. it seemed counterproductive because it weakened the motivation to keep separation across boundaries.;0
34230904;HackerNews;2023-01-03;if the same thing is said about a and b it is not guaranteed that ab unless that thing specifies equality. anyway i agree with the article that microservices are basically modules. they extend the domain of modules. they're usually overhyped.;0
34230874;HackerNews;2023-01-03;you want elixir and erlangotp process trees not microservices.;0
34230854;HackerNews;2023-01-03;i'm unsure how to sell this idea. i don't want to force my view on others until i truly understand the problem that they're trying to solve with modulesmicroservices.for searching multiple files ripgrep works really well in neovim 1;0
34230828;HackerNews;2023-01-03;this is the usual don't use a one size fits all solution sometimes microservices are good sometimes they're bad. just be smart and think about why you're doing things before doing them.;0
34230816;HackerNews;2023-01-03;modules are lot cheaper if you have a solver for them.microservices are the same modules. though they forceadd distributiveness even where it can be avoided which is fundamentally worse. and they make integration and many other things lot harder.;0
34230782;HackerNews;2023-01-03;how can i sell your idea?i easily find my way in messy codes with grep. with modules i need to know where to search to begin with and in which version.fortunately i have never had the occasion to deal with microservices.;0
34230748;HackerNews;2023-01-03;i suspect that most people would be better off favoring inlined code over modules and microservices.it's okay to not organize your code. it's okay to have files with 10000 lines. it's okay not to put business logic in a special place. it's okay to make merge conflicts.the overhead devs spend worrying about code organization may vastly exceed the amount of time floundering with messy programs.microservices aren't free and neither are modules.1 jonathan blow rant 2 jon carmack rant;0
