ID;Source;Creation Date;Content;Sentiment
12133670;HackerNews;2016-07-21;Title:The End of Microservices, Content: http://lightstep.com/blog/the-end-of-microservices/;0

12146612;HackerNews;2016-07-22;...so what is a new concept regarding microservices?i don't see anything new... new tools granted. then again there's new tools being produced every day for every architectural style.;0
12142662;HackerNews;2016-07-22;i described some of the benefits i am currently experiencing from using microservices where we previously had a monolith.sure i do appreciate it. it's just that my experience in a company that used both was that the microservices weren't worth it more generally i think a lot of people leap on microservices without thinking about other ways to achieve what they want so i want to fully work through the options. spinning up multiple components generally takes a few seconds once the image is built as it is not much more involved than spinning up a new docker container of an image that is already pulled. each image might take a couple of minutes to build but because there are no hard dependencies between images unlike libraries in a monolith any amount of them can be building and deploying in parallel.you can do a parallelized build for a monolith too each component can build in parallel. assembling the final image obv. has to be done at the end but it's a small part of the build time. it doesn't really matter how fast the whole thing can be builtanddeployed before because in a monolith you need every developer building and deploying their own library versions as well as the monolith. meaning not only do your changes to production have to wait in the queue for everyone else's but you unintentionally pick up work from other folks along the way. that road leads down to the environment you describe where every developer needs at some point to spin up their own dev instance and live on their own branch just to be able to test in isolation resulting in an organization that requires merging building and deploying several times along the way in different environments before the change finally reaches production.if your team structure is such that you need individually versioned components which has its pluses and minuses you can do that while still having a single final deployable. i also described a perfect use case of an http interface or rpc or whatever language agnostic interface you want to use it doesn't matter to me and rarely matters in the real world. data science work is often in a different language space than web work. i'm not going to bundle native pythonrclojure dependencies with my node.js apps. it's too much work to maintain those bindings between runtime versions and app versions. i'm not going to force data scientists to use js because the library ecosystem is targeted toward completely different use cases. with http or rpc or whatever transport each team can use the best tools for the job.i think it's worth mentioning a lot of people jump to http without thinking when actually something like thrift is much better suited to an rpclike use case.i've actually come to think that the best languages are generalpurpose languages and you should just use one language scala for everything. i accept that that's a minority viewpoint though.;0
12142043;HackerNews;2016-07-22;this comment is made all the more humorous by the fact that google doesn't actually do microservices internally. they have no qualms about building giant monolithic binaries for things and split things out based on the need not some blind architectural fetish. the reason being they don't like to be woken up by their pagers.;0
12141413;HackerNews;2016-07-22;yeah we were debating about whether i should write a post about the end of servers instead of the end of microservices. i thought we'd get a livelier discussion with microservices but i totally agree that they are already getting to be yesterday's buzz word.;0
12141405;HackerNews;2016-07-22;i wrote the post with pretty rosecolored glasses on. i totally agree that microservices can be a form of premature optimization in particular because of the cost with today's tooling. but i think there's hope that lot of those costs will go down both in terms of dev time and infrastructure with things like aws lambda etc.anyway if devs think a little more about the interfaces i think that will be a good thing.;0
12139839;HackerNews;2016-07-21;the real reason is that by having these microservices it allows single developers or teams to own or control parts of the codebase ... sally can't see the code to joe's service and joe can't make requests to sally's production instance... specifically like a microservice allows encapsulation of functionality it also allows encapsulation of blamei think the example of joe's and sally in parent 1 and your comment makes the point in microservices. during various web services integrations developers not only may blame specific part of system as faulty but also helps follow rule 'do not test your own code'. i remember few situation in premicroservices era when during developing new api wrapper developers discovered a flaw in the remote web service e.g. parameter doesn't change state nondocumented error code or raw java exception as response. in these cases owners of the api are are usually notified about issue so we may expect that will be fixed.i agree with you that is hard way to advocate either way is better. it is worth noting that creating a micro services leads to problem which may end with duplicating creating monolithic code to provide possibility to communicate between the hosts imagine mesh network.1;0
12139638;HackerNews;2016-07-21;i described some of the benefits i am currently experiencing from using microservices where we previously had a monolith.spinning up multiple components generally takes a few seconds once the image is built as it is not much more involved than spinning up a new docker container of an image that is already pulled. each image might take a couple of minutes to build but because there are no hard dependencies between images unlike libraries in a monolith any amount of them can be building and deploying in parallel.it doesn't really matter how fast the whole thing can be builtanddeployed before because in a monolith you need every developer building and deploying their own library versions as well as the monolith. meaning not only do your changes to production have to wait in the queue for everyone else's but you unintentionally pick up work from other folks along the way. that road leads down to the environment you describe where every developer needs at some point to spin up their own dev instance and live on their own branch just to be able to test in isolation resulting in an organization that requires merging building and deploying several times along the way in different environments before the change finally reaches production.i also described a perfect use case of an http interface or rpc or whatever language agnostic interface you want to use it doesn't matter to me and rarely matters in the real world. data science work is often in a different language space than web work. i'm not going to bundle native pythonrclojure dependencies with my node.js apps. it's too much work to maintain those bindings between runtime versions and app versions. i'm not going to force data scientists to use js because the library ecosystem is targeted toward completely different use cases. with http or rpc or whatever transport each team can use the best tools for the job.;0
12139317;HackerNews;2016-07-21;can you elaborate why? presumably with microservices you're always running the latest version whereas you're mentioning a need for different branches and versions in your comment.not necessarily. depends on the needs of the customer and what we deploy to them. in general we try to deploy the most recent version of everything when we make a release for a particular customer.the issue we have with our builds is dependency management. as a note below that in itself is something that could be addressed by refactoring our projects1. because of the way we need to deploy our software shaded uberjars even a wellstructured dependency hierarchy would result in large data updates every time we had to update the monolithic application. microservices don't force you to modularize you can still make a mess by not cleanly separating things or by cutting across the wrong boundary. you modularized well because you created a clean separated thoughtout architecture not because of any intrinsic property of microservices.they don't force you to modularize iwelli. but they force you to think about how to break your application up. you still need the systems engineering to break it up well.you're right that services aren't the only way or necessarily the best way to accomplish this. we could get the modularization just by refactoring the organization of out projects. in the absence of the requirements for thirdparty integration and an actual need for horizontal scalability that is what i would have done. alltotaled though i think the service paradigm was the right way to go for us.i need to note for context that the software we write and deliver needs to be delivered on physical disks yes we still literally ship software and that deployment size is an issue. we also can't guarantee that we will have access to anything besides a windows or linux jvm so our deployment needs to drag all of its supporting data along with it. being able to simply deploy a new version of a particular service makes updates much less painful.1 and actually using versions for our maven artifacts but that is a battle i lost a long time ago...;0
12138303;HackerNews;2016-07-21;the microservice maybe not micro but definitely service architecture we are moving to will allow us to compose applications with reusable building blocks more easily than trying to maintain different git branches and library versions.can you elaborate why? presumably with microservices you're always running the latest version whereas you're mentioning a need for different branches and versions in your comment.microservices don't iforcei you to modularize you can still make a mess by not cleanly separating things or by cutting across the wrong boundary. you modularized well because you created a clean separated thoughtout architecture not because of any intrinsic property of microservices.;0
12138251;HackerNews;2016-07-21;there is software and concepts around managing microservices that didn't exist before and so on. nothing can be new when you use such a vague way of comparing things. there were electric cars in the 1800s why talk about tesla?;0
12138190;HackerNews;2016-07-21;microservices aren't distributed objects;0
12137936;HackerNews;2016-07-21;every generation's microlith is the next generation's monolith.for this generation the end of microservices will be when we can look at a cluster as one big unit and deploy a microlithic monolith on it.for the next generation who knows how they will slice it up.;0
12137824;HackerNews;2016-07-21;1. being able to scale individual smaller components rather than one giant applicationwhy does the size of the application matter? sure it'll take up a little more disk space maybe even some memory but probably less than the overhead of splitting into components. two copies of a monolith wastes less ram etc. than five components of which you deploy two copies of one. 2. being able to buildanddeploy any one module much faster than one monolithic bundle of local dependenciesmaybe but first see if you can make buildanddeploy of the whole thing fast. remember that microservices will slow you down a lot in the case where you do need to spin up multiple components e.g. every time you spin up a dev instance. 3. universal interface with languageagnostic applications. do you need to expose big data statistical analytics but can't find data engineers that are comfortable with javanode.jsgo? doesn't matter hire the best ones and let them use pythonrclojure. http doesn't care.when you have an actual use case for a http interface then of course you should expose one. but most of the time yagni.;0
12137587;HackerNews;2016-07-21;libraries typically don't have databases or daemons. it's operationally very different.can i envision a languagespecific framework wherein microservices are just plugins that implement interfaces java interfaces for example for exposing rpc endpoints which you then mount in your framework allowing developerenforced separation of concerns but still allowing a single codebase to share things like config structures database accessibility etc.?sure. i can't imagine why anyone would want to do it that way though. for example you couldn't realistically opensource one of your services or write it in a different language. servicespecific database stuff would get hairy quickly. and so on.;0
12137554;HackerNews;2016-07-21;you missed my point. i did not say reusability is the ionlyi factor that dictates the use of microservices.if we wrote everything as one big service we'd lose the dozenorso benefits of microservices.hypothetically if we rewrote what we have today as one big monolith we couldn't selectively opensource parts of it. it'd really all have to be a single language as opposed to the three we use right now. ...and if we decided to change the language like we're in the process of doing with a transition from ruby to go node.js we'd have to rewrite all of it. deployment would be potentially more brittle since you're deploying a single codebase. our apps are designed to gracefully tolerate partial unavailability. we'd have to be careful to control individual services' resource footprint. we have some services which are super light and have very few dependencies they don't carry a monolith on their back. we'd have to jam in productspecific stuff for n different products into a single codebase. some of our microservices iaren'ti reusable they're completely productspecific. squishing lots of unrelated concerns into a single codebase is not feasible. developers would be trying to tightly couple services and violate separation of concerns faster than you can spell technical debt....and so forth.maybe i didn't articulate it well enough but my original point was that microservices are great ifor all sorts of reasonsi but ialsoi a toooften missed point is the benefits of reusability if you just design thing right.put differently microservices are a lot less powerful if you idon'ti design them for reusability and as a prerequisite multitenancy;0
12137471;HackerNews;2016-07-21;the reality is that microservices add a whole host of failure modes for just one benefit over monoliths they are easier to scale horizontally. if you don't absolutely need horizontal scalability and not many companies do then you'd be foolish to pay the large cost.if you are writing and deploying standalone applications i agree. microservices do have another benefit though forcing the application to be modularized. there are better ways to do that though like having proper systems engineering lay out the application architecture.if you are writing applications that need to be integrated with thirdparty applications or need to be configured with different functionality for different customers microservices can still make sense. this is what has pushed my company in that direction. we currently have a set of monolithic applications with varying but overlapping functionality and customers who want feature x from application y and feature w from application z plus feature v that we are developing just for them. our code has become a mess of curricular dependencies and duplicated code in order to meet these desires.the microservice maybe not imicroi but definitely service architecture we are moving to will allow us to compose applications with reusable building blocks more easily than trying to maintain different git branches and library versions. it also allows us to better manage the noncode resources we need to deploy as we have hundreds of gigs of data resources used by various libraries. furthermore we will be able to deploy applications with either our inhouse gui and command line tools as well as provide the apis necessary for our customers to integrate our applications into their own thirdparty frameworks.;0
12137452;HackerNews;2016-07-21;i agree about fiefdoms and want to address a particular aspect of that pattern somewhat complementary to yours that i've seen at least in the very large organization that i'm a member of.specifically like a microservice allows encapsulation of functionality it also allows encapsulation of blame1. in a monolith from whence the org i'm in came a build failure or test regression could be caused by any number of failures across any number of horizontal bands in the organization. oh the build automation crashed because the build team updated to the latest version of java but the build didn't. oh the ui filters stopped working because the api team changed something without deprecating. it meant that development in spite of agile efforts still had a ticktock cadence where breaks halted work and tracking down the responsible parties and getting things fixed might take time a lot of areas with deep specialties required to understand why something might be wrong. this also meant because of the way the organization was structured and the way the build was structured that pressure was directed along very hierarchical routes. managers saw bugs from customers and pressured testers and devops people who maintained automation to investigate causes and transfer responsiblity to developers who might be able to actually fix the problems.as we've been decomposing into microservices and likewise aligning along feature teams the blame gets allocated at apiservice interfaces2 instead of topdown. since the build deployment uptime and algorithmic functionality of each service is theoretically the domain of a single team the blameflow is more distributed and simple. an algorithmic bug a build bug and an availability issue are all addressed the same way report the issue to the team responsible for that service and let them work it out.i'm not advocating that either way is better. there were nice aspects about a singlelocation debug tree in the monolith. i've seen teams that have become experts at deflecting blame and thus slow down the entire broader effort. and i know i'm possibly conflating two paradigms inappropriately feature teams and microservices. just a notable pattern to my eyes.1 i don't necessarily mean 'blame' here in a pejorative sense. perhaps 'responsibility' would be a more neutral term.2 steve yegge describes to this being a top priority during amazon's serviceplatform decomposition.;0
12137230;HackerNews;2016-07-21;microservices are for organizations that can't seem to enforce encapsulation at the object level.devs not creating good interfaces in oo design? stick them on a different server that ought to show them. of course now your spaghettified object hierarchies are spaghettified api call hierarchies.;0
12137089;HackerNews;2016-07-21;i do agree that people tend to overcomplicate their architectures initially this is premature optimization of another form. that being said microservices don't need to be written in the host language nor do you need to deal with creating wrappers. granted interacting with kafkaampq isn't frictionless. microservices can be upgraded or scaled out individually without touching the larger application as a whole. microservice calls can be deferred and scheduled easily.;0
12136852;HackerNews;2016-07-21;i joined a company where the proof of concept had inevitably become the monolithic application we would work on for the next two years. everyone on the team agreed that the monolith would be a liability so we started to share knowledge on microservices and plan for that in the future. to do this we stuck to a handful of rules. systems should do one thing and do it well with a well defined api and protocol. whilst all the data may be in the same redis and mysql instance we made the data store configurable as well its location and made sure systems did not read or write each other's data. we wrote generic systems as libraries with no dependencies on the rest of the monolith. the results of this work which was a lot of refactoring is that when we decided to farm some work out to a contractor we could do so as a microservice. they worked in their favourite language with their own tools implementing the api we wanted over a specified protocol. at any point it would be possible to split out services to scale them horizontally but we didn't have to until we need to because every split increases the operational costs and complexities a little.;0
12136335;HackerNews;2016-07-21;while i appreciate the allure of such models one point gives me pause tracing and debugging. maybe the tools have caught up to the point where tracing why a job wasn't triggered or failed in the middle is a simple task but it always seemed tedious to me. my hope is that the explosion of the microservice framework will trigger a corresponding explosion in the tools to tracedebug it.;0
12136311;HackerNews;2016-07-21;the discussion about monoliths vs. microservices reminds me about knuth's 10pages of pascal code vs. mcilroy's 6command shell pipeline;0
12136233;HackerNews;2016-07-21;another good article on this subject my experience with microservices has been pretty painful. my analogy of microservices is it's a bit like building a car factory on two sides of the danube. and there's no phone line in between. you've got a factory building cars up to a certain point but then they have to stop work and pack it all up onto a barge figure out how to fit everything on the barge and send it away across the river for the other side to spend time unpacking amp figure out how it all fits together...as a django guy i've tended to follow the pattern of spending time making my models nice and rich with useful traits which will be helpful at all levels of the app down to the views. to then have to pack this all up and deliver some dumb json to the other side feels like a massive waste of time. with microservices i spend my life marshalling data around.and the number of times i've realized i've just spent an hour discussing the philosophical implications of how a particular bit of the rest interface should be designed all for an interface that we're the only consumers of and doesn't need to exist in the first place... i've found depressing.the ramifications on testing are a further story. do you have to test all kinds of ways you can receive your rest requests malformed if you're the only consumer and know exactly how you're going to use it? good use of developer time?;0
12136206;HackerNews;2016-07-21;i don't know about the microservices and stuff but i've got one cumbersome monolith to deal with and it had started to rot you know rely on outdated dependencies that one can't upgrade without significant effort etc etc. splitting it to a few isolated different systems looked like the only sane choice.luckily i've had to redo one logical part of the monolith anyway because of some changing business requirements. so i made it a separate independent project that had used all the modern currentlystable tech rather than fewyearsold one accumulated baggage of the past architectural mistakes and it all went quite nicely.it took me 1.5 weeks quite busy ones but meh to extract all the old code pieces that i've needed clean them up update with the new logic and get the freshlyminted project ready tested packaged up and running in production. the only thing i've lost is ability to run crossdb queries we just have a folder of readonly sql query snippets to fetch some useful statistics once a week or so because i put the data in a separate database. i hope postgresfdw would work when i'll need it.would i've tried to update the whole monolith it would've taken me months.so the next time i'll work on some largeenough part i'll probably extract it into a fresh project as well. as i see it i'll end up with a remains of legacy project surrounded by a few smaller monoliths. and then the legacy piece would be small enough to get cleaned up.i don't know about micro scale and putting every tiny thing into a different microservice though. i have an impression it requires a lot of extra unwanted cognitive load to manage so seems like an overkill to me.so my point is software code rots over time. multiple projects services allow to update pieces at different pace which is less stressful on developers.;0
12136173;HackerNews;2016-07-21;i couldn't agree more. martin fowler warned us a long time ago the first rule of distributed objects don't distribute them.funny that now the same person carries the flag with the symbol of microservices which are seen as a way to get rid of architects. that's exactly what thoughtworks believes in and you will understand more if you read the first chapters of the book building microservices or if you join their recent conferences. just my 2 cents.;0
12136150;HackerNews;2016-07-21;i'll take your words about testability and maintainability but still i'm not convinced this would be be considered a microservice by most proponents of the term like in soa services in a microservice architecture1 are processes that communicate with each other over the network in order to fulfill a goal. also like in soa these services use technology agnostic protocols.2;0
12136003;HackerNews;2016-07-21;i can even add that we only do web software but we do them exactly that way.i can even add that not only do we do them exactly that way but it's many times faster and more reliable than microservices for reasons i have written about before1.the reality is that microservices add a whole host of failure modes for just one benefit over monoliths they are easier to scale horizontally. if you don't iabsolutely needi horizontal scalability and not many companies do then you'd be foolish to pay the large cost.1;0
12135786;HackerNews;2016-07-21;when you have a large service you can end up with a lot of coupling. meaning that it is hard to have teams that specialize in specific parts of the application you need a huge team that knows everything about everything and that doesn't scale as your code and company grows. and you can see the effects of that in reduced productivity and technical debt beyond belief.even if you hire highend talent they will be forced to worship people that have the knowledge about how all the bloated jengatower mess works.and that's only the people problem let's not even discuss how you build deploy test things in a reliable way without taking days to produce a working build.that and the fact that your quality of life will suck since you won't be in control of such mess.with microservices you have one service that does a limited set of things that is easy to monitor maintain test deploy and even entirely replace if necessary.;0
12135738;HackerNews;2016-07-21;the replacability is usually much better due to being forced to define sharp boundaries with clear interfacesif by sharp boundaries with clear interfaces you mean api specification how is it a microservice thing? i thought the benefits of microservices lie in behindthescenes details.;0
12135713;HackerNews;2016-07-21;i agree with you that it's not a bad thing i think it's the main benefit of microservices for most larger organizations the ability for different teams to control their own destiny and not be blocked on each other.but there's now a whole bunch of new developers out there who are just starting out and read all about these microservices and think that it's ithei way to write web backends and that if you don't do it that way you just don't know what you're doing. even if you're a two person team you must use microservices if you want to scale out in the future apparently. it's just unfortunate the amount of cargo culting going on.;0
12135712;HackerNews;2016-07-21;there's quite a bit of variability in what people mean when they say microservice i've read quite a few articles over the last few years that describe things as i just did.however you are correct. most people are unable to get the cruft out of their head so when they talk about microservices they mean something like exactly the way we used to do things only with a few differencesi was talking to a team last year that wanted to do microservices. they had a framework a lot of tools and were busy doing research most of which consisted of reading fanboy posts and walking through happypath tutorials.when i started listening to what they were talking about in terms of an architecture? wow! too much to go into here but one of the things was a microservice that at the beginning of the pipeline cleaned all the data.think about that. one service which was responsible for knowing every data type performing all safety checks and ensuring that all of the other services could run correctly. all in one place. you screw that one up? the whole thing is broken. you couldn't ask for tighter coupling.and this they thought was better than a monolithic app.i'm a big fan but micoservices are going to make a huge mess in the industry that it will take decades to clean up. that's because most people doing them will think of them just as you suggested.having said that the ones who don't are going to run over everybody else in terms of productivity. good for them and the orgs they work for;0
12135705;HackerNews;2016-07-21;i really value your contribution thanks for sharing.i give the proponentsconsultants credit for proposing a practical and incremental solution to these people instead of just insulting them or saying you're doing it wrong.that being said the issue i have with microservices is the fact that the below is repeatedly used as a core technical argument they had built the whose system using the classic boxboxcylinder architecture. there were hundreds of little top tier 'services' but in practice they all shared the same database had to be deployed pretty much at the same time and version upgrades had to go in lockstep. every so often database changes were necessary and the world would grind to a halt for months to make the system still work after the migration it was awful.this is not a feature of monoliths this is a feature of shortsighted design at the beginning and cowboy design at the end.let's be clear apart for load balancing for performance critical areas which only exist in 20 of the applications and only cover 1 of a typical such application or 60 if you are google facebook or amazon or the rest of the top 10 there's nothing that microservices do better than inmemory libraries. also centralizing everything as opposed to having processes run on various servers creates the issue of the single point of a failure. whole new classes of similar issues appear. it basically is buying troubles.adding microservices will never be a neutral operation and incurs a real cost. this cost is the cost of distributed objects which has been known for over 20 years and has been welldocumented by our fathers.once the above has been dismantled it then comes to yes but teams can develop in different languages yes but dependency management becomes easier. but once again when it comes these interoperability considerations a solution also exists and has been created about 15 years ago. this solution is called .net 30 languages compiling to a single intermediate language com components firstclass library support etc.... even the yes but i need to communicate with non .net inmemory applications is very maturely addressed by the framework. it was one of the firstuse cases addressedi also read in this thread the ability of teams to control their own destiny and not be blocked by other teams. with libraries teams can choose the version that works best for them and a welldesign inhouse library would provide the extension points dependency injection dynamic binding... that would allow the clients the other teams to specialize the behavior.so in a gist my main reproach for this is that if people put the same effort they put in learning microservices to learning system and component design they wouldn't even be a need to talk about the former. my regret is that people will always choose the hype and the new. but hey that's how the game works.;0
12135696;HackerNews;2016-07-21;but that is the thing.it just means that instead of using the language features and creating clean interfaces across modules they were witting spaghetti code.with microservices they get to write spaghetti rest calls with the added fun of distributed computing failures.;0
12135681;HackerNews;2016-07-21;i'd agree philosophically that this is the right way to do it but that's not what most people are speaking about when they say microservices. they usually mean small independent servers communicating via rpc each of which only does one thing. i'd say that this is pretty much the opposite of what you describe since now each task needs the overhead of serialization deserialization marshalling errorchecking process monitoring etc.;0
12135669;HackerNews;2016-07-21;microservices also enable you to scale individual parts of your application. if you need better performance for say image compression then it's much easier to add resources to a service that lives in its own process space or its own server or rack of servers or data centre.. than it is to improve the performance of a specific library in a larger application.;0
12135662;HackerNews;2016-07-21;i'm okay with calling that a microservice since it's infrastructure code that needs to be deployed and maintained as part of the app. but it's really only a line of bash.i'm under the impression that most people wouldn't call that a microsevice. moreover isn't that solution completely dependent on the implementation of the code that is writing those certain files without making this dependence explicit and pretty difficult to test automatically?;0
12135591;HackerNews;2016-07-21;in fact that's how most nonweb software is still written and done.i can even add that we only do web software but we do them exactly that way.if anything it adds more complexity because now we need to do all kinds of data marshaling error checking monitoring have more infrastructure for something that should have been done in shared memoryinprocess to begin with.i couldn't agree more. martin fowler warned us a long time ago the first rule of distributed objects don't distribute them.there are a few exceptions where its useful to scale out parts of a distributed applicationyes and very very very few. as i always say microservices are not an architecture they are an optimization.;0
12135553;HackerNews;2016-07-21;with some work you can have the some behaviour but the microservice is also about the data like user ids and passwords for a login microservice.;0
12135541;HackerNews;2016-07-21;i had the feeling that microservices would add too much of complexity but with faas this is canceled out by the fact that almost all server management complexity is handled by a different company.;0
12135436;HackerNews;2016-07-21;it is a pure function call. there are no side effects just a clear and simple input stream and a clear and simple output stream.i agree with your characterization. all except maybe the i'd probably write a quick js viewer that can collapse stack traces part.here's the thing i'm so minimalist that i'm only going to add frameworks and libraries as a last result if you stuck a gun to my head. i'm going to resist as much as i possibly can.i love writing code. and every line of code i write has to be compiled deployed is prone to bugs has version dependencies and so on. many times it adds unnecessary complexity to the solution. i love using cool frameworks and libraries. same goes for them.the magic here is that the vast majority of whatever you're doing? it's already been done. use os code that's ran successfully for ten twenty years. write your own code only as a last result. micrososervices shouldn't have more than 100 lines of code.yes it's a function. maybe 3 or 4 closelyrelated functions. if it gets past that level of complexity refactor.the only thing i'd add here is that you'll end up factoring out common code as you go along. that code needs to be put into a shared corporate library which also should be small along with shared typeswhen done well you end up with the realization that you've been doing it wrong all along. when done poorly you just make an even bigger mess than you did doing it the old way.here's one small example. i was writing a production project for some folks a few years ago. we needed some way of showing system status.the old way could have used all sorts of things logging systems server metric systems and so on. i would have probably done some research downloaded a library or framework set it up along the happy path and made some really awesome html dashboards.then the library would change or the metrics would be different or the configuration would need tweaking etc.i figured out what we really needed to see was timedate stamps on certain files. so i pipe ls to a web file and chron it. five minutes later it's working. it'll be working ten years from now. if we need something more complicated? we'll add it. one tiny little bit at a time.i'm okay with calling that a microservice since it's infrastructure code that needs to be deployed and maintained as part of the app. but it's really only a line of bash.some people would say that what i did was completely trivial. these are people who do not understand what the hell is going on. that was a win. if i could have 5 or 10 microservices like that which provide business value? i'm freaking iwayi ahead of the value curve as opposed to a similar team who's still slogging through 7000 lines of mostly boilerplate code that does basically the same thing.;0
12135421;HackerNews;2016-07-21;not as i understand microservices. a library would be something that's compiled or included in to your application code. a microservice is a separate process that the application communicates with over a protocol eg http.;0
12135388;HackerNews;2016-07-21;i feel like maybe the big idea of microservices is that web apis provide better isolation guarantees than library calls and now with the move to saas either the scale of our applications is large enough or more likely with virtualization the intraserver network latency is small enough that we can afford the extra overhead of web apis relative to library calls in exchange for that isolation.;0
12135376;HackerNews;2016-07-21;i agree with you. in my defense people who want microservices are generally asking for developer autonomy but just using technical language to do it rather than managerial.;0
12135351;HackerNews;2016-07-21;if you're starting micro why do you need the services part at all? why not just make it a function call?to use your example if my task were make a record of the errors of this process available on the web my first thought would be to write to stderr pipe stderr to a file and then serve that from the webroot of some commodity webserver like apache 'python m simplehttpserver' or even s3. if the format is too hard to read i'd probably write a quick js viewer that can collapse stack traces aggregate similar errors etc all done in the web browser. or use cutawksed to process it before dumping it in the webroot. it's only if the data gets big enough that it starts freezing the browser that i'd reach for elk or something similar. i don't know anyone who would call this a service though indeed it seems the polar opposite of what most people talk about when they say microservices.;0
12135344;HackerNews;2016-07-21;sounds kind of like what i would do except i would use a database table controller for each of the things you consider a microservice.;0
12135287;HackerNews;2016-07-21;you are if you care about whether you're deploying things that aren't necessary. with microservices you can take a single specific service that two projects share and reuse it. with a monolith you can't unless you deploy everything else as well. that can easily fail a requirements check say hardware requirements are too costly and force you to redevelop the service for the second project.;0
12135268;HackerNews;2016-07-21;microservices are a new name for a very old concept.this is just lowcoupling highcohesion by another name.small composable decoupled highly cohesive components are what good software has been about for decades but it now has a new name in the server sw world microservices.only the name is new amp hyped. the concepts have been true forever.;0
12135267;HackerNews;2016-07-21;i think it's the old loose coupling vs. late binding discussion. some people confuse the former with the latter.you can very mechanically achieve late binding with microservices but it takes extra effort to actually achieve loose coupling and guess what the effort might or might not be less than doing loose coupling within the components of a monolith.;0
12135254;HackerNews;2016-07-21;i also don't see how microservices are more reusable.however the ireplacabilityi is usually much better due to being forced to define sharp boundaries with clear interfaces.;0
12135242;HackerNews;2016-07-21;i think you've missed the point in several different ways here.first there's a difference between i've seen it done like x and when done well it's done like ytoo often we play this game where we talk teach and apply y but then in the real world it gets done like x. turns out that x sucks a lot so then we throw away y.microservices may be done poorly in most real world applications. in fact it would surprise me if they weren't.this article doesn't help much. microservices are not just another version of soa. it doesn't work that way. in soa you start with a general category of service say logging. you write it simple yet broad and it's supposed to handle all folks that need logging. in microservices you're doing one tiny little thing like make a record of the errors of this process available on the web. the vast majority of times if you define what you're doing narrowly enough? the os already does it. whereas if you start broad? you're writing code.then you slowly and methodically expand on that mission a little bit at a time refactoring your microservices as you go. it's both a different way of structuring apps from monolithic days iandi a different way of looking at constructing and maintaining apps. if you think of it as the same blob of binary bits broken into smaller pieces you've missed it. likewise if you think of it in terms of services. the micro is the key word here not the services part.this actually requires a much heavier interaction between developers not setting up fiefdoms. if done correctly it pushes larger groups of developers across teams to work more tightly together. if it's doing something else? you're doing it wrong.;0
12135208;HackerNews;2016-07-21;you are not getting more reusability from a bunch of microservices compared to one big service i don't see where you got that?;0
12135181;HackerNews;2016-07-21;i'm sorry i think the author completely misses the point about why microservices were controversial at all?distributed systems are not the same as centralized ones and you cannot paper over the differences between the two. it is wrong to think that distributed microservices will completely replace centralized services in some future paradise. the difference is not a tech fad it's more like a law of nature. distributed systems should plan for network failures yet nobody wants to get a 503 from their cpu.;0
12135027;HackerNews;2016-07-21;you got the google part wrong. google is all in on microservice architecture and has over a decade of experience doing it. there is not some gigantic google.exe program. perhaps you have heard that google uses a single source code repo and drew an incorrect conclusion.;0
12134947;HackerNews;2016-07-21;it is weird to read people write about microservices or some other tech fad as if it is this otherworldly thing that requires instruction and training. so many words dedicated to describing the supposedly bad old days!all this stuff is just another aspect in the life of a practitioner of computing. a proper expert should see these things not as a fad but as a collection of techniques that can be added or subtracted to at will depending on the prevailing need. it's silly to declare any of these fads dead or alive they're just simply techniques that ...people... have bundled together under a common label;0
12134881;HackerNews;2016-07-21;i see several people criticize microservices here. we've been doing it for about 6 years and are extremely happy with it.a core principle which a lot of people and articles ignore though is ireusabilityi. i bring this up on hn every time there's a discussion about microservices yet i've never seen any discussion about it.essentially you build out the backend to act as a library for your front end. so we have login storage analytics reporting logging data integrations various forms of messaging businessstructural stuff etc. etc. all bundled up as separate services. the front ends just use these services to build a coherent product. the front end is the monolith the microservices are the cloud.for example let's say i wanted to create a new product called hacker news. i'd use our storage service to store links and comments. i'd use the login service to let users log in. i'd use our messaging service to send notifications about things like verifying your email or send password resets. i'd use our analytics backend to emit events for reporting. and so on. i could easily build the whole thing without writing a single line of backend code and without setting up a new cluster because every backend service has been designed with multitenancy from the start.this ability to piggyback on a platform of services where i think the real utility of microservices lies. everything else finegrained scalability smaller surface for tests languageindependence swappable implementations etc. etc. are secondary to that.;0
12134866;HackerNews;2016-07-21;if that's the case i'd argue we're conflating software development management with software engineering execution. it's illogical to assert that utilizing microservices implies entirely forgoing centralization.;0
12134848;HackerNews;2016-07-21;in 99 of my experience the services aren't a real distributed system anyway and are vaguely organized by function developer interest and yes control.but that's kind of the point. they're a networked system of interacting processes but not a distributed system. a distributed system generally is a tightly coupled and coordinated set of services running on many machines for purposes of resilience or scaleout. microservices are more for organizational scaleout. a microservices might be a distributed system but several interacting microservices probably isn't one pedantically speaking.microservices are an evolution of how largescale integrated systems have played out as a pendulum swing between tightly coupled systems and loosely coupled systems.after the mainframe into the clientserver era most nonweb software in a large organization eg. most it back offices dating back to the 90s were not built as a single application it was built as a set of independent applications that were coordinated by something a shared database data extracts message queues transaction processors and rpcs.data extracts were the ultimate in loose coupling. you got an update every night from other databases and could do whatever you wanted with the data. but of course this led to data quality problems when customer records or inventory couldn't reconcile.so we moved to a service owns its data type situations and wrapped them in message queues or rpcs. this is basically how something like sap works it's a set of modules with their own schemas that are tightly coupled through a set of rpcs and messages.but this eventually had none of the benefits of networked modularity everything was so coupled and intertwined it was a mess to change and upgrade you had to do the whole thing at once which is why sap upgrades are so notorious.what makes microservices different is that we've evolved them to have truly independent interface from implementation by having the implementation lifecycle of a module be tied to the server down to the metal so it can be completely autonomous from other services. therefore i can upgradereplacescalemove these runtimes whereever i want whenever i want. i can also place proxy or gateway intermediaries between them more easily. this is soa done well in effect.we've also evolved our practice of service interface design beyond rigid idls and wsdls and schemas into more permissive extensible and better documented apis or events along with easier versioning but the state of the art still has a long way to go there.not a panacea but on the flip side i've rarely seen a maintainable scalable and easy to change networked monolith. they do exist but required the controlling designers to be deeply talented with full control over architecture decisions and they didn't get into analysis paralysis. but even they eventually couldn't keep up with changes so they're breaking their monoliths up today ime.;0
12134841;HackerNews;2016-07-21;i think this is a smaller evolution than microservices non microservices.... as others have pointed out the real discussion is autonomy versus centralised control.;0
12134808;HackerNews;2016-07-21;oh yeah i don't think it's bad research going into this. i mean i've been writing software professionally for almost 20 years now and i am super excited about for example containerization and other trendy areas. i think it's igreati that people are pushing the boundaries of soas and i think microservice is a good term describing ihowi the boundaries are being pushed. we will all benefit from the improved tooling and experience gained.my only complaint is this ostrich mentality of declaring ubiquity and ignoring the downsides and unsuitable cases. i suppose drinking the koolaid might be necessary to really buy in and push the paradigm forward but sometimes it feels like willful ignorance.;0
12134743;HackerNews;2016-07-21;speaking as a young engineer i can tell you many are already looking past microservices towards things like aws lambda amqs and baas which make a great deal more sense. why? because it helps reduce dev effort down to purely the logic you'd have to write no matter what with better guarantees about reliability and scalability and less maintenance. i hesitate to say 'serverless' because that still feels somewhat out of reach but that's the direction things are trending towards.i also get the sense that a lot of purists moulded in the ways of yore are alarmed at the waning relevance of their skillset. this to me seems like a bigger problem than the evolution of software paradigms.;0
12134648;HackerNews;2016-07-21;i'll tell you the real reason behind microservices developer fiefdoms. fauxspecialization. it allows developers to feel like they have control over certain pieces of infrastructure and run the gambit on their strategy for getting ever more increasing pieces of the pie.it has nothing to do with building reliable software. you could just as easily build and deploy a single networked application so called monolith that is composed of many different libraries that have well defined interfaces which can be tested in isolation. in fact that's how most nonweb software is still written and done.the real reason is that by having these microservices it allows single developers or teams to own or control parts of the codebase and enforce their control via separate repo's and when speaking runtime via authentication sally can't see the code to joe's service and joe can't make requests to sally's production instance of her service that gives a guess at how long the car has to arrive to pick poor end user bob up.i've seen this same thing play out countless times at large tech companies and startups alike. it has nothing to do with building scalable or more maintainable or more cleverly designed applications. if anything it adds more complexity because now we need to do all kinds of data marshaling error checking monitoring have more infrastructure for something that should have been done in shared memoryinprocess to begin with. not to mention all the issues and headaches caused by fan out of tons of api requests complicated caching scenarios etc. i've seen the horror of microservices architecture where no one person is responsible for the actual app only their service.there are a few exceptions where its useful to scale out parts of a distributed application but in 99 of my experience the services aren't a real distributed system anyway and are vaguely organized by function developer interest and yes control.;0
12134489;HackerNews;2016-07-21;any service taking requests from a client generates a uuid and passes it through to any additional services it calls. most microservice frameworks have this functionality built in.you log to a central store such as an elk stack or any of the great third party offerings. when you need to see the entire stack trace you search by the id.;0
12134311;HackerNews;2016-07-21;this is a great point. i don't think the hype is due to a fad alone. there are a lot of good reason why microservices are much easier to create and deploy today containerization and the associated technology around it. this makes microservices a very natural paradigm for app deployment.of course its not a holy grail. but we see that kind of thing over and over again. i think its ok it gets developers genuinely excited to try new technology. its only when this hype influences dangerous decisions that i'm worried about.;0
12134247;HackerNews;2016-07-21;it's all a balancing act. the two main contenders are developers and scalability.it makes no sense for a single team to run 2000 microservices that come together into a single app. the amount of overhead for managing so many interfaces is insane.at the same time it's hard to justify 2000 developers working on a single binary. you end up with entire teams dedicated to managing and deploying. companies do it google but it's not without costs.if every microservice runs with the same specs container size of containers then there is nothing gained from scalability. if anything you're probably wasting a large amount of resources if your containers cannot shrink any more.at the same time if you are deploying thousands of copies of of a single binary when most of the resources go to 1 of the code then you're wasting resources with needless copies.the microservices fad is definitely brought on by the recent rise of virtualization. it's probably a bit overboard.;0
12134222;HackerNews;2016-07-21;not to seem naive but i work with a lot with microservices and i've never heard of lightstep...... follow up what's everyones opinion on this?;0
12134188;HackerNews;2016-07-21;equating microservices with information superhighway really shows the tech bubble that this article is written in. information superhighway was a vacuous but mainstream term used by politicians and public figures. microservices is a tech hype train led by expensive consultants and pickaxe companies thriving off the current tech boom.don't get me wrong a serviceoriented architecture is the only thing that scales to large companies. once you get to dozens of engineers and millions of lines of code you will inevitably need to have an soa because conway's law. also there is a learning curve to building microservices which improved tooling really helps with.however the thing that really grates at me is how these articles say things like iservices are now an everyday everydeveloper way of thinkingiwith nary a mention of the overhead. there is no way around it distributed systems have an irreducible complexity no matter how good your tooling and boilerplate is. you have to put in extra work to decouple everything and handle failure in a way that actually reap the benefits of the distributed system. and in the end what these articles always gloss over is the interface between these systems. if you can easily define an interface between systems that stays relatively stable as the service evolves then congratulations you have a good candidate for a service with minimal overhead. but for most applications those interfaces are shifting all the time and there is no better tooling than multiple logical services running within one binary and build system where iintegration testing and validation is cheapi. this is a real fucking problem people it's not going to go away because there's a couple billion dollars worth of venturebacked startups ready to blow their cash on you in the vain and most likely misplaced hope that they are actually going to ihave toi scale to dozens of engineers. premature scalability is one of the worst siren songs for young engineers and we're seeing it in spades right now.;0
12134110;HackerNews;2016-07-21;i don't think they are. i would be surprised if 10 of new code right now was coded in microservices.;0
12134068;HackerNews;2016-07-21;they have the word microservice on their homepage d;0
12134062;HackerNews;2016-07-21;maybe a more appropriate title could be 'microservices are the norm';0
12133924;HackerNews;2016-07-21;when this year i came back from dockercon i immediately wanted to write something very similar to what this article describes. i wanted to imagine a world where containers and microservices were part of the past already and so i wrote dockercon 2020 1 and how it will look like.1;0
