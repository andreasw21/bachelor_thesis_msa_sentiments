ID;Source;Creation Date;Content;Sentiment
12508655;HackerNews;2016-09-15;Title:Microservices, Content: http://basho.com/posts/technical/microservices-please-dont/;0

12601669;HackerNews;2016-09-28;if your product or project is not or has services then it does not need such a thing called microservices.;0
12519490;HackerNews;2016-09-17;you need almost none of that scary list to start building microservices. lambda functions can be created in minutes even in ui console. and they have almost everything from that scary list by default.lots of people are still in denial regarding microservices...;0
12518261;HackerNews;2016-09-17;one of the ways we managed to get a microservices system on prem vsphere or openstack is to configure it with a system that can handle the whole provisionbuildconfiguredeploy as a single unit .. though the learning curve was steep.;0
12516001;HackerNews;2016-09-16;there might not be a unified domain modeli agree with this. see my reply to mahyarm c.f. analytical debt. keyword here is might not.if there exists domain level solutions incurring the iforeveri micropayments in context of operational complexities of a rush to embrace microservices is a systemic fail of the technical leadership.;0
12515747;HackerNews;2016-09-16;microservices embody the idea that there might not be a unified domain model across the organisation.;0
12515280;HackerNews;2016-09-16;layered systems do not have to be 'monolithical'. note that we're both at this moment using layered systems to have this conversation. a layered monolith can still easily have random people cut across boundaries without you knowing because there are hundreds of engineers all working in the same system.i appreciated your final word regarding social reasons and i think we're in strong agreement in that regard.in the final analysis it seems accurate to say that microservices approach permits runtime operational micro payments towards organizational and analytical debt 1.the hypothetical systemstraw man? you posit above is indicative of organizational not architectural failuredeficiency.1 in the 'technical debt' sense.;0
12513205;HackerNews;2016-09-16;if this person used microservices perhaps their site wouldn't be down right now...;0
12512963;HackerNews;2016-09-16;i'll go against the majority or vocal minority? and say i like your title it's good because it attracts attention i wouldn't read the post if it were a understand the implications of having a microservice architecture or whatever others recommend.;0
12512958;HackerNews;2016-09-16;i suppose there's a difference between the from the ground up microarchitecture and using a micro service or two that should really differentiate the various should we use microservices? discussions.several sites i'm aware of have an facebookstyle chat service which is basically an off the shelf node app on its own. this makes far more sense than trying to build such a thing into their legacy app. it also perfectly describes a very useful micro service in a very different environment to yours.;0
12512824;HackerNews;2016-09-16;my conclusion as well. in my mind i call them 'airgapped modules'.;0
12512720;HackerNews;2016-09-16;yes. for me shared state in the linux kernel is like a shared database between microservices. it makes life way easier is faster but you need to be careful you don't introduce subtle bugs.;0
12512685;HackerNews;2016-09-16;the newman book is worth a read i'm going through it at the moment and a lot is applicable to soa as well. microservices is partially a rebranding exercise to take the massive space soa covers and talk about a more specific definition.the main thing is the size of the services the clue being in the name. also there's a clearer emphasis on the services being more business related concepts soa can often described in more techy service splits rather than business concepts.;0
12512326;HackerNews;2016-09-16;microservices also enforce boundaries significantly more strongly. a layered monolith can still easily have random people cut across boundaries without you knowing because there are hundreds of engineers all working in the same system.large companies don't have problems throwing more engineers at a problem. but they will always have a problem in coordination costs.microservices also allow you to use different tech stacks for different purposes more easily.maybe use java for one involving hadoop or some gis library. use erlang for some message management service use golang for some simple api service use nodejs for some frontend web server etc.overall the advantages of microservices come for social reasons not for a particular technical reason.;0
12512219;HackerNews;2016-09-16;i'm sorry i'm not aware of the person but would be interested in readingseeing it. a quick google search yielded is this the one you referred?btw the list is not an invention worth copying. all items in that are not novel or unique they are general practices that every good engineer would have their own version of. i'd like to see the talk and try to add a few more items to this.;0
12512163;HackerNews;2016-09-16;in my experience once microservice it's very hard to run the whole system in local environment. it's nearly impossible to overview the system anymore.;0
12511681;HackerNews;2016-09-16;sounds like your company built a distributed monolith when they thought they were building microservices.;0
12511649;HackerNews;2016-09-16;that is a good list. at an even simpler level perhaps we can summarizeimicroservices necessitate the application of a more rigorous set of engineering practices to all service infrastructure components and therefore carry a greater overhead than traditional development methodologies rigorous engineering does not come free. whether that tradeoff makes sense for any given project is a question of resources and requirements.ii feel two salient points were not mentioned 1 popular microservice orchestrationinfrastructure management approaches are not universally applicable their limitations should be recognized before assuming applicability. 2 the webhost is currently down perhaps the author should have used a scalable or distributed cluster of microservices;0
12511528;HackerNews;2016-09-16;i think microservices can work well but also agree that it's easier to start with a monolith. it's hard to go out and create perfect microservices. in my experience they emerge from the problem much like how an amoeba gets big and breaks off at natural points.;0
12511424;HackerNews;2016-09-16;you use microservices when your project expands beyond the monkeysphere number where everyone knows everyone else.a layered architecture can give you the same.microservices imo address organizationalindustry deficiencies in the design and evolution of domain models. you're basically trading analytical pain for operational pain. as the top comment in this thread with the excellent list concludes you will need engineers. microservices are good for large companies.and this has nothing to do with number of developers. it has to do with inherent complexity of a unified domain model for large organizations. as an analogy consider microservices as scripting to layered architectures compiled language.;0
12511399;HackerNews;2016-09-16;you use microservices when your project expands beyond the monkeysphere number where everyone knows everyone else.it allows teams to work in their own world without having to coordinate as much with other teams or people.microservices are good for large companies. if you're small you don't need them.;0
12511311;HackerNews;2016-09-16;ifallacy 5 better for scalabilityi ihowever its incorrect to say that you can only do this with something like a microservice. monolithic applications work with this approach as well. you can create logical clusters of your monolith which only handle a certain subset of your traffic. for example inbound api requests your dashboard front end and your background jobs servers might all share the same codebase but you dont need to handle all 3 subsets of work on every box.ithis makes little to no sense to me and feel like we're bending the definition of monolith to mean microservice so that we can tick the bullet point. how exactly do i achieve this when my code is mashed together and all running together?i have a monolithic app today an internal website which is so small that it could be served ignoring that this would make it a spof from a single machine. but it's so closely bound to the rest of the system it is stuck alongside the main api. so it gets deployed ieverywherei.if it were discrete enough that i could run and scale that internal service separately i wouldn't be calling it a monolith. at that point they're separate executables and scalable independently that's practically the definition of microservice. and i can't do this if where they need to they don't talk over the network one of the earlier bullet points.;0
12511296;HackerNews;2016-09-16;it doesn't have to be messy. i've worked in monoliths that are a complete disaster. i've worked in microarchitectures that are a complete disaster. it's the same kinds of people and management practices making these disasters.i will say the only clean systems i've worked in have been microservice oriented. all monolithic systems i've worked on never scaled properly and always had bugs with 1000 function deep stacktraces.i've talked to people who have worked in excellent monoliths rails and django. i know they exist.moral is do it right and have good development practices.;0
12511179;HackerNews;2016-09-16;that's pretty spot on. i once made an abbreviated flowchart of the above for my microservices article i urge everyone to use it to decide whether they really need microservices or not.;0
12510962;HackerNews;2016-09-16;that's one thing i've always thought when people claimed microservices followed the unix philosophy. unix doesn't even follow that philosophy it's a monolith! yet it's also a modular system which is possible without being either a microkernel or microservices.;0
12510840;HackerNews;2016-09-16;note also that microservices experts and i'm not one of those recommend a monolithic and transactional core architecture for microservices infrastructure.this is a pithy encapsulation of something i've been thinking a lot about recently bud off a microservice from your transactional core if it is higher leverage to do so. any good readings you've found on this perspective?an example that comes to mind is i might write my core application in ruby on rails but need to perform a specialized cpuintensive function pdf generation. i can delegate that to a microservice invert a cpubound problem into an io bound one from the perspective of the rails core and get the job done with less hardware.;0
12510814;HackerNews;2016-09-16;i think it does carry those lessons but most languages are incredibly bad at enforcing modularity. monoliths make it far too easy to cheat and dynamically typed languages are typically worse here.microservices then just forces on you the modularity your language should have already given you.;0
12510705;HackerNews;2016-09-16;i guess in my head it's also eliminating a lot of code bloat using microservices. just my opinion though.;0
12510606;HackerNews;2016-09-16;i heard about microservices about a year ago and now it said the hype has ended before i even noticed? admittedly i'm not in the loop and it's hard to track all the trends from outside.;0
12510419;HackerNews;2016-09-16;a word which totally not carries lessons learnt from microservices vs monoliths. but using that name is fine by me i'm not trying to define other people world just sharing mine.;0
12510395;HackerNews;2016-09-16;i dunno. given the fuzzy definition of microservice i tend to think of otp applications as logical microservices... ones you can even build a monolith or distributed monolith out of if you want.;0
12510307;HackerNews;2016-09-16;instead of microservices i split my projects in tons of libraries and think of them as products enforcing a well thought of and consistent api usage api not http one. i call that an atomized monolith.there's already a term for that modularity.;0
12510088;HackerNews;2016-09-15;stabbycutyou how does basho's choice of erlang as the primary language affect it choice. my naive understanding is that erlang forces one to build a singleprocess system as if it were a multiprocess system from day 1. does this make the monolith microservices switch easier for erlang systems than it is for others?;0
12510079;HackerNews;2016-09-15;microservices is just decoupling by another name.... and you do not need a networkboundary to enforce this.if code is decoupled enough that it can be separated into independent processes communicating over a network that creates additional freedom into how the components can be deployed to real or virtual hardware which is itself a kind of decoupling.if you have processes communicating by localonly ipc methods or even moreso components operating within the same process there is a form of tighter coupling than exists when the components are separate networked components.;0
12510059;HackerNews;2016-09-15;interestingly the sam newman book about microservices specifically says it's easier to succeed by starting with a monolith that you then break up. that advice does seem to be ignored by people who want a microservice architecture because it looks good on their cv or because they think it will magically solve a bunch of hard problems they don't know how to solve.;0
12510054;HackerNews;2016-09-15;i see microservices as responsibility deduplication in a organizationtraversalwide.aka soa. why call it microservice ?;0
12510018;HackerNews;2016-09-15;jesus christ. stick a load balancer in front of it and scale horizontally works precisely as well for a monolithic app as it does for a microservice. which is to say it might work to some degree to some total load for some systems and it might not for others and will eventually break down at high enough load for pretty much anything that's not a pure function e.g. you could scale a restful javascript linter horizontally presumably forever with more load balancers and more api servers but your chat system is going to get more complex;0
12509989;HackerNews;2016-09-15;you dont need to introduce a network boundary as an excuse to write better codeabsolutely this!microservices is just decoupling by another name.... and you do not need a networkboundary to enforce this.monolithic code can also be nicely decoupled too.;0
12509967;HackerNews;2016-09-15;we ship a microservicesbased product onpremises. you can do it but it's a heck of a lot of work. plus you don't get any of the benefits microservices might bring in a cd scenario you can't do cd over an airgap.;0
12509927;HackerNews;2016-09-15;stabby! several thumbs up to the point 1 that interface boundaries needn't be coincident with service boundaries. in my experience the benefit of breaking out microservices is the decoupled deployment. a heuristic is if you have fixesfeatures that are waiting to be pushed to production until unrelated code is passingqa'd you've got a good candidate for a separate service.;0
12509926;HackerNews;2016-09-15;that's a key point it's easier to do things wrongpoorly on microservices.;0
12509844;HackerNews;2016-09-15;why would someone push for those 5 thruths? the point of microservices is to ease ops life so that deploying is less of a big banglike event and more geared towards incremental and local evolutions.;0
12509726;HackerNews;2016-09-15;while this and many other writings about microservices are largely concerned with networkbased environments there exists another microservice exemplar specific to the jvm worldosgi01i mention it mostly to assit those wanting to explore the concept of microservices itself as opposed to assuming a network transport is always involved. being jvm specific kicking the tires on it naturally requires that environment. perhaps though some of the writings discussing it would be of benefit to those using other tech stacks.of course osgi does not preclude distributed processing and often is employed for such.0 1;0
12509702;HackerNews;2016-09-15;we were also built from the ground up with microservices and had the exact opposite experience. faster shipping more value to end users more predictability apis designedbehaved similarly across functions despite polyglot tech much less coordination overhead deployed dozens of times per day with a lt 10 dev team prerelease backends well in advance of the userfacing parts etc. we had to invest a lot in infrastructure but that was worth it for many other reasons as well. dozens of repos is annoying but not for a technical reason a lot of saas like bugsnag and github used to charge by project.the biggest downside is it makes shipping an onprem version nearly impossible. the infrastructure and the software are so inextricably linked that it is not portable in the least bit.;0
12509624;HackerNews;2016-09-15;instead of microservices i split my projects in tons of libraries and think of them as products enforcing a well thought of and consistent api usage api not http one. i call that an atomized monolith.i get the cool things about microservices properly isolated functionalities ability to assign a team on it simplicity of code and considering each feature as important not just that thing in the codebase.but it also have all the good parts of monolith easy deployment and local setup aggregation made easy and ability to run integration tests.for my rails projects geminabox was of great use for me to achieve this as it allowed me to host private gems. lately i've done a lot of golang and was surprised to see how it's a natural pattern with go packages.only hurting part for ruby projects keeping dependencies up to date in all those libs since they all have their test suite it means that i at least have to update them for test dependencies. to solve this i've built some tooling that will update all my project automatically and create merge requests for them running from a cron task.;0
12509563;HackerNews;2016-09-15;one of the downsides of the blog post was that i adapted it from a lightning talk so it was meant to be a little contentlight but to put ideas in peoples minds around how to think about the tradeoffs.for example your point about go vs rails is an apt one i would only add that i made that comparison because...a it was originally a golang meetup where i gave the talk b go is increasingly becoming popular as a choice people move to off of rails for performance sensitive code scala being the other popular choice i see and also for building microservices themselves.i could have and maybe should have gone a little more in depth at that part but the idea wasn't to be fully exhaustive for better or worse.but the main takeaway about the performance gains was that the idea of putting the word micro in front of something magically made it more performant without appreciating why. it's a response to folks simply parroting information without understanding it.thanks for the feedback.;0
12509533;HackerNews;2016-09-15;you need to be this tall to use micro services basic monitoring instrumentation health checks distributed logging tracing ready to isolate not just code but whole buildtestpackagepromote for every service can define upstreamdownstreamcompiletimeruntime dependencies clearly for each service know how to build expose and maintain good apis and contracts ready to honor bw and fw compatibility even if you're the same person consuming this service on the other side good unit testing skills and readiness to do more as you add more microservices it gets harder to bring everything up hence more unitcontractapi test driven and lesser e2e driven aware of micro service vs modules vs libraries distributed monolith coordinated releases databasedriven integration etc know infrastructure automation you'll need more of it have working cicd infrastructure have or ready to invest in development tooling shared libraries internal artifact registries etc have engineering methodologies and processtools to split down features and developtrackrelease them across multiple services xp pivotal scrum etc a lot more that doesn't come to mind immediatelything is these are all generally good engineering practices.but with monoliths you can get away without having to do them. there is the login to server clone run some commands start a stupid nohup daemon and run pstoptail to monitor way. but with microservices your average engineering standards have to be really high. its not enough if you have good developers. you need great engineers.;0
12509483;HackerNews;2016-09-15;my thought is that this comparison between a monolithic code base vs a microservices code base is a bit subjective. if you're starting out chances are your code base hasn't even gotten to the level of being monolithic. so those thinking about how they're going to architect their platform may begin to think that a microservice setup could help for future changes to their code. it really depends on each team their background and how they want to think about their platform in the future. to list out the pros and cons of both to draw a conclusion that one is better than the other is certainly setting a bias that i believe to be a bit unfair. just look at netflix and their container services. it's a platform adopted by a ton of companies including nike. so for some a microservices approach makes a lot of sense.;0
12509475;HackerNews;2016-09-15;i appreciate the feedback but unfortunately i think you've made a bit of a leap in terms of what my point here was.it isn't that i'm saying don't build microservices but rather don't adopt this approach until you understand the tradeoffs involved. i've worked on teams that have done it well and not done it well. i've worked with large codebases that are well maintained and poorly maintained. there are tradeoffs that need to be taken into consideration before adopting any major architectural approach.i will say that upon reflection the original title could have been reworded a bit to better express this.;0
12509445;HackerNews;2016-09-15;i see microservices as responsibility deduplication in a organizationtraversalwide.deduplication is a very old concept differentiates good sysadmins from bad ones since the 90's and good programmers from bad ones.thinking organizationtraversalwide is what is hard for some persons.currently working at consulting in a big corp... you get to this problemresource name foobar type int organization view point ... etc until app 35 and script 192679microservices thinking transversely solve that. see aws googlecloud azure etc resource names arns etc for an example of a simple and great microservice.note also that microservices experts and i'm not one of those recommend a monolithic and transactional core architecture for microservices infrastructure.;0
12509439;HackerNews;2016-09-15;hi author here thanks for taking the time read it.you're not wrong in that this article is meant to point out the pitfalls of the approach and to advocate for understanding before diving into a particular architecture.it's meant to give people things to consider before deciding breaking things into microservices is the right thing for their engineering org at that time.i attempted to note several times that my intention was not to say microservices are bad but rather please don't dive in before you consider the trade offs. it's not as simple as some folks might have you believe so i felt it was valuable to have a lessons learned type retrospective coming from someone who has been involved in both approaches.thanks for the feedback.;0
12509436;HackerNews;2016-09-15;a interesting article with some good points. i think the important takeaway is understanding that monoliths are probably better for smaller companies with less total code and fewer total engineers. at small scales the costs of microservices network overhead distributed transaction management rpc complexity devenvironment complexity outweigh any benefits. a monolith lets you develop quickly pivot easily build crossdomain features and is more efficient up to a point.that said i believe there is a point where monoliths begin to break down.first it is tough to keep code well structure in a monolith and eventually things bleed between domains. that means as mentioned engineers must understand the entire codebase. this isn't practical for 100k loc codebases. strict boundaries in the form of interfaces limit the scope of code that every engineer must understand. you probably still need gurus who can fathom the entire ecosystem but a new eng can jump into one service and make changes.second deployment is a mess with any more than a few hundred engineers on a given code base.third it becomes increasingly difficult to incrementally upgrade any part of your tech stack in a monolith. large monoliths have this tendency to run on 3yearold releases of everything. this has performance and security implications. it also becomes difficult to changes components within your monolith without versioned interfaces.fourth failure isolation is much harder in a monolith. if any portion of code is reused between components thats a single point of failure. if your monolith shares dbs or hardware between components those are also points of common failure. circuitbreaking or ratelimiting is less intuitive inside of a monolith then between services.tldr start with a monolith migrate to microservices when it becomes too painful.;0
12509394;HackerNews;2016-09-15;cannot agree more with this based on experience of small startup. let's say you want to develop a mobile app and rest api for it hosted somewhere in cloud. there's so much hype about it so you want to do it right it's right indeed but for some distant future until which your startup needs to survive. so the possible solution is to take some common stack like spring cloud and build a number of microservices with service discovery config server oauth and api gateway.it appears it's not so easy 1. first documentation as always is not the best and you'll have to spend time figuring out how to wire together different parts of the system and build various configurations of it for local development ci build and production. 2. then there's debugging issue. once you've figured out how to work with docker good news it's really easy today you may want to do some debugging in ide but it becomes really painful to launch everything correctly with attached debugger if the services interact with each other. 3. finally it's production deployment setup and associated costs. besides the complexity of deployment do you really want to pay for 1420 ec2 instances at the time of the launch of your service and burn the money on 0 cpu activity? it will take months probably years to get user base sufficient for utilizing this power.the better approach is to develop single server app with future scalability in mind. you can still have separate components for each part of domain you just wire them together at packaging time. this server app still can scale in cloud with correctly set up load balancer and database shared between nodes.fortunately we spent not much time on building microservices about 1mw to figure out the costs and benefits and were able to refactor the code to simpler design but many developers should not care about them at all at early days of their company.;0
12509313;HackerNews;2016-09-15;because scaling a monolith is not a realistic approach. every single monolith i have worked on has been refactored as domain specific microservices and in every case it was a resounding success.;0
12509265;HackerNews;2016-09-15;like all things one size doesn't fit all. not everything is a nail regardless of how shiny the hammer is. having said that when the situation is right microservices are great.some of us have been through this all before with soa or in my case with com. each individual component is simpler but the documentation between the components becomes absolutely vital.we ended up keeping a copies of the interfaces in a central location with documentation of all changes per version so that everyone would know how to talk to all the other systems.and don't think that the interfaces won't change. they will. and often across many systemscomponents. like a ripple.;0
12509253;HackerNews;2016-09-15;there's some good points here and some i disagree with. one area though where i think he misses the point is additionally many of these stories about performance gains are actually touting the benefits of a new language or technology stack entirely and not just the concept of building out code to live in a microservice. rewriting an old ruby on rails or django or nodejs app into a language like scala or go two popular choices for a microservice architecture is going to have a lot of performance improvements inherent to the choice of technology itself.languages and tech stacks generally have tradeoffs. considering rails vs go you could consider the massively oversimplified tradeoff to be that rails is better for prototyping and iterating quickly while go is better for performance. in an ideal world you'd write your webapp in rails but put the performanceintensive stuff in go. you'd need to communicate between the two by say http. suddenly you have services.the performance gains of using a new stack aren't orthogonal to services they're actually one of the key selling points of services you can use whatever stack is most appropriate for the task at hand without needing to commit the entire project to it. you can use postgres for the 99 of your app that's crudy and i dunno cassandra for the 1 where it makes sense. it's difficult although not impossible to do that cleanly within a monolith.;0
12509219;HackerNews;2016-09-15;i think it's more of whether or not you need that scale. if you don't have the resources for it to make sense to optimize everything like that you're probably wasting your time iandi making things slower by pursuing microservices.;0
12509204;HackerNews;2016-09-15;yes i have definitely experienced this. at the company i work at we have dozens of super tiny services that could have been replaced with a single class or module in a codebase.each of the dozens of microservices gets it's very own dedicated aws load balancer rds instance and autoscaling group in multiple regions. just the infrastructure management alone is monumental.iedit punctuation.i;0
12509173;HackerNews;2016-09-15;my approach is to design like microservices and develop like a monolith. thinking about microservices will force you to define module their boundary and interfaces. a monolith will simplify deployment refactoring. once your code matures you'll know if any microservice has to be taken out and deployed seperately.;0
12509152;HackerNews;2016-09-15;why would you not be able to scale a monolith? you can apply the same principles to it stick a load balancer in front of a micro service and scaling based on measured load?a microservices allows you to scale up very particular components of an architecture but there is nothing stopping a monolith from being horizontally scaled in just the same way. in aws i would make the monolith deployed with an ami in an autoscaling group with a load balancer in front.;0
12509129;HackerNews;2016-09-15;microservices like nosql databases and complex deployment systems docker are very important solutions to problems a very small percentage of the development community has.it just so happens that the portion of the community is the one most looked up to by the rest of the community so a sort of cargo cult mentality forms around them.a differentiator in your productivity as a nonhugecompany could well be in not using these tools. there are exceptions of course where the problem does call for hugecompany solutions but they're rarer than most people expect.;0
12509066;HackerNews;2016-09-15;this could be titled if you do things wrong it won't be good.a lot of his examples are of people doing things poorly or incorrectly. i could make the same arguments about object oriented programming my saying it's bad because someone makes every function a public function.for example microservices are absolutely more scalable if done correctly with bulkheading and proper fallbacks and backoffs and proper monitoring altering and scaling.but those things are hard to do and hard to get right.;0
12509062;HackerNews;2016-09-15;agreed most of the points this article makes are invalid as well. google has been running the microservices pattern forever and seems to scale fine. for example he mentions that costs are ndoe based but no where in a microservice pattern does it say each service has to run on its on vm;0
12509057;HackerNews;2016-09-15;i for one feel the same way when someone tells me they are building microservices for a small application that they don't ever plan to scale to that levels. imo amongst us there is a widespread issue of here's the new cool thing my applicationsystem has to do it. the other day a friend was talking on and on about setting up a hadoop cluster for what i saw as a onetime use batch script.;0
12509030;HackerNews;2016-09-15;as someone working with this setup right now coming from what is fondly referred to around here as the godmonolith of our 1.0 version i couldn't disagree more....but as always this is an artform writing and designing not laying down pavement.there's no right way and any blanket statement about anything is false.don't use microservices where they don't make sense make educated decisions and choose the best option for your situation.it made sense in our situation because all our services have very very very specific rules and boundaries and there's no overlap anywhere.;0
12509025;HackerNews;2016-09-15;one suggestion i would make if you are going to use microservices is to consider using grpc rather than rest. you can save yourself a lot of the hassle involved in the communication that way and make things quite a bit faster.;0
12509023;HackerNews;2016-09-15;the title should be i've never implemented microservices properly so you should avoid them.;0
12508957;HackerNews;2016-09-15;from personal experience microservices enforce a clear interface and isolation pattern. this is achievable many ways but having discrete deployed code makes it very hard to violate rather than being disciplined.licensing costs can go drastically up as most modern licensing is nodecore based. as can deployment procedures get more complicated.i would love to understand how this article believes that the modules in a monolithic system can be scaled horizontally if they are actually a single code base in a single system. either the system isn't monolithic or it they have never really done it. sticking a load balancer in front of a micro service and scaling based on measured load requires tools and technologies but is very scalable. it also allows you to do rolling deployments of drainingrotate outupdaterotate in that allows you to get near no planned downtime.distributed transactions are the devil but you don't need to do them in a microservice design. it requires design work on the front end to clarify what the system of record is but if each service has a domain it controls and all other services treat it as the truth it's rather simple. i say this having researched doing payment transactions across geographically diverse colo's and we treated that as a shardingreplicationrouting issue very successfully.ninja edit starting with a microservice design is most likely overkill for a lot of systems but either way clear interfaceboundaries in your system are good and healthy;0
12508941;HackerNews;2016-09-15;raises some good points but i think the title isn't really correct. it's not don't use microservices it's more about making sure you understand the implications of having a microservice architecture and making sure it's not an excuse for not writing a monolith or soa properly.;0
