ID;Source;Creation Date;Content;Sentiment
13167188;HackerNews;2016-12-13;Title:Microservices? Please Don't, Content: https://dzone.com/articles/microservices-please-dont?oid=hn;0

13180565;HackerNews;2016-12-15;microservices don't solve the volume problem a monolith can have multiple to deployments to handle volume.;0
13172585;HackerNews;2016-12-14;so break that logic up into smaller services yet again splitting up the domain into smaller pieces. no one said a microservice can't call another microservice!logins are a bad example because it really shouldn't take 100k lines to handle it but replace 'logins' with any business domain logic that you need.and honestly the biggest challenge often is building the simplest api possible without limiting your clients.;0
13172233;HackerNews;2016-12-14;i think if you are not capable of designing a decent api you won't be able to design good microservices either. both require some level of competence and discipline.;0
13172205;HackerNews;2016-12-14;but your networked api is language agnostic your library is not.it depends but microservices are in many cases better where your application is large. examples aws uber.monolith is better if your application smaller and cover just single problem. examples slack trello jira;0
13172129;HackerNews;2016-12-14;microservices imo are more about scaling engineering organizations than they are about scaling actual code or producing better code. treating each part of the product as a selfcontained service a product in itself with welldefined customers and defined contracts with those consumers will often allow different teams within an organization to operate with more autonomy.;0
13171992;HackerNews;2016-12-13;the author addresses building internal software as monolith vs. microservices not the use of others' services as part of one's monolithmicroservice.;0
13171127;HackerNews;2016-12-13;the current thoughts on microservices is that you should really reevaluate how critical strong transnational guarantees really are to your application.are there some examples of what else one can do?i'm generally fine with service 2 eventually being called if service 1 is but then i need that to happen.e.g. i have a payment service and an internal subscriptions service. if user requests a refund i have to both issue refund to payment service and cancel internal subscription;0
13171065;HackerNews;2016-12-13;not really. that section is about simplicity. microservices can be more complicated but they shorten the feedback loop and reduce handoffs.;0
13170734;HackerNews;2016-12-13;a problem i see with many microservice vs monolith discussions is that there seems to be an assumption that it is a binary relationship instead of an analog one. that is there exists all sorts of architectures in between the microservice model and monolith model that have different tradeoffs. you have programs like postfix which has a collection of small applications working together via sockets queue based separation like sidekiq rpc systems like protobuffers or thrift etc. you don't have to use an httprest api to get many of the benefits of microservices while controlling the complexity.;0
13170456;HackerNews;2016-12-13;a company of 100000 with 100 developers does not make high level architectural decisions from a blog at least it should not. if you read the article and can't identify exactly why the issues he raised don't apply to your organization's architecture then it probably idoesi apply to you.the author did address your situation and said to use microservicesiwhen youre ready as an engineering organization.ibut for most smaller companies the issues raised by the article are significant one company i worked at tried to do microservices and found that doing distributed transactions across multiple microservices was causing much more complexity than the microservices saved. doing nestedrecursive transactions and rollbacks across multiple services was causing multiple problems especially in deadlock detectionavoidance. they eventually moved much of the code to a more monolithic service.;0
13170177;HackerNews;2016-12-13;because you obviously need to add that feature to service b before anyone can use it. this goes for anything in software libraries products apis etc.ideally that feature should be developed indepedently by the team looking after that service. it could however be a feature request by another team.once the feature is ready you deploy it and then advertise this feature is now available. if it's a breaking change you version it so it doesn't effect existing services.then the team for service a can now start integrating that feature into their service.you don't need complicated orchestrated deployments. the time from serviceteam b advertising that the feature is available to service a acutally consuming it may be weeks.you just treat the microservices as separate products exposing a api which operate on different timelines. other teams may request features but the team maintaining the service determine the how and the timeline. obviously higher priority items get developed first.;0
13169842;HackerNews;2016-12-13;we did a selfdriving vehicle for the 2005 grand challenge as microservices. this was under qnx a hard real time os with really good interprocess communication. samecpu overhead for interprocess calls is very low and calls over the network are also efficient.that architecture was mostly because there were lots of things running asynchronously that were not in sync. the sensors lidar radar gps ins wheels etc. all had their own clocks and schedule. an interprocess call was either do this on your next cycle or what was the situation at time t? a request for where were we at time t returned an interpolated value from gpsins fusion t had to be at least 50ms or so in the past so there were fixes available before and after the requested time. this allowed asking for position info more frequently than some sensors could respond. on each lidar line scan the vehicle position was interpolated and used for map updating. planning always ran a little in the past so we could use interpolated rather than extrapolated data.this sort of thing is common in robotics but may not be that helpful in web services.;0
13169674;HackerNews;2016-12-13;so as a small company or startup the upside of microservices is the architecture lends itself well to the use of third party services. using auth0 for user auth is awesome for not having to right a ton of user management boilerplate. content ful for cms capabilities gives you a content management system and ui. firebase for db and push services amazon sns for notifications.a lot of early prototyping and startup tasks can be done gluing together third party services while you focus on core product offering. you can always pull back services as you outgrow these. i think this use case is one of the huge reasons microservice architectures have been so popular.;0
13169388;HackerNews;2016-12-13;when should i use microservices?when you ineed toi.there is a long history of applications being implemented poorly and then switching their design in order to fix the implementation. istop that!i shitty legacy codebases are a fact of life but just changing the design without considering why it ineedsi to be that way won't result in anything more than a new shitty implementation.at a previous employer there was a mandate given down that all new services had to be 100 apidriven. of course very few people followed this. but even if they had this would not have resulted in every single team's tools performing better or more reliably. some head honcho probably just wanted the ipotentiali for all of the benefits of services with apis but completely ignored the fact that there's cases where you just don't need an api or that it would be effectively meaningless to its function.you can design monolithic now and split out microservices later or vice versa. the former allows you to work faster and get shit done now. the latter gives you the iideai that in the future you can tie together new services with a minimum of effort but not a promise. add to that that it's the equivalent of wrapping every system call in a shellack of ipc calls and you get into some really kludgy stuff. and heaven forbid you ever need to call one of those services 10000 times more than you used to and suddenly wonder why there's a big bottleneck in your system that didn't exist when the function was monolithic.;0
13169376;HackerNews;2016-12-13;like all things in computing sometimes it works sometimes it does not.an example of when its a stupid idea is thisa set of microservices for generating transcriptions for videos. it consists of the followingso a wrapper for ffmpeg to take a video from s3 and split the audio put to a new s3 bucketo a service that take the audio url and uploads it to google stt spits out textnow there is no requirement for keeping audio about so this service is basically an unreliable single step service with poor logging and monitoring.it doesn't help that to make it all microservicey all the videos are shuttled about via s3. which means they've recreated a really shit file system on top of s3.all it needed was a hot folder and a commandline program to be triggered by inotify.but that wasn't new enough despite it working and being a fucktonne faster and easier to debug.;0
13169359;HackerNews;2016-12-13;i have this thing i say sometimes... which kneecap do you want the bullet in? microservices vs monoliths is a itradeoffi and a partisan holy war my way is right and their way is wrong argument fails to recognize that point.monolithic services benefit from integration and suffer from complexity. microservices benefit from simplicity and suffer from isolation. that's it. that's what matters. if you build a monolith sooner or later you wind up with a big ball of mud that nobody fully understands with careful consideration required before any new functionality or refactoring. likewise if you build microservices you wind up not knowing exactly who or what is dependent on whatever mistakes you might have made in the design in the first place and a lot of interteam negotiation required to make significant changes in how the microservices behave.what i find interesting is the evolution. if you have a ball of mud monolith it can be very difficult to refactor due to complex internal dependencies. pulling a chunk of functionality into a microservice is a way of pulling off a major refactoring without finding yourself up to your ass in alligators.likewise if you find integration points and interteam communication and duplicated structures are killing you you start merging microservices together building something more complex to solve complexities that exist outside of any single service.software evolves. deal with it.;0
13169341;HackerNews;2016-12-13;this was poorly worded on my part kubernetes does not in anyway solve this problem.instead i meant to use kubernetes as an example of the work being done to standardize and abstract these isortsi of microservice issues. kubernetes solves a lot of orchestration issues and i expect there will be greater work with other projects into solving other problems like distributed transactions in the future.the current thoughts on microservices is that you should really reevaluate how critical strong transnational guarantees really are to your application.;0
13169328;HackerNews;2016-12-13;hello all you nice folks on hn. original author of the article here. a few things i'd like to add since this is essentially what feedback i get every time this has made the rounds1. i don't think microservices are bad or that they don't work. quite the contrary. my argument is simply that there is a lot of additional complexity in using this approach to your architecture and to consider if you're able to handle that before diving in.2. this was adapted from a lightning talk i gave almost 2 years ago and is almost bydesign light on hard details or deep dives. it was meant to just introduce the problems by talking about fallacies which many think are strawmen but they're arguments that i've heard from people in my own discussions on the subject.3. even if you disagree with my points i appreciate folks taking the time to read and provide feedback.thanks!;0
13169250;HackerNews;2016-12-13;hi original author here!quickly on the elementary nature of the post this was adapted from a lightning talk i gave and so it was sort of designed to be a very quick introduction into the problem space.also this was meant to be and this is my own fault for maybe not more carefully spelling this out aimed at people just starting out with a new project or endeavor as a warning that just sprinkling some microservices on it is not a magical panacea for scalability or good software design.thanks for taking the time to read and comment!;0
13169219;HackerNews;2016-12-13;this argument i'll buy but there is a lot of really good work going into orchestration like kubernetes which makes a lot of these concerns much lower.can you explain more how kubernetes help with distributed transactions? i was aware they are more of a management system for microservices not something that handles db transactions.i've found splitting a monolith into microservices very painful because it prevents you from easily having allornothing db commit semantics. it's a lot easier to wrap your entire rpcapi endpoint in a single db transaction than it is to issue multiple commits e.g. an rpc to a microservice that writes and worry about the large number of states that can result if your endpoint crashes midway.;0
13169127;HackerNews;2016-12-13;where did the author get those fallacies to refute? they're more like straw men.there is no infrastructure panacea for crappy software engineering practices or bad unscalable designs.we've been running microservices in production for years. it is more difficult to partition behavior into little chunks than to make a monolithic app. it can be slower if you don't handle interservice rpc properly and as your servers evolve you have to stay on top of merging or splitting services as needed to maintain clean internal rpc's. it's a whole lot of work actually.why do it? because there are also benefits. in a large system microservices which are tested at the rpc boundary can be deployed independently of each other which is huge. if you have a bunch of people building a monolithic app you can only rev it as fast as the slowest of your teams can build and qualify it this has been the biggest win for us! it's easier to test these things because you can mock at rpc boundaries versus mocking code which is a more realistic scenario which helps you find issues like interrpc auth problems which you wouldn't find in codemocked unit tests.i think of it this way it's a whole lot of extra work which you have to do which buys you flexibility in deployment and testing. that's a big deal.;0
13169022;HackerNews;2016-12-13;polyglot i've concluded is more trouble than it's worth you always end up wanting to reuse code between modules so a good generalpurpose language for everything is much better than multiple languages. scaling is a nice problem to have it makes sense to split out services when you need to do so to scale but it's not worth the overhead until you need it particularly if you have enforced decoupling already because that ensures that you will be able to cleanly factor out services when the time comes.the more experience i get the more i think right tool for the job is bad advice. it makes it sound like tool choice is always 5050 whereas actually in a lot of cases it's more like 955. i've worked at a number of organizations using various architectures but the one that was most gungho for microservices was by far the least successful i think as a direct result of their approach to microservices.;0
13169020;HackerNews;2016-12-13;we do both.we have domain based services based on nodejs which tend to be smaller for example a content management service is separate from our notification service which is separate from our user authentication service which is actually provided by a third party auth0. in fact being able to use third party services in place of homegrown is one of the big benefits we've found of a microservice architecture. particularly when creating prototypes and trial apps for clients. the goal is in initial launch we leverage third parties as much as we can then pull back and replace with internal services as we need.but we also have a suite of npm modules which can be shared across the services for common tasks our orm models being a primary use case. maintaining the libs can be a bit of a pain point and making sure we have solid tests is crucial to making sure we don't break other services but it works pretty well.;0
13168885;HackerNews;2016-12-13;very true but decoupling is only 1 of the benefits of microservice. polygot environments scalability etc also come with microservices vs modules.as with everything its about the right tool for the job and a lot of organizations are more than happy to trade network overhead for the other bullet points microservices offer.;0
13168871;HackerNews;2016-12-13;that sounds like most of the benefits you're describing simply due to redesigning the system with the benefit of experience and the much deeper knowledge about the problem which you learned building it the first time. almost every point on your list could be restated in the opposite direction the current monolith is requires vagrant and doesn't mimick production nearly as well as smaller containers.the decision to require use has nothing to do with microservicemonolith and you'd get the same consistency benefits if you deployed a large single application in a container as well plus you'd have the added simplicity and debugging benefits from not needing to run additional applications for things like orchestration or service discovery. this design will be easier to understand and with dev turnover that means bringing new devs up to speed faster. this is especially important when working with outside development firms which we do.easier to understand is an aesthetic choice but it generally means things like a clean design organization good documentation etc. which can be done in a monolith as well. smaller services can encourage that but they don't necessarily i've seen plenty of gnarly interdependencies and underdocumented schemas and they have a hard upfront cost that now all of your new developers will need to be able to start reload and debug many separate services and understand any interdependencies. if your culture and tooling can manage that well it almost certainly could maintain a clean larger codebase following the same principles. deployments and scaling will be much faster. if one endpoint goes down it won't affect others. we are working to ensure one endpoint is not dependent on another.this is certainly the appeal but many places find that the scaling benefits are less than predicted because the business logic requires things which are harder than expected to separate or scale independently and there's a cost to separation if that means that you're now forced to implement something like distributed transactions or locking on top of your own custom services.again i think a team with the experience and support which can do this well in one model is also likely to have similar results with the other. when change is required in a certain part of the application only the related service can be modified and redeployed.if you have a welldefined automated deployment process this is a relatively minor benefit in either case. assuming you weren't just running a single instance of the previous app you need a way to handle things like bluegreen deployment managing schema updates etc. no matter which design philosophy you pick. no longterm commitment to a single technology stackthis is one of the strongest arguments but there is also a cost involved to having to learn and support multiple stacks. again i think that's more a function of culture and resources i've seen places which were too conservative until they couldn't find developers at any price as well as places which had severe oooh shiny problems where every module was written in the latest thing the lead developer had seen that week.again i'm not saying one approach is right or wrong but rather that it's too narrow a view to look at one practice in isolation. the microservice idea has been around for decades but it hasn't become universal because quality of implementation matters a lot and it's not optimal for all problems i'm pretty sure the team at oracle which built the deeply horrible business application i had to support about a decade ago used many of the same arguments to pitch the benefit of their enterprise java web service architecture which turned simple database queries into thousands of calls to services on a dozen servers. it's not that the concept was right or wrong but that it wasn't a silver bullet.;0
13168814;HackerNews;2016-12-13;you don't have to use a restful api and json. if you feel that configuration is lacking you can use a binary format and a nonrestful api.sure and that improves things a lot. i do use thrift via scrooge sometimes. i get the sense that isn't what the microservice advocates are talking about though.but even then why introduce a network boundary when you don't need to? all it does is make your system slower add overhead converting back and forth from dtos and give more opportunity for calls to fail.;0
13168706;HackerNews;2016-12-13;the problem is that network apis still suck. the boundary between components is the place where strong typing is most vital but microservices are still largely based around stringlytyped json.you don't have to use a restful api and json. if you feel that configuration is lacking you can use a binary format and a nonrestful api.;0
13168690;HackerNews;2016-12-13;we use queues microservices. it's a good combo.we also split the messages into different types commands and events. a command is to perform a specific action and is normally aimed at a specific service. and event alerts any subscribed service that a action has happened.so you send a createorder command. after processing it would fire off a createdorder event which any subscribed service could pick upsuch as a emailservice sending a confirm email. allows you to create workflows and monitoring systems quite easily.i'm interested in your experience with rabbitmq?;0
13168586;HackerNews;2016-12-13;now the argument is always well if you and your team were just better coders and more disciplined that wouldn't happen but in the real world it is shown to be incredibly difficult to actually have a team that is that disciplined and microservices give a real hard barrier to enforce that discipline.i agree that you need enforcement. but by having a multimodule project in a good build system you can enforce decoupling at build time without the overhead of a network bourdary.;0
13168569;HackerNews;2016-12-13;what's simpler than a container that has clean api in and out?the problem is that network apis still suck. the boundary between components is the place where strong typing is most vital but microservices are still largely based around stringlytyped json. if everything's an api call calling to it is trivial.calling a library api is a lot easier than calling a web api the interfaces can be their own container.no they can't. that doesn't make any sense. what do you even mean? i know that a container does its job and does it well.maybe. i'm never clear on what exactly the job of the container is supposed to be it seems to involve process isolation i'd think ordinary processes should do that? and maybe doing funky network namespacing and pid namespacing and a few other things like that only then other people are saying you shouldn't do that? a container makes it evident if it is the result of bad programming. you'll see good data go in and bad come out.only if you can tell good data from bad data. which is much easier to do within the language where you have a type system to help you. this plays right in to containerization. computestorage is cheap.computestorage is cheap so you probably won't ever have to make your system distributed. the biggest problem with microservices is that they slow development by making it much harder to run the whole system. anything that makes your development feedback loop slow is a big problem. yeah lisp and fp still hasn't taken off.fp is taking off. it's a lot bigger than it was 5 or 10 years ago. hence containers. it's a ball of privilege separation data segregation clean interfaces and easily maintainable.on the contrary containers are being pushed as the one true solution to everything and seem to aggregate a bunch of unrelated concerns.;0
13168567;HackerNews;2016-12-13;we split our monolith into microservices. we did so to make it easier to reason about but morever we did it so that we can apply different data persistence strategies for each entity. a monolith would have us bound to a single persistence type e.g. sql but microservices frees us which makes reasoning the application easier. the monolith didn't work for us so we moved to microservices but we didn't start with a microservice we started with the monolith and grew and evolved it as we needed too.;0
13168561;HackerNews;2016-12-13;the author didn't discuss queues once. i work at a company that uses microservices and queues. right now we use rabbit which is terrible for some reasons i won't get into but the one good thing about it is that each message has to be acked. you take a message you process it and then you make that you've processed it.things don't get lost. you can requeue messages that end up being deadlettered due to bugs. you can scale the number of services that read from that queue. you can have services up independently if they just read and write from a system that says here's a chunk of data to process.you can loose data with rabbit and if you're starting from the ground up you might want to look at something like kafka instead. if you don't care about message loss and just need throughput like if you're doing real time logs or sensor data something like zeromq might be more appropriate.the idea behind microservices is that you gain stability at the expense of some redundancy.;0
13168503;HackerNews;2016-12-13;imho i think some of the fallacies listed there are correct. having said that we cannot say something is bad just by the fallacies. here are some of the advantages of microservices 1. increased isolation reduced dependencies results in reduced code roll outs 2. also helps in software upgrades. for. eg. we need to upgrade from jdk as example from one version to another 3. smaller blast radius 4. a service can be managed by smaller team adhering to a specific service contract 5. forces team to do test driven development around the service contract.of course every engineering pattern comes with trade offs and they may not serve all use cases. we need to pick amp chose what works for the problem and team.;0
13168492;HackerNews;2016-12-13;why does one imply the other? i regularly build applications out of composable libraries that are wired together with bogstandard dependency injection systems and each separate library handles its own testing and can be kicked off in its own ci process.i could even add in the boilerplate and performance hit of microservices if i wanted tojust launch each library with its own thin http layer. but i don't and don't need to.;0
13168479;HackerNews;2016-12-13;in java for instance there are methods lt classes lt packages. once there are dozens of packages and thousands of classes a project becomes hard to navigate and understand especially when code isn't wellwritten with hacks disregarding modularizations. using microservices reduces scope and prohibits some of these nogos.at that point you step up to using multiple maven modules. which can give much the same development experience as microservices but without the extra network boundary.;0
13168464;HackerNews;2016-12-13;java is the one ecosystem that i think has this sorted because maven gets releasesversioning right and makes multimodule projects easy. you need to align yourself on consistent versions of your transitive dependencies but how many of your modules would not use most of your dependency libraries especially the allencompassing frameworks that tend to have transitive dependency issues anyway? and of course all your modules have to depend on the same versions of things but that's a good idea anyway even in a microservice world using two different versions of a framework for different modules will lead to a confusing debugging experience. classpath scanning would be an issue if done blindly e.g. not scoped to specific packages but who's actually doing that? and if you absolutely have to have multiple different versions of a dependency osgi while a massive pain is more lightweight than an actual network boundary.;0
13168445;HackerNews;2016-12-13;rather than responding to each of these points which are valid points here's a blog post i wrote for codeship a while back on microservices with heroku that dives into a lot of the tradeoffs from an organizational and infrastructure standpoint.;0
13168431;HackerNews;2016-12-13;microservices always struck me as a reinvention of service oriented architecture from the 90s and early 2000s. this was done using rpc protocols like java rmi or corbait's not really a reinvention it's just a continuation of soa as an architectural style. the new name mostly i think is to get away from the attachment to particular technologies which became associated with soa in the general consciousness.i've always thought the connection was obvious and intentional.;0
13168420;HackerNews;2016-12-13;you'll find most microservices experts will say microservices is a specific implementation of soa.a lot of the early soa architectures used huge middleware applications. modern microservices keeps the stuff inside the microservices themselves.;0
13168389;HackerNews;2016-12-13;i am an older dev that did a lot of soa work back in the 2000's and i disagree that microservices are a reinvention. in my opinion they are a further refinement of those soa ideas which is a good thing to keep moving forward as an industry.a lot of the soa work i did was putting restsoap interfaces on various monolithic apis. this was generally a good step forward and decoupled things especially the frontend but it was far from perfect. you still had the monolith and a lot of the codesmell that gets built into a monolith of spaghetti dependencies making it hard to write new features and move forward.now the argument is always well if you and your team were just better coders and more disciplined that wouldn't happen but in the real world it is shown to be incredibly difficult to actually have a team that is that disciplined and microservices give a real hard barrier to enforce that discipline.i very rarely see things that are truly reinvented and i think that is some serious ego bias essentially saying back in my day we did it right and you dummies are just figuring it out.instead i see every new generation of developers refining good ideas over and over again which improves our industry and products.;0
13168367;HackerNews;2016-12-13;the problem is if you need 100000 lines of code for your login you can probably break that up. ex employee login vs. contractor login.so where you might think microservices others may be thinking of your monolithic login service.;0
13168231;HackerNews;2016-12-13;some counter points especially with fallacy 1i fallacy 1 cleaner codeii you dont need to introduce a network boundary as an excuse to write better code.ii see this all the time as the argument against microservices but if you are just disciplined you don't need them. it seems pretty clear to me that a large body of programming history has shown that it is incredibly difficult for a whole team to be disciplined all the time. if everyone was perfect drivers we wouldn't need seat belts. some artificial barriers can be very helpful to tackle people working in the real world.i fallacy 2 its easierii distributed transactions are never easy.ithis argument i'll buy but there is a lot of really good work going into orchestration like kubernetes which makes a lot of these concerns much lower.i fallacy 3 its fasterii you could gain a lot of performance in a monolith by simply applying a little extra discipline.iagain with the discipline... but another point he makes really misses the marki additionally many of these stories about performance gains are actually touting the benefits of a new language or technology stack entirelyiwhen you have microservices it allows you to use the best tool for the job for each individual service. if you have a java monolith and you want to add new functionality that say golang would be better suited for chances are you are still going to develop it in java because it has to fit with the rest of the monolith. his example counters his claim.i fallacy 4 simple for engineersii a bunch of engineers working in isolated codebases leads to not my problem syndrome.ithis is pretty subjective and i really think depends on culture and buyin. almost all these same things could be said about a well architected soa monolith.i fallacy 5 better for scalabilityii you can scale a microservice outward just as easily as you can scale a monolith.iagain his example seems to counter his claim. yes you could segregate the api calls to your monolith but you are still going to have the overhead of those unused apis. unless you are doing some really clever dynamic loading that code is still going to be loaded into your executable package at the very least redundantly increasing ram load making for wasted resource utilization which converts to real dollar and cents in the vm world. additionally the author completely ignores any potential startup costs of needing to load a larger monolith over a smaller microservice.;0
13168222;HackerNews;2016-12-13;the article's author description points to a startup company with a handful of devs so it's quite likely that they indeed wouldn't gain much from microservices.but large companies with large code bases are a whole different story and what works well for the former might be unfeasible for the latter.;0
13168169;HackerNews;2016-12-13;i think the popular counterpoint has been microservices forces consideration of a good api because you are now on the network even if its just localhost.;0
13168124;HackerNews;2016-12-13;the big advantage of microservices imho isn't that their code is small though that can be true it's that their idomaini is small. if it takes 100000 lines to manage your user logins then do so but put it behind a simple api that the rest of the company can use.now you've freed yourself doubly everyone else can just trust that logins work and the team focusing on logins can focus on just that one thing.;0
13168094;HackerNews;2016-12-13;i'm around the developer age you call old and i actively work with microservices. i agree with your comment but i don't think there's anything wrong with reinvention as long as the new techniques libraries and frameworks are actually advancing the idea and not relearning by making the mistakes of the past. there's no reason why we can't make up new words for evolved or subsets of technologies if that gives the industry a common vocabulary to use.;0
13168068;HackerNews;2016-12-13;i think it's touched in 2 and 4. the author argues that it becomes more complicated because each service needs to be understood thoroughly and mentions the notmyproblem syndrome.while these issues are definitely there the problem of understanding a subsystem also exists on large monolithic applications. the notmyproblem syndrome seems like an indicator of bad devs andor company culture i've seen this happen once and might be mitigated by making people work on multiple microservices instead of completely separating them.in my opinion separating a big project into multiple services emerges from the fact that most languages don't have builtin features for modularization on a large scale. in java for instance there are methods lt classes lt packages. once there are dozens of packages and thousands of classes a project becomes hard to navigate and understand especially when code isn't wellwritten with hacks disregarding modularizations. using microservices reduces scope and prohibits some of these nogos.;0
13168066;HackerNews;2016-12-13;1 this sentiment.i'm currently working in a large monolithbased environment and i've never seen a tragedy of the commons effect degenerate an environment to a larger degree. poorly considered features and changes horribly written and slow tests bad modularity and a total inconsideration for the long term sustainability of the codebase are all par for the course. good ci configuration linters and lots of rubocop rules help a little but only go so far as they can't pick out code that's only subjectively bad.the basic problem is a total lack of any individual responsibility. just like how you'll have a minimal effect if you only throw one plastic bottle into the ocean introducing poor code quality code into the large repository isn't really your problem it's everybody's problem and nothing you can do will ever move the needle in one direction by very much.going too far the other way into microservices is probably also bad but given a choice between a company with a monolith and a company practicing microservices in moderation i'd go with the latter everytime.;0
13167984;HackerNews;2016-12-13;while breaking up a giant api is reasonable. microservices are tiny so you and the author may be talking about different things.what of your services consist of less than 100 lines of code? 1000? 10000?ps nanoservices are often used as the negative extreme but as microservices have a rather fluid definition people are not always on the same page.;0
13167901;HackerNews;2016-12-13;this article explains the caveats and pitfalls of microservices which are extremely important to understand.in fact when making any technical decision there are always pros and cons to every choice. it's infuriating to me when projects libraries frameworks articles etc. only communicate their advantages without describing their disadvantages and drawbacks. i can't and won't pick a technology until i understand what it doesn't do and when it doesn't work.so yeah this is a nice antidote to the microservices hype. in my experience these are some of the most important drawbacks of using a service oriented architecture.;0
13167804;HackerNews;2016-12-13;i'd like to hear some background from the author on his situations. personally my current company is over 100000 employees. we have a few 100 developers and many stacks web apps mobile apps etc. our api is essential and is currently a giant monolith written by devs who no longer work here.splitting api code into repos based on endpoints allows us to have small easy chunks to deal with. it also allows us to drop those into containers and monitor and scale much easier. it also means instead of one api team other devs can easily pickup a small code base and make changes for their stuff and submit a pr for the api team. this article seems a bit elementary to have been voted up high on hn to be honest. it failed to acknowledge the true merits of doing microservices properly and the huge gains. not all code bases are meant for microservices. however huge monolith api's in general are a very good example where it's a perfect fit.;0
13167658;HackerNews;2016-12-13;microservices always struck me as a reinvention of service oriented architecture from the 90s and early 2000s. this was done using rpc protocols like java rmi or corba while microservices are normally done with https or eventpubsub systems.basically you're reinventing linking and weaklazy binding across a system or container boundary. that's it. this is not a new idea. it has some advantages in areas like scaling and modularity but it also has disadvantages of increased latency complexity and all the weird edge case failure modes introduced by the fact that ithe network is not reliable.ione of the fun things about being developerold over 25 is seeing the same things get reinvented over and over and over again by every new generation of developers.;0
13167626;HackerNews;2016-12-13;seems to me that every point is well it depends and i didn't find it particularly convincing.i work in a microservice codebase with the realization that it might have been premature to what we needed but it does roughly live up to our aspirations. products sharing infrastructure and common functionality accounts file storagemanagement notifications email and solid boundaries for easier outsourcing support for using different languages in different parts if necessary.i've found gains i've found costs. the article is right in that microservices are not a silver bullet i think few people really believe they are.;0
13167618;HackerNews;2016-12-13;i've worked with microservices in the last year and a half and i partially agree with the author. my current approach is that of logical microservices running within the same processruntime but with a languageindependent api pure json for example.;0
13167583;HackerNews;2016-12-13;fallacy 4 simple for engineers leads to not my problem syndrome.i've found the exact opposite happens with microservices. with welldefined interfaces and apis i know exactly where things are breaking and can pinpoint the service and code more quickly.;0
13167507;HackerNews;2016-12-13;here's an exchange between jedberg1 and author sean kelly about a previous incarnation of this microservices article september 14 2016 and in that same thread in another response sk writesii do wish i had titled it better as most people have rightfully dinged me on this one i ... and yet here's another new article about microservices with another clickbait title. the subtitle then has the breathless icontinue reading to find out why.iserious nonsnarky question to hn audience do more than 50 really prefer this style of writing?1 i singled out jedberg's comment as significant because he discussed the costs and tradeoffs of microservices at 2 wellknown companies redditno netflixyes. the interview transcript;0
13167407;HackerNews;2016-12-13;the author never discusses the most important pieces of microservices. the biggest one in my mind being organizational scalability. he talks about scalability from a performance viewpoint but not an org standpoint. same with speed. yes microservices add overhead and can be slower than a monolith but they can give you autonomy and business speed. business speed is so much more important than performance.;0
13167375;HackerNews;2016-12-13;not sure i agree with the article. in a nutshell microservices enable the organization with rusted engineering practices to roll forward. initially it sounds like a hype but people will reap the benefits once they start building them.;0
