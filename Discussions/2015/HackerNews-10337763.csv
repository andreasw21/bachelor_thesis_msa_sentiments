ID;Source;Creation Date;Content;Sentiment
10337763;HackerNews;2015-10-06;Title:The microservices cargo cult, Content: http://www.stavros.io/posts/microservices-cargo-cult/;0

10399681;HackerNews;2015-10-16;we should grab lunch to chat about this.simply put you split a microservice when you need to split teams.microservices aren't a solution to a technical problem they're a solution to a socialorganization problem described by conway's law.;0
10347559;HackerNews;2015-10-07;if you've built your microservices on top of multiple databases then you could have built the same features in a monolith on top of multiple databases. what helped scaling is splitting the database not splitting the application.;0
10342626;HackerNews;2015-10-06;maybe every module in a monolith could also be considered a microservice with extremely fast networking and an extremely terse remote interface specification language.;0
10342591;HackerNews;2015-10-06;if you used those sophisticated ops and well defined deployment tools and dev environments to develop a monolith wouldn't it be just as easy?no it wouldn't allow us to be as fast. most of our services are under lt200locs not a policy just happens to be the point where people seem to split things out. the idea is that any service can be rewritten completely in a few days.there are no tie ins to any platform compiler version syntax or language. this might sound like chaos but it's a huge productivity gain as i feel full ownership over features i write. naturally we aim for good docs and code coverage and use continuous deployment and integration tools to keep everything green.as for scale any microservice can be run across any number of instances without having to scale up the entire platform. this allows us to identify hot areas and deal with them effectively.we don't use network calls well not http or tcp to communicate between services. services themselves are pretty transportindependent and work well over tcp but nats is the transport of choice at the moment for interservice communication.;0
10341182;HackerNews;2015-10-06;ionce there are more than a handful of people working on anything no one person understands the details of the whole. smaller specialized services can at least act as and enforce those boundaries as upstream comments said.iuntil you have so many services that you also need someone that understands the details of all the different services interacting.really if you can't control your developers from leaking through separative concerns then they'll do it in any architecture. monolithic or microservicesbased.;0
10340960;HackerNews;2015-10-06;again this is something that is independent of microservices. if you have a modular mono codebase then one team can easily deploy commits that only touch their module.;0
10340944;HackerNews;2015-10-06;for sure there's a buzzwagon and true microservices are just a kind of soa which itself wasn't new etc.what's different this time round is that microservice hosting should be much icheaperi.when you're cheap enough all sins are forgiven.;0
10340845;HackerNews;2015-10-06;i think you're right but scales will shift in a surprising way also it's possible to refactor to microservices bit by bit not all at once.1 easy scaling allow for worse coding and therefore quicker developement.for webscale you're right and if you can run it all on a single cheap server then no need to worry about it small servers are so cheap the cost per month is insignificant relative to say ramen cost per month.but what if you write your app incredibly inefficiently? perhaps because you develop it quickly you're not highly skilled or not even a developer it's difficult to optimise. it's very slow seconds per request. that's fine for getting started but you need to scale it far before it gets to webscale.you could just upgrade to a better server but at some point the costs becomes prohibitive. the key thing about microservices is that they should be cheaper because vendors can better utilise capacity and customers only buy what they need when they need it.2. you don't have to architect the whole project for microservices from the get go.e.g. if there's a single resourceheavy function factor it out into a microservice. your main code becomes super cheap to host the microservice only uses expensive resources as needed when and if it runs.at the moment microservices are a pain to set up and manage. but with tools it will become very easy to factor out a module into a microservice.that is assuming that code is already a separate module microservices aren't magic pixie dust!;0
10340745;HackerNews;2015-10-06;are they of necessity completely isolated units deployed with docker and kubernates on a coreos cluster and communicating only via http each with independent databases?i'm pretty sure the docker kubernetes and coreos parts are unnecessary as iirc microservices started being discussed before those tools were available those tools were driven in part by microservices but aren't essential to the model.http is likewise unnecessary its the most obvious protocol choice but there is no reason that microservices must be httpbased you could have a set of microservices using just about any protocol you want.;0
10340703;HackerNews;2015-10-06;there are other options like spend the same resources building a monolith that is not spaghetti. and it is certainly possible for the sum of microservices to become spaghetti.;0
10340528;HackerNews;2015-10-06;at least with microservices i know the interface is all i have to worry about.you wrap your code inside a reusable library if you want to encapsulate it and expose only a small public interface. you don't start a new service for that.;0
10340508;HackerNews;2015-10-06;the other benefit of a microservice is you can understand it. you can have the entire thing in your head. it's easier to maintain. with a monolith good luck.;0
10340359;HackerNews;2015-10-06;agreed. in fact batch jobs are in at least one dimension imorei decoupled than strict microservices.current client is a photobooth. photos all can be shared from client app and web each share is just a rest post containing sharetypestring and metajson all share types email mms twitter etc go through the same endpoint. web api simply adds these to message queue for the corresponding sharetype job to process. this way new types of sharing options can be added just by changing the client and adding the new batch worker no updates to the webapi server app itself are necessary.proper microservices are usually described as being directly coupled to each other. they're just the new hotness so everyone wants a piece.as most of the comments are saying choose the shoe that fits.;0
10340046;HackerNews;2015-10-06;yet another article that misses a huge aspect of microservices ireusabilityi. i'm going to borrow from an older comment 1 here.almost all of the swathe of microservices we've developed internally are generalpurpose. we've built a dozen or more userfacing apps on top of them. if i wanted to build a new app today i would typically sit down and write a node react app configure some backends and i'd be done. i don't need to write a new back end because i can just call our existing services.if you look at what a modern web app is most apps these days are actually stupidly similar. they typically need things like user accounts authorization with existing oauth providers e.g. facebook some kind of database to store and search structured content notifications email text push storing images or video syncing data from external sources analyticswe have generalized reusable microservices that do all of this.let's say i want to build a hntype link aggregator with comments. i will use our document store to store the links and the comments in a nice hierarchical structure. i will use our login microservice that mediates between an identity data model and an oauth account registry. i can use our tiny microservice devoted to recording updownvotes. i can use our analytics backend to record highlevel events on every ui interaction.i can write this without a single new line of backend code.this ability to pick and mix functionality you need is the real largely undiscovered beauty of microservices in my opinion. it's the same idea that makes aws attractive to many people you're building on the foundation of thousands and thousands of work and reusing it.we just whipped up a new site recently where 95 of the work was purely on the ui since all the backend parts already existed. the remaining 5 was just code to get data to the system from a thirdparty source plus some configuration.reusability requires that you plan every microservices to be flexible and multitenant from day one. it's a challenge but not actually a big one.is it possible to do this monolithically? sure. i would be afraid of touching such a beast. we have very few issues with code devolving into legacy for example the strict sharednothing apis ensure that halfbaked clientspecific hacks don't sneak into the codebase. if anything messy happens it happens in the client app and that's where it should happen. eventually you'll throw the app away but the backends remain.;0
10339776;HackerNews;2015-10-06;really? it's ten times as much work to implement microservices?no it says the servers have to do tenfold more work not you to implement them. whether that's correct or not is another discussion.;0
10339523;HackerNews;2015-10-06;i was just talking with a friend about batch jobs and i was remarking that they can also be considered microservices. the difference is that batch jobs don't need to be interactive so the contract is different.unfortunately it's a bit late for me to include this in the existing article but it's a good topic for a next article. you will generally have a much easier time splitting tasks off and running them on workers than fullblown standalone services because the mq can retry the tasks they can be idempotent you can have different timeouts etc.the usual definition of a microservice is a stricter subset of a task in general.;0
10339518;HackerNews;2015-10-06;i'd take a stronger line than this. microservice architectures scale iworsei than monoliths. because with a monolith you can just do this moreover unless you're doing something intrinsically computationally expensive video transcoding or whatever or you've screwed up your bottleneck will be in the database anyway. scaling the database looks exactly the same for monoliths and microservices you can scale up scale out or split.;0
10339444;HackerNews;2015-10-06;iconflicts over what truly constitutes a microservice will ensue.iso true. i feel like this has always been an issue in the services world. it's hard to nail people down on a definition that's both accurate and prescriptive. either you end up with a definition that is so generic as to be unhelpful or you come up with narrowly defined definitions that miss important use cases. i've decided that services is a word like jazz or porn or art you know them when you see them.my only wish is that we could as an industry find a way to better bootstrap our systems. we have a tendency to launch products companies around bad ways of doing things and then spend a not inconsequential sum of money retrofitting everything.it would be great to see tools and framework built from the ground up to address both developer productivity iandi scalability. it too often feels like achieving scalability comes at the cost of developer productivity... perhaps because by the time you need to scale you've got enough resources to hire tons more developers and have them engage in menial tasks.;0
10339423;HackerNews;2015-10-06;i think it is fascinating how an idea can emerge with a fuzzy meaning and in the space of 2 years become rigidly associated with a narrow set of technologies which will surely be much more temporary than the idea itself thus forcing people after 3 or 4 more years to come up with a new word for roughly the same idea.in the summer of 2013 i was working at timeout.com and we were trying to reinvent the architecture of the site. timeout.com had spent several years using the php framework symfony to build a massive monolithic cms and the thing was a disaster. it was shockingly slow. if you ssh'ed to inside the datacenter and then tested the response time of the system under ideal conditions from one computer in the data center to another computer in the data center then the average response time was 10 seconds!this lead to a long internal debate. i advocated for what i called an architecture of small apps because at that time none of us had ever heard the word microservices. i did not hear that word until march of 2014 when martin fowler wrote his essay but back in the summer of 2013 with permission i published the whole internal debate that we had had at timeout.com you will notice that you don't see the word docker in my essay nor do you see it in martin fowler's essay. and in my essay i suggest we use zeromq to bind our apps together.but 2 years after we had our internal debate i've noticed that more and more people now associate microservices with a very specific set of implementation details docker kubernates http and service discovery.i acknowledge that these 4 technologies can be combined in very powerful ways. i currently work at the startup incubator run by nyu and i get to eavesdrop on what the folks at lsq.io doing since they sit next to me. and i get that pelly is a frighteningly smart guy doing extremely cuttingedge stuff. i totally admire everything they are doing.however i personally feel that i'm following a microservices strategy and yet what i'm building is still a lot like what i described in my essay of 2013.july 30th 2013;0
10339341;HackerNews;2015-10-06;as with everything there are advantages and disadvantagesthe author focuses on microservices however i think there is a larger point to be made. it is not that some particular architectural pattern is bad or good it's that when you don't fully consider the requirements of your application and apply some pattern or technology just because it's the hot item this week you are going to end up with problems. this has less to do with microservices in my experience and more to do with less technical managers making decisions for a project when they don't fully understand.;0
10339286;HackerNews;2015-10-06;martin fowler identified a lot of the same tradeoffs in this video one benefit i haven't seen mentioned yet microservices are effective at reducing the mental page size when working on any particular part of the system.;0
10339245;HackerNews;2015-10-06;you're giving me flashbacks.but the parallels are eerie. someone gives a nomenclature to a style of architecture that many people were already using just last week i heard that netflix invented microservices and suddenly the attention of the industry pivots. technologies will be invented to ease adoption yay! but people will forget that this architectural style is one part of a solution for a particular type of problem it is not a solution for every problem nor does adopting it mean all of your other problems will go away.but consultancies will rise debates will rage and conflicts over what truly constitutes a microservice will ensue.;0
10339168;HackerNews;2015-10-06;at my job we've avoided microservices thus far. 90 of our deployments are just to heroku. every now and then i lament in my mind that we aren't using the coolest new tools docker microservices and all the things that come with but what we have works ireally welli and we can easily scale up by 10x and things will still work.every time i think of the mess that it will cause to break up things to microservices i'm glad we aren't doing it yet. when the time comes we'll roll out to services asneeded but that day isn't today.;0
10339132;HackerNews;2015-10-06;i think this article isn't very useful. it's unfortunate that we have this human need to blow things up and then deflate them. i dislike the term microservices because for most organizations all it does is plant a flag all the way across the yard from monolithic. suddenly the guys at the top have a new buzzword and the engineers are all trying to make their services as small as possible so they're micro enough.most of the gotchas the article mentions aren't logical consequences of decomposing into smaller services at all. you don't have to have different data stores for each service. you don't need to marshal data between services. if a service needs to call a service it's just a client like any other client so if we want to call standard http requestresponse handling marshaling i guess it will sound more complex and scary. breaking a monolithic app into smaller pieces doesn't increase complexity it reduces it. and to the extent you have more things to monitor that probably means you can now monitor and control things that were more or less invisible outside the log data in the monolithic architecture.more importantly decomposing a problem into logically related areas of functionality that can execute separately allows you to make the most efficient use of compute resources and it is consistent with the idea of favoring multiprocessing over multithreading. in almost every way groups of simpler things collaborating makes much more sense than large complicated things that do all. it's only when we create these knights in shining armor that people start feeling like they have to be knocked off their horses. use the tools and techniques that make sense.;0
10339114;HackerNews;2015-10-06;iin fact someone needs to write an article on levels of microserviceness which certainly has multiple dimensions and branches and point out the benefits and drawbacks of each level.ii think i might iliterallyi have a soa maturity model slide laying around somewhere from my mid2000's consulting career.let me know if you need it ironically or not.;0
10339059;HackerNews;2015-10-06;if the argument we're going with is well microservicesfirst is relatively new so we won't know for another year or 3 if this is a mature route to take but everyone's trying it anyway so let's do that there is no way i can or want to sell microservicesfirst to stakeholders.;0
10339039;HackerNews;2015-10-06;i think one thing that microservice and some other models correctly point to is that tiers of the traditional 2tier 3tier and ntier architectures aren't universal and that their are good reasons for some systems to have components that are arranged in some manner other than stacked fronttoback layers.;0
10339026;HackerNews;2015-10-06;i always though that microservices would be helpful if you had frequent transient programmers like contractors. where you can onboard a new person faster by having them focus an a much smaller view of the system.;0
10339009;HackerNews;2015-10-06;the micro in microservices is the issue. it reminds me of the nosql movement. the truth is that everyone has a multitiered architecture. the only question is how many tiers you need. it's always more than 1.;0
10338990;HackerNews;2015-10-06;agree with the premise. an excellent example premature optimisation or yagni. an alternative is to factor your code by business capability bounded context as microservices endorses. factor the code as such but don't deploy the logical partitions as physical ones.keep it all in one deployable artefact inprocess for as long as you possibly can. use an inproc message bus first don't dive into rabbit until you know you need it. as soon as you require that infrastructure cost for http mq monitoring a ballooning of boxes vms deployment complications you'll notice the spike in operational expenditure.grow you architecture organically.;0
10338961;HackerNews;2015-10-06;looks like you can afford to have monolith and don't worry about this microservice thing p.;0
10338948;HackerNews;2015-10-06;there are also a distinct lack of tools for debugging coordination and scheduling problems in a imicroservicei or as they used to call it in my day service oriented architecture system.in an asynchronous rpc scenario does microservice a listen for the appropriate response message from microservice b before continuing work on request x99? does it respond to all messages in the appropriate order? what happens in a cascading failure scenario when the backend system microservice b relies on is taking too long due to bad hardwareburst trafficddosresource contention?do you have tools that can analyze your program for critical sections where you need explicit locking and ordering mechanisms? do you have analysis tools that provide guarantees that your fancy distributed architecture is completecorrect?these are just a sample of the things openstack has to think about a microservice architecture for managing orchestrating and authenticating access to datacenter resources. it's a hard hard problem and an ongoing effort by thousands of wellpaid engineers across the globe to get right.i have no doubt that a small team of talented developers could stand up a system of apis around their core services to get a system running. however i can guarantee that they will be making huge tradeoffs in terms of correctness and reliability.at least with a imonolithi is that a pejorative? application you do have tools to analyze and debug your code that work well and have been battletested for a couple of decades. i suspect you would produce fewer bugs if you were constrained for developer talent and time.;0
10338913;HackerNews;2015-10-06;this leaves open the question of what iarei microservices. are they iof necessityi completely isolated units deployed with docker and kubernates on a coreos cluster and communicating only via http each with independent databases? yes this seems a bit much for most projects.there are midway options though. even the lowly batch job is a good way to get some of the decoupling without having to go allin. i find batch jobs and message queues give me 80 of the benefit of microservices with only 5 of the pain.in fact someone needs to write an article on levels of microserviceness which certainly has multiple dimensions and branches and point out the benefits and drawbacks of each level.of course the end game being a docker container for each line of code.;0
10338798;HackerNews;2015-10-06;boundaries have problems in monoliths as well can't really imagine it would be any easier with microservices.;0
10338711;HackerNews;2015-10-06;when you were evaluating amqp did you consider a lightweight rpc system like nameko ?;0
10338651;HackerNews;2015-10-06;building any new feature into the program means you get to walk the dependency treesame with monoliths except it is often a worse experience. at least with microservices i iknowi the interface is all i have to worry about. in monoliths of any size inevitably someone has reached into parts of the program they shouldn't have just to get something 'done quickly'. and this is one of the main benefits of microservices enforcing the interface boundaries. related deleting a field ... never going to happen. we're talking years of planning. any field added ... ever ... has to be taken along for the ride for years. oh and don't even think about deleting the code that interprets and supports the field for the same reason.that's just poor design and happens just as much in monoliths. the db is the almost always the challenge when removing a field. i could argue that microservices make it easier since the service providing access to that field could remove it from the db and then dummy it out until clients are updated. also why wouldn't someone remove the field from all the clients when removing it from the supplier?with that said i agree that microservices should be something that happens organically from a monolith. think about an amoeba that reaches a certain size and only then do parts split off. i also think there is some ambiguity to what constitutes a imicroiservice. i'm sure my idea of proper granularity is different from others.;0
10338626;HackerNews;2015-10-06;the problem with microservices for us has been the composition of operations. yeah we use the rx observable patterns and it helps but the code is still non intuitive for new developers if the language is pretty much proceduralimperative. even with languages like scala it still gets confusing. even if you have a language where threads are cheap golang you still have to compose the operations.i have been meaning to see if there are microservice like frameworks for haskell similar to hystrix which is what we use.;0
10338624;HackerNews;2015-10-06;what you're describing is an operating system.replace microservices with microkernel and you can read the torvaldstannebaum debate instead 1;0
10338597;HackerNews;2015-10-06;that's somewhat disingenuous. historically all software has been monolith first and has only adopted an soa out of need. the microservice mindset is relatively new and we're not really going to see it mature for another year or few.;0
10338580;HackerNews;2015-10-06;do you think you can do microservices without devops? i see the correlation you're making but i think a more traditional organizational structure can work fine.;0
10338558;HackerNews;2015-10-06;a network protocol is only a small component of a microservice in terms of affecting performance by far the biggest difference is an inprocess call vs networkipc call. the latter is at least hundreds time slower due to how computers work 0.i'm talking about a function call overhead only so if the actual processing takes more than a few milliseconds it stops being important.0;0
10338552;HackerNews;2015-10-06;i think some of these points are gross exaggerations. you immediately increase the things your servers have to do tenfold.really? it's iten timesi as much work to implement microservices? personally ive seen slowdowns on the order of 1000 when moving to microservices yes ten times slower.then you implemented your microservices iwrongi.i think that the author's understanding of the goals and purposes of microservices is maybe a bit misguided. microservices are about frontloading scaling problems not about having a clean architecture or smaller codebase. if you never need to scale you don't need microservices but you're probably wrong.the flowchart at the end of the post really underscores for me that this author's argument is not genuine. he holds up this shibboleth of a monolithic architecture something that doesn't really exist in 2015.;0
10338473;HackerNews;2015-10-06;very true but i've heard modularization touted as a benefit of microservices many times as if it's exclusive. you can get modularization as a firstclass feature in your favorite language and almost for free!;0
10338467;HackerNews;2015-10-06;tldr microservices have their place and can be useful for certain environments but they are not a fixall.they can be pretty nice for multitenanted development environments. sure you could use any of the other isolation techniques but being able to provide an environment that can be started quickly and somewhat easily depending on the rest of the services required. not to mention that the popularity of container systems and their ease in understanding dockerfile vs rpm spec means that other people can hack away at the dev environment without having to know the ins and outs of building proper packages although they should learn.now for a production environment i would never move to a microservices architecture for the reasons listed in the article and my own dislike for adding overhead and complexity to solve issues that can be easily dealt with using tools that have existed for years proper packaging with dependencies etc...;0
10338430;HackerNews;2015-10-06;the article didn't even mention a lot of drawbacks changing anything means changing half a dozen programs. potentially in different languages.building any new feature into the program means you get to walk the dependency tree making sure no serialized stuff from a new version gets sent to an old version. good luck with circular dependencies.related deleting a field ... never going to happen. we're talking years of planning. any field added ... ever ... has to be taken along for the ride for years. oh and don't even think about deleting the code that interprets and supports the field for the same reason.also related best of luck with the interactions between oh we're not going to do that after all sorry about asking you to already push that and update the database and the we really need to do this next thing right now features. and theconstant serialization overhead. people go overboard with this microservice crap and the result is that 99 of your program's cpu time is used putting objects to json and back which is very expensive due to constant alloc'ingi and you have 10100 times the normal memory overhead.microservices should be like optimization build your program without using them and then figure out where they'd make sense.i yes i know you can sortof avoid it these days with cap'n proto and flatbuffers;0
10338420;HackerNews;2015-10-06;of course microservices are just another tool in the toolbox.i think what's frustrating is the lack of support in moving from a monolith to a microservice architecture. i haven't built a lot of them myself but it feels like you're rolling your own frameworkarchitecture whenever you need to make the transition. is that anyone else's experience or is it just not possible to codify best practices?;0
10338414;HackerNews;2015-10-06;the main benefit of microservices is that each team can ideployi their service independently.this is really useful to reduce the level of required of interaction and pressure between teams.;0
10338410;HackerNews;2015-10-06;microservices are advertised as a means to modularization but it's what programming language modules are for they are defined on source code level and can be freely used in different runtime components without networkopsversionmanagement headaches. when you have your module defined that way you can think of exposing it as a microservice because this may make sense for your use case.yes yes yes ! if your architecture and data model are funked up then it doesn't matter how you implement them you are screwed. on the other hand proper modeling with separationofconcern and welldefined interfaces will let you implement as anything you need be it microservices or function calls inside a monolith.;0
10338406;HackerNews;2015-10-06;martin fowler wrote a great post monolithfirst 1 just a few months ago. ing him 1. almost all the successful microservice stories have started with a monolith that got too big and was broken up 2. almost all the cases where i've heard of a system that was built as a microservice system from scratch it has ended up in serious trouble.1;0
10338405;HackerNews;2015-10-06;oh dear. we're staring down the barrel of the microservices gun. it's the only answer to a huge monolith php app i'm told. we're a small dev team have no scaling issues we just have badly designeddisorganised data all over the place.perhaps i'm being selfish because having all your data in one place esp with an orm on top makes my job of automation really easy. e.g. to generate monitoring configuration only for servers in accounts that are not suspended that are provisioned that have a public ip that are not in the blackhole table etc is really easy with joins.;0
10338372;HackerNews;2015-10-06;this phenomenon is just part of human nature. same thing happened with oop design patterns tdd etc.to apply microservices effectively you should first build the monolith modularizing at the source code level and adding choking points as needed. over time microservices will naturally roll off the monolith not unlike boulders rolling off mountains after rain or earthquake. don't go dynamiting in anticipation.;0
10338325;HackerNews;2015-10-06;and it makes no frigging sense for a startup or any new project to start with microservices...doesn't that really depend on what the startup is doing? if your goal is a saas platform things might be different. ..you'll often end up with microservices that are divided in suboptimal ways causing a lot of pain.or one large monolith that is a mess. really doesn't matter if you go with monolith or microservice architecture you can screw up both ways.;0
10338323;HackerNews;2015-10-06;having read one of the success stories linked in the beginning i think i am starting to get it. that was a rather candid article describing a team which after having got burned by a sprawling monorail architecture decided to split it up into services nothing micro there based on iorganizationali viewpoint if there is some knowledge about a part of application shared by 34 engineers it makes sense to split it into a separate module so it can be developed faster. and as i am inferring from the pictures their services don't call each other much so it is really close to a modular monolith. so if migrating to microservices architecture really means splitting that damned monorail into something more manageable then it is a really good idea after some point.;0
10338314;HackerNews;2015-10-06;many of the advantages of microservices can be achieved by refactoring your monolith code to be less monolithic.i would suggest using functional styles wherever possible plenty of isolated unit testable code and a hexagonal architecture that pushes all the io mutation side effects etc. to the very boundary of your code. also see gary bernhardt's boundaries talk for more interesting thought in that vein;0
10338296;HackerNews;2015-10-06;you're right but sometimes modules ! servicesyour database is a service. you can't use multiple dbs depending on the situation.if it can be replaced by multiple instances of the same module than yes creating a microservice is probably stupid;0
10338282;HackerNews;2015-10-06;sadly often the reason you need to work with different people is that you've architected your product to be so complicated that it needs lots of guys working on it.it's amazing how much a team of one can do if you don't saddle said team with arbitrary complexity such as a microservices architecture. maybe you'll need to scale to that level one day. but you'll definitely want to ship. one guy and a sane architecture can do that.;0
10338275;HackerNews;2015-10-06;yep when evaluating whether to go with more microservices we looked into rabbitmq for the transport and protobufs for serialization. in the end we decided to roll the existing microservices into the monolith which was by far the better decision as we didn't need the scalability.;0
10338252;HackerNews;2015-10-06;some of the weaknesses can be tempered by not using http to communicate between the microservices slowdowns on the order of 1000 bunch of code necessary to marshalunmarshal data ... there are always dragons in there.and also problems of versioning data integrity etc.i've had those problems in a microservices architecture. that's things that are solved by protobuf0. your servers exchange small efficient structured data and you get tons of other benefits unmarshaling for free integrity versioning ....potential downside a language you want to use having no protobuf api.finally i see another downside to the microservices architecture it may be decided that the smaller decoupled code bases should be stored in multiple cvs repos. which turns into a nightmare a single bugfix may span across multiple repos and there is no clean builtin way to links commits across them you still should sync the interfaces e.g. with git submodules etc. this is a thing i've witnessed firsthand and proposals to merge the repos were dismissed since we were using a microservices architecture. yes it's a mistaken implementation of the microservices paradigm but it still happens.edit i recommend protobuf not by preference over other equivalent solutions but because it's the only one i know and have used. alternatives are evoked below.0;0
10338246;HackerNews;2015-10-06;the article is a little weak but well worth the read.i love the microservices concept but fair warning as bad as oo has gotten over the past 2030 years microservices promise to be even uglier.why? because not only are you mucking around in the code iyou're also mucking around in how everything connects to everything else in your cloudi.just like we saw vendors come out with clickanddrag ways to create new classes now we're seeing vendors start to sell prefinished microservices. get the disk out of the box boot it up fill out a couple of forms and voila! now you have microservices.that worries the living crap out of me because microservices iarei the architecture of the future. you just can't get from here to there using a magic bullet. learn you some pure fp make everything composable using the unix philosophy and keep your loc to a bare minimum. toss off every damn thing you don't need.as much as i know they are the way forward i have a bad feeling that consultants will have plenty of billable time coming up straightening out a lot of messes.;0
10338214;HackerNews;2015-10-06;as others have already pointed out you don't need microservices to achieve a good modularization of your code. then have each team work on a different module with clearly defined apis between them. no need to separate them with http calls.;0
10338187;HackerNews;2015-10-06;if i learned one thing in software engineering it's modularization matters most. and microservices seem to be the epitome of this concept.if you have to work with different people you need a way to minimize dependencies between them.also the more encapsulated things are the less the starting skill of a person matters. you just need people who get things done. later you can switch out the bad modules easily. which is a huge economic factor.i can't count the hours i spent with fixing horrible monoliths and the years it took to replace them.but if there is a horrible microservice you can do this in a fraction of time.;0
10338184;HackerNews;2015-10-06;rule of thumb divide number of fulltime backend engineers by 5 and you get ideal number of microservices .too many microservices is a complexity mess too little means you have a monolith that is hard to iterate on.;0
10338171;HackerNews;2015-10-06;i see the strengths and weaknesses in the article and the complaints from all the comments here but i still find the trade off of microservices worth it. it requires sophisticated ops and well defined deployment tools and dev environments but we have to handle ten billion requests a month on our stack. the ease at which we handle that scale and the speed at which engineers get to iterate and deploy makes microservices all the more worth it.;0
10338135;HackerNews;2015-10-06;magine that each python module runs as a microservice. for many modules this would lead to huge performance degradation for example a regexp module can be called thousands times per second the running time of a call is usually short and replacing an inprocess call with a network call will give 1001000x slowdown.this is absolutely irrelevant. if your call budget is 400ms then extra 4ms that it takes fetching a data from a micro service is negligible. make 400ms 4ms and you are done.;0
10338126;HackerNews;2015-10-06;yeah which just goes to show how microservices advocates understand programming.;0
10338118;HackerNews;2015-10-06;not only that the microservices is just sunrpc corba reborn and we all know how they worked out.;0
10338117;HackerNews;2015-10-06;i don't agree that scaling up is an unqualified advantage of microservices. in practice you have to coordinate communication between your services. though some of this communication will be asynchronous publishsubscribe ie speed unimportant some communication will necessarily be synchronous.if one heavy part of your rails app takes up 90 of the processing time there is nothing wrong with just getting a bigger machine for the whole app. the bigger cpumemorywhatever will be spent on the heavy part and the rest will be normal.for most business scaling is not a problem they can just get bigger machines. having to reimplement transactions across your microservice architecture really is a problem. very often transactions need to cross microservice boundaries and that really requires a lot of thought;0
10338109;HackerNews;2015-10-06;one thing that is usually overlooked do microservices fit your team structure? a team who spends all day together can manage a monolith very well synchronous releases everythingatonce are not a problem. if you don't need 247 then it's even better.however if you're a distributed team maybe across timezones quick discussions are difficult and 'costly' then microservices might worth the effort. managing the deployment and operations is more difficult but sometimes much less coordination is needed when people communicate through apis and not skype and slack.;0
10338065;HackerNews;2015-10-06;data segregation since all your data now lives in different data stores youre responsible for relationships between data. what would be a simple cascading delete in a monolith is now a complicated symphony of dependencies calls and verifications.imho this is the biggest problem with microservices transactions are not available in a microservice environment. you'll have to work really hard to get anything that comes close.;0
10338034;HackerNews;2015-10-06;yes a thousand times yes! microservices are yet another tool in the box but they shouldn't be used on everything. and it makes no frigging sense for a startup or any new project to start with microservices...the main advantage of microservices are in scaling and in reducing complexity of a big system but those advantages only make sense when you have enough traffic so that you have to scale or when your system has become complex enough to warrant microservices.when first starting development the most important thing is speed of development to get feedback from users as soon as possible. it's much faster to develop a clean well optimized monolith than to spend a lot of time developing a whole bunch of micro services. and while thinking in term of microservices will help you to better conceptualize your software architecture at this stage you don't have all the informations needed to have a clear idea of what the final architecture will be and you'll often end up with microservices that are divided in suboptimal ways causing a lot of pain.;0
10338008;HackerNews;2015-10-06;microservices are advertised as a means to modularization but it's what programming language modules are for they are defined on source code level and can be freely used in different runtime components without networkopsversionmanagement headaches. when you have your module defined that way you can think of exposing it as a microservice because this may make sense for your use case.imagine that each python module runs as a microservice. for many modules this would lead to huge performance degradation for example a regexp module can be called thousands times per second the running time of a call is usually short and replacing an inprocess call with a network call will give 1001000x slowdown.but if you take a different use case of the same module complex regexps running on large texts potentially causing outofmemory errors then packing the module into a microservice can make sense separate processes can have large caches an outofmemory error terminates an instance of a microservice only and not the calling process.generally i think the advice should be to always use source code modules in the first place and create microservices using these modules for specific use cases only involving runtime needs like caching fault tolerance scalability.;0
10337912;HackerNews;2015-10-06;i love his little worflow diagram embedded in the article;0
10337900;HackerNews;2015-10-06;i'm in the middle of a microservices mess than was forced upon us. i have nothing positive to say. if you're in the saas space already and it's not a greenfield project it's orders of magnitude better to deploy lots of smaller identical monoliths than it is to try and build and deploy lots of services and manage the contracts and complexity between them.major problems i've seen are per transaction performance sucks due to the network or ipc channels development friction logical complexity infrastructure complexity managing contracts between services debugging failures monitoring performance bootstrapping new staff and the biggest of the lot headspace.if you want to succeed at least in the short term just keep your monolith tight and fast and without sprawling infrastructure requirements. single machine single process single storage engine or database single messaging system. then scale that to multiple instances. if your site deployment requires at least 20 machines due to sprawl you're going to be even more screwed when you throw microservices at it not less. if your application is incredibly complex it's not going to work either. the problem domain needs to be small and easy to consider as it's difficult to cleanly extract a chunk of your average monolith into a standalone concern.there are also people with technical authority in many companies who blindly follow the latest fad without real consideration of suitability risk assessment or accountability. if someone starts waving microservices aws and everything else around they need to fight their position and everyone needs to assume that isn't the default end game.;0
