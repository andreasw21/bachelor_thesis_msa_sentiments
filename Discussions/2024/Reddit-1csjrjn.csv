ID;Source;Creation Date;Content;Sentiment
1csjrjn;Reddit;2024-05-15;Title:You probably donâ€™t need microservices, Content: https://www.thrownewexception.com/you-probably-dont-need-microservices/;0

l45m3vh;Reddit;2024-05-15 15:45:16;i agree with the premise most companies don't need microservices. most companies will never scale to need or benefit from microservices. if you are a dev that has at most a 100k users and you don't have five nine uptime requirements sure ship that nodejsrubypython monolith. the problem is not the micro services architecture but that junior to mid level devs are reading the tech blogs and listening to conference talks given by the faang and similar scale companies that need microservice architecture due to scale and organizational dynamics. i wish that for each conf talk that boils down to we improved our scale by ludicrous amounts by.... they have caveats identifying the use case. and then you have the devs that want to work for crazy scale companies who want to pad their resume by saying they are a distributed systems engineer. but much like programming language the question of whether or not to do microservices is a question of the right tool for the job. i have worked with monoliths large boulders to microservices the trick is to consider the architecture that's needed. sometimes that's microservices and other times it's a monolith.;0
l47a512;Reddit;2024-05-15 21:30:42;do you have a crappy unmaintainable monolith? why not try refactoring it into 70 crappy unmaintainable microservices?;0
l45fyhe;Reddit;2024-05-15 15:04:39;hottest take object oriented programming is just microservices where your intermodule communication is inprocess method calls. microservices are just oo where you abstract out the transport for intermodule communication so you can deploy each object in its own process space. which to put it another way you should design your microservices so that they can all be deployed inside a single process or deployed across a networkcloud environment.;0
l45s0xo;Reddit;2024-05-15 16:21:31;microservices were never strictly needed for 95 of software applications. they can be useful though if you have some functionality that you'd like to decouple from your application. the reasoning for this can vary from nonmatching update schedules needing the service in several applications it being written in another programming language or requiring another os to run on or to simply wanting to offload the work on separate infrastructure. like most programming concepts there is a time and place where it's a good choice to use them but not everywhere all the time.;0
l45ny8v;Reddit;2024-05-15 15:56:47;i dunno microservices fit pretty neatly into the whole loosely coupled highly cohesive thing imo microservices may be bad but soa isn't inherently evil even for small companies;0
l47fh8o;Reddit;2024-05-15 22:01:05;most instances of microservices i see are effectively distributed monoliths. in such cases it's just development and infra overhead for basically no benefits. i think pulling out medium sized services can have benefits but true microservices only make sense if you can very clearly explain the benefit without handwaving. also in these comments i see a lot of talk about supposed benefits. such as uptime but having more services will not generally make uptime of your whole app easier. performance but it's actually in many ways more difficult to determine required scaling for microservice and the overhead is often significant actually decreasing performance. the actual benefits of microservices are about precise control updates and organizational. in many cases that is more a function of your team size than it is about the amount of users.;0
l45haxw;Reddit;2024-05-15 15:13:53;microservices are great if you need to triple your workload over distributed systems in order to achieve the same result as you would on a monolithic architecture.;0
l45wu24;Reddit;2024-05-15 16:49:29;microservices were invented as a specific antidote to classic soa and messaging for very specific reasons. as far as i can tell the definition hasn't changed in the 10 15 years of hardcore adoption yet here we are... these discussions ironically always start off with an incorrect premise about microservices with some truth sprinkled in. these articles perpetuate the myths then prescribe a solution that undermines a real genuine need for microservices. this article is no different. part of the problem with classic soa is shared dependencies through poor design. whether this was hardware a network or comms channels database table library or another service it was everywhere. the poor designs were usually due to a combination of relational data requestresponse and other synchronous patterns service a called service b called service c etc. the secondary outcomes from these fundamental problems were problems of scalability and maintainability. you couldn't make a single change and deploy it quickly without high risk. yet what seems to drive these decisions nowadays is team organization and independence. this means you have a reverse conway's law effect where your organization structure which isn't likely to be welldesigned informs your technology decisions. this is a horrible way to design technology. second once serverless architecture was introduced people went ham with the nanoservice approach function as a service which is a clear antipattern that aren't miroservices. you get none of the benefits but all of the problems. first design your solution properly. one team does this. your core team. do not throw people at the problem until it's necessary. a single team can be large at first and broken up later. this means perhaps taking a classic dddstyle approach and mapping value streams correctly. this also means taking advantage of asynchronous processes such as by using events as much as possible. then do the proper performance and scaling analysis on how your already welldesigned solution should be naturally split up not could be for the sake of team topologies but because of technical necessity. this could be scaling for throughput but also for security data segmentation and backup auditing and compliance change management billing etc. being split up can be done logically within a single physical service or physically through independently deployable services. but the bottom line is if you don't need any of that you don't need to physically split them up yet but it should be trivial to do so because you designed your internal solution correctly to begin with. if you're starting out with an assumption that your services will be designed in a way that informs your data structure and how you're going to scale at the service level all of which is all informed by a presumed team topology you will fail every time.;0
l46qnaa;Reddit;2024-05-15 19:38:52;ya but my resume needs microservices!;0
l46420l;Reddit;2024-05-15 17:31:07;with all the layoffs happening in tech one thing im hearing more and more is companies having too many services after deep cuts. i mean whose fault is this really? i've never heard of anyone designing features to accommodate their own dismissal. i think this is a case where if companies don't value the maintainability of their services it's their bag of microservices to hold.;0
l46yvfe;Reddit;2024-05-15 20:26:01;even more direct you don't want microservices if you don't have to. distributed systems suck. say it with me again distributed systems suck. they have all the problems of nondistributed architectures and the problems of distribution in addition. don't do that to yourself if you don't have to.;0
l470m0o;Reddit;2024-05-15 20:36:05;my primary issue with microservices is that people don't even use the term correctly. any sort of service oriented architecture gets called microservices no matter how big they are. the vast majority of people do not want and do not need microservices but it was a buzzword so people slapped it on everything anyway.;0
l472q3t;Reddit;2024-05-15 20:48:15;i find such articles rather frustrating. yes microservices are not always the answer. but that's easy to say. the hard part is deciding when microservices are appropriate and when they aren't. that is the topic i'd love to hear more ideas on.;0
l45n1ik;Reddit;2024-05-15 15:51:09;aws and azure are touted as toptier solutions but in reality they're overpriced bloated services that trap companies into costly dependencies. they're perfect if you want to handcuff your architecture and surrender control to a few certificationjunkie gatekeepers within your organization. defending the absurd costs which can easily escalate to over 100k annually with comparisons to developer salaries is laughable and shortsighted. most companies don't need the scale these giants promise and could manage just fine on a 5100month linode often boosting performance without the stratospheric fees. moreover the complexity of these platforms turns development into a nightmare bogging down onboarding and daily operations. it's a classic case of paying for the brand instead of practical value. way too many times i've seen these bloated architectures doing things which could have been done with an elegant architecture of much more boring technology. good load balancing proper use of cdns optimized queries intelligent caching and using the right tech choices such as nodejs where acceptable performance is achievable but going to things like c for the few things which need brutal optimization. where i find these bloated nightmares to be a real problem is that without a properly elegant and simple architecture that people start hitting dead ends for what can be done. that is entire categories of features are not even considered as they are so far beyond what can be done. what most people including most developers don't understand is how fantastically fast modern computer is. gigs per second can be loaded to or from a high end ssd. a good processor is running a dozen plus threads at multiple ghz. for basic queries using inram caching it is possible for a pretty cheap server to be approaching 1 million web requests per second. using a video game as an example a 4k monitor running at 120fps is calculating and displaying 1 billion 24bit pixels per second. if you look at the details of how these pixels are crafted it isn't even done on a single pass. each frame often has multiple passes. if you don't use a gpu many good computers can still run at 510 frames per second meaning nearly 90 million 24 bit pixels per second. what exactly is your service doing that has more data processing than this? btw using a gpu for non ml processing is what i am referring to as part of an elegant solution where it is required. plus threading is easily one of the hardest aspects of programming for developers to get right. concurrency race conditions etc are the source of a huge number of bugs disasters negative emergent properties etc. so we have this weird trend to creating microservices which are the biggest version of concurrency most developers will ever experience in the least controlled environment possible. one of the cool parts of keeping a system closer to a monolith is that this is not an absolute. monoliths can be broken up into logical services very easily and as needed. maybe there's a reporting module which is brutal and runs once a week. then spool up a linode server just for it and let it fly. or have a server which runs queued nasty requests or whatever. but if you go with a big cloud service it will guide you away from this by its nature. some might argue why not use ec2 instances for all this? the simple answer is cost and complexity. go with something simpler and cheaper than just religiously sticking with a bloated crap service just because you got a certification in it. btw the fact that people get certified in a thing is a pretty strong indication of how complex it is. i don't even see people getting c certifications and it doesn't get much more complex than that. the best part of concurrency bugs is how fantastically hard they are to reproduce and debug when dealing with a single process on a single system have fun on someone else's cloud clusterfuck.;0
l46haxa;Reddit;2024-05-15 18:46:11;microservices also let you deal with network interactions for every single thing you do which you know adds exponential complexity.;0
l47ewss;Reddit;2024-05-15 21:57:47;i work in a company that last year decided to create a new project with microservices. the problem? our application could benefit from using microservices but not in the way we are doing it basically we have a microservices monolith if one of the first microservices is down the client cant do shit. also for each service we have 3 or 4 projects attached to it that are required for it to work and the best part about that? they are distributed in different teams and its a pain in the ass to make a change in one project because we need the packages updated in the other and that one also needs something updated. basically this company has 0 knowledge in microservices and has basically 0 qualified people for this me included. and we are shipping a monolith with more than 200 services attached that should work separately but dont.;0
l49s4if;Reddit;2024-05-16 08:20:56;sometimes i wonder if i lived through a privileged one in a lifetime org that did microservices just right and the reason why this sub seems so biased against them at least my perceptionfeeling throughout many threads seems to favor monoliths over microservices is that most of everyone here has had to suffer through an architect's bad implementation of them or a corporation without the budget for infrastructure that isn't ez right out of the box open source. i wouldn't put scalability in why i liked them although you do have the option we only ever had one microservice where that mattered because pretty much every service out there needed something from it. we basically had k8s in one of the big 3 cloud providers deploying docker images from artifactory. we had weekly and daily prod releases it was so easy now looking back to just run a pipeline for tests verify in dev within a minute prmerge to main and just deploy the one service i needed to update if the product owner gave the ok we were like 10 teams of 6 devs working across 5070 microservices just in the one little corner of the org i worked at monitoring was all automated logging was painless there was no need to wait for people to merge to main there was no monthly calendar release date everyone was rushing to keep up with the code cutoff date its done when its done there was no need to undeploy a monolith and keep people posted you had a change that was just 1 minute to deploy not hours of waiting on a jenkins. my last programming gig before i moved up to a role where programming is more incidental than anything was with a monolith and you can probably gather from the above what that was like. if you have the infrastructure for it not jenkins automated monitoring dynatrace to trace who is talking to who a good receptacle for logs there's no real reason why not use microservices.;0
l4a71eo;Reddit;2024-05-16 11:30:43;i feel like this is more about bad software architecture than microservices. microservices are fine when you don't go balls to the wall insane with them like in your example with 350 microservices running in production. that's not about microservices they absolutely have larger problems than that.;0
l46jyfv;Reddit;2024-05-15 19:00:59;the biggest problem with microservices is that some people read theory and principles behind them and then they follow those rules like they are only way to do things. i've found that great way is to go somewhere between. you can have core as monolith. if there is some parts you know will need better scalability make them as microservices. software doesn't need to be 100 monolith or 100 microservices.;0
l46zl9l;Reddit;2024-05-15 20:30:10;i think the difficulty is really knowing what to carve up and how. its not just about performance and scale of your system to multiple users. its also about build times and a growing dev organization and the blast radius of a single change. there are many solutions to these problems that dont have to be microservices but they still need to be dealt with. a lot of companies ive joined that have a monolith problem havent figured out how to solve them without carving it up. id love to see better build and deployment systems that arent at faanglevel companies so the blast radius and time to test build and deploy isnt so very very bad when everything is in one codebase.;0
l48qns9;Reddit;2024-05-16 03:05:30;i mean probably is doing a lot of lifting. you may not need microservices wont get clicks;0
l493n1f;Reddit;2024-05-16 04:36:07;you should make a monolith with things fairly nicely chunked into columns so you can split it at a later time into a microservise or 3. but that's also because i think people are terrible at figuring out where they should split before hand. in quite sure my work will make our fairly simple system into 6 microservices. id be ok with 2 one for all api calls to register them in and another for processing changes;0
l49j2wh;Reddit;2024-05-16 06:44:49;so i used it to explain to others why we needed different binaries running in production. the traffic pattern for the search module was completely different from the traffic pattern for the shopping cart module. it made sense to split these components. additionally it would allow us to have multiple teams working independently and autonomously. that would help us with the challenge of growing the company to thousands of engineers. they probably mean processes...? because if it's just a library binary say an sodll or a jar... meh? that being said if it is a library one puts it in its own place say a repository or even a directory within one and buildstestspublishes it separately. hey presto one thousand of engineers works on it separately! there are a handful of such generic promicroservice reasons and every single of them is weak for a vast majority of situations just like this one is. as a corollary tfa is right you probably don't need microservices. i am looking around my work and just seeing waste of resources with them. microservices everywhere but the actual load they have can be served on a potato. there's only a few out of dozens upon dozens that naturally fit separate development scaling and deployment. otherwise nah just a backend app server back in the day and a few frontends for it and everything will be done cheaper.;0
l46cybe;Reddit;2024-05-15 18:21:42;in my experience full blown microservices makes things difficult to test and maintain. a more domaindriven api approach suits most places better.;0
l46gmzi;Reddit;2024-05-15 18:42:30;i thought i disliked monolithic django until i had the pleasure to implement a microservice based platform. so much chaos.. everybody failing to communicate the right json messages redundancy everywhere accidental coupling.. horrible;0
l46nt7t;Reddit;2024-05-15 19:22:59;currently i have two apps online for two different businesses. both apps use the the same authentication service. this means that i am guilty of using microservices without needing to. oh the huge waste of using the same critical service for two different apps? maybe treating all app development issues as religious dogma isn't the right approach?;0
l46wlya;Reddit;2024-05-15 20:12:52;let's not forget the massive amount of added complexity microservices brings to the table and the requirements for a lot of staff with different technical knowhow that needs to be hired. money money money!! the invoices can be huge! instead of small. now if you were a managersystem owner that people upstairs believe in which road would you take?;0
l49m8i1;Reddit;2024-05-16 07:16:23;by grudge with microservices was not so much that they are more complicated to debug or less efficient on resources. but instead a simple relation that the guys who advocate the most for chopping the app into 100s little services were actually unable to code any of them. like if keeping service small was a kind of protection mechanism for not passing 10 singletons in every constructor. guess that kind of true since if your service has only 3 classes you can't create 10 arguments constructors.;0
l49y04v;Reddit;2024-05-16 09:31:54;amen i worked at a company where we decided to do microservices... only thing is they were just servers. nothing micro about them. i wrote a monolith fetcher and data store. i was told to use the main database because... i really don't know our architect was an idiot and he's the one who demanded microservices yet we had tons of single points of failure and he somehow thought his design was brilliant even though our database fell over daily. that being said if you ever need to scale it's going to be a painful transition..... but it's a painful transition that's good to have. if you do 75 percent of the work and then have to do 75 percent more work to convert it to microservices... you're doing 50 percent more work... but you've already proven you need the change and you likely can get more developers plus start to fully understand your system rather than starting with microservices and slow development to a crawl early on. get your mvp and mlp out of the way asap because that's your goal not paying the time for microservice.... you're right you really don't need them... until you actually do. i've said it a million times. no one pays for your effort if your monolith server works just as well as microservers the customer is only going to see a binary it works versus it doesn't work. that's all that matters early on. heck i'd even say scale horizontally at least once before doing the microservice conversion if you can get away with it. everyone wants to operate like a faang but ignores faang operates it because they know they have the money to pay for it and the customer interest to make it worthwhile. if you're not an established business... you don't have either of those things and while it's a nice to have... mvp mlp honest that's all that matters for a new business. prove you have something. startup with around 200 that's like saying you have a little cancer when it's a visible cancerous growth hurting you. jesus.;0
l45uaxn;Reddit;2024-05-15 16:34:51;at the end of the day we write only two type of programs compilers and databases. there are only so many ways you can interweave them and microservice is one way of doing so where you arbitrarily declare that the boundary is a process boundary instead of a threadpackagemodulewhatever. now whats interesting is how you make sure your services or whatever they are called can interact with the right properties for your application. monolith microservice lambda whatever does not help you in this regard even though thats where complexity lies. tldr microservice is bike shedding at its finest.;0
l45payi;Reddit;2024-05-15 16:05:07;exactly i've said similarly the last time a microservices are bad article came up. you need the right tool for the right job. it doesn't help that five years ago every article was microservices are amazing! everyone read it and adopted without thinking. there's also the problem of too many microservices which is a different problem people fail to identify. the answer to too many isn't always none at all. everything in moderation. these decisions always need to be thought through but it is my experience that the vast majority of developers put a lot of stock into blog articles and other postings that cannot possibly take your scenario into account yet follow those blogs as if they were.;0
l45vs7q;Reddit;2024-05-15 16:43:26;scalability isn't the only benefit of microservices the independent deployability of microservices can help regardless of the number of users. i split up a small application into microservices. it was originally developed as a monolith and implemented several related services so originally running them all in the same process made sense. but some of the services are running long running jobs and some of them finish quickly. every time i'd make a change to the quick services and i wanted to deploy i'd have to check if there were any users that were currently running long running jobs since obviously redeploying the application would trash their work. so i split the application into separate services each long running service getting its own microservice and the short running stateless services bundled together in their own microservice. it all boils down to requirements. you may not have the scaling requirements of a faang but there are other requirements that benefit from microservices. as usual think about what you are doing yagni and don't throw out the baby with the bathwater.;0
l46rf9y;Reddit;2024-05-15 19:43:15;there's a middle ground between monolith and microservices. you can take a few large core components and seperate them out without them becoming micro;0
l472j8a;Reddit;2024-05-15 20:47:09;part of the problem is that to get a job where they actually need microservices you get ahead of the queue if you have experience with microservices. so that's another incentive to implement microservices even if you could make do without them.;0
l47epeg;Reddit;2024-05-15 21:56:38;i dont necessarily agree with the scale being the only reason you could decide to go with microservices you can use microservices when you need very different uptimeload requirements between domains or very different lifecycles.;0
l498t3u;Reddit;2024-05-16 05:15:17;i mean usually what ends up happening with companies building microservices is they end up building a distributed monolith.;0
l499rpv;Reddit;2024-05-16 05:22:56;one serious upside to microservices unrelated to scale of org and user count is being able to keep dependencies of core code slim while leveraging a lot of existing code without compromising security at the cost of speed and financial costs. horses for courses as they say.;0
l49vdhn;Reddit;2024-05-16 08:59:05;the problem with knowing what the right tool for the job is that we have no way of knowing that when we start a project. i work at a company that has almost every one of the problems the author mentioned. somewhat paradoxically my company also has a monolith on its platform absorbed from an acquisition guess which one has issues with scale? and im not talking anywhere near 100k users or 5 9s up time. on the other end all of those microservices biggest bottleneck? multi tenancy in a couple large oracle and sql server databases. splitting responsibility into hundreds of microservices is a maintenance nightmare poorly architected software is a business catastrophe waiting to happen;0
l4685tq;Reddit;2024-05-15 17:54:18;i think you're right but i also think if the possibility exists that you'll scale in the future a microservice architecture might just be a good initial time investment to reduce headaches later.;0
l49ybn7;Reddit;2024-05-16 09:35:59;the thing is he's not saying it's a circle. he's not saying faang shouldn't use it. he's not saying no company needs it. he's saying you shouldn't start with microservices as a default especially if you're a startup.;0
l4dvf1x;Reddit;2024-05-17 02:13:07;i can't wait for a version of containers to come out with the express purpose of containerizing a monolith server around all your microservices to deploy to a single server because not having to communicate across the entire web is slower.;0
l48v9ml;Reddit;2024-05-16 03:37:00;you had 37 problems and thought i know ill use microservices. now you have 75 problems.;0
l45j1rg;Reddit;2024-05-15 15:25:31;and deploying all microservices in a single process is a very useful thing to do you can use that for integration tests that require way less orchestration than your cloud deployment.;0
l465hqj;Reddit;2024-05-15 17:39:13;which to put it another way you should design your microservices so that they can all be deployed inside a single process or deployed across a networkcloud environment. this has been my conclusion as well. my take has been to use persistent message queues everywhere there's been an urge to make a microservice. a queue listener can run right on the same system as sent the message or it can run entirely elsewhere. the process that listens can easily be removed from the same system and moved completely elsewhere. and as a bonus mqs are amazing for logging what's going on putting parts of a system in maintenance retrying things that break after fixing.;0
l45uvyi;Reddit;2024-05-15 16:38:16;i agree with this but the expectation in microservice environments is often that dedicated teams own each service and the interfaces are thus much more rigid. legacy callers are a concern for every single interface update. even if you can guarantee that all callers migrate to a new interface you still have distinct applications being deployed along their own schedule and depending on availability expectations usually high in microservice environments need to support legacy calls even if just during the rollout period. thats not the case for oo. youd never be in a situation where half of your application is deployed. and its more rare to have such distinct class ownership. conceptually though i completely agree.;0
l4663kg;Reddit;2024-05-15 17:42:40;hot or not i disagree. microservices are about independent deployability and team independency. objects are about neither of that.;0
l471oe0;Reddit;2024-05-15 20:42:15;microservices is explicitly a restricted form of oop. a big part of why people like microservices are because it is restricted. microservices stop you from doing quick cross boundary hacks that cause problems forever after.;0
l49yn0y;Reddit;2024-05-16 09:40:02;which to put it another way you should design your microservices so that they can all be deployed inside a single process or deployed across a networkcloud environment. you're missing the point. you're saying spending time and effort to develop a microservice that is loosely coupled versus a function in a monolith server. don't waste time creating the microservice design if you don't need especially early on when your goal needs to be shipping a product not over engineering it. it'll be painful later. great... because that means you still have a job and people want your product enough that you have to develop solutions for scale. that's actually a great problem to have. the opposite problem of technical work before revenueproof of concept has killed far more companies with far better ideas. the difference is if you can't get your initial product out into the market in a timely fashion someone will eat your lunch. on the other hand you might just be saying write a good api wrapper between distinct classes that don't share data when possible and well yeah.. .but that's just good code design. sadly we stopped practicing that long ago.;0
l464s6q;Reddit;2024-05-15 17:35:13;no absolutely not. a horrible perversion of microservices is like oop across a network. this is what most people do who have no clue. good microservices need to be as independent as possible to avoid all synchronous communication even the original messagebased oop of smalltalk is not like that.;0
l461ubi;Reddit;2024-05-15 17:18:30;here's another fun thought i had what if you made your in process objectsmodules communicate with request and response instead of normal method calls. my thinking is how you might translate your standard shitty java bean services to rust where you definitely can't have all these structs referencing each other like that. so in process nano services! what if we figured out how to analyzehad macros for code where we could write all this microservice stuff with queues and whatever else agnostic over in process and out of process. so you could easily have a monolith you deploy on aws scaling horizontally with ease but could also test locally all in process?;0
l4dw37r;Reddit;2024-05-17 02:17:47;there is literally no such thing as application that needs microservice architecture. an application could benefit from some aspects being put into microservices but there is just no use case where your entire app needs to be entirely microservice unless the entire app itself does like 2 things.;0
l45qvav;Reddit;2024-05-15 16:14:39;is it always bad? im not saying it's bad. i believe jet.comhttpjet.com actually startedhttps out using microservices and it had a great exit to walmart. im just saying we as engineers need to have critical thinking and choose what is best. i agree it fits very well in the loosely coupled highly cohesive it's hard to get it right though.;0
l4833xa;Reddit;2024-05-16 00:23:24;it feels most people's first foray into microservices is basically created creating a distributed monolith a big application that now runs in multiple smaller applications and what were local method calls are now network calls. all the pain of both a monolith and a microservice with few of the benefits. if you truly want to achieve a loosely coupled highly cohesive then you likely need to have an event driven system which is it's own world of pain. you replaced big application that makes it hard for lots of people to work on to something that multiple people can work on independently but no is much harder to understand debug and operate. it is easy to screw it up and you end up having to hire people just to support operations and developer tooling if your estate becomes large or critical enough.;0
l45ndkx;Reddit;2024-05-15 15:53:13;load balancer 3 instance of the monolith ? worked for a company that had that setup scaled linearly with the amount of machine. no microservice required.;0
l45scdi;Reddit;2024-05-15 16:23:23;in order to achieve the same result as you would on a monolithic architecture. if you're achieving the same result as with a monolithic architecture why would you use microservices? microservices only make sense when some services in the application have different characteristics than others such that you would get a different result if you separated them. some services require more compute and some services require more memory and deploying them together on the same infrastructure means you're compromising one to satisfy the other or you're paying way too much for infrastructure to support them all. microservices let you optimize. some services deploy for different reasons. it would be nice not to have to redeploy the entire application just to update one service. microservices let you deploy independently. i think monoliths are a good starting point but if it makes sense to split things out into multiple services there's nothing wrong with that either. but here's a hot take. a monolith is already a microservice if it's small enough to be independently scaled and deployed. people pay too much attention to micro and think that means every conceivable service in the application should be its own process too.;0
l45qjz1;Reddit;2024-05-15 16:12:46;at my last company each person in the test group was given an environment with 4 vms to run the stack one for the database one for the ui and two for the good stuff. when development architected the next version they decided to break everything down into microservices. each member of the test group now has an environment with 13 vms with no increase in performance or feature functionality and their stack startup time went from less than ten minutes to over an hour. when they raised concerns they were told there's nothing we can do about it we need to do this to become more scalable. when a customer raised concerns they were told that's our top priority we're working on it right now.;0
l45nvxd;Reddit;2024-05-15 15:56:23;there is so much scaling options these days i cant imagine when a microservice would be an ideal place to start. yes im mad because we started with microservices on a new project..;0
l466aua;Reddit;2024-05-15 17:43:47;is it developers or is it management drinking the microservices koolaid? i built a video project that very much could have benefited from the parallelism and i can bundle a couple of seconds of video frames into a 200kb blob that i can send over the network but i have to think carefully about sending all the data that process is going to need to do its work in one go so i can process the entire chunk without blowing through my 20ms frame budget. amortized over 120 frames that's not too pricey. but a lot of developers don't put that much effort into optimization either. i considered just breaking up and storing the video in their component segments which would be awesome for processing all the chunks in parallel but the complexity of ingesting tracking and reassembling that data is daunting. probably some money in it but i can't afford the two years without income it'd take to develop it. and the current state of the art for corporate media handling is building ffmpeg command lines and forking them off to do work at least at meta and comcast anyway.;0
l45mskr;Reddit;2024-05-15 15:49:37;it's not really developers. this goes to the managers who hear that microservices are the bees knees then makes everyone build microservices. i'd rather not have to print shit to cloudwatch to debug why something that works locally isn't working after deployment.;0
l4dxcp9;Reddit;2024-05-17 02:26:35;i didn't think microservices were made popular for any particular problem. i'm pretty sure improvements and popularization in containerization sparked a search for a problem to use that solution on. no problem was found but we collectively decided why not. we've done this with a zillion technologies before let's just throw one more on the pile and keep collecting these paychecks. so here we are making money on the problems we've created and complaining about it on the internet.;0
l49ptlr;Reddit;2024-05-16 07:54:44;i think that the real problem with microservices is that people implement them wrong and for wrong reasons. the reasons to move away from monolith you have many teams working on the same codebase. it's really hard to make sure monolith doesn't end up like a big ball of mud hard to work with on every aspect. and development speed on monoliths is sooo slow! deployment hazards with huge codebases deployments are risky so they are done less often. and you end up with a mess deployed as rarely as once every 24 weeks memory leaks that can bring down whole system down in monolith everything works ok or nothing works at all. simple report can bring your whole system down if memory leaks surfaces. drains money when scaled. sure you can make 3510 instances of your monolith each one costs a fortune. meanwhile only 25 features really need high throughput but it's all or nothing so you scale whole thing monolith turns into legacy fast you can't just upgrade one module. that's the reason so many monoliths still run on java 11 python 2.7 node 14 etc. and the problem i see with monoliths implemented with small teams where monolith would be just fine implemented by people with no experience wrong design wrong boundaries so microservices are chatty. a microservice should encapsulate the whole business process so they should talk little with other microservice.;0
l476ccl;Reddit;2024-05-15 21:09:06;im sorry to hear that. ill probably write some article on when it may be a good idea to use microservices and what companies should prepare to successfully implement them e.g. service catalog rethinking testing strategy etc;0
l45p02z;Reddit;2024-05-15 16:03:16;you can do microservices without aws or azure. these two things aren't really connected. i can deploy a macroservice to an instance just as easily as a i can deploy a microservice to an instance. also in a great many environments the developers creating these services don't have a choice in how it's hosted. that's often a higher level decision that developers are forced to live with.;0
l4735t6;Reddit;2024-05-15 20:50:46;microservices also let you deal with network interactions for every single thing you do which you know adds exponential complexity. no they don't. there is no blocking network communications in true Âµservice architecture. if there is a network interaction for everything you do then someone seriously misunderstood Âµservice architecture and actually ended up with a distributed monolith.;0
l4aa6pg;Reddit;2024-05-16 12:05:41;my previous company had 700 microservices in production and absolutely amazing infrastructure to support those services and enable the teams but i was the doe for some of those teams so i might be biased. it is an investment though. i believe all you have said is possible using monolith as well but the challenges will be different and therefore the investment. for the majority of companies that need to scale the initial investment for microservices is lower than the investment to scale a monolith as you scale the org. but there are a lot of things you need to consider at scale like dependency management search code maintaining hundreds of pipelines ownership large scale changes etc. im starting to understand why google has decided to have a monorepo.;0
l45qmxv;Reddit;2024-05-15 16:13:16;i agree with everything you said. just a note that this article is not a microservices are bad it's a microservices are not always what you need kind of article.;0
l47q6w8;Reddit;2024-05-15 23:03:10;imo the bigger problem is most projects rarely spend resources trying to figure out robust boundaries and microservices. most splits occur along business concerns which is a very bad idea. just because you have a feature and you can outsource development it doesn't mean it makes a good microservice. so even 2 microservices can be one too many. a good litmus test is whether or not that functionality can stand on its own as a properly versioned library with decent stability and robustness guarantees if it cannot what makes you think it makes a decent microservice? so many projects end up with a random number of microservices and repos that simply slow down development and cause loads of other issues lack of code review lack of static safety across calls having to touch 10 repos for a logical change etc. instead of helping in any meaningful way.;0
l463u29;Reddit;2024-05-15 17:29:52;they force you to write code in small easily testable and reusable chunks. which we should have been doing anyway but no one ever does. if we put similar effort into monolithic code that we do for microservices we'd probably see similar results. i'm increasingly moving toward writing small libraries that i can just make install or package to be installed with the os and my toolbox of things i can just reuse without having to reinvent the wheel on every project just keeps getting larger. then we start running into the c dependency management problem but that's another problem. i think it might be a law of nature that there are always more problems.;0
l46vdju;Reddit;2024-05-15 20:05:41;scalability of the app isn't always even a result of microservices. scalability of dev throughput is arguable. splitting a monolith into a couple of things with different deployment cadences and usage patterns isn't even microservices. some variation of modular deployed monolith codebase is often more useful.;0
l47osz5;Reddit;2024-05-15 22:55:01;that's easier said than done because if you end up with a highly coupled system you'll have to redeploy mostly everything anyway every time you make a change. and you can scale a monolith and do gradual rollouts just as well. simply going with microservices does not give you that benefit unless you do it well. given how most projects are developed i conjecture it's a rather rare occurrence that microservices are robust enough to avoid coupling and redeployment when anything nontrivial changes. furthermore it also happens to hurt static safety and local testability in practice if you're not careful so you could easily end up having to redeploy stuff over and over because you cannot validate changes confidently.;0
l493w87;Reddit;2024-05-16 04:37:59;the independent deployability of microservices can help regardless of the number of users. yeah i've been burned by platforms where adding even the simplest new feature took a month for the database team to integrate or where testing meant hours of compiling and packaging other teams' code or where the other team wants to upgrade to library v2 you have to as well or the api you're using will break. microservice ideas like severless deployment decentralized databases and smart endpoint dumb pipe are tools and not the only tools that prevent that level of coupling and bureaucracy.;0
l4a3bq5;Reddit;2024-05-16 10:41:46;microservices for me are about seperation of responsibilty why should my auth code be impacted by some deploy to random business logic usually these pieces are completely self contained and should be kept that way. one thing no one really talks about with monoliths is how easy it is to make things dependant on each other with out realising. it takes one bad dev to join 2 tables that shouldn't be in the same db and now you need a migration strategy to fix your problem that or some foreign key is not nullable and now some random unimportant table is the most important one because core business data has a fk dependency on it;0
l49ygei;Reddit;2024-05-16 09:37:42;unfortunately i keep hearing microservices but what they actaully mean is what you wrote aka domainmacroservices and its really frustrating. they are anything but micro.;0
l4874bb;Reddit;2024-05-16 00:49:58;what makes most sense to me is to have boundary based on organizational level i.e. you don't want multiple teams modifying the same repo as it leads to stepping on each other's toes. 100 agreed. the teams ive worked on and with that leveraged microservices were primarily due to organizational setup constraints. to me its a great example of conways lawhttpsen.m.wikipedia.orgwikiconway27slaw.;0
l45twnz;Reddit;2024-05-15 16:32:32;deploying all microservices in a single process does that actually work in practice?;0
l45wq38;Reddit;2024-05-15 16:48:51;this. modularity and message passing are general concepts that apply to both oo and microservices. but there are important differences at build time and run time.;0
l46mnba;Reddit;2024-05-15 19:16:20;then the next thing you know youre stuck on the largest servers that exist and you cant scale that's the best sort of problem to have because if you have already vertically scaled to the point of using the beefiest servers on the planet your income from that is more than enough to hire a ftime team just to optimise things out into microservices.;0
l467wds;Reddit;2024-05-15 17:52:50;lol using build time to judge if you should do microservices is like saying developers who put up prs with low lines changed are less productive.;0
l462zb7;Reddit;2024-05-15 17:25:01;an object contains behavior and state like a microservice is also behavior and state. they both expose their interface as messages that you can pass to them. the implementation is encapsulated.;0
l46gsbv;Reddit;2024-05-15 18:43:21;oop does not necessarily involve synchronous communication that's the entire point behind cqrs. commands don't need to be synchronous and can immediately return since the caller is not expecting a response. this is essential for oop code to work well asynchronously. queries need to return synchronously since the caller is expecting a response. which is something microservices need to be able to handle as well. in fact what you're describing is not only good microservice design but is also good oop design.;0
l4692dt;Reddit;2024-05-15 17:59:24;spot on. there's a lot of hate for microservices but these are the legitimate benefits. i also think it might be a definition issue because i've worked with microservice architectures on a few different projects and it's never been more than 10 services at most. there are plenty of issues to talk about but there are also some things that monoliths simply won't solve. maybe i've been fortunate enough to have never experienced true enterprise hell.;0
l45zqus;Reddit;2024-05-15 17:06:25;that is hilarious as long as you are not dealing with it sounds like my experience as well. the worst part is that the monolith got split but the messaging layer between the services needed to match. so the microservices still needed to be released as one but they did not want to do that anymore. so essentially the messaging layer became is locked for change. it is 100 hype development some new dev read a medium article about microservice and the cloud and wanted to bring it sold it to management and bam fucking hell.;0
l460gg9;Reddit;2024-05-15 17:10:34;yeah but you see plenty of places with more microservices than developers... at work we have 10 microservices and 2 backend devs none if which are me. it's fucking stupid. there's so much setup stuff copypasted everywhere and the devs constantly and randomly do stuff like have inner loops that call another service synchronously 100 times for basic lookups so what should be five lines of code calling db taking 50 ms instead becomes 80 lines of grpc glue code to make 100 calls times 60 ms 6000 ms.;0
l45rj6w;Reddit;2024-05-15 16:18:35;i come from an era where network access was actually expensive both in financial and performance sense. you can organize your code around people and team structure within a monolith too. network is an arbitrary barrier. my first product ever was already based on soa that's the boomer predecessor of microservices shipped as a single deliverable.;0
l464tn2;Reddit;2024-05-15 17:35:27;it is not unheard of having a team that manages a system of microservices with more microservices then developers on the team. i find this peak insanity.;0
l46apas;Reddit;2024-05-15 18:08:52;you don't need microservices for that;0
l45rrsf;Reddit;2024-05-15 16:20:00;that's orthogonal to microservices vs monoliths. you can break api compatibility with microservices too let's just do microservices is not an alternative to proper planning and change management.;0
l461isj;Reddit;2024-05-15 17:16:42;thanks. the challenge with taking on things like events is that you get into a whole other domain of complex design analysis that's needed but you get engineers the same ones blindly pushing for microservices pushing for things like cqrs and eventsourcing right off the bat. no.;0
l4dydn4;Reddit;2024-05-17 02:33:48;all of your reasons to move away from monolith have nothing to do with a monolith vs microservice. a monolith can use shared code bases that are in different source control repos and compile to separate dlls. a microservice app is just a monolith with the big old interweb in between the dlls. it is still up to the developers to write the code in ways that separate concerns and are not tightly coupled. you could easily and so many companies do write microservices that are completely dependent on each other and your whole app still breaks every time any team changes any microservice.;0
l47crgu;Reddit;2024-05-15 21:45:35;lolwhat? if you are doing interprocess communication on the same server to implement microservices you've just implemented a shitty monolith. also you can just have you know regular services. not micro. and just stand up a few apps if that is what you need. cause unless you need the insanity of microservices you are better off ignoring that architecture.;0
l45qw71;Reddit;2024-05-15 16:14:48;just a note that this article is not a microservices are bad it's a microservices are not always what you need kind of article. fair enough i jumped to an invalid conclusion there. apologies for that.;0
l4a3rnt;Reddit;2024-05-16 10:47:35;just a note that this article is not a microservices are bad it's a microservices are not always what you need kind of article. well it doesn't really say anything at all it's basically saying sometimes there are negatives to microservices we've been having that conversation for years. there are also plenty of negatives with monoliths which is why people are drawn to microservices.;0
l49n0x8;Reddit;2024-05-16 07:24:39;a good litmus test is whether or not that functionality can stand on its own as a properly versioned library with decent stability and robustness guarantees if it cannot what makes you think it makes a decent microservice? wait people do that? i agree that's a good litmus test and i've seen my share of sub optimal factoring of responsibilities between microservices but i guess i've been lucky enough to never encounter a system that includes services that would obviously fail that test.;0
l465nbx;Reddit;2024-05-15 17:40:06;they force you to write code in small easily testable and reusable chunks. not necessarily. microservices don't force you do this and you can end up in an even worse hell called a distributed monolith.;0
l4dtikz;Reddit;2024-05-17 01:59:33;microservices don't have anything to do with this. what you are talking about is simply separation of concerns. you can do this in many different ways in all sorts of architectures. microservices are a particularly vague marketing term that generally came about alongside technology like kubernetes and have been since decoupled from that and sold in so many different but always extraordinarily obfuscated ways that there is no meaning to the term whatsover.;0
l479ww7;Reddit;2024-05-15 21:29:24;yes but how are you splitting the services and how are you handling ipc where there was only a direct method call before? you've said something is more useful without explaining how to do it. it is better to think of microservices as a set of architectural communication and deployment patterns than a thing that is or is not.;0
l47q0xc;Reddit;2024-05-15 23:02:10;you're describing a distributed monolith which isn't a necessary consequence of using microservices and a sign you've done something horribly wrong. properly isolated microservices won't require you to redeploy everything. which is why understanding things like ddd is very important and not just for microservices.;0
l46m2d7;Reddit;2024-05-15 19:13:05;does that actually work in practice? sure. if you're talking to your microservices over protobuf it's trivially easy to shim it so that the call never actually goes out on a wire. in go using nethttptest you can do the same with http rest calls too.;0
l46j0ok;Reddit;2024-05-15 18:55:44;we used this for proofofconcept development. the design was singleprocess but the entry point simply scheduled a set of asynchronous services. these services would be wired up using async inprocess communication. testing was easy and you can decide to extract one service into a microservice and replace references to it with a component that calls the microservice.;0
l46aia2;Reddit;2024-05-15 18:07:44;there is more to it than just pumping your requests through a message bus when they are still requests that expect a response. oop like it is done today relies almost exclusively on synchronous communication with method calls. microservices should not be anything like that it is the total exception.;0
l46n6q7;Reddit;2024-05-15 19:19:22;it does in 99.9 of all cases where oop is used nowadays. perhaps in the original idea of oop it was different but even in smalltalk you are addressing messages directly to an object pointtopoint. the problem with synchronous communication in microservices is not that it blocks you can write the same sort of logic with asynchronous requestresponse messages and it would be even worse than an rpc call. another common thing in the microservices universe is to fire a notification message into a broadcasted topic without expected a message back but many times your service is still expecting something to happen. perhaps you're expecting an email to be sent to the customer based on your notification. the problem here is the expectation itself even if it is only implicitly in the head of the programmer who wrote that microservice. as long as there is an expectation that something is happening somewhere else then the business use case is not owned and implemented completely by that microservice usually orchestration patterns must be used then if it can not be implemented by just one service. the concerns that govern how classes are structured in an oop program are almost completely orthogonal to the concerns that govern microservice boundaries. implementation details of communication between objects services bla bla bla are entirely irrelevant. you can make anything synchronous asynchronous distributed inprocess if you want.;0
l46duu1;Reddit;2024-05-15 18:26:48;an eventbasedobserver pattern is generally considered a good way to decouple object dependencies. i think its a good fit when you only care about a fire and forget message but you lose the ability to have a return value or acknowledgment baked in. instead you need to have some kind of correlation concept like an id so that you can simulate a transaction across multiple messages. this is a requirement in a message queuebased world of genuine networked asynchronous microservices. but as it pertains to abstracting away the details of how messages are passed http vs. inprocess there is a bit of an impedance mismatch. you cant really create an abstraction that treats them both the same becuase they are fundamentally different paradigms. i feel like youd have to leak some of the implementation details.;0
l4801j3;Reddit;2024-05-16 00:03:35;sounds like those backend devs are incompetent and would be doing terrifying stuff regardless of microservice vs monolith;0
l46ri1n;Reddit;2024-05-15 19:43:40;where i work we have around 40 microservices in the backend with two part time developers. the frontend team is 10 people...;0
l48svzf;Reddit;2024-05-16 03:20:47;people these days are doing soa and calling it microservices. soa is still a really useful set of design principles.;0
l48tbvl;Reddit;2024-05-16 03:23:49;why? microservices should be small and as srp as makes sense. small leads to numerous. its not insane its a natural outcome of the architecture.;0
l47skul;Reddit;2024-05-15 23:17:32;yeah my point is that the developers i've worked with who work with microservices never seem to be all that enthusiastic about working with them. i wonder how many of those deployments are just management jumping on the microservices bandwagon after reading an article in business weekly about how you can set up microservices and then hire a bunch of entry level developers to maintain your services for you. if there is a developer who's really onboard about writing and using microservices in those shops they're usually the worst developer in the shop. i'm aware i might be overgeneralizing though! i hear you on video services. i wrote a c wrapper on top of ffmpeg's c api allowing me to just set up an object to read a media files and other objects to just subscribe to audio and video packet events from the first one. this works really well but rapidly devolves into callback hell when your workflows start getting big. but i was able to build a high performance video test system for comcast using that general approach. i haven't run across anyone else directly using the ffmpeg c api perhaps with good reason. time warner was using directshow and c to do that sort of thing. if you're interested you can look at one of my reposhttpsgithub.comflyingrhenquestmedia2 where i'm noodling around with ideas to improve on the design with limited success. i am able to break up compressed segments from iframe to iframe and send them across the network with zmq but keeping track of the stream metadata was awkward. i think i need to do a better job of encapsulating the ffmpeg data structures in my code and maybe set up some workflow factories so i can just drop my workflow in json or something and have the factory automatically set the object subscriptions up for me.;0
l47fqum;Reddit;2024-05-15 22:02:38;i think you often have a problem then you have a strategy that solves the problem the strategy then becomes the rules and every square peg is bashed into that round hole because that's the rules. microservices is just one example of this;0
l4e5cam;Reddit;2024-05-17 03:23:05;i can't actually find anything but i don't doubt you. i just don't think what we call microservices today is that. it was containerization that all of a sudden made devs start going hey let's make everything microservices! and made whatever that was into whatever it is today.;0
l4ezu7j;Reddit;2024-05-17 07:30:37;a monolith can use shared code bases that are in different source control repos and compile to separate dlls. how often that's the case? how easy is it to make a dirty hack just this time with such approach? of course it can be done but it's much harder to keep order in huge monolith everybody must care everybody must know everything than with microservices done right. microservices that are completely dependent on each other that's the antipattern i wrote about. that's distributed monolith in which you have no benefits from microservices yet all disadvantages of distributed systems.;0
l4axzo8;Reddit;2024-05-16 15:29:17;in my opinion there are three arguments for microservices 1. number of engineering teams as you wrote 2. is independent scaling necessaryhighly recommended? 3. do parts of the software need to run separately? in my current project most of the software can run in the cloud but there are components that for some customers need to run on premise so they need to be split out;0
l4a68rl;Reddit;2024-05-16 11:20:18;there are also plenty of negatives with monoliths which is why people are drawn to microservices. yes a monolith has its own challenges. sometimes is better to have the challenges of microservices than of a monolith. but probably not as many as we accept by default.;0
l4a6zav;Reddit;2024-05-16 11:29:59;it probably wasn't entirely arbitrary in the mind of the architect or the business but it still didn't go well due to crosscutting concerns and lack of robustnessplanning. frankly i have doubts that most projects can even split the frontend from the backend for a web app due to the way they do things. if they keep piling up tons of adhoc features and halfbaked pocs that require changes to both components it makes very little sense. many businesses do operate largely doing that kind of work. ime and even here on reddit people have this backend that's supposed to connect to external services a b and c or maybe they try to split shopping carts from ads and product listing they'll hand each out to a different team building their own microservice but there's very little attempt to build generallyuseful functionality. in the best case now they're writing more code just to shuffle data around because of the split. in the worst case changes touch everything because everybody implemented the bare minimum for their use case while many opportunities to share code and dependencies are lost. which makes me think it's way more common than people admit although i can totally see it working under certain conditions.;0
l466mdl;Reddit;2024-05-15 17:45:36;ugh tightly coupled microservices. the ninth circle of programming hell.;0
l47p14h;Reddit;2024-05-15 22:56:22;i understand your encouragement to think of microservices as a set of architectural communication and deployment patterns but it has an implication of fine grained service definitions that meaningfully differentiate from traditional service decomposition. decomposing services isn't new. microservices is a particular flavor of service decomposition and it's useful to understand if something is or is not something even when there is ambiguity when discussing alternative choices especially when we have perfectly valid and distinguishing names for the other things. for instance an alternative and often perfectly viable solution is to multiply deploy the exact same app. then expose endpoints jobs scheduling etc. for each via service domain lifecycle etc. via some other method. this often requires almost zero rework of the app and only effects the service endpoint layer. it's definitely not microservices neither is it exactly monolith deployment but it very much meets the goal of many service decomposition projects.;0
l47vjlk;Reddit;2024-05-15 23:35:34;i know. it isn't necessarily i agree. but it's way too common. simply doing ddd does not really help. i'd say that unless you have a decent upfront design and you design robust components akin to libraries out there we all use and modify infrequently ourselves it is very unlikely microservices will help. or they're not micro at all but rather bigger things like databases and such. many companies ime are simply looking to split work on some adhoc features that interact at a common point and they can't even draft up a requirements document ahead of time which makes microservices not viable as a general approach. how do you isolate a shopping cart from a products service when all you do is build the very minimum you need at that time? you don't you'll keep changing everything and you'll keep doing it across 10 microservices using clumsy api calls instead of native calls. you can't decompose every app out there or you should only do so very sparingly.;0
l466v9i;Reddit;2024-05-15 17:46:59;are your inprocess microservices interacting over http or etc or have you subbedin a direct method call style invocation in some way? edit sorry i just noticed you're specifically talking about an integration testing environment. my question still applies but the production case is more interesting. come to think of it i've used both overthewire network interactions and directinvocationthatlookslikenetworkclientlib approaches in integration test scenarios. but ime make it work is usually the highest priority there so inprocess http interactions for example are usually good enough in that context. in a production context the desire to take advantage of the inprocess efficiencies would be stronger i assume;0
l46r2al;Reddit;2024-05-15 19:41:13;it does in 99.9 of all cases where oop is used nowadays. isn't this also through of how most people implement microservices? as rpc using rest grpc or something else? smalltalk you are addressing messages directly to an object pointtopoint. actually no. you're addressing messages to an reference to an object. this is important because actual object could be hiding behind a proxy. you can think of an object as message queue. the problem with synchronous communication in microservices is not that it blocks yes the problem is the requestresponse coupling. but that doesn't have anything to do with oop. again with a properly defined command there is no response so you're not coupled to anything. as long as there is an expectation that something is happening somewhere else then the business use case is not owned and implemented completely by that microservice how's that different than any software system? microservices regular standalone applications whatever? any application should clearly define a bounded context and encapsulate the use cases within that bounded context and communication between bounded contexts should be done through clearly articulated interfaces to prevent expectations on implicit behavior as much as possible. the concerns that govern how classes are structured in an oop program are almost completely orthogonal to the concerns that govern microservice boundaries. you're basically describing domain driven design which not only originated in oop but the same vocabulary and design methodologies of ddd have been adapted for the design of microservices.;0
l4hq0ct;Reddit;2024-05-17 20:28:49;nah. i have microserviced stuff that needed to be done in another programming language though.;0
l46j0bw;Reddit;2024-05-15 18:55:41;i think theres a tell when people say microservice architecture. microservice is an implementation detail not architecture. its easy to conflate the two because creating microservices requires that you make architectural boundaries whereas with a monolith you can jam all your spaghetti into one class until your hearts content. but the architecture is logical boundaries not physical. its much less of an initial commitment to draw those boundaries with polymorphism upfront and then break things out physically if they need to scale for different reasons or if people waste a lot of time waiting for each others builds.;0
l49wx8z;Reddit;2024-05-16 09:18:22;everything is insane if it is driven by ideological purity rather then practical sensibilities. having more microservices then developers adds overhead and complexity while delivering no value to the business or development productivity. btw in literature doesn't really allude that microservices must be so small that you can have more microservices then developers. srp is actually both poorly defined and poorly understood and open to interpretation. srp for classes is and not should not be the same as for services.;0
l4ghimw;Reddit;2024-05-17 16:09:02;that's fair. i suppose it's still inline with what i was saying in terms of devsorgs blindly adopting microservices because of misconceptions about it not for the reasons articles like the op point out.;0
l4gz305;Reddit;2024-05-17 17:52:00;the problem is there is no such thing as a system which doesn't depend on all of it's parts to some degree. there is no pattern behind microservices that solves this. it's not really a problem to be solved. if your app needs authentication you have to authenticate. you can't just skip that part if the microservice that does the authentication deprecates it's auth function. it's this magic wand kind of thinking that causes junior devs to constantly chase shiny things because they think it will solve an unsolvable problem.;0
l4a75xr;Reddit;2024-05-16 11:32:21;as with every thing it's a trade off i don't think anyone should default to microservices over monoliths though;0
l470ih0;Reddit;2024-05-15 20:35:31;tightly coupled microservices if someone ends up with tightly coupled Âµservices they had a fundamental misunderstanding of Âµservice architecture but tried to implement it anyway.;0
l46exu5;Reddit;2024-05-15 18:32:56;none of this implies that the services need to run in separate processes. the problem is that sometimes people think they can use microservices as a way to avoid poor design because bad design is somehow harder. it boggles my mind that there are people who think a deployment strategy can ever substitute thinking and diligence to ensure proper architecture.;0
l47rd1c;Reddit;2024-05-15 23:10:10;for instance an alternative and often perfectly viable solution is to multiply deploy the exact same app. through feature flags which conditionally shut down parts of the app you don't want running? i hope that's not what you mean. i inherited an app like that where we disabled some features that weren't necessary in certain environments. the application had a bunch of feature flags as command line arguments to control what we wanted to run in which environment. it was stupid because it often lead to deployment errors when we made a mistake setting the flags. feature flags even destroyed a company knight capital. that app became so much easier to manage when i split it into microservices. and it wasn't really even hard because many of the services were independent anyways they just happened to be sharing the same binary because it was easier to put them there. the result was a much less complicated apps even if there were a few more of them.;0
l482itm;Reddit;2024-05-16 00:19:36;simply doing ddd does not really help if you're doing ddd you're isolating bounded contexts from each other to prevent coupling with defined interfaces between them. this is great for ordinary software development to enforce modularity and prevent balls of mud but critical for microservices. unless you have a decent upfront design you don't even need decent upfront design as well. you can refactor using techniques like the strangler pattern and pinch out services. you can make them microservices or keep the application monolithic and improve the architecture. simply looking to split work on some adhoc features that interact at a common point and they can't even draft up a requirements document ahead of time i'd argue that poor engineering discipline not only makes microservices not work but software development in general. monolithic apps developed this way will be buggy and unstable as crap is piled haphazardly on top of crap. but only an idiot thinks that microservices will make crap teams produce something not crap. microservices will only create distributed crap. you can't decompose every app out there or you should only do so very sparingly. simple apps need simple architectures. decomposition should be driven by an actual need. as usual think about what you are doing yagni and don't throw out the baby with the bathwater.;0
l46xpg5;Reddit;2024-05-15 20:19:13;it was direct method calls in one case and proper over the network rpcs in the other. direct method calls are nice for debugging you can just step into the call with the debugger but it doesn't test stuff like requestresponse deserialization or other protocol peculiarities so i would only use it if there's little logic there that could introduce bugs. when it comes to production deployment if you deploy as single process then you'll very likely not going to do anything different in tests. in that case i wouldn't even call it inprocess microservices just a monolith with clear code structure. the key point for me is that if you deploy your code as microservices it shouldn't prevent you from testing multiple services working together inprocess.;0
l4715n3;Reddit;2024-05-15 20:39:15;are your inprocess microservices interacting over http Âµservices shouldn't be interacting over http. if they are you don't have Âµservice architecture.;0
l476o4w;Reddit;2024-05-15 21:10:59;at least in kubernetes different microservices are actually running in separate processes and isolated from each other in containers. so that's an improvement at least...;0
l4hudoh;Reddit;2024-05-17 20:54:39;again that doesn't necessitate microservice architecture. you can for example create a class library that compiles to a dll and run it in a windows service which talks to a database or other messaging system to interact between your app. adding an api that then needs another protocol to communicate usually http is always another layer and a slowdown. you should only do it if you need to like your api is being accessed by thousands of people for all sorts of reasons so you need it to be public. it costs a lot of money in dev time and getting devs up to speed on technology to make an api really fast. not every app is netflex. just do the fastest easiest thing that works. there is a lot of confusion over what microservices are and some people seem to be calling pretty much anything that is separate from a big monolith app a microservice. but that's not what it is. it is creating apis to interact across the web that is microservice architecture.;0
l4b2xoo;Reddit;2024-05-16 16:01:23;youre complaining about ideological purity yet speaking in absolutes delivering no value. dogmatism usually leads to bad outcomes as you suggest but so does overgeneralizing. atomicity is one of the design goals of microservices and one end of that continuum points to srp. the design goals are guardrails not walls. a lot of the time you should bounce off them depending on the scenario.;0
l4a7a97;Reddit;2024-05-16 11:33:53;yes there is nothing wrong with microservices per se. and there is nothing wrong with monoliths as well. but our industry seems to have forgotten that there is no silver bullet.;0
l46jv3r;Reddit;2024-05-15 19:00:28;one the big things i think they do solve is just ownership of stuff but it can be as much of a negative as a plus it's a lot easier to have clear ownership over a microservice than a part of a monolith;0
l47vrrk;Reddit;2024-05-15 23:36:56;sorry if this a dumb question but i'm a little confused are you using muservice as a shorthand for microservice or does that refer to something specific and distinct? for what it's worth while i've been shocked and dismayed by the way some people seem to interpret microservice architectures these days e.g. i interviewed a midlevel dev the other day from a company that runs a really basic boxofthemonth subscription service that apparently has more than 100 distinct microservices many with dedicated database and he sincerely believed this was a great idea but the aspect of this overall thread that i found interesting wasn't really the just do well designed monolith part i'm comfortable with my ability to make appropriate and contextaware decisions about how to partition responsibilities across services but the run a soa inprocess part. to my mind the ideal version of that would look like an actual multiprocess microservice architecture that you have the option as a deploytime decision to run in a monolithic process or as a federation of standalone services or bundle together or split apart more or less arbitrarily. the dumb version of that is just a bunch of conventional microservices running in a single process but coordinating as if they aren't. but minor deployment and service management simplicity benefits aside i don't see a major advantage in that approach. but to the extent that you could seamlessly switch between ipbased or arbitrary ipc i guess interactions between services running in distinct processes and conventional method invocation style interactions between services running within the same process would be pretty great. the obvious way to do that is probably to have some kind of serviceapi client sdk possibly per service and just have inprocess or networkbased implementations of that interface but that dedicated client per service design is not my preferred approach as matter of taste maybe. so the topic i was really curious about was that inprocessmultiprocess flexibility.;0
l4ik65h;Reddit;2024-05-17 23:32:03;ah this particular microservice was mainly because i could not load the required libraries. i was trying to automate libreoffice previously openoffice document modification and conversion functionality. to interact with libreoffice java libraries are required which i could not load from the application that was written in php. of course there are probably other and possibly better ways to achieve what i wanted but time investments were also a business need that i tried to address. for example i could have just rewritten the uno libraries that i needed in another language but then i'd have a month of work instead of a week. another advantage of this setup is that i don't need to install libreoffice on every machine that i want to generate documents on even if by now i've set it up so it runs in a docker container. ultimately i ended up using the service in a whole bunch of applications instead of only the one i built it for so i suppose it worked out well for me.;0
l46kfne;Reddit;2024-05-15 19:03:44;that only works if each microservice is owned by a separate team which is also the case for monoliths. what happens when it's the same team that owns all the microservices? it's tempting to take shortcuts instead of maintaining proper design discipline.;0
l47z9u0;Reddit;2024-05-15 23:58:41;yes Âµ is the symbol for micro e.g. Âµs for microsecond. i interviewed a midlevel dev the other day from a company that runs a really basic boxofthemonth subscription service that apparently has more than 100 distinct microservices many with dedicated database and he sincerely believed this was a great idea each Âµservice having their own database is indeed an important part of Âµservice architecture. if someone is unable or unwilling to do that then they shouldn't be considering Âµservice architecture. it sounds like the person you interviewed had a great grasp of Âµservice architecture.;0
l46lnr3;Reddit;2024-05-15 19:10:48;at least as far as ownership if the same team owns all the microservices or the whole monolith it's the same.;0
l48ssz2;Reddit;2024-05-16 03:20:14;yeah i didn't hire that guy either. look kid enjoy the junior year of i'm gonna guess your state school physics program? or whatever stage of life you're at that makes you think statements like Âµservices shouldn't be interacting over http and each Âµservice having their own database is indeed an important part of Âµservice architecture don't make you sound like a complete tool. alas if only there was some proven durable mathematicallysound data store with a welldefined isolation model that could handle all 7 tables and 24 connections that would be needed to support two shitty microservices at the same time. but at least with 12 databases there's no single point of failure right? besides there's no value in being able to see more than a tiny slice of your business data at the same time. no one's ever wasted time on something as pointless as tearing down data silos. i'm absolutely convinced each service must have it's own database is an unassiable principal of microservice design. you're exactly right anyone unwilling to commit to that is too cowardly or too simple to handle the power of the Âµ seriously though try to remember that there's no single right way to design a system. but i guaranfuckingtee you if you need 100 services 30 databases and 25 engineers to ship your sockofthemonth box to the 2500 subscribers you're billing thru recurly you're doing it the wrong way. that's a weekend project if there ever was one.;0
l48tzr2;Reddit;2024-05-16 03:28:16;you seem upset that you dont understand microservice architecture. i am not advocating for or against the architecture. i am simply stating that making blocking http calls between services is absolutely not microservice architecture. if you do this you have gained absolutely nothing. you have replaced super fast and reliable in memory method calls with relatively slow and error prone network calls. if you want to make blocking calls between services then by all means you do you but dont call it microservice architecture because it is not.;0
l4950je;Reddit;2024-05-16 04:46:18;in retrospect i confess i'm morbidly curious about what your definition of microservice architecture is exactly. you seem to be saying that it's 1. many finegrained services 2. each with its own independent database. 3. absolutely no streaming interprocess communication especially no http so presumably all of this running in a single process? and not only is that a microservice architecture it's the microservice architecture. anything that's using nasty blocking errorprone http or that shies away from one database per service is unworthy of the name. is that right? it seems like almost all of that is directly derived from what you wrote.;0
l498641;Reddit;2024-05-16 05:10:22;1. many finegrained services 2. each with its own independent database. yes. 3. absolutely no streaming interprocess communication especially no http so presumably all of this running in a single process? i never said there was no interprocess communication. i said there is no blocking interprocess communications. they communicate via asynchronous events which they use to keep their databases insync. for example a user service would publish an event when a user changes their email address. any downstream service that needs a user's email address can consume that event and update their database accordingly. when that downstream service needs the email address for a user it doesn't make a blocking http call to the user service for it instead it already has it in its own database. this is microservice architecture. unfortunately the term has become so generic that it actually has no meaning and when someone says they are using microservice architecture you have to ask them what they mean. what they generally mean is they converted their monolith to a distributed monolith all the complexity of microservices none of the value.;0
l49irs8;Reddit;2024-05-16 06:41:52;ok now we're getting somewhere. i don't follow what you mean by blocking. are you saying not transactional in the requestresponse sense? i also don't understand your aversion to blocking http is when your solution to that is a database call instead. isn't that query just as blocking in the submit a request and wait for a response sense? if you want to argue http is less efficient than some other requestresponse protocol that's fair but if i'm reading you right that your objection is the requestblockingresponse aspect itself then why does the database read get a pass on that? the same question might apply to whatever mechanism you have mind for the event publish and consume but it's too openended as described to know one way or another. many probably mostly mq protocols are fundamentally reqres at a wire level even if that's wrapped up as something that doesn't seem like it. especially if you want guaranteed delivery or clever routing or other robust features also http doesn't strictly have to be symmetric of course eg a web socket can be used for asynchronous communication exactly you described and often is used for event publishing in particular but outside of a browser context that probably doesn't have much of an advantage over generic networking sockets is there a source or citation behind your conviction that this is the one true definition of microservice architecture ? because while i agree that what you've described here fits you practically acknowledged that's not the industry standard concept. if you're right and most everyone else is wrong what's your source for that? frankly i think what you've described here is what's more commonly known as an event driven architecture which is a kind of microservice architecture for sure and well suited to a lot of situations and intermittently trendy for the past 15 years at least not to say it's popularity is underserved. but while i can see the claim that its the best microservice architecture i've even argued that it's the best microservice architecture for specific systemscontexts but i don't think i've heard the claim that it's the only and i'm 98 sure it's wasn't the first or original microservice architecture. if you want to say event driven architectures are nifty i agree though i'm not sure i agree with all of your design choices. but i don't see the justification for asserting it's the one true microservice architecture all others are imposters. because unless you've got some obscure early academic paper with a reasonable claim for coining the term or something like that it seems pretty obvious that it isn't pick any source going all the way back to the midlate 90s when the term was popularized or to the late 80searly 90s when we had related names for essentially the same architecture. i don't think you'll easily find one source whether current or historical agrees with that framing. edit incidentally it's not unusual for an asynchronous message queue style event driven architecture to have higher latency than a well designed reststyle microservice architecture. there are other advantages to the event driven approach of course but if your objective is to respond to external clients as quickly as possible and you're willing to throw money at scalability if it comes to it then your concerns about the blocking nature of http may be overblown. the loosely coupled asynchronous approach sacrifices some of the immediacy you can obtain from direct service to service connectivity with or without blocking;0
