ID;Source;Creation Date;Content;Sentiment
1dmi48v;Reddit;2024-06-23;Title:You Probably Don’t Need Microservices, Content: https://www.thrownewexception.com/you-probably-dont-need-microservices/;0

l9vyedv;Reddit;2024-06-23 12:57:55;what most people don't understand is that microservices solve organizational and not technical problems. microservices are a pattern to enable different teams to build solutions that are focusing on a single domain. no need to unverstanden the whole business. this decouples these teams but naturally comes with its own challenges e.g. dependencies of other teams to your api. however the idea is that these challenges are easier to solve then having hundreds or thousands of developers work on a monolith. but people tend to think microservices solve scalability issues. this is also true because if you break your application into smaller components and maybe even group them by their functionality you can scale them based on their needs. but thats not the unique selling point. microservices help you scale your organisation.;0
l9w2xcs;Reddit;2024-06-23 13:44:44;i remember one situation in a previous company where a bounded context had so many little services that any change required many teams to work together to deliver it. and even worse the performance was awful. we tried baseball and it didn't work. a monolith smeared out over different containers is not a microservice architecture.;0
l9vr77r;Reddit;2024-06-23 11:31:26;i feel like this is becoming a more common narrative... finally. i'm in the belief that microservices are mostly just a hype thing that are being pushed onto people by cloud providers to make more money. huge companies like google and netflix holding ted talks and keynotes of how great microservices are for them completely ignoring how they're actually the minority and how 99.9 of companies will be better off keeping things simple in one monolith.;0
l9wg37s;Reddit;2024-06-23 15:34:49;the article is summarized some of the pains with microservices well. what it doesnt do is to put equal effort into describing the pains of alternative designs. so yeah sure. any given architecture will have problems. there will always be trade offs. in that sense the article is spot on. you dont always need microservices. i just wish it had been said differently. focus on your needs as an organization and pick an architecture that match today and the coming years.;0
l9vy3pr;Reddit;2024-06-23 12:54:40;microservices and monoliths are kinda of pick your poison they both suck but for different reasons. but i have seen people make careers out of pushing microservices and not having anyone who can apply competent analysis to a problem. but what i really hate about microservices is the testing so many mocks of other services just to test one api change. then it is a case of maintaining and updating the mocks in some cases different teams making different mocks of the same api. and the resiliency and performance testing of the different apis. and those who pushed the microservices hand wave the problems away. monoliths have their own massive problems with testing.;0
l9w12nw;Reddit;2024-06-23 13:26:25;there are microservices and then there are microservices. one type of microservices is a distributed system where a bunch of microservices coordinate to perform some business process. this is obviously easier to do in a monolith since you get things like transactions and shared data models. with microservices you have to adopt complex patterns like the saga pattern to coordinate microservices and use patterns like cqrs to synchronized data between microservices. i personally would avoid going down the microservices path in this situation unless a really good reason presented itself. another type of microservices is just a group of completely separate programs. there is a temptation to add features to existing monoliths because you don't have to create another repo another cicd pipeline etc. but then you have a monolith that is a bunch of random services cobbled together because of convenience not because it makes sense for them to belong together. so you have to deploy unrelated features for a change to one service. in this context i don't see what's wrong with creating a new microservice at the beginning or pinching out a microservice out of an existing monolith.;0
l9wa21i;Reddit;2024-06-23 14:48:31;i see articles like this all the time. if you have a simple domain don't complicate it with microservices and a distributed architecture. just use a monolith. if you're working in a complex domain and require the ability to deploy at scale use microservices. there's almost never a single solution for these kinds of problems. just use what works for your unique situation;0
l9y17vz;Reddit;2024-06-23 21:30:09;my simple argument against the causal use of microservices is that in many decades of programming experience the number one bugaboo is threading. by threading i mean any separate bits of code which need to communicate with each other while running at the same time. microservices is threading but with even less ability to replicate and debug. when these separate bits then need to readwrite the same data problems often arise. serious very hard to debug problems. there are all kinds of strategies involving queues with workers locks data isolation etc but i really don't see those as viable solutions which are any better than not having used microservices in the first place. i don't agree with most of the other arguments for microservices such as scalability this is a very rare requirement. most scalability is pretty straight forward with normal architectures. you see a machine is approaching its limit so you get another machine or a bigger machine. there are going to be very specific use cases where server load is wildly dynamic say running an event ticket service. these are the exceptions not the rule. division of labour. this is just a cheat for a bad architecture with bad managers. the result is more going to be a bunch of jira chasing slaves with a few devops gods who dictate the architecture far more than is healthy. cost. nope. not happening except for those weirdo edge cases. development ease this is a huge lie. yes it is easier to onboard someone to go jira ticket chasing in a smaller module but now they might work at a place for years without an understanding of the greater whole. most companies system should easily run in a dev environment on a single laptop. the percentage of systems where this is not the case is going to be a tiny fraction of 1. to make it hard for a dev to see and posses the entire dev environment is just weird again job security for some devops guy who would reply i can just spin up a dev environment for them to work in. the key word in this sentence is i not they i do like that some elements of microservices have propagated out into the more realistic world. things like putting the db in one container admin in another front end in another back end in another etc. this allows for interesting load sharing. for example maybe there is a brutal ml driven process which needs to run every night. it can run on its own machine at its own pace without disturbing the other machines. or if the db becomes a choke point the db can be spread out on multiple machines to share the load. way easier with containers.;0
l9xpo7c;Reddit;2024-06-23 20:20:40;will someone please just tell me the truth do i need microservices or not?;0
l9yr035;Reddit;2024-06-24 00:04:23;all software is either 1. shit or 2. will become shit i like how microservices let teams throw away the old shit in favor of new shit they feel ownership over every few years. binding everything together even with the latest and greatest modularizarion strategies ever imagined still means you have a system everyone hates in a few years as staff rotates and didnt fight the battles the people that wrote it did. you rarely get budget to rework the foundation of a monolith because the riskreward is never worth it to the business. rebuilding a discrete application that only does a few things is always easier to sell and lets teams experiment with new things. there are plenty of downsides to this as the article spells out but ill take that trade at any org where you dont know the name of every engineer working in the stack.;0
l9z79uj;Reddit;2024-06-24 01:53:28;the thing i need less of are blogs which tell me that i don't need microservices.;0
l9vpfm1;Reddit;2024-06-23 11:08:59;here's the gist the post argues that many companies adopt microservices architecture unnecessarily. it emphasizes that monolithic architectures can be simpler and more efficient for many projects. the complexity and overhead of microservices can lead to increased costs and development time. the author highlights that the decision should be based on specific project needs rather than following trends. practical examples and case studies are provided to illustrate the potential drawbacks of microservices and the benefits of monolithic systems. if the summary seems innacurate just downvote and i'll try to delete the comment eventually click here for more info i read all commentshttps;0
l9wuxfm;Reddit;2024-06-23 17:13:12;my own experiences have been 1. microservices at the api or internal function are a pain they add complexity and often need to be cohesive for the overall function making them less reliable because more moving parts and longer string makes it easier to break. but function based miniservices on scaling or logical boundaries are a gift from heaven vs a legacy monolith or megalith. the yscaling is the foundation and needs to be right. 2. xscaling is deceptive. it seems simple conceptually and seems like the right direction but some things that seem xscaled just aren't. they may be sharing state and end up with multiplicative load. they may make the system nondeterministic and difficult to work with when one clone is aberrant. 3. zscaling is an oldie but a goodie. predictable pragmatic low surprises but if you have to do aggregation of state across the zones and on demand that becomes annoying and painful. our current strategy is to have zscaled low value high volume moving high valuemvp type data to xscale and breaking up yscale across the discrete logical products and it seems to be doing well much more flexible performant and adaptable than before and i think a lot of fun to work with.;0
l9y7rv3;Reddit;2024-06-23 22:09:00;wait you're telling me that microservices aren't a silver bullet? can such things be?;0
l9ymlyn;Reddit;2024-06-23 23:36:27;more microservices more apps you need to constantly keep up to date and patch;0
l9yvhtc;Reddit;2024-06-24 00:33:51;you probably dont need microservices ftfy;0
l9z1br9;Reddit;2024-06-24 01:12:32;its safe to say that if youre reading advice on microservices from reddit you definitely dont need microservices. if your company is big enough that your bosss bosss boss has hired management consultants to tell you need microservices then maybe its time to consider it.;0
l9z44bx;Reddit;2024-06-24 01:31:32;monorepo and microservices are false futurisms which don't fit majority of the use case. people do it because it's supposed to be done this way;0
l9w0aoc;Reddit;2024-06-23 13:18:21;ive worked in two companies one is pretty much a household name in the usa that went really big on microservices. i hated it so fucking much. i never want to work on a microservice ever again.;0
l9ww1cj;Reddit;2024-06-23 17:20:06;as your monolith grows you'll wish you did microservices;0
l9xezcy;Reddit;2024-06-23 19:16:05;i think they solve all of those organizational scalability and reliability issues. but they also introduce their own variants of all of those. and not every company observes the same categories of issues with either paradigm. most companies will never notice scalability issues truly related to a monolithic architecture but plenty of them need global redundancy and partial failures. depending on their manpower microservices make development easier or harder. its just way more complex than „theyre great „they suck or even „you will probably never need them. i personally work in a small startup and we process like hundreds of requests a day. we still need global redundancy and isolation for data protection and extreme reliabilityavailability requirements for some services yet very generous acceptable downtimes for others. teamwise it doesnt make much sense to split the way we did but domainwise and also considering vastly different performance requirements for the machines it does. we are a very unique case but thats my point not every company is your basic websiteecommerce platform. there are many different businesses out there with very different operations and therefore needs. the microservice decision or really any architectural decision is unique to each one of them and thats what makes these blanket statements in either direction so annoying.;0
l9w75e7;Reddit;2024-06-23 14:23:47;this is an argument i see often but nobody is yet to explain how or why it would be any different from simply building your monolith process from multiple smaller packages each managed by a different team. your software is already written by dozens of different teams through all the libraries it depends on why not use that method for your internal modules as well? i've recently implemented this in jsts with an internal npm repository and it worked great. one team manages the users package and uploads new versions to npm whenever they're ready another team manages the teams package that depends on the users package. you can even run them independently in separate processes if you really want since they both have their own main.js file that you normally don't run when running it as a monolith. in my mind this kind of destroys the whole it enables teams to work independent of each other argument for microservices no? the only downside is at deployment time when releasing a new version of a core package would require rebuilding of the depending packages as well assuming the change needs to be reflected immediately. sure this is why microservices might be ideal for faang sized companies but for the remaining 99.9 this is a complete nonissue.;0
l9w6klx;Reddit;2024-06-23 14:18:41;do you use dependencies in your software? those are built by other teams with which you have 0 communication and are not even part of your organization yet nobody even thinks twice about using and including them. you can apply this within your organization as well where teams release new versions of dependencies which are integrated into a larger deployment. there is some discipline involved here but considering the huge downsides of microservices once components must communicate over a network that seems like a trivial issue.;0
la03fra;Reddit;2024-06-24 05:53:18;microservices don't have to be split up by repository. you can write a bunch of microservices all in one monorepo. you could even write them all in one single codebase and then deploy out modules onto separate servers. microservices just refers to where the code runs not to anything organizational. i've worked on projects completely by myself and one of the most productive techniques i've ever used is building stuff with serverless functions. according to fred george the only thing used in modern programming that comes close to his original definition of microservices are serverless functions. writing everything as a bunch of dead simple functions that interact in really highlevel ways like raising events and responding to events is just an incredibly easy way to architect simple systems.;0
l9y741g;Reddit;2024-06-23 22:05:06;what most people don't understand is that microservices solve organizational and not technical problems tell that to my org. the main managers behind our switch to them also believe everybody should be able to jump into any other teams code and just start changing things with no guard rails. also believes believes all the microservice should share most the same liberaries but no architect or liberary maintainers. it's all so clearly incoherent and the disaster of a delivery we've had is the most damning evidence. worst part is they're fairly clueless to it all.;0
l9ytcsz;Reddit;2024-06-24 00:19:44;microservices are not about organizational strategy and they are not about scalability. these things can be happy byproducts i guess though ive never seen it convincingly argued that microservices actually help scalability. microservices are about operability and deployability. if youre an organization deploying thousands of changes a day then getting all those changes rolled out across the fleet in a monolithic application becomes a massive headache. its a lot easier and simpler and cheaper to be able to roll out changes only to a small subset of the fleet for the particular microservice containing the change.;0
la00bgt;Reddit;2024-06-24 05:27:18;i see startups adopting microservices in a misguided attempt to reduce technical debt. the logic is microservices now avoids needing to break apart a monolith later. what everybody should understand is that breaking apart a monolith later is better than paying all the conceptual pain involve with microservices today.;0
l9yw2r7;Reddit;2024-06-24 00:37:40;what most people don't understand is that microservices solve organizational and not technical problems. i think what proponents of microservices don't understand is 1. it's debatable if microservices even address these organizational problems. 2. microservices make a backend architecture dramatically more complicated. 3. this additional complexity comes with significant cost both directly to engineering and the business as a whole.;0
l9ww95v;Reddit;2024-06-23 17:21:25;what most people don't understand is that microservices solve organizational and not technical problems. no proponents often give different answersdefinitions. beentheredonethat. murkiness is a yellow alert warning of fadcult. do note independent version deployment of components is often included in claims. i noticed if your shop settles on a primary rdbsms brand one can use the db as the message communication board for splitting a big app into multiple smaller ones multiple executables for example if you need such splitting. but make sure splitting makes sense for shop needs first. and stored procedures are perfect for the small shared services micro services. the bigger services are applications written in an app language java c python etc. or at least subapps. the message sharing tables double as a log which is handy for troubleshooting. have a status flag to mark processed messages. perhaps make a trigger or nightjob to chop out older data periodically to keep small. this way you don't have to mess with jsonoverhttps. since you will probably connect to a db anyhow you don't need to manage a separate json connection service reuse. most small and medium shops do settle on a primary rdbms. if you work for a giant conglomerate with different db brands then json could make sense.;0
l9wa8zi;Reddit;2024-06-23 14:50:07;it's sort of like everyone who thinks they want tdd really wants code that is written so it could be tested or at least could be very simply modified to be tested such as by taking a function as an argument to modify behavior at test time n 1 but i'm currently in a role where everyone is excited about the new direction of converting microservices into modules in a monolith in a monorepo. devdeploy time has gone down by orders of magnitude for the parts of the system that have been pulled into this paradigm. i think a lot of teams end up in ball of mud monolith territory and microservices look like the antidote and in some ways are easier than having the vision of how to accomplish the same degree of modularity in a single service only splitting out services when they ought to be from a runtime perspective e.g. workers that shouldn't or can't come from the same process;0
l9z3igq;Reddit;2024-06-24 01:27:25;remember amazon prime video using microservices to process videos? imagine transferring high bitrate 4k videos service to service. this particular usecase isn't compatible with microservice architecture at all.;0
l9x5kex;Reddit;2024-06-23 18:18:45;almost everyone who think they want microservices actually just want modular code. microservices are modular code structured so that breaking modularity is expensive so it's easier to solve problems within the modular structure than to bypass it just this once. in most organizations a developer will eventually have an incentive to propose do it badly quickly and cheaply as an option to the manager and the manager will have an incentive to choose that option over do it the right way less quickly and less cheaply. microservices try to change the cost structure so that the options are do it badly expensively and slowly and do it the right way less expensively and less slowly so that the incentives discourage breaking modularity. in theory we could go with a modular monolith and change the incentive structure but we usually don't have the power to change organizationwide incentive structures and even if we do there's no good way to prevent it from changing back later on.;0
l9w95p3;Reddit;2024-06-23 14:41:06;they are not just a hype... the main thing microservices bring is that they allow a complex problem to be split into bite sized chunks that can fit into a mind of a single developer or a team. what people often don't realise is that they trade one problem complexity of management of too big monolith for another complexity of managing many small pieces working together. depending on your usecase and how exactly you handle it one may be better than the other for you.;0
l9wgbd6;Reddit;2024-06-23 15:36:27;what google and other big players have that almost nobody else have are clear interfaces with draconian rules about state. if you want a global presence on the web and you have 200 stateless webservers scattered around the globe you likely won't find it too difficult to manage. now if you rely on 20 apis scattered in their own microservice realm and you are a programmer worth your salt that won't be difficult either as long as it's all stateless. the hard part is managing state whether it's acls actual data or service dependencies that nobody seem to really acknowledge exist in most systems for whetever reason. as long as you have a plan for each of those and make the scaling part truly stateless microservices work very well. but microservices as you said were hype and too many people with limited cognitive abilities had to work on this... even last week a guy came to me saying he needed 4 machines to launch a new service and wanted my input to make all of it work. that was you typical webserver with bespoke config db and api endpoints. that thing did not need to scale and each of them were stateful. when i said alright so you want that to scale out so if the web server get's overloaded i can just spawn a new web server and put a load balancer in front right? the guy said oh god no! you can't just do that! which is exactly why microservices are getting such a bad press now.;0
l9w8loj;Reddit;2024-06-23 14:36:25;let's not blame the service providers for the incompetence of the companies doing microservices wrong. i'm pretty sure it's counterproductive for these providers to always have to deal with accounts that complain to them about their costs of operation. some of these companies struggle to even make sensible and coherent packaging schemes in each of their code bases. also most of the talks about microservices given by these big tech companies that i've seen so far have been clear about the caveats. it's not their fault people listening to them think they have the same scale and the same problems.;0
l9x8f6g;Reddit;2024-06-23 18:36:13;dont underestimate hardware changes. 20 years ago your server had 12 cores per socket and just a few gigs of ram. storage solutions were slow disk drives and 100gb was consisted big data. spreading a large app across many systems was pretty necessary for standard business stuff even for medium sized companies. today a company can afford a single socket with a hundred cores a terabyte of ram and terabytes more of fast ssd storage. in the same time processing power has gone up 100x or more the needs of those medium businesses has only gone up slightly. the result is that monolithic systems start making a lot of sense again to reduce the overhead and increased dev time of microservices.;0
la0743r;Reddit;2024-06-24 06:25:35;microservices should never be reading or writing the same data. each service should have its own infrastructure up to and including their own data store. as an example of a microservices you might have a payment service which is stripe payments but in house. a llm service which is firecracker but in house. a model store service which is hugging face but in house. a authentication service which is google identity but in house.;0
l9zul6w;Reddit;2024-06-24 04:42:23;1 for the tco angle . not a huge microservices fan but your argument is an angle i had not considered before.;0
l9xdzzu;Reddit;2024-06-23 19:10:06;you know this kind of reasoning does not help your case. it actually makes no sense if you think about it. let's apply this reasoning to another situation. you probably shouldn't smoke if you want to maintain your health you don't need to exercise. you don't need to eat right. etc. basically what you said could be twisted to apply to literally anything. you can't just adopt the arguments in favor of splitting up functions and files and presume that is an argument in favor of microservices. they're obliviously not the same thing. thus your argument blatantly targets people who don't think too much about what you're saying;0
la1mvv3;Reddit;2024-06-24 15:17:46;yes you can do microservices poorly.;0
l9y2thi;Reddit;2024-06-23 21:39:43;you can't really use what businesses are doing e.g. the way the cloud is taking over as a metric for whether something is objectively good or bad better or worse businesses will usually do what's most profitable regardless of developer burden accumulation of technical debt etc. the only useful information is that x thing can be done with microservices and that it's performance is acceptable.;0
l9xmw6m;Reddit;2024-06-23 20:03:57;if the technical debt in your monolith is so large you wish you used microservices then starting out with microservices will make you wish you wrote a monolith. why? skill issues.;0
l9w8jmi;Reddit;2024-06-23 14:35:57;in a monolith its pretty hard to prevent distant coworkers from using other teams untested private methods and previouslysinglepurpose database tables. like a law of nature this leads inexorably to the giant ball of mud design pattern. of course microservices have their own equal and opposite morbidities you take what couldve been a quick inmemory operation and add dozens of network calls and containers all over the place. good luck debugging that.;0
l9w8od9;Reddit;2024-06-23 14:37:03;because a microservice is more than a library. you get leaky abstractions where the service consumer now needs to understand performance implications of that new database transaction you added or that one failure mode of a new rpc to another service. and that's only assuming things go well. what if someone introduced a critical bug? do you have to roll back the whole platform? if you push all of the operational burden down to whoever deploys the binary you run into organizational issues.;0
l9wr082;Reddit;2024-06-23 16:48:21;it's not managing software it's managing people. each microservice has different teams responsible for their operation. they have their own databases firewall rules authorization sets design teams qa groups etc. by having this separation you can create change and still not involve too many people. it also reduces cognitive load on developers while coding. the smaller domains and clear boundaries mean there is simply less stuff to consider when doing the work.;0
l9whsp2;Reddit;2024-06-23 15:47:03;the difference is that other components can only consume the parts you have chosen to publish using this api. this basically enforces other teams to not rely on hacks or behaviour you do not expose. for example in a monolithic application you could consume data just from a database table. however the table may be owned by a different team and therefore they will make changes. this can't happen in a microservice environment because if you proper implement the boundaries the only possibility to use your services is to use it through the api which is kind of a contract. i don't say that people do not try to work around this but its a lot harder to shot yourself in the foot.;0
l9wh08w;Reddit;2024-06-23 15:41:24;100 this. people seem advocate microservices because it forces them to create an explicit clear api for their library. but they should already be doing that for any library they write.;0
l9w8o3x;Reddit;2024-06-23 14:36:59;because as a single service how would you manage oncall and other operational challenges? microservices are the equivalent of it works on my machine.;0
l9xtj2v;Reddit;2024-06-23 20:43:52;right it does still require coordinating rollouts and introduces more surface area for fuckery. also shared infrastructure means you have to settle on a hardware config that's equally unoptimized for the worst case of all teams. also if you're going to the trouble of splitting into different processes you might as well just split to separate containers on k8s at that point. i don't think microservices are a magic bullet and they can create more problems than they solve but they do have some distinct advantages and disadvantages vs. plain submodules. you're effectively trading simplicity for stronger submodule isolation which can be a good or bad trade depending on whether you actually need stronger submodule isolation.;0
l9xvsc6;Reddit;2024-06-23 20:57:21;i think there are different ways to do a monolith and microservices. i feel that the topic here is to use a monolithic repository to manage your application versus separate repositories which often forces a microservice architecture i suppose another flavor is having a single application that aggregates all the different repositories together but i don't think people commonly approach things this way because it's a lot of extra work to emulate the a mono repository set up. for most faang sized companies they can do whatever they choose. this is always abstracted away from the individual team. for example facebookmeta is a monolith as a repository and they have a complete suite of teams focused on making that experience work well for each developer at the company. amazon is a mix but they're more oriented towards the micro services and separate repository development. they also have a bunch of interesting stuff which makes exposing apis and calling apis from other internal services which makes it easier since all the code isn't in the same repository. if you have amazon friends they call this thing smithy but i've known it as the predecessor called coral.;0
l9ynohr;Reddit;2024-06-23 23:43:13;this is an argument i see often but nobody is yet to explain how or why it would be any different from simply building your monolith process from multiple smaller packages each managed by a different team. for our microservices i can build deploy and update them completely independent of input from any other team. the bigger the team working on a service the more likely you are to start falling into things like release schedules planned feature releases long manual approval processes.;0
l9yoa5q;Reddit;2024-06-23 23:47:03;this is an argument i see often but nobody is yet to explain how or why it would be any different from simply building your monolith process from multiple smaller packages each managed by a different team. trying to deploy a monolithdo merge conflicts for services worked on by an entire company sounds like an absolute nightmare. this happens with games and there's so much organization that goes into deploying one binary to players. having to do that for all services for a live service game sounds like it would immediately kill any velocity not to mention the issue with scaling independent parts of the app. most people don't need microservices but the reactionary point of view of they introduce as many problems as they solve is just not accurate. there's definitely a subsection of folks that moved toward microservices because it was a fad but by and large they exist because they solve problems and it's easier to deal with the problems they introduce than the ones that would be present without them.;0
la0qv3b;Reddit;2024-06-24 09:58:59;is it then just a sevice? if you read what microservice preach then you can have anywhere between 0.5 to 2 microservices per developer. so we have 5 microservices per a team of 12 devs and you can't just understand a domain of one servie they are really intertwined and you still need to figure out how the whole system works in order to participate in the development.;0
l9wevou;Reddit;2024-06-23 15:25:54;libraries and services have very different operational characteristics. nobody in their right mind would argue that something that could be operated as a library should be a microservice. even an organization the size of google prefers libraries over microservices. the organizational problem starts when there actually is a material operational burden involved in deploying the service. now someone needs to understand what that operational burden is and needs to be able to reason about the impact a deployment has on the platform. that's the problem that microservices try to solve.;0
la033q4;Reddit;2024-06-24 05:50:25;15 minutes? try 2 hours. that's what it's like at my current company. amazon literally invented microservices in 2001 because tests on the daily monolith build took an entire night to run.;0
l9wh7ts;Reddit;2024-06-23 15:42:56;in other words it is just a hype. managing a big monolith is much easier than managing microservices. it is extremely difficult to test an integrated microservice and it's much easier to do the same for a monolith.;0
l9zyaus;Reddit;2024-06-24 05:11:05;imagine you're building a website. as part of writing that app you want to let users pay for stuff but you don't want to build out payment processing. so then you go out do some research and decide to use stripe. stripe gives you a nice and convenient api and they handle all the pci compliance and payment processing. microservices are stripe but inhouse.;0
l9whf9j;Reddit;2024-06-23 15:44:23;where's the micro in here. they are just services. soa and seperation of concerns predate microservice by a lot.;0
l9w0ozr;Reddit;2024-06-23 13:22:31;i am the single dev guy left on a project with some 30 microservices.;0
l9whck8;Reddit;2024-06-23 15:43:52;that's also why i strongly disagree with this point in the article low coupling and high cohesion are hard to get right. it gets even harder to get it right in a microservices architecture. you may end up with very small microservices also called nanoservices that are tightly coupled and with low cohesion. i remember one situation in a previous company where a bounded context had so many little services that any change required many teams to work together to deliver it. and even worse the performance was awful. this example is very good because on top of that the teams wanted to create another service to aggregate all the information to improve performance. the idea of merging little services to have more cohesion was considered bad because it and i e looked like a monolith. this is not a monolith vs microservice problem. it's a badly designed code problem.;0
l9we3fk;Reddit;2024-06-23 15:20:06;not sure if i'm reading your comment right is the concern that exceptions thrown from a module could bring down the whole monolith? in that case microservices have the same issue you have to handle errors from an rpc exactly like a normal function call and additionally take into account network latency and connectivity issues.;0
l9wirq2;Reddit;2024-06-23 15:53:53;i think no one said that this can't work. there are good examples that this is possible. but like i said its an organziational challenge that is solved using microservices. for some companies microservices work better then changing two decades of management decisions in how the corporate structure has been formed.;0
l9x3gdq;Reddit;2024-06-23 18:05:45;nobody in their right mind would argue that something that could be operated as a library should be a microservice. yes they would. been living under a rock? the op article is a response to that blanket mentality. when there actually is a material operational burden involved in deploying the service what the hell does that mean?;0
la0h51t;Reddit;2024-06-24 08:05:14;no no they literally had microservices. they converted it into a monoloth application. but it still runs on serverless but uses a single ecs task. it makes sense for them to use monolithic serverless function as they want to be able to process the videos as they come. and i would imagine this is highly variable. https;0
l9w2gtw;Reddit;2024-06-23 13:40:16;microservice architecture has unsurprisingly an emphasis on the small size of the services. soa on the other hand doesn't preach a particular size of deployed applications. soa puts the emphasis on the apis that's actually the meaning of service in soa. applications having a standardized formalized apis wasn't that omnipresent obvious as today. it was often the case that one application exposed several services. in contrast ms arch preaches separation of services into applications you could make an equation that service is an application.;0
l9vumq8;Reddit;2024-06-23 12:13:57;also the wrong answer size of the microservice is irrelevant it's about the services having no shared dependencies and able to run independently of one and other. if you have separated them into their own concerns why would they be doing http calls to other services breaking the dependency rule;0
l9vzk5e;Reddit;2024-06-23 13:10:32;microservices often communicate via rpc not over http. in that sense they to operate like function calls;0
l9wa9uk;Reddit;2024-06-23 14:50:18;distinct os service and then have them communicate with http instead of function calls. this is absolutely incorrect. if you are spitting up a monolith and splitting it into services using blocking http calls then you have totally missed the point of microservices. blocking http calls dont give you independent deployment and development. you want an event based architecture. each microservice has their own db kept in sync via events. you can google eventual consistency for more information.;0
l9zm10q;Reddit;2024-06-24 03:39:29;some yahoo in another team sees the code and flips it to public that's how. since it's all viewable in a giant codebase they can. slowly but surely all methods effectively are public if folks want. the alternative is forcing interfaces or being a total micro managing nutcase. forcing interfaces is the biggest win microservices across teams has. ...until the latest staff eng convinces the org to move to a mono repo with your microservices architecture. now you have the worse of all worlds since it's distributed network calls and everything can be easily flipped public!;0
l9wab3n;Reddit;2024-06-23 14:50:35;sounds like youre assuming that 1. your runtime actually enforces publicprivate object access and 2. other teams arent allowed to modify your teams code or write to your tables without permission. in my experience those are not things to be taken for granted. private methods arent firmly protected in ruby python etc. expectations on when its a good idea to import or change another teams code vary wildly based on organization and experience levels. the upside to microservices in this context is that its harder for other teams to take hard dependencies on things you didnt intentionally expose as part of your public api. these restrictions are easier to enforce when the other teams code isnt running in your process and their process doesnt have access to your database passwords.;0
l9wpxk3;Reddit;2024-06-23 16:41:35;when your new service ships everyone is upgraded at once ready or not. i have a bit of experience working with such an architecture. it's a recipe for disaster and i would hesitate to call it a microservice architecture. what you end up with is a monolithically deployed worstofbothworlds collection of tightly coupled services that gives you all the problems associated with microservices with none of the benefits. edit btw we ended up fixing that. not by moving to a monolith as the article suggests but by properly decoupling services.;0
l9xipq6;Reddit;2024-06-23 19:38:49;microservices are worse than the disease. 100000x slower calls between modules extra deployments no transactions refactoring becomes harder inevitably leading to a maintenance nightmare compile time errors become runtime errors etc..;0
l9xem9g;Reddit;2024-06-23 19:13:52;yes. you are right. what i like best about microservices is the fact that they're easy to use and you can just jump right in and start coding!;0
l9yqrmr;Reddit;2024-06-24 00:02:54;yeah i know what you mean. we implemented a colossal microservice system that was supposed to simplify and replace the existing mess of legacy services that ultimately querywrite data tofrom a single 3rd party source. the funny thing is that this project is kind of what you are proposing a lift and shift solution that would allow us to abandon the mess of adaptors and 12 hop roundtrip requests we had fallen into. but here we are multiple years down the road and incompetent leadership constant changes to our data model and the need to deliver something even if we haven't talked to our consumers and figured out what that thing actually is or even figured out who the hell our consumers are has led us to essentially build a monster of a system that nobody wants to use. so now we are building the adaptor layers for our consumers and and we need to segregate those adaptors by product! and its all becoming a big mess again.;0
l9wjcrk;Reddit;2024-06-23 15:57:56;most people who are doing this are using containers and are setting limits and letting something like the k8s scheduler handle eviction and moving services around. no place ive seen using microservices has been using nonclustered hosting. similarly all dbs have been out of cluster;0
l9wnm29;Reddit;2024-06-23 16:26:40;ok so addressing specific concerns into their own service is enough for it to be a micro service? in your example invoicing etc would typically be linked to a dedicated crm and there would be a small adapter that updates the crm. but that would violate one of the principles of being a microservice having its own database. as the crm would need to be centralized. microservice bros would add like layers of caches local copies instead of querying the crm directly to fetch the data and to display it. sounds like a strawman but shit like this happened to me. there are microservice purists shall i say. if independent business functions would have their own services and that would be it. i'd actually call myself a microservice fanboy. i personally don't like nosql and each service having its own independently deployed database.;0
l9xlyo4;Reddit;2024-06-23 19:58:19;your runtime actually enforces publicprivate object access this is a weird argument. i can use reflection to call a private method in .net but unless i absolutely have to i shouldn't. i should a find a different way of accomplishing my task or b talk to who wrote the method and ask them to offer a public method. expectations on when its a good idea to import or change another teams code vary wildly based on organization and experience levels. microservices aren't going to solve this team makes things private that shouldn't be this team circumvents access modifiers or these two teams don't talk to each other because justin is a poopiehead. at best they're going to hide such organizational problems which is bad in the long run.;0
l9wlunq;Reddit;2024-06-23 16:15:04;teams develop these modules in their own git repositories and publish them to a package repository like artifactory. then your application pulls them in as prebuilt binaries that can be plugged into your part of the application. you can compose the librariespackages together to form a larger application the way you would with microservices just using inprocess calls instead. its true that this application would need to be deployed as a monolith. but the point many are making is that the main benefit of microservices is less about scaling individual services and more about scaling organizationally by allowing teams to develop and release their part of the domain separately.;0
l9xigri;Reddit;2024-06-23 19:37:21;at some point you have to trust that your developers aren't trying to actively sabotage the integrity of the project and have noncode means to enforce this. after all this same question could be asked of code inside a microservice. what if some subcomponent decides to randomly delete records in the microservice database to solve some immediate problem and it breaks the application? that's either malfeasance or a bug and you deal with it accordingly.;0
l9ydvpd;Reddit;2024-06-23 22:44:34;its all about trade offs i guess. with a monolith that is deployed on a regular schedule you know when something could break and can roll back the version to a knowngood state. with microservices that are deployed on individual team schedules a break could happen at any time and knowing what broke things isnt always easy so rolling back to a knowngood state is harder. plus with microservices you have n teams rolling their own deployment processes with varying amounts of competence. as compared to a monolith where the sole deployment process can be hardened.;0
l9yvor5;Reddit;2024-06-24 00:35:07;i just realised everyone talking about microservices scaling better were missing the forest for the trees. microservices allow the right team to be quickly blamed for scaling issues forcing them to take ownership of their fuckup and fix it. that does have business organisational value. ive lost count of the number of times ive seen a team try to wriggle out of their responsibilities by blaming everyone but themselves. if theres only one overarching performance metric for the whole system this is possible. if each team builds their service in isolation it isnt.;0
l9ykwwb;Reddit;2024-06-23 23:25:57;while i'm in favor of a clean operational model some of these are not problems tied to monilith. you are talking about deployment model not development model. a module... how is a 20x slower downstream service any better? don't tell me in the same machine i can't stop that function from using all the cpus. thread pools have been used for years to provide the same feature with less overhead. seems like allowing developers to have zero sense of deployment model awareness and spamming threads everywhere just because thay can have their own environment is a great swe practice. team a... this point makes very little sense to me. which non faang service need 2 days to run a pipeline? they should see again if it takes more than 2 hours for a release pipeline. tests? if it's unrelated why should both test pipeline run together? if you refer to qa time how can a microservice model tests that the old team b code and new team a code is valid together in 2 days if the whole testing process take the same amount of time? you don't need to deploy both changes at the same time monolith or microservice. i agree that coupling release is terrible having to restart deployment machine is a no from me especially on things that rely on jit. point 3 4 5 feels like just a repeat of 1 and 2. im not original commenter nor i support him but i agree with his idea. a library offer much more flexibility than a microservice. i can easily adapt a library to a microservice not the otherway around. certain languages even support transparently using both. one such way is decorate the exposed object and forward them to the deployed actual service.;0
l9vzkar;Reddit;2024-06-23 13:10:35;again this doesn't mean anything. separation of concerns doesn't mean nothing in your system is allowed to communicate to another part of it. but if a microservice is to be inependent of other services then it can't do a http call as that would be a dependency service a should still work even if service b is down;0
l9w8oiy;Reddit;2024-06-23 14:37:05;it allows the development work to scale. you can have separate teams with separate deployment and monitoring efforts. microservices are almost always about allowing more people to work together on the same overall project. otherwise no one would opt for a distributed system. theyre much more complicated to build and maintain. you can just only have so many people working on a single codebase effectively;0
l9xildg;Reddit;2024-06-23 19:38:05;but splitting your code into multiple small services that communicate via http is still absolutely microservices. that is nothing but soa and that does not give you independent deployment and development which is the primary advantage of microservices.;0
l9z7apa;Reddit;2024-06-24 01:53:38;this is a weird argument. it is. it definitely is. it assumes that some of your coworkers will be psychopaths who disregard every aspect of good coding practice so they can ship some pile of shit an hour faster. that's insane. that should not happen. that said i've worked with people like that. i've encountered whole teams and even business divisions that work that way. so engineering in a way that protects your team and your services against that is unfortunately less silly than i'd like it to be. do microservices solve the organizational problems? no. they do however help contain them and limit the runtime fallout. you don't have to worry about the next team over the one with the psychos screwing with your database tables if they don't have access.;0
l9wbbu2;Reddit;2024-06-23 14:58:50;have you perhaps mistaken me for a fan of microservices or of monoliths? theres no one right answer in this field only a series of besteffort compromises.;0
l9x0r5u;Reddit;2024-06-23 17:49:15;if you have a heavyweight lookup service you only have to beef up the machine that's running it in order to perform lookups in the user request path. if you have a lookup library you have to beef up every machine that's performing lookups in the user request path. this is a problem that a whole lot of systems don't have. but it's hard to work around it without microservices if you do.;0
l9y7g8g;Reddit;2024-06-23 22:07:06;there are lots of ways for developers working on a codebase to step over unenforced boundaries without intending to do damage especially as the codebase gets older and more complex and the people who originally built it are in short supply. this is true generally just not about soa. i'm certainly not promoting microservices as a panacea but characterizing something that often doesn't work as pretty simple is a red flag for me.;0
l9y2g92;Reddit;2024-06-23 21:37:32;in what world is it easier to onboard a new developer by teaching the entire business domain vs one focused subdomain? false dichotomy. why would having a monolith require a new developer to learn the entire business domain? what are you talking about? it sounds like you are brainwashed to me. we have to use microservices otherwise we're going to have to teach every developer every aspect of our entire program! what?;0
l9w1rp8;Reddit;2024-06-23 13:33:21;you can do http calls. it's better if you do asynchronous communication but it's not forbidden. you can have stateless services that provide functionality just via restrpc calls. that's why the circuit breaker pattern was invented https service a should still be fault tolerant.;0
l9w1sey;Reddit;2024-06-23 13:33:33;you separate the domains you don't isolate them. they can still contact each other but they should be able to do simple business logic independently. caching data from other microservices is very common. they also commonly use the same database servers but with different schemas so they don't get entangled. that way you can just lift the individual schemas to separate database servers when scaling becomes an issue. a simple view of a microservice is as a single deployable unit including databases and stuff. this doesn't mean it can't require other services to do some work but it does mean it can't require other services to be deployed. so it can't require data from other services on load.;0
l9zfovi;Reddit;2024-06-24 02:53:37;yes eventually you will have one final test for the whole system but that's also true for a microservice solution no? no you don't. services are entirely tested in isolation and every team is only responsible for their component working correctly. support issues route directly to the responsible team if their part of the user experience is resultantly broken. you never have to test the system as a whole because the concerns are entirely separated. as long as each team integration tests their dependencies on other team's systems and the userfacing teams properly test their component then the system is holistically tested. as an example there's probably hundreds of teams and systems that end up feeding onto the product page on amazon. the vast majority of the testing of those components is happening so far down the chain that the teams who actually build the widgets for the userfacing web page doesn't even know about or think about what is happening in those systems. it's just a trusted contract and any issues get routed down the chain appropriately. by releasing a new version of their package? how is this any different from a third party package releasing a new version? and how does that actually get into the running production code? in a monolith someone ends up owning the deployment process and it means that every change is bottlenecked on that release. with soa each team fully owns their own deployments and there's no contention whatsoever for that process.;0
l9zvygp;Reddit;2024-06-24 04:52:48;yes eventually you will have one final test for the whole system but that's also true for a microservice solution no? no. think of microservices as saas sub processing but in house. when you use stripe in your app you never actually test their integration with visa. at most you do integration testing with mock data returned from stripe.;0
l9yy4fm;Reddit;2024-06-24 00:51:09;thats ignoring the premise of this entire conversation. the original comment stated that microservices solve an organizational issue. this is true. this isnt to say that theres no other solutions or that organizations could still be successful maintaining certain monoliths. but the implementation of that architecture is specifically to address that issue. and also i said every domain not every part of the program. as we keep stating microservices are appropriate with massively complex or diverse business domains. i have worked in companies with these types of problems that needed to be solved while also maintaining the monolith which was the core application or product. its not some kind of insane concept like you keep making it sound.;0
l9w9rqa;Reddit;2024-06-23 14:46:10;ive never worked on a true microservice system. i suspect unless you have an engineering org with 100s of people you dont need it. monoliths andor a systems with a few central components are underrated. in some sense its kind of weird to me to start with a distributed system design. seems like if you did that you over engineered up front. unless youre working in a domain that lends itself to being naturally distributed or something;0
la1yogf;Reddit;2024-06-24 16:33:45;there are ways to optimise. if you only commit what you change in one service in a modular monolith where services don't depend directly to each other then you can go thousands of commits every minute and even every second ad infinitum. nothing works for a shitty monolith though other than hacks definitely not microservices that's for sure. you need to be conscious on cohesion and coupling all the way to deployment from local to prod. it's not that you don't need. you simply can't do microservices at all sometimes.;0
l9wssmc;Reddit;2024-06-23 16:59:41;i've been writing software for over twenty years now and couldn't agree more. i actually came up with the exact same architecture style independently and dubbed it library first approach. in the end good architecture is about getting the boundaries right which is way easier to do in a monolithic code base which for example requires the same language being used. also requiring the teams to build libraries forces modularity in the same way that decentralised architectures such as microservices or scs do but without the cost and complexity of the network. you also still keep the ability to move one of the libs into its own independent service at any time. and just orchestrating a few libs within a main project enables modular reuse and composition again without all the headaches of the network. some languages make it easier to set up and enforce boundaries between modules and i wish more languages would make this a core concern but it's nonetheless easily possible to enforce boundaries without a network border. and it's definitely preferable.;0
l9x02bo;Reddit;2024-06-23 17:45:00;im trying to reason about how this is fundamentally different from microservices outside of replacing synchronous apis calls with in memory api calls which is definitely an improvement. i suppose another advantage is breaking api changes are caught right away and easily as the code will no longer compile. many of the drawbacks of microservices remain such as domains not being properly split up potential n1 queries everywhere cascading failures stale data etc. would love to hear your opinion on this maybe im missing something;0
l9wphrx;Reddit;2024-06-23 16:38:47;for whatever reason you might prefer runtime integration than build time. and multiple packages enforce the later. also especially on backend you don't need an additional layer to glue your dependencies. two reasons top of my head. i'm all in favor always choosing solution that fits your needs both business and organisation. be it packages monolith or microservices;0
la4i2eb;Reddit;2024-06-25 01:11:36;are you talking about web dev in the context of microservices she deployments? if so you can bundle the code dependant libraries using pnpm and restart the server using a load balancer to maintain uptime elastic beanstalk in aws or a lambda behind api gateway. runtime loading of libraries is not a problem in this context maybe a few kbs or mbs in the worst case scenario. of course in node there's the node modules problem which is fixed by not uploading the whole folder but rather rely on pnpm lock to build on the ci server.;0
la7dcok;Reddit;2024-06-25 15:40:23;it's the same thing one module per folder regardless of the language there's always a command to start and a script to deploy. only your runtime need to support the language. if your tech doesn't really allow good microservices implementation then go traditional servicebased. microservices is essentially a deployment strategy that requires efficient module design.;0
