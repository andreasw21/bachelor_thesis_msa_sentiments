ID;Source;Creation Date;Content;Sentiment
1czgqi1;Reddit;2024-05-24;Title:Don't Microservice, Do Module, Content: https://yekta.dev/posts/dont-microservice-do-module/;0

l5gdyr3;Reddit;2024-05-24 13:12:04;at least at my company the scaling benefit of microservices have never really been touted. the two main benefits for us is that theyre independently managed and they can be used as a common solution for a given problem. but also for context our biggest problem is that we have not one but several legacy monolith solutions several of which because the teams were siloed developed independent solutions to the same problem. so were focusing on microservices mostly to modernize with minimal impact to the end user and to avoid the siloing problem. both of these are more business facing problems than tech problems.;0
l5g8x4k;Reddit;2024-05-24 12:20:45;i really align with all the points. as an engineering manager for a team that has taken microservices to an extreme this hits home. also what you say advocating for a single tech stack e.g. java or .net throughout actually has massive advantages contrary to popular opinion. there are maybe few industries where one part can be written in java and the other needs to be written in rust.;0
l5gsrek;Reddit;2024-05-24 15:10:08;of course if you build a distributed monolith you shouldn't do microservices. but then distributed monoliths aren't really microservices. like everything in software microservices or monoliths are not intrinsically good or bad it's what you make of them that's good or bad.;0
l5gknl1;Reddit;2024-05-24 14:09:41;i work for a software company that's been around making erp type products since the 80s. their rise to dominance and success in the industry it serves happened with a huge onprem monolithic desktop fat client app. their first stumble was deciding to rewrite the old monolith into the exact same monolith but in a different language and desktop app tech stack. their second and current stumble is to rewrite the rewrite as an extremely opinionated homegrown microservices platform approach. the one project i'm on has been attempting a rewrite of the rewrite for over 3 years now. from the eager customers perspective they're losing patience as we aren't actually delivering anything to them in any timely manner. we spend so much time fighting the design of containers for the sake of containers rather than focus on the root problems like a poor understanding and plan for the problem domain. just yesterday i fought one pod by debugging it locally only to realize the bug was in a different pod and our missingpoor logging in the system misled me. every dev team now writes a crud api at best and they pat themselves on the back thinking mission complete. our monoliths made money because they did a ton of business logic and processing that spreadsheets would fall short on. you ask folks how you'll distribute a rollback strategy on a very large transactional problem and they either ignore it or double down into the cult that microservices magically fix that problem. in our monolith we can start a database transaction super simple stuff. i've yet to see a truly capable saga pattern in our microservices rewrite. what i'm getting at is i will always take a well thought out monolith over a but we're using kubernetes now! dumpster fire of a design. as the article states towards the end i can't help but think this was resume driven design with a side of buzzword bingo.;0
l5gu1j2;Reddit;2024-05-24 15:19:01;some good points but had a chuckle at this point under ease of monitoring with a monolithic architecture your system is either up or down with no inbetween. that's actually a big liability of the monolith. if the entire system is down there is a big problem. developersengineers make mistakes it's human but i'd rather have partial availability than a complete outage. but my opinion on this like in most things it comes down to implementation. you can have terrible microservice and monolith implementations it's about the engineers implementingmaintaining them.;0
l5gb38x;Reddit;2024-05-24 12:43:51;microservices have become a religion and speaking out or going against it is heresy. i do think microservices still have its usages but at a cost far far greater than people are aware of. its benificial in very large teams huge projects and projects also connecting to a lot of legacy. but for most companies with about 30 devs or so way to expensive. one thing id like to argue in favour of microservices can be resilience when only a part of the system is faulty the rest can continue working without issues assuming proper decoupling.;0
l5gd034;Reddit;2024-05-24 13:02:53;while i'm all for bashing on microservices for being used wrong in so many projects i don't think the author really understands microservices very well. modularity and being able to use many different languages seems to be a big focus of the article when that's really just a side effect of microservices. microservices are definately overhyped but they are hyped for a reason nevertheless. on a scale of netflix for example microservices are a great choice but the article completely fails to point out why a company of that size would prefer microservices to any other architecture.;0
l5gyo55;Reddit;2024-05-24 15:49:38;i would actually encourage people to ditch some notions of modularity if they're coming off useless and insane amounts of microservices. that's one of the main issues with microservices in practice superficially looselycoupled modules that are actually tightlycoupled. write software that's modular in the same way we wrote it premicroservices don't impose artificial contracts that end up creating a lot of work for no benefit. that is don't just make a monorepo of pseudomicroservices. even huge projects like the linux kernel have no stable apis internally since version 2.6 it's been a boon to the development they do change things a lot. and refactoring is reasonably easy in a modern safe language. learn proper abstractions practices and use your judgement. it's really not that hard but you likely do need proper reviewership and maintainership. i think companies can afford that if they save on inefficiencies introduced by extreme isolation and duplication inherent in certain microservicesheavy architectures. staff that's a little more experienced and capable of dealing with an actual large project could be a whole lot more productive and cheaper than hiring 10 times as many devs who can barely deal with a few files.;0
l5h4ep3;Reddit;2024-05-24 16:25:33;i'm not religious about it but i disagree. both patterns have their place. the article doesn't really address how monolithic architecture does it better. there are ways to mitigate many of the downsides mentioned within microservice architecture. many of the points are debatable at best. for instance up or down monitoring as a pro to monolithic architecture is just wrong. having multiple levels of up is useful and not purely a microservice driven concept. it is useful to know which components are in a working state whatever your architecture choice is.;0
l5heknm;Reddit;2024-05-24 17:26:26;i think we can all agree that using the right tool for the job is important. additionally we can agree that a microservice architecture isn't the beall and endall solution for every technological problem. however i think it's shortsighted to completely write it off in the way its done here. this article is too biased to convince anyone who hasn't already been convinced. others have already made some good comments for both perspectives but i'd just like to emphasize some points that are specifically relevant to my experience. disclaimer the points i'm making are not at all impossible in a monolithic architecture. when working with a modular monolith you dont want to navigate through all directories to understand a specific part of the system. the main difference in terms of understanding the codebase is that instead of knowing the name of the repository or project you need to know the directory in which the module is located. this is the only major difference when it comes to comprehending the subsystem. i don't understand how this is different when working modulebased versus working with a microservice architecture. if you want to understand part of your system you will have to look at the code and documentation for that part of the system. conceptually there is no difference. sure with a monolith you have all the code you need right there in one directory but at the same time you could argue this massively increases cognitive load. to use your example when trying to understand the payment module you might ask yourself whether there are or aren't any direct dependencies to code that lives the auth module. you could argue there shouldn't ever be but there are many things that shouldn't have ever been. with a microservice architecture all services can be separate repositories at least this is what we do and you'll need to collect them if you want to trace from beginning to end. but once you've got a clear understanding of what you need to look at you'll only have collected code that is relevant to what you want to learn about. you'll quickly know whether the paymentservice has direct dependencies to auth. i don't mean to insinuate that one is necessarily better than the other however the fact is that you face the same exact conceptual problem if you want to understand a part of your system. with a monolithic architecture your system is either up or down with no inbetween. with microservices you need to monitor every service. all the services need to be up and they need to be able to communicate with each other all for you to be able to say the system is up. if even one out of your 888 services is down the system can no longer be called up! this makes a massive difference when some processes in your system are critical and some are less critical. some processes might cost your company thousands of local currency when down for 10 minutes. others only cause slight annoyances to your coworkers. being able to quickly inspect individual services running in our kubernetes cluster with the help of proper monitoring is incredibly useful to be able to pinpoint why a critical process might not be working. the fact that you can quickly apply a bandaid solution by redeploying or hotfixing the microservice saves time which is great if you're ever called in the middle of the night! money and not unimportant reputation. both internal and external to your company. why would you ever want to allocate more resources to one particular part? its not like the other parts will eat up the extra resources. but what if they do? if noncritical process gets stuck due to developer error or unexpectedly large loads and starts hogging memory it's really nice that in a microservice architecture only that process is affected not critical process.;0
l5gj760;Reddit;2024-05-24 13:57:46;microservices were a marketing tool pushed by cloud services to get you to use more of their services. they are fine in many cases but pointless and overly expensive in 95 of cases just like almost every insert my favorite fucky fucky frameworklibrarytool here. they scamming small companies who see big company x does it so why shouldn't we? but but but we'll all be the size of netflix soon we gotta build for the future now! 3000 users 80kmonth bill. congrats you got scammed!;0
l5hdbza;Reddit;2024-05-24 17:19:07;both have their place its a tradeoff. the always microservice and always monolith crowds are both wrong;0
l5vdbt1;Reddit;2024-05-27 13:51:24;the tech world is just getting back on his feet! microservice is not an end game but just a possible solution to a clear problem. most of the time totally useless and misused! shiny object syndrome as its best.;0
l5hqxhf;Reddit;2024-05-24 18:38:41;i was looking for a better explanation on how microservices are bad for the earth alas. many of the outlined problems are easily solved by monorepo and have barely anything to do with microservice architecture. no need to turn any of the approaches into a religion. some work best here others work better there.;0
l5ipmqk;Reddit;2024-05-24 22:07:09;i would say soa with right sized services beats microservices and monoliths every time and its nothing new were rediscovering hot water..;0
l5iy7v7;Reddit;2024-05-24 23:00:52;as someone coming from an unnecessarily complicated microservices environment to a very small startup leading the backend development i've definitely been looking towards modular monoliths. i still haven't found many good reference project for actually well implemented modular monoliths that enforce some of the standards standards. well at least not for python which i've been searching for. appreciated if anyone has anything to point out. similarly the article completely skips over something that can become a huge issue as a company scales up which is data segregation. even if your code is modular if the data is completely a big ball of mud with everyone accessing anything directly through the database you're in for a tough time especially if your database becomes your bottleneck. lastly the article assumes all microservices exclusively communicate using synchronous request response communication ie api calls and no proper integration events exist. if this is the case of course you will have a terrible time but then maybe the architecture is poorly applied. adding to that this is something where in a monolithic application at least separate deployments start making sense i.e. api and workers which then is no longer a monolith in some people's mind. i at least again am not finding many good solutions to having an out of memory event bus run in the same process as an api for python and similarly such solutions don't really scale well in dotnet.;0
l5j25ki;Reddit;2024-05-24 23:26:28;is it really that challenging to instruct a team to work within a specific directory? yes. it's far too easy to just fix the code in the other directory if you need to. fault isolation can be just as effective ensuring correctness by testing the contracts. how to isolate a memory leak? one additional question though. right now we have like 30 microservices and we are slowly upgrading them from .net 6 and .net 8. it takes months but everything just works. microservice by microservice. with a big monolith you have to upgrade everything at once.;0
l5k26x6;Reddit;2024-05-25 03:45:59;having some service partitions for sufficiently different parts of your workload definitely has its uses. if you have alwaysactive apis serving user requests that have to be low latency some background processing that is primarily network heavy and some other processing that is primarily cpu heavy and some latenight cleanup and batch processing jobs after which you can stop the instance you might want to split it up into microservices and scaletune them appropriately and mix technologies like ec2 and lambda or equivalent but the idea of having multiple microservices contributing to a single requestresponse cycle is definitely a bad idea when a monolith can handle it all in a single request just be allowing it to instantiate the same service that would be running on a different box in a microservicefirst architecture;0
l5kun8e;Reddit;2024-05-25 07:58:49;team autonomy is it really that challenging to instruct a team to work within a specific directory? at the end of the day a module can simply be a directory within the same project. yes and... we don't even need that. it's trivial to have whatever module anywhere like a separate repository and publish it to an appropriate inhouse module repository. debugging a modular monolith is undoubtedly easier than tracing a bug through a network of systems. good luck identifying a logical bug in a use case that spans 100 microservices yes. on top of that testing a module itself in isolation is easier then testing a remote call. it might not be much easier depending on what your ecosystem has but it will be easier. when it comes to fault isolation microservices may seem to have an advantage no. they definitely have an advantage. a runaway module might for example eat the whole process memory therefore effectively taking everything else down other scenarios exist too. however depending on the usage of the module or microservices the fault impact might be the same regardless. say authentication and authorization. if that goes down i am royally screwed regardless of how and where it is running. runtime this one is so obvious it's not funny. for a remote call to have an edge over a local one there has to be a mountain of code andor io behind that will only win under concurrent load. people getting microservice detection wrong on the performance reason is i think utterly rampant. it is easy to see why that is the decision to make a microservice for some piece tends to be made early when there's often no performance data to speak of. that is a recipe for a blunder. versioning in a modular monolith the entire system is versioned as a single unit eliminating the need to manage each librarys version separately. this simplification greatly reduces the time spent on versioning yes. assembling something using different module versions is easy. the client doesn't need to move to a new module api and when they do they need to change just like they would change their microservice call. meanwhile the module is free of versions supported all at the same time whereas a microservice is not. deployment one common claim about microservices is that they can be developed deployed and scaled independently. a more accurate way to put it is that they must be developed deployed and scaled independently. again yes. it is simply and obviously more stuff to do. this random babbler conclusion use microservices sparsely only after when you learn from actual usage and characteristics of your system what needs to go elsewhere. also use them to match your organization structure but then do not pretend that you are solving other problems admit that it's merely organizational.;0
l5pnhvl;Reddit;2024-05-26 08:16:57;seeing a lot of pushback on microservices lately. i guess at this point that is a contrarian position and some people have a boner for that. there are no magic bullets but this article is just one sided bullshit. here's another ancient persian proverb he who shits on popular shit for clout may not present all the best arguments.;0
l5h2mz4;Reddit;2024-05-24 16:14:40;the author of this article seems to have a fundamental misunderstanding of microservice architecture.;0
l5hv4ru;Reddit;2024-05-24 19:03:16;you are not just wrong you are stupid yeah terrible article about microservices by someone who has never dealt with a production monolith;0
l5iwlkj;Reddit;2024-05-24 22:50:41;written by a bad developer who doesn't understand the point of microservices. microservices are isolation on steroids they prevent the spaghetti code that plagues monoliths any time two modules share the same common code that is by definition spaghetti code they prevent one module from hogging the cpu corrupting program memory and generally damaging the execution of the code in strange and interesting ways. as soon as a developer begins to talk about the difference between a network call and function call they no longer have any understanding nor idea of what they are talking about. in standard business software there is literally no difference between the two from any practical standpoint. the end user can not differentiate between these two options so they are for business reasons exactly the same. and the most important part of microservices is there ability to allow you to delete code. there is no situation in a microservice based system where you can't delete and replace one of the microservices and that is worth every cent of extra development effort in your typical multi year long projects. the section on data consistency might as well be a section on i really want to write bad code with a really bad design. clearly there is no isolation of different domains with inside the head of this software developer.;0
l5h1nfi;Reddit;2024-05-24 16:08:32;anyone that is doing microservices by converting an inmemory function call to a network call has a fundamental misunderstanding of microservice architecture. if someone is using microservices they should have an eventbased architecture. nothing else really makes sense for achieving the goals of microservices.;0
l5iutrn;Reddit;2024-05-24 22:39:33;i think i will use this whenever someone says microservice should at least make them think about what they are suggesting.;0
l5hi66u;Reddit;2024-05-24 17:47:26;imo a big advantage microservices have that you dont really get with modulesmonoliths etc is that you have a very clear and strictly enforced interface between the subsystems. even when i write extensive archunit tests as soon as i turn my back some jackass starts updating the violationstore after their code fails the layer checks because it fixed the failing test. microservices also gets bonus points for only having its own weird magic incantations to start up instead of the sum of all environment variables and command line options required for each module. and they are generally much easier to stranglehttpsen.m.wikipedia.orgwikistranglerfigpattern than big monoliths with much larger surface area. as far as advantages go scalability and whatnot comes as a distant second to reducing the idiot blast radius.;0
l5h0cxe;Reddit;2024-05-24 16:00:21;i don't know about that... companies typically do microservices precisely to silo. you're hoping to extract common functionality into reusable microservices but that's unlikely to happen unless the business side changes too. in fact you could already do it with libraries in most cases you didn't need an actual standalone service. unless people sit down and figure out which things are recurring themes and which can be generalized and made into robust solutions that can be shared across the company and actually allocate resources towards that goal instead of the next random feature things won't change. that requires leadership that's aware of how things go in software and isn't just looking to scale raw business figures pushing the limits of diminishing returns.;0
l5h0c7s;Reddit;2024-05-24 16:00:14;hahaha yeah what is this bullshit even ease of monitoring with a monolithic architecture your system is either up or down with no inbetween. with microservices you need to monitor every service. all the services need to be up and they need to be able to communicate with each other all for you to be able to say the system is up. if even one out of your 888 services is down the system can no longer be called up! if a microservice is down most of your system should be absolutely functional and up! if it ain't you have a cursed condition known as a distributed monolith. microservices are subsystems. you can have e.g. a file uploading subsystem be toast while the rest of the system works normally. you can have a memory leak in one component without the other components getting resource starved or going down with the oom event. you need to be clear about which systems are considered critical and which aren't. if your critical systems are up you're up. if some noncritical system is down you might be in some warning or reduced state but you're very much not down. also how to tell me they've never worked as a sysadmin without saying they've never worked as a sysadmin scalability why would you ever want to allocate more resources to one particular part? its not like the other parts will eat up the extra resources. if your system needs more ram it needs more ram. why would you care about which part needs more ram?;0
l5h1rf8;Reddit;2024-05-24 16:09:14;the transaction part is what i still don't get to this day. once you decouple your microservices and have one database per microservice you will then have to reimplement transactions when you run into the situation you mentioned. it seems like a huge downside that often gets ignored or downplayed.;0
l5irpg5;Reddit;2024-05-24 22:20:05;the whole article waves away complicated issues as if they don't require deeper consideration. op decided on each bullet point and then tried their best to write at least one whole paragraph for each point but some people in tech could write entire books out of each of op's bullet points. fault isolation for example is another big reason that companies choose microservices but that bullet point is like 50 words long. op waved away most issues that microservices solve like they were pasky flies getting in the way of the bias op was aiming for.;0
l5jdmps;Reddit;2024-05-25 00:44:14;yeah we do a sort of domain driven services. each domain typically has a primary macro service with possible microservices broken out for various purposes as needed. thats often things like a hot microservice or a rapidly changing microservice that needs to deploy fast or things that might be temporary or thrown away like mvps that we dont want to impact the primary service and are rolled into the primary if it becomes a keeper.;0
l5hri2a;Reddit;2024-05-24 18:42:01;this sounds like a midpoint between microservices and monoliths. instead of breaking everything into a tiny service because it's technically something separate keeping some things together because they typically only work with each other makes sense. or perhaps the better way to put it is don't separate something out just for the sake of doing so.;0
l5h6ca1;Reddit;2024-05-24 16:37:24;microservices have become a religion and speaking out or going against it is heresy. pretty much every article posted to rprogramming about microservices that gains traction is negative about them. microservices haven't been in vogue for years.;0
l5gf6k6;Reddit;2024-05-24 13:23:10;microservices have become a religion and speaking out or going against it is heresy. it actually works in reverse too. i have to keep avoiding the term microservice in meetings because i know any proposals will get shut down by the manager who once read that microservice is the 8th sin. people not willing to or capable of evaluating the context is the problem not technologies or techniques because they are just tools. tools have their uses.;0
l5h8d37;Reddit;2024-05-24 16:49:36;assuming proper decoupling that's a big assumption. most often microservices are just distributed monolith made by interns lead by a lead dev cto because they've been in the company for 2 years after gettting their degree who read a medium blog post presenting the basics of microservice in their language. circuit breakers? don't know her. or more generally handling errors? don't care catchthrow all the way! multiple single point of failure like the database redis the api gateway or in fact any of the services? sure we got those. trying to cache everything because function call are know milliseconds network calls piling on each other? not a problem. random race conditions? services locking each other in a closed loop? nothing some good ol' midnight debugging can't fix and those pizza nights are always good to foster company culture. but don't fret soon our cto will stumble on a medium article about ddd and all those service will become cqrsevent driven over a let's get started install of kafka. but hey! when you only got 10 users per month you have to be creative to make sure your architecture breaks often.;0
l5gjjtg;Reddit;2024-05-24 14:00:38;ive been a microservice software engineer for 5 years now and i dont know they seem to be trending downward in usageimplementation. there are better alternatives these days with modules as shown here but also many standalone cheap products which act as microservices. so many awsazure tools are just microservices with ui attached why reinvent the wheel? and for data processing etl jobs can be performed without microservices in databricks etc. so i think were at a point of retrospective. weve learned the problems with microservices such as code overlap too many network calls and lack of definition for service size. microservices still have their place dont get me wrong but other options should be considered first.;0
l5haol9;Reddit;2024-05-24 17:03:21;and here i am as a junior dev working for a company with 3 devs and the boss wants to implement a microservice architecture. the boss is one of the devs.;0
l5gwd2i;Reddit;2024-05-24 15:34:32;i actually recently joined a 4 person team that's using 6 microservices a bff for an application with fewer than 50 users... leaving soon though;0
l5gn7aj;Reddit;2024-05-24 14:29:44;even at netflix's scale do you want microservices or several monoliths? obviously as a project gets large you want to divide it so that different teams can work on it independently and reduce blast radius. but does each team need 10 microservices? probably not. if we define a microservice as something that needs to make calls to other services over network then nearly everything is a microservice. but in practice as long as your team is only managing one service it behaves like a monolith.;0
l5geksu;Reddit;2024-05-24 13:17:41;i agree. i get your point. however once a company chooses microservices turning back becomes a very costly option from the start. it's indeed a tradeoff but most of the time the troubles aren't worth it. netflix itself probably already has reached a point where a single use case requires the aggregation and communication of let's say a hundred microservices. imagine debugging 100 microservices looking for one bug. the least a modular monolith does is enforcing some level of integrity which in return makes debugging less painful.;0
l5gp66z;Reddit;2024-05-24 14:44:31;microservices have lots of benefits. reddit is sort of cult against them right now but trust me none of the pluses magically disappeared. 1 as you mentioned they can be scaled independently and distributed across datacenters and regions. they buy you a lot of resiliency when designed correctly 2 if you have proper decoupling you can extend your system by adding and deploying new services versus refactoring existing ones. 3 you can refactor and update your system piece by piece. im sure we can all remember .net to dotnet upgrades of our monolith that took over a year to complete. not so with microservices. 4 they can be deployed in smaller safer pieces versus pushing a new version of the monolith which often turns into a religious process event at some companies 5 they let you mix and match technology where appropriate use the right tool for the right job 6 tooling is great in kubernetes. containers in general microservices or not when done right allow the software to run anywhere. at my job you can pull down a devcontainer repo that builds with a single click and spins up a hundred service environment without needing to install anything the developers machine.;0
l64yuc7;Reddit;2024-05-29 07:57:20;what you just described is not microservice but soa which the author puts within the safe starting point zone.;0
l64z3rg;Reddit;2024-05-29 08:00:10;we have about 10 independent monoliths that use a lot of the same code. that code is either jarred up or copy and pasted into each project. sounds like you could benefit of a monorepo and have those reusable code parts as modules that can be imported instead of creating a microservice for that reusable code. this is basically the author's argument;0
l5gec5m;Reddit;2024-05-24 13:15:30;i am saying this as someone who works on a distributed microservice system too. everytime i hear let's make that a service i push back on it because services for tiny things are such a silly idea;0
l5h0bb7;Reddit;2024-05-24 16:00:04;because there isn't a one size fits all solution that's the reality of it. a lot of us don't work on tiny projects and a lot of us do. all devs work in very different contexts and sometimes microservices are the answer and sometimes not;0
l5jres8;Reddit;2024-05-25 02:25:31;i'm a big fan of event oriented architecture but there's nothing wrong with network calls to other microservices if done right. for example we do cqrs and sending a command to the microservice allows the process manager to know exactly the status of the command handling instead of throwing it on an event queue and hoping that it gets handled and waiting until a timeout hits to realize there is no listener for that command anymore or that the other service that handles that command is down.;0
l5iywy6;Reddit;2024-05-24 23:05:24;as soon as i turn my back some jackass starts updating this is my main reason for not wanting to move away from microservices. i do not trust people to not break things or worse do something dodgy that does work and is very very hard to roll back without upsetting other teams. broken gets fixed shite stays forever.;0
l5gswt9;Reddit;2024-05-24 15:11:11;wait you don't run every dependency as a distinct microservice? s;0
l5i44l8;Reddit;2024-05-24 19:56:18;.net aspire looks really great opinionated microservice architecture;0
l5h0pni;Reddit;2024-05-24 16:02:37;monitoring is more than just uptime especially in a monolith. this is an area where monoliths can be really painful. lets take an example like ok pretend you have a product like shopify you have two layers of customers. your direct customers and your customers customers. when you have a traffic relationship like that some areas of your application will dramatically skew the metrics and monitoring of others. you probably receive a thousand requests related to your customers customers for every one request your direct customers make which means simple monitoring of availability across your monolith is never going to be a good solution you need to break up your request metrics into sub category based on business need or owning team or something but in a monolith this is a unique class of problems that is natively solved by the architecture of a microservice. its not unsolvable but its something you do have to invest more into for the same capability provided for free with most reasonable microservice implementations. availability is also a relatively simple case for this it only gets more complicated which is why the reduction to just using uptime is frustrating uptime is fine for healthlikeness checks but is not fine for anything else really.;0
l5j7h7g;Reddit;2024-05-25 00:01:42;i feel like you should be setting up good monitoring regardless. things like tracing and spans in open telemetry are incredibly useful for both microservices and monoliths and you also need metrics for both. with microservices it is trivial to know which part of the system that is leaking memory file descriptors consuming all the cpu spawning threads left and right and all sorts of things it's the one that keeps crashing. analyzing threaddumps and heapdumps are usually easier too.;0
l5hftf9;Reddit;2024-05-24 17:33:44;if you need transaction across microservice i would put forward you either didn't split you domain properly or that you should not not do transaction at all and use a stream architecture...;0
l5h690y;Reddit;2024-05-24 16:36:51;right not impossible by any means but it ups the complexity and ultimately requires a higher skillet of the average dev in my opinion. cowboy coding crashes fast in microservice design. but my company got to where it was today on it and it has caused a skillsculture lag. the devs who know the business aren't good at microservices and the devs who are good at microservices don't know the business.;0
l5hqq6e;Reddit;2024-05-24 18:37:29;totally agree and to be fair our loggingtelemetry was poor in the monolith too. lots of devs here fall back on being able to debug the code running locally when something goes boom. in the old days we'd have the onprem customers back up their entire database and send it to us sometimes by shipping a disk drive if it was large when we needed to troubleshoot. we'd restore that database inhouse and run code against it. when you are up against that sort of culturemindset microservices make it so much harder. in my case this service was returning a 500 error with no additional info. i looked at our telemetry system no logged exception there stack trace etc. basically just a something went boom error. when i begrudgingly debugged that service locally i found it was an error on a call to a different service. the call itself was 200 ok the issue was a mismatch in the anticipated response json. if i couldn't debug locally i still would have no idea why it wasn't working. that's a pretty common occurrence in this new project.;0
l5hvqjm;Reddit;2024-05-24 19:06:50;well if you have a monolith and the sql server goes down youre screwed. microservices might have several smaller storages;0
l5kornu;Reddit;2024-05-25 06:54:53;there is a lot that happens so i'll be brief. 1. start with vision what does it look like in ideal state and why 2. create definitions what do you define a faas microservice monolith etc. every company has a slightly different take which is fair 3. make sure you understand your asis architecture if you don't you will be hitting walls going where did this appservicefunction come from and stopped you dead in your tracks 4. make sure your leadership understand the previous 3 points and buy in if not find out what they disagree on and identify amicable solution 5. plan your execution across quarters without negatively impacting product roadmap or product squads some specifics you asked we moved away from aws and to azure long time ago and never looked back faas if it can be part of service add it to the service faas should be very lose in some sense decoupled from entire solution vm our analysis gave us a vertical and horizontal thresholds to trigger scalling with vertical being first i paid for 100 of cpu i am going to use 100 of cpu kinda joke repos blew away as many as possible aimed for monorepo. this is just start tho hope it helps.;0
l5kp8jo;Reddit;2024-05-25 06:59:46;pretty much microservices have a brand loyalty cult vibe these days so we are very cognisant when someone says here is another microservice then another then another. modular monolith or modular macroservice is beautiful when done right.;0
l5gyao3;Reddit;2024-05-24 15:47:13;yeah it's possible to get the reduced blast radius of microservices without a microservice architecture but then you've pretty much restricted yourself to writing your system in erlang or some other beam language like elixir. a lot of the microservice architecture stuff is also just a good idea in general like having generally stateless applications and environments clear automated build steps ease of scale and so on. i doubt anyone who's been a sysadmin for crusty apps that require arcane incantations to start require a year and a half to do so can't be safely restarted have mutually incompatible environment requirements and are all but impossible to scale or even run in a highly available setup and since moved on would want a return to those days. we know the absolute bullshit shortcuts envelopers will take if they can and we want some way to hold them by their ears so they don't keep doing it.;0
l5gqr8f;Reddit;2024-05-24 14:55:59;every service is a trade off. a new service adds complexity maintenance costs running costs and more mental load to developers but at the same time improves independent scaling and reduces the blast radius if services do go down. you definately don't want hundreds of simple crud microservices that each handle a single entity but at the same time you don't want your whole app to go down if a single mistake happens. also i very strongly disagree with your definition of a microservice. the whole point of the domain driven design in microservice architecture is that services are independent. http calls to other services should only be an exceptional case. splitting your monoliths' modules into microservices and replacing function calls with network calls is one of the biggest and unfortunately quite common mistakes that people make when they join the microservice hype but have no clue what they are doing.;0
l5gi24q;Reddit;2024-05-24 13:48:17;yes distributed debugging is one of the downsides of the architecture. but if a single bug concerns more than even 5 services then you are not working with microservices but with a distributed monolith.;0
l5gsbwg;Reddit;2024-05-24 15:07:07;if your daily user base isn't measured in millions you don't need microservices. if it is you might need microservices.;0
l5hykmw;Reddit;2024-05-24 19:23:36;yes but what if you need to abstract two lines of code? surely you'll need a microservice;0
l5hd0ya;Reddit;2024-05-24 17:17:18;microservices are fine for large user bases. we have nanoservices and it really sucks to support.;0
l5h88ri;Reddit;2024-05-24 16:48:53;the first step to migrating to microservices is to split the database up. each microservice has its own database. data redundancy is both allowed and expected. a key part of eventdriven architecture is that there is no synchronous communication between microservices. so there is never an instance where an inmemory function call has been replaced with a network call. when a microservice gets a request the request is fulfilled using data from its own database. it will then publish an event indicating what it did. any interested downstream service can handle the event so it can take the appropriate action usually by doing some crud operation in its own database. so eventually the databases get synced up and eventually is usually measured in milliseconds. you can google eventual consistency for more information about this. as an example consider a user service whose sole responsibility it is to manage users and their profile information. a request comes in indicating that a user has updated their email address so the user service dutifully updates its database with the new email address. it then fires off a profileupdateevent which contains all the current user profile information. any downstream service that needs to know the user's email address can handle that event by seeing if the current email address is different than the one in the event and update its database if so. then when the downstream service gets a request that requires the email address it doesn't have to hit the user service to get it it already has it in its own database. this is the only architecture that makes sense to meet the independently deployed and independently developed goal. the only thing that matters is the event contents and those are very easy to keep backward compatible because you simply never remove information from the event but can add. you need a message broker that can be configured for guaranteed message delivery e.g. rabbitmq. the hardest part about this architecture is discovering what events each service fire off. also in this architecture you should really try to avoid using sdks they create tightcoupling and just accept code redundancy as well as the already mentioned data redundancy.;0
l5jtpyq;Reddit;2024-05-25 02:42:46;i'm a big fan of event oriented architecture but there's nothing wrong with network calls to other microservices if done right. there is as soon as you make a synchronous call to another microservice you have lost independent development and deployment. every effort should be made to avoid them if at all possible.;0
l5iuf95;Reddit;2024-05-24 22:37:03;i have a really negative view of this sort of framework. microsoft has actually already tried this twice before with cloud services deprecated and service fabric two azure products. this isnt exactly the same because its not tied to azure but the altogether one stop shop for microservices hasnt really panned out so far.;0
l5kasg8;Reddit;2024-05-25 04:52:07;you can have decoupled microservices but you're bound to run into a business requirement that involves them in an atomic way maybe something like update inventory api for product x schedule a shipment in shipping api notify user by email and update user credits in payment api . not sure what a stream architecture is though i'll have to read up on it;0
l5gsxui;Reddit;2024-05-24 15:11:24;ok so you suggest splitting the system into multiple processes. postgres has such architecture for exact same reasons. but nobody would claim postgres architecture is microservices. process ! microservice.;0
l5r76l1;Reddit;2024-05-26 17:24:43;if you separated the concerns in a proper way by extracting the bounded contexts in your domain in a monolith why would the migration from modular monolith to microservices be different than replacing function calls with network calls? what do you mean by independency between the services? what kind of dependency you image when you have a modular monolith? i can only image an issue in module a which causes to stop working an exposed api in module b because of maybe a memory leak happens in module a which is something really rare. because of that kind of rare issues i don't think that it makes sense to adopt microservice architecture. i agree it's needed for some companies especially for the companies which need high level of availability and scalability. however the thing is most of the companies are not that kind of company.;0
l5hv6jl;Reddit;2024-05-24 19:03:34;we have 100 users after 2.5 years of microservices. fuck my life;0
l5ixt2d;Reddit;2024-05-24 22:58:17;the system i work on processes single digit millions of transactions per hour. email marketing it has roughly three microservices one of which i think we could fold back into the monolith. for the other two the primary benefit is security isolation for things exposed to the open internet. the microservice aspect to it is a necessary pain.;0
l5k4qkl;Reddit;2024-05-25 04:05:32;the first step to migrating to microservices is to split the database up. each microservice has its own database. data redundancy is both allowed and expected. wait a minute microservices are there to allow you to scale individually. as in you have a service that does a b and c. a is bursty low cpu cost and quick to run b is bursty even lower cpu cost but takes 5 minutes per transaction c follows a consistent schedule has a high cpu cost takes 5 minutes to run and must run every 10 minutes in a situation like this you have an ideal use case for breaking your monolith into at least 2 micro services. but nothing in that requires that you add a new db. if your problem is purely on the service side then modify the service. if your problem is purely on the db side then modify the db. i fear that you are complecting 2 very different things. sure they certainly can and often times do align. but they are certainly not the same.;0
l5hlpcb;Reddit;2024-05-24 18:08:02;a key part of eventdriven architecture is that there is no synchronous communication between microservices. so there is never an instance where an inmemory function call has been replaced with a network call. that's the error. when you compare the eventdriven microservices architecture to a monolith with decoupled modules architecture that is what you end up comparing a function call and a network call. monolith auth.checktoken function call event driven architecture eventdispatcher.dispatch'authchecktoken' network call to the queue manager network call to the listeners;0
l5hj54v;Reddit;2024-05-24 17:53:06;well yes stuff like frameworks should be easier to upgrade with microservices. but i've encountered situations like incompatible versions of serialization libraries or other dependencies which pretty much required upgrading everything or at least a large portion at once. it could even be a companyinternal dependency that becomes a choke point. i'm also not keen on making assumptions like if built appropriately. but i feel like microservices make it even worse for a few related reasons 1. they make it easier to avoid wider code review and design considerations. that probably applied to the smaller monoliths your coworker worked on. 2. some projects are likely to choose arbitrary components for microservices or implement the bare minimum without sufficient research to make said components robust. so contracts are fairly meaningless and things are likely to change over and over. the boss won't address that tech debt either until some feature demands a change then that gets hacked up in the worst possible way. 3. it's easy to end up with a ducttaped monolith composed of microservices. then everything is harder for very little benefit like you can easily upgrade certain external libraries but other stuff still causes a huge mess. ultimately i don't think that a monolith will solve all those problems but i think microservices particularly the micro bit give certain companies more rope to hang themselves. it's going to be easier to argue quality standards and scoping in a monolith and people will spend much less time bikeshedding networked apis. i'd say it even fits the agile culture better in some ways if you're not going to have a good design upfront. it might be easier to justify a separation between rough prototypes and production. the one thing i'd be concerned about is finding enough people able to navigate and contribute to a larger codebase. which is kind of a businessscoping issue really.;0
l5nfplg;Reddit;2024-05-25 21:26:25;im not suggesting or advocating anything im saying that that is the case with microservices and that that is one of the plus sides among downsides. in the end it all depends on what you need and with what downsides you are willing to live;0
l5v49du;Reddit;2024-05-27 12:12:49;if you separated the concerns in a proper way by extracting the bounded contexts in your domain in a monolith why would the migration from modular monolith to microservices be different than replacing function calls with network calls? because network calls are slow and unreliable. and you definately don't want call chains including 5 different services because response times would quickly exceed 1 second for each user request you'd probably have to deal with distributed transaction management and debugging would be a nightmare. sharing data between services is expensive that's why you'd design microservices to use as little data from other services as possible. obviously you can never completely avoid it. in that case you'd preferably share the data asynchronously wherever possible and only call other services directly if you can't avoid it. fictional netflix example let's say you have 2 services. a metadata service which contains all information about movies title description age rating license status etc. and a watchlist service that saves the users' liked movies. since licenses with publishers sometimes do expire some movies on the watchlist may become unavailable at some point so the requirement is to check in the watchlist service wether the movie is still available. you don't want to delete the entries because the movies could become available again later. now in a monolithic world your watchlist service would just call the metadata module and check the license status when you need it. between microservices you want to avoid that network call. that's why the metadata service would instead publish all changes to movie metadata to a message queue kafka is very popular in my experience. the watchlist service is subscribed to that queue and consumes all updates. you obviously don't need the movies' title or description but the watchlist service will save just the data it needs which means saving the movie id and its license status as duplicated data in the independent watchlist db. now the watchlist service can just check in its own db wether the movie is currently available. this is a pretty common approach in microservice architecture and it highlights a few things you need to deal with inconsistencies. message queues are not instant. it could take a couple of seconds for all services to react to an update. in this example it's no big deal because worstcase scenario is that the user selects the movie on the watchlist but can't view it. for more critical entities for example whenever money is involved you will have to take a different approach. this is also one of the reasons why netflix is so often ed as a great example where microservices work really well because only a few of their entities are super critical. who cares if a typo in a movie description takes 2 seconds longer to update right? you need to care about errorhandling. if the system is inconsistent for a few seconds it's often not a big deal. but if you don't monitor and handle your exceptions properly you risk having inconsistent data between services for the same data set. this can lead to pretty messy behaviour. even if the metadata service and its whole db burn to the ground the watchlist service can continue to work without impact. sure there won't be any metadata updates for a while but the service has everything it needs to continue operation as normal. microservices are expensive. message queueing systems aren't cheap and you will write a lot of messages in a microservice system. additionally you'll need much more db capacity because you duplicate a lot of data. operational and maintenance costs also come on top.;0
l5l600u;Reddit;2024-05-25 10:18:15;it's because more often than not people in software engineering often including the engineers themselves too lack the understanding to accurately determine what the long term effects of their decisions will be. hence reading a book a blog post or acquiring superficial understanding of something like domain driven design microservices or the next pattern of the year can be turned into a dogma by a team lead or a manager.;0
l5mizly;Reddit;2024-05-25 17:50:25;wait a minute microservices are there to allow you to scale individually. in my view the most important benefit of microservice architecture is independent deployment and independent development. scalability follows from those two things.;0
l5l27hp;Reddit;2024-05-25 09:29:26;i think part of the issue with microservices is that it winds up meaning different things to different people especially if they never bother reading any definitions. there's likely some platform constraint that just comes from running e.g. containers in kubernetes but beyond that people will architect stuff in a way that makes sense to them and that way may or may not be a good fit or even idea. personally i'd expect microservices to either be or vibe with acidhttpsen.m.wikipedia.orgwikiacid so they can share a database rather than having to manage or pay for more of them. and i expect that in part because i expect to be able to scale a microservice to multiple replicas. i think established adults have experience with apps that you couldn't scale or run in a highly available manner because they are just too stateful and racing but i'm starting to think kids these days might have been spared some of the things we've seen and wanted to get away from and think we're just trying to get them to do stuff in a needlessly complicated fashion.;0
l5hox3u;Reddit;2024-05-24 18:26:53;what you're describing is literally an enterprise service bus and the old soa architecture that came from that. it is absolutely not the same thing and yes i was around when soa was all the rage. soa generally meant blocking rpc calls with soap web services. there is nothing at all in common between soa and eventdriven architecture with microservices.;0
l5hwarb;Reddit;2024-05-24 19:10:07;making sure a request is authenticated is the job of the api gateway. if the request isn't authenticated then the gateway should respond with a 401 and then the ui should send the user down some authentication flow. once authentication is complete the gateway can associate a session with the user and store a jwt in the session usually with a distributed cache of some type and the ui can resend the original request with the appropriate session identifier. if the request is authenticated i.e. has a session identifier the gateway can pull the jwt out of the cache for the session identifier add it to the request and forward on to the appropriate microservice like normal. the microservice extracts user identity from the jwt. make sure a successful authentication and an unsuccessful authentication take roughly the same amount of time so that valid usernames can't be determined by a timing attack.;0
l5jkews;Reddit;2024-05-25 01:33:17;and once you get a few too many microservices? monorepo! which is just a fuglier word than monolith that suggests intent;0
l5omocc;Reddit;2024-05-26 02:41:46;this is simply not true you can have separate projects without having to run them as separate processes. your main process can just import the sub projects and run them all in one process. obviously you need one or few main processes that don't do much on their own aside from creating a composite project of the sub projects. read into why amazon invented microserviceshttpsyoutu.beesefay0fdkc?si5zgmusupqv2ls9j3 in 2001. a large factor slowing development down was the sheer amount of time it took to build and test the monolith. according to the new amazonian training the monolith took over half a day just to compile.;0
l5nglrr;Reddit;2024-05-25 21:32:35;never heard that before but i see the value. then let me ask when do you feel the threshold is for splitting a service up into microservices? i gave my own threshold based on my initial understanding. in what context would you say that a service has reached a point where microservices might make sense?;0
l5minpr;Reddit;2024-05-25 17:48:19;i think part of the issue with microservices is that it winds up meaning different things to different people definitely. these days when people say they converted to microservice i always ask them what they mean i.e. describe their architecture. i find in most cases what they actually converted to is a distributed monolith. imho there is no value at all in converting a monolith to a distributed monolith.;0
l5mjuug;Reddit;2024-05-25 17:56:04;it's going to suck to have permissions replicated in individual service's databases much better for each service to query a permission service. each service should have a copy of the permissions that it cares about in its database. a permission system works just fine in an eventdriven archtecture. much better for each service to query a permission service. if you are making synchronous calls between microservices you have tightcoupling and have lost all benefit of microservices they can't be independently developed or deployed. you have created a distributed monolith. you would be better off keeping your app as a monolith there is nothing inherently wrong with a monolith and most apps are just fine as a monolith.;0
l5p8je2;Reddit;2024-05-26 05:40:41;you would be better off keeping your app as a monolith that is correct. unfortunately this opinion is purely an engineering focused argument and doesnt take into account organizational hierachy and politiking and those things actually affect the software architecture way more than engineering concerns! the whole reason microservices can take off in an org even if it isn't actually better than a monolith is that it mimicks an org structure. individual teams own individual services and they obligate themselves into adhering to contracts between teams either software api contracts or verbal ones. where contracts need to change there's some process to do so one team does not just write code for another's. this leads to a lot of inefficiencies in the software but it works politically. guess what wins out in the end!;0
