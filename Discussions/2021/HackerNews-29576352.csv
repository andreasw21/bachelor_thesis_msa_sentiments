ID;Source;Creation Date;Content;Sentiment
29576352;HackerNews;2021-12-16;Title:Don't start with microservices â€“ monoliths are your friend, Content: https://arnoldgalovics.com/microservices-in-production/;0

29646953;HackerNews;2021-12-22;the exact reason why i compare microservices to oop that's just because some guru uncle bob or even more probably martin fowler i think some rather long by now time ago wrote a lot of examples along the lines of methods should be at most five preferably three lines long in java.if you look for later examples of the same kind of recommendation you'll probably find they're mostly written in funtional languages nowadays so you could just as well say that's why i compare microservices to fp.;0
29614235;HackerNews;2021-12-19;yeah the ops side of microservices is important.more granular scaling. scaling up instances of 8 16 32gb or even larger instances is much more expensive than 124gb instances. in addition monoliths tend to load slower since there's more code being loaded so you can't scale up in sub minute timesobviously there's lazy loading caching and other things to speed up application boot but loading more code is still slower;0
29607442;HackerNews;2021-12-18;i feel like a lot of microservice advocates fail to price in the overhead introduced when you split stuff up into multiple independent communicating units.example replacing a simple database query effectively instant and relaying the data as a local variable with poking a seperately hosted microservice which ends up adding 20ms of overhead doing a https request encoding and deencoding the result in json etc.;0
29606318;HackerNews;2021-12-18;this is actually quite a nice sweet spot on the monomicro spectrum. most bigger software shops i've worked at had this architecture though it isn't always formally specified. different servers run different subsets of monolith code and talk to specific data stores.the benefits are numerous though the big obvious problem does need a lot of consideration with a growing codebase and engineering staff it's easy to introduce calls into codedata stores from unexpected places causing various issues.i'd argue that so long as you pay attention to that problem as a habithave strong norms around think about what your code talks to even indirectly you can scale for a very long time with this architecture. it's not too hard to develop tooling to provide visibility into whatscalledwhere and test foraudittrack changes when new callers are added. if you invest in that tooling you can enforce internal boundaries quite handily while sidestepping a ton of the organizational and technical problems that come with microsevices.of course if you start from the other end of the monomicro spectrum and have a strong culture of e.g. understand the service mesh really well and integrate with it as fully as possible you can do really well with a microserviceoriented environment. so i guess this boils down to invest in tooling and cultivate a culture of paying attention to your architectural norms and you will tend towards good engineering ... who knew?;0
29603692;HackerNews;2021-12-18;yes the original argument was that boundaries can't be enforced. arguably it is easier to enforce boundaries between microservices.;0
29603356;HackerNews;2021-12-18;there is no single development in either technology or management technique which by itself promises even one orderofmagnitude improvement within a decade in productivity in reliability in simplicity. fred brookssussman summed up the problem nicely we really don't know how to compute! so we latch onto whatever semiplausible idea some consultant cooks up like flowcharts structured programming agile objectoriented programming testdriven development microservices and countless other things.microservices impose a transport layer over whatever it is you were doing before. so that's one extra point of failure that you've got to contend with. complex problems require complex solutions. sure there are better and worse ways of doing things but there are no miracles.;0
29601965;HackerNews;2021-12-18;microservices requires lots of forethought design and highly qualified engineers.you spent the same amount of forethought design and talent on monoliths youd might not need microservices.the real issue is scale.a well designed micro service mesh will scale. a well designed monolith might scale.;0
29596353;HackerNews;2021-12-17;amazon was also doing microservices very early and it was a monolithic c application originally obidos.microservices was relly more about locality and the ability to keep data in a memory cache on a thin service. rather than having catalog data competing with the rest of the monolithic webserver app on the front end webservers requests went over the network to a load balancer they were hashed so that the same request from any of the webservers hit the same catalog server then that catalog server usually had the right data for the response to be served out of memory.most of the catalog data was served from bdb files which had all the nonchanging catalog data pushed out to the catalog server initially this data had been pushed to the webserver. for updates all the catalog servers had realtime updates streamed to them and they wrote to a bdb file which was a log of new updates.that meant that most of the time the catalog data was served out of a redislike cache in memory which due to the load balancer hashing on the request could use the aggregated size of the ram on the catalog service. rarely would requests need to hit the disk. and requests never needed to hit sql and talk to the catalog databases.in the monolithic world all those catalog requests are generated uniformly across all the webservers so there's no opportunity for locality each webserver needs to have all the top 100000 items in cache and that is competing with the whole rest of the application and that's even after going to the world where its all predigested bdb files with an update service so that you're not talking sql to databases.;0
29591723;HackerNews;2021-12-17;overall this setup would work perfectly fine in a smallmedium company and take 510x less time than doing everything the faang way.the point was never comparing it to the faang way. the point is it's easier at the beginning to maintain one monolith and all the production stuff related to it than n microservices.;0
29591341;HackerNews;2021-12-17;i didnt't even get a quater of the way down the page before i stopped reading.as soon as the author started listing things like k8s as needed for microservices it shows they havent stopped to think out side the box. there is no reason you can't run your set of microservices as 34 docker containers on the same host no load balancers no k8s no log aggrigation etc etc etc.if your application makes sence as microservices you don't need to start with all of that so including it all in the cost of startup makes no sense at all as your application starts to scale out and need them add them at that time your going to need most of it for a monolith application as well and some of them you may never need k8s for example there is no reason you can't run your application on just plain old compute infrastructure you don't even need to look at the cloud that old box in the corner of your office might be all you need for the projectif you stop and remember that microservices just means small single function services not things like k8s you will probably find that you can actully do a lot less work if you go down that road by letting other exsisting projects so a whole bunch of the work for you and save you reinventing the wheel to get your project finished and out the door.;0
29590723;HackerNews;2021-12-17;when the autor says to be fair using k8s helm i was able to install logging grafana prometheus very easily. if you leverage on helm3 and bitnami 1 helm charts you can go fast.also you can use pipeline like githubbitbucket pipelines to deploy and remove jenkins completly i have done it and it is a viable solution although with some lockin.so the complexity is a bit less if you study enough well your setup but you imust take time to plan your solutioni.after three years of k8s study in my humble option k8s is far better compared to docker swarm even for tiny projects with k8s as a cloud managed solution even small provider had it nowadays.1;0
29590439;HackerNews;2021-12-17;you're talking about something very odd here... a monorepo with a monolithic build output but that... transforms into any of a number of different services at runtime based on configuration?i'd say that it's more uncommon than it is odd. the best example of this working out wonderfully is gitlab's omnibus distribution essentially one common package e.g. in a container context that has all of the functionality that you might want included inside of it which is managed by feature flags here's an example of what's included now i wouldn't go as far as to bundle the actual db with the apps that i develop outside of databases for being able to test the instance more easily like what sonarqube does so you don't need an external db to try out their product locally etc. but in my experience having everything have consistent versions and testing that all of them work together makes for a really easy solution to administer.want to use the built in gitlab ci functionality for app builds? just toggle it on! are you using jenkins or something else? no worries leave it off.want to use the built in package registry for storing build artefacts? it's just another toggle! are you using nexus or something else? once again just leave it off.want ssltls? there's a feature flag for that. prefer to use external reverse proxy? sure go ahead.want monitoring with prometheus? just another feature flag. low on resources and would prefer not to? it has got your back.now one can argue about where to draw the line between pieces of software that make up your entire infrastructure vs the bits of functionality that should just belong within your app but in my eyes the same approach can also work really nicely for modules in a largely monolithic codebase. is this meant to be simpler than straight separate codebase microservices?quite a lot actually!if you want to do microservices properly you'll need them to communicate with one another and therefore have internal apis and clearly defined service boundaries as well as plenty of code to deal with the risks posed by an unreliable network e.g. any networked system. not only that but you'll also need solutions to make sense of it all from service meshes to distributed tracing. also you'll probably want to apply lots of ddd and before long changes in the business concepts will mean having to refactor code across multiple services. oh and testing will be difficult in practice if you want to do reliable integration testing as will local development be do you launch everything locally? do you have the run configurations for that versioned? do you have resource limits set up properly? or do you just connect to shared dev environments that might cause difficulties in logging debugging and consistency with what you have locally?.microservices are good for solving a particular set of problems e.g. multiple development teams one per domainservice or needing lots of scalability but adding them to a project too early is sure to slow it down and possibly make it be unsuccessful if you don't have the preexisting expertise and tools that they require. many don't.in contrast consider the monolithic example above i'd argue that up to a certain point this sort of architecture actually scales better than either of the alternatives in comparison to the regular monoliths it's just a bit slower to develop in that it requires you to think about boundaries between the packagesmodules in your code which i've seen not be done too often leading to the big ball of mud type of architecture. so i guess in a way that can also be a feature of sorts?;0
29590250;HackerNews;2021-12-17;i agree to not start with microservices.. but its better to not wait too long after the project is growing.regarding his points infrastructure requirementsyou don't need all that stuff! you can have multiple services run on paas services cloud run and you dont need to deal with all the kubernetes stuff. even if you prefer k8s then you still dont need a service mesh from the start. datadog and gitlab brings you very far with hardly any work on your side. faster deploymentsmy point 80 microservices? crazy .. why? just have a service per business domain and try unifying the cicd stack.we had 1 big monolith which would deploy 5 times per day buy every deploy took around 1 hour.having 5 to 10 services that all deploy within 5 minutes is so much nicer to work with. the supporting culturethis is important architecture follows company organization and vice versa. every team often owns 1 or 2 services. teams should be organized by domain. business boundaries should be agreed upon in a higher level.sitting in your dev corner building services without talking and aligning with the product owners amp mt is a recipe for distaster imho. the services should solve a problem that po's understand. you should have alignment. better fault isolationwe never said it was going to be easy... it requires a different way of building your system. you need to think distributed systems.;0
29589817;HackerNews;2021-12-17;the problem is that orgs are not set in stone. teams get merged and split in reorgs buyouts and mergers happen suddenly your microservices designed around cleanly defined boundaries no longer make any sense. sure you can write completely new microservices but that is a distraction from delivering value to the end customer.;0
29589799;HackerNews;2021-12-17;for me it highly depends on the size of software the time to market the time the software is supposed to work without major rewrites.if i am doing a blog application or an website for one time event i would pick a monolith.if i start on erp a checkout solution i would pick microservices.also if the man power is low but i expect growth in the future i might go for a monolith broken in separate projects with minimal dependencies between modules so it wouldn't be terribly difficult to break it into microservices when the need and man power arrives.;0
29589736;HackerNews;2021-12-17;seems to me that the author is poor at designing microservices. using his example the login session and user services should be only one service something like keycloak there's no advantage to splitting this up so why would you? analytics service should never be a dependency of another serivce but rely on service discovery and a preset telemetryanalyticsrpc endpoint which each of the consumerfacing services implements.has anyone claimed that microservices will fend of poor design? there's never a silver bullet.;0
29589283;HackerNews;2021-12-17;the archetypical microservice ecosystem i am aware of is google's production environment. it was at that point primarily written in c and java neither very famous for being dynamically typed.but it was a microservice architecture built primarily on rpcs and not very much on message buses. and rpcs that basically are statically typed with code generation for client libs and code generation for serverside stubbing as it were. the opensource equivalent is grpc.where going microservice is a potential saving is when different parts of your system have different scaling characteristics. maybe your login system ends up scaling as olog n but one datamunging part of the system scales as on log n and another as just on. and one annoying but important part scales as on 2. with a monolith you get lbs in place and you have to scale you monolith out as the part that has the worst scaling characteristic.but in an ideal microservice world where you have an rpcbased mechanism taht can be loadbalanced rather than a shared message bus that is harder to much harder to scale you simply dial up the scaling factor of each microservice on their own.;0
29589156;HackerNews;2021-12-17;i know thanks.my point is precisely that if you have to handle large quantity of state e.g. travel agency handling diverse item bookings to sell as a complete holiday packages note that this includes having conflicts on inventory like cruise cabin categories or hotel rooms microservices add latency by replacing function calls with rpc and gain you... an unspecified advantage in terms of... deployment? the possibility to have hundreds of developers working on the system in parallel?i have always worked on mediumsize monoliths during most of my career and iah if we had 137 developers all working on this everything would be magically solved but alas we have a monolithi was a sentence i uttered or heard exactly 0 times so far.;0
29588939;HackerNews;2021-12-17;ive heard before that microservices deployment scheme solves one particular task if you get traction youll be ready for scaling. if you cant do that you are already dead cause being unable to get 10x more users with a click when they come means your competition will do that instead. is that still true?;0
29588921;HackerNews;2021-12-17;i like monoliths... which are modular inside... no need for microservices easy deployment even without docker and kubernetes... just a single binary...;0
29588812;HackerNews;2021-12-17;its really not odd at all...this is how compilers work...we have been doing it forever.microservices were a half baked solution to a nonproblem partly driven by corporate stupidity and charlotan 'security' experts i'm sure big companies make it work at enough scale but everything in a microservice architecture was achievable with configuration and hotpatching. incidentally you don't get rid of either with a mcs architecture you just have more of it with more moving parts...absolute sphegetti mess nightmare.;0
29587824;HackerNews;2021-12-17;i mean this is kind of how microservices should be done. start with a mvp monolith then carve off microservices if needed performance or large team size.the problem is when the lead dev has been huffing the architecture paint too hard and starts prematurely spinning up microservices because it feels good.;0
29587781;HackerNews;2021-12-17;i it's a pretty obvious conclusion to anyone who has worked in both environments or have had to migrate from one to the other so it's not particularly insightful.iit should be obvious but apparently it's not. so many architecture astronauts drinking the koolaid and making a mess. premature microservices can easily kill a product.;0
29587721;HackerNews;2021-12-17;that can definitely happen and be painful. i now work at a very large organization though and the benefits of microservice design are obvious as were the pains of monolithic ones when i was working on an old legacy monolith in the same place.;0
29587713;HackerNews;2021-12-17;my understanding from the html template days is that a monolith contained both the business and presentation layer together. i made plenty of those with struts 1.x and spring mvc. micro services were pitch as a means to separate the front end and back end.i'm a bit confused on microservices vs monolith in the modern spa context. if i have an application that's front end is react and back end is go and the two communicate over resthttprpc do i have microservices or a monolith?;0
29587591;HackerNews;2021-12-17;i doubt you can judge the blast radius.say your little service just changed how it parsed backticks. now that innocuous change may affect none of the immediately connected microservices but another services three hops away relied on the old behavior of your parser through some complex business rules driven logic. now go test and later troubleshoot that vs standing up a single monolithic jar on your laptop and seeing the exception stack trace tell you exactly what you broke.;0
29586877;HackerNews;2021-12-17;oftentimes however with microservices it's the tail wagging the dog. microservices architectures become such a burden that they strain the capacity of the existing team which leads to more hiring which thanks to conway's law leads to more microservices being built which leads to more operational and architectural overhead which leads to more hiring...;0
29586831;HackerNews;2021-12-17;the individual code bases of a microservice might not involve spaghetti code but the interconnections certain can. i'm looking at a diagram of the service i work on with seven components written in three languages five databases 25 internal connections two external interfaces and three connections to outside databases all crosswired via 6 connections with a similar setup geographically elsewhere in case we need to cut over. and that's the isimplifiedi diagram not showing the number of individual instances of each component running.there is clear separation of concerns among all the components but it's the interconnections between them that take a while to pick up on.;0
29586815;HackerNews;2021-12-17;of course this advice doesn't ialwaysi make sense but it makes sense more often than people want to admit. not that this is an original claim if anybody remembers the majestic monolith.simply put the microservice path makes a lot more sense when your organization is so big that you don't really know what other teams are doing all the time and need a clear delineation of areas of responsibility or maybe if you have very large volumes you're dealing with. that doesn't describe most orgs but if it describes you consider microservices.;0
29586706;HackerNews;2021-12-17;my impression which seems to be supported by this article? is that when you're small you can actually get up amp running with an mvp with a nonserverless monolithic approach iandi scale for a bit before you hit a wall. and ionlyi at that point 1 scaling becomes much more complex and 2 monolithic infrastructure prevents you from easily implementing bestofbreed solutions within segments of your functionality to optimize various functionality. and from a cloud services pov it's cheaper and perhaps require less dev time though i'm guessing that will depend on the projectthis seems reasonable? at least at the early amp earlymid stages. if you make it that far and see things like scaling issue in your future it seems like you should also be at a stage of growth where you'll be getting reasonable funding offers and can invest the resources into migrating away from monolithic.disclaimer my opinion here is formed mostly from following a notcompletelydissimilar process even when working with things more on a monolithic side of things i'll use a highpowered workstation to spin up a vm's on the same host and then if i need to i can migrate individual vm's to their own betterresourced instances on other hardware to scale things. i did this some years ago with a hadoop cluster and the process worked out nicely.although as it turned out that example didn't last long hadoop was overkill because i overestimated the bigness of my data which turned out to only be on the bigger side of small. or smaller side of medium. when i had a rethink on it i wrote some python code against a the primary sqlbased data source amp used keras to do what i needed instead iterating each pieceon a nicelyspec'ed workstation took an hour or so and a full endtoend run maybe 34 hours.but this is kind of my point starting out it's easy to thing oh i need to plan for ever possible eventuality amp level of scale. no you don't.and a final caveat to this ymmv since circumstances differ from project to project. but these are things to consider before you automatically go for slicing each piece of functionality into grains of sand with their own microservice.;0
29586541;HackerNews;2021-12-17;i've wondered if it's not a ploy by cloud vendors and the ecosystem around them to increase peoples' cloud bills. not only do you end up using many times more cpu but you end up transferring a lot of data between availability zones and many clouds bill for that.disagree. i'd argue that microservices are inherently more cost effective to scale. by breaking up your services you can deploy them in arbitrary ways essentially bin packing n microservices onto k instances.when your data volume is light you reduce k and repack your n services.because your services are broken apart they're easier to move around and you have more fine grained scaling. further increasing lockin to the managed cloud paradigm if not to individual clouds.also disagree. we use nomad and it's not hard to imagine how we would move to another cloud.;0
29586327;HackerNews;2021-12-17;i've been a professional programmer since the late 1990s. what i observe is that many people flocked to microservices because they had only known monoliths and they were sick of the limitations inherent to them. now we have a generation of engineers who have only known or been taught microservices and a backlash has developed because they are sick of the limitations inherent to them.this is my reading of the antioop antiinheritance movement as well. to spice up bjarne stroustrup inventor of c there are only two kinds of programming languages those that don't make it and those that people bitch about.;0
29586287;HackerNews;2021-12-17;absolutely agree. the point of microservices is to separate the concerns from an organizational point of view not for technical reasons.most of the advantages attributed to microservices can also be achieved with a monolith architecture using a sane and rigorous design.i find it frustrating at work when i see teams of 50 people having issues coordinating work because they have a monolith while we often unnecessarily spread a team of 5 people among 10 microservices.;0
29585594;HackerNews;2021-12-17;one problem i've never seen mentioned regarding microservices is what happens when the organization that produced them has moved from growing to stagnating and finally into decline. if microservices ship the orgchart what happens when that organization fails to attract engineers?i worked for a company that microserviced themselves into a pit. we had a huge layoff which completely killed the morale of the remaining engineering staff. over the next 3 years more and more engineers left and the company refused to replace them. what started out as teams 5 people responsible for 3 microservices ended up as teams of 3 people responsible for 6 microservices.it was kind of cool to be responsible for more architecture and see how it all fit together but the sad reality was that too many of the microservices that had been stood up were stitching together disparate data from other microservices to then perform what a single sql query against a rdbms was doing.;0
29585586;HackerNews;2021-12-17;independent teams each developing independent services and acting without topdown approval is a different way to coordinate development that values productivity keeping everyone unblocked and innovation finding better ways of doing things.i've had the opposite experience. in the monolith anyone can make the necessary changes because it's all one codebase that everyone is familiar with. at most you might need some helppairingapprovals from experts in particular areas but in general any team can work independently.by comparison in the microservices world many teams either don't want you to touch their service or are using a tech stack so unfamiliar to you that it would take too long to be productive. and there's a rat's nest of interdependent microservices so you end up begging other teams to adjust their roadmap to fit you in. independent teams can pursue very different patterns without needing to agree with each other.i see this as more downside than benefit. if everyone is using different tech stacks it's harder for people to move between and contribute to different teams. and you end up with situations where one team uses java while another uses scala which brings in extra complexity to satisfy what are essentially aesthetic preferences.;0
29585291;HackerNews;2021-12-17;i disagree microservices are an architectural concept related to the software not to the infrastructure.whether you are using containers or vps or serverless or bare metal for your infrastructure that's completely unrelated to the concept of microservices you can deploy either a monolith or microservices in any of the above.as an example you can deploy a monolith on lambda1 or you can deploy microservices on bare metal using one of the several self managed serverless engines available2.1 see e.g. or 2 see e.g. and;0
29585064;HackerNews;2021-12-16;agree. imo modularitycoupling is the main issue. my issue w the microservice architecture is that it solves the modularity problem almost as a side effect of itself but introduces a whole host of new ones that people do not anticipate.yes if you at the outset say we will separate things into separate services you will get separated services. however you do not need to take on the extra complexity that comes with communication between services remote dependency management and additional infrastructure to reduce coupling.;0
29585058;HackerNews;2021-12-16;microservice is inconsistently defined. one cannot accuse them of using a strawman definition if there is no realman.;0
29585054;HackerNews;2021-12-16;managing complexity is hard no matter the approach to it. microservices define boundaries around component inputs and output and try to reduce complexity by black boxing functionality. monoliths try to reduce complexity by managing code languages libraries databases etc. i'm not sure there really is a good answer between the two because over time1. vendor and open source blackboxes get introduced to monoliths and you end up with a monolith built around a bunch of microservices.2. common tooling has a huge benefit and copypasta code gets the job done faster than everything being custom every time. so you end up with microservices that every task ends up importing some giant framework and uses common libraries so the monolith gets imported to the microservice.software gets complex faster than we all like to believe... it seems like software has gravity attracts complexity and ends up being a big ball of mud in the end almost every time.;0
29584932;HackerNews;2021-12-16;i've wondered if it's not a ploy by cloud vendors and the ecosystem around them to increase peoples' cloud bills. not only do you end up using many times more cpu but you end up transferring a lot of data between availability zones and many clouds bill for that.a microservice architecture also tends to lock you into irequiringi things like kubernetes further increasing lockin to the managed cloud paradigm if not to individual clouds.;0
29584905;HackerNews;2021-12-16;my theory is that microservices became vogue along with dynamically typed languages. lack of static types means that code becomes unmanageable at a much lower level of complexity. so the complexity was moved to the network which looks like a clear win if you never look outside a single component.;0
29584898;HackerNews;2021-12-16;i'd like to challenge one part of your comment that microservices break up data on module boundaries. yes they encapsulate the data. however the issue that causes spaghettification whether internal to some mega monolith across modules or between microservices is the semantic coupling related to needing to understand data imodelsi. dependency hell arises when we need to share an agreed understanding about something across boundaries. when that agreed understanding has to change microservices won't necessarily make your life easier.this is not a screed against microservices. just calling out that within a domain of understanding semantic coupling is pretty a fact of life.;0
29584806;HackerNews;2021-12-16;yeah i don't think there's really a best approach here. i know where i work right now we have this giant java app that is just a nightmare to even get running. i've been working on the microservices and they do have all the downsides you're talking about but i can get that stack up and flying super fast whereas this giant java app takes 3 minutes to even be barely functional and has so many configuration options that out of this 1000 line config file it's hard to find the 3 things you might actually care about.;0
29584587;HackerNews;2021-12-16;the idea of microservices sometimes reminds me of visual programming looking at infrastructure diagrams. like instead of writing the code and executing it. you implement variables databases conditions lambda loops pubsubsqs etc as separate entities and then put them together.;0
29584157;HackerNews;2021-12-16;you're talking about something very odd here... a monorepo with a monolithic build output but that... transforms into any of a number of different services at runtime based on configuration?is this meant to be isimpleri than straight separate codebase microservices?;0
29583989;HackerNews;2021-12-16;i think this leads to silos. microservices written in different lang's mean java dev x can't maintain python service y.. not in an efficient way. what's worse java dev can't move to team y without upskilling not only on the service but also the lang so they get pidgin holed. she also can't move because she's the only java dev left.;0
29583929;HackerNews;2021-12-16;here's my take on microservices it's a form of modularization. like all modularization it can be useful to uncouple larger parts of a system to enforce an architecture avoid unintended crossdependencies make explicit the dependencies that are intended to allow teams to work more independently and to allow the different parts of the system to be be developed compiled built deployed and sometimes scaled independently.but all this comes at a cost you have to know where the module boundaries are because moving these is much harder. the flexibility that you've gained within each module comes at the cost of making it harder to move the border between modules. it's very easy to put down a module border in the right spot and you make a refactor needed for cleanup or performance improvement go from tricky to impossible. e.g. that piece of info needed in this module now canonically lives in the other one. or we accidentally add a couple n's to the time complexity of an algorithm that works on data in multiple modules.but getting the borders right on the first try is hard unlikely even. where those borders should be depends on a lot of things the user domain the performance characteristics the development teams conway's law and all that and the ways in which the business requirements change. for that reason i think most successful modularizations are either done by breaking down an existing monolith providing these insights or by basing it on a known running system that is close enough in its needs and environment.;0
29583902;HackerNews;2021-12-16;i have worked in companies which had monolith software but they have been large and established businesses.i will not name names but i can say this...all but one had constant repetitive and quite painful failures not fixable it seemed. one company was an exemption with some failures but a clear culture of pushing issues while implementing new features.and one company i have been with from startup days till 150 employees had a microservice infrastructure i have never seen so little downtime such a smooth back office front end database reporting system. the cto was owner and main developer if something went awry he would start working on the fix within minutes no matter the day or time. the fastest issue response time ever. 2 lifetime downtimes of a handful minutes for the full service and a couple components which didn't work for maybe an hour or sometimes overnight. i have to say though when one microservice broke it took down more tangential services than one would think but other than that hands down the best software i ever worked with.;0
29583826;HackerNews;2021-12-16;microservices doesn't necessarily mean k8s running on selfmanaged compute instances as in the example given in the article.the main mistake of the article is that the premise is microservices but then the examples are about infrastructure k8s etc but the 2 things are not tied you can have that same architecture cited in the article running monolith instances for example and it would be every bit as complex as managing the micorservices example without any of the advantages.fully managed serverless solutions like lambdacloudflare workersetc managed through sam or serverless framework solves most of the problems cited in the article.the whole infra in our case is api gateway lambda dynamodb this infra is not more complex to manage than our old monolith which was on alb ec2 rds.deployment is one sam deploy away done in github actions this is actually even simpler than our previous monolith.;0
29583628;HackerNews;2021-12-16;how many more articles do we need to drive this point home? first it was a fashion to develop using microservices. now writing about not using them is in vogue .;0
29583430;HackerNews;2021-12-16;another point of confusion among many folks is monorepos. some consider monorepos monoliths which is more like comparing apples to oranges imo.monorepos provide some of the benefits of monoliths in terms of 1 making it easier to refactor your entire codebase at once 2 sharing some common dependencies like framework versions etc. which makes it much easier to keep those up to date and more secure as a result 3 sharing some common utilities like unit testing harnesses etc. 4 other thingsat the same time monorepos don't force one into a monolith architecture at all an in fact can provide most of the same benefits of microservices in terms of separate deployments etc.the most important lesson in my mind is there's no panacea or perfect structure as a prescribed way to do things. every system has its own demands which also change over time and the only should is to tailor things on a casebycase basis adjusting to a better structure when needed.;0
29583156;HackerNews;2021-12-16;modular design is decades old though. rails devs argue about it because it's against the rails way and that makes things harder for them. but i've been modularizing my java webapps since i graduated from college 18 years ago.but also microservices weren't pioneered by rails devs. they were pioneered by huge companies and they definitely have a role to play there as you point out.;0
29582529;HackerNews;2021-12-16;not it's adding a single microservice to a monolith.;0
29582493;HackerNews;2021-12-16;ok maybe a better way to say it is that having teams independently develop services is a good way to reduce the coordination tax iif you have high coordination costs.i if your environment doesn't have that problem i guess this doesn't apply.coordination between engineers was a frequent activity everywhere i've been regardless of how well built the systems were. for example a new requirement for the customers signing up in a given country to have features x y and z enabled. in a large organization there are probably a few teams that will be involved that make that happen. the question is how to coordinate them.many companies try to solve it with topdown decision making prioritizing certainty but hampering productivity some teams have to wait and strictly limiting risky innovation nothing can be done without approval.independent teams each developing independent services and acting without topdown approval is a different way to coordinate development that values productivity keeping everyone unblocked and innovation finding better ways of doing things. you have to invest a bit in tooling and recommended patterns to keep things from going crazy but you kind of need to do that either way.aha here's a difference. if we're talking about the same things icommoni tools and patterns don't need to be enforced. independent teams can pursue very different patterns without needing to agree with each other. this is a big advantage if you don't like being told what to do by people who are pretty remote to the problem you're solving. different people react differently to that. netflix teams tended to be staffed with very experienced and skilled people no junior or mid level positions so there wasn't much value in one engineer dictating architecture patterns or tooling to another. nearly all tooling was optin and the good tools were the de facto standards. but if you came up with a better tool or pattern you had the freedom to try it out. this is how independence fostered innovation and why microservices were useful in such an environment.;0
29582367;HackerNews;2021-12-16;you would only deploy 10 microservices if all 10 changed at once. why are all 10 changing at once? especially if you find yourself in the model where your microservices share codegood architecture decisions trump the monolith vs microservices argument. i'm not saying crossservice shared code is inherently bad but it does have a bad smell.;0
29582292;HackerNews;2021-12-16;maybe because breaking up a monolith has proved to be as hard as combining microservices once you get past the obvious and trivial steps.;0
29582286;HackerNews;2021-12-16;if youre going with a microservice a kubernetes cluster a load balancer multiple compute instances for running the app and hosting the k8s clustertry running a hightraffic highfunctionality website without something equivalent to this. what's this magical single computer you'll be running it all on? you'll need a cluster of servers on a rack somewhere managed the old fashioned way. you'll need equivalent tools to deploy to them and monitor them.i think what this article should be getting at is that lowtraffic sites shouldn't start with microservices and maybe that's true. but if you're trying to build a business that scales rapidly you want to be ready to scale your website from day one.;0
29582256;HackerNews;2021-12-16;there is a lot of talk about monoliths vs microservices lately.actually it's been going on for years and it's always the same argument. people think they're thought leaders for saying start with monoliths and only move to microservices if you absolutely need to!it's a pretty obvious conclusion to anyone who has worked in both environments or have had to migrate from one to the other so it's not particularly insightful. and yet here were are 5 years later saying the same thing over and over again.;0
29581948;HackerNews;2021-12-16;this article sounds like someone who's never successfully implemented either solution. things that are wrong so farmonolithic apps need monitoring e.g. prometheus just as much as microservices.monolithic apps can have scaling issues if you only have one database instance especially if you're writeheavy so you may need to shard anyway.monolithic apps will probably want a messaging system or queue to handle asynchronous tasks e.g. sending email exporting data.microservices do not require kubernetes. you can run them fine on other systems at my last job we just ran uwsgi processes on bare metal.microservices do not require a realtime messaging system. you can just use api calls over http or grpc or whatever else. you'll probably want some kind of message queue as above but not as an integral part of your architecture meaning it can just be redis instead of kafka.microservices do not require separate db instances. if your microservices are all using separate schemas which they should you can migrate a service's schema to a new db primaryreplica set whenever you want. in fact if you have one e.g. mysql primary you can have multiple secondaries each only replicating one schema to handle read load from individual services e.g. a primary write node and then separate read nodes for user data product information and everything else. when it's time to break out the user data into a separate database just make the read replica the new primary for that db and add a new read replica off that.this dude just straight up doesn't know what he's talking about and it sounds like his experience with microservices is following a bad 'microservices with golang kafka cassandra prometheus and grafana on k8s' tutorial.here's how you write baby's first microservices architecture in whatever language you use1. decide where the boundaries are in your given application e.g. user data product data frontend rendering payment systems2. write those services separately with httpgrpcwhatever apis as your interface.3. for each api also write a lightweight native interface library e.g. userinterface productinterface paymentinterface. your services use this to call each other and the method by which they communicate is an implementation detail left up to the interface library itself.4. each service gets its own database schema e.g. user product payment which all live on the same mysql or rds or whatever instance and read replica.5. everything has either its own port or its own hostname so that your nginx instances can route requests correctly.there now you have a working system which behaves like a monolith working via what seems like internal apis but is actually a microservice architecture whose individual components can be scaled refactored or rewritten without any changes to the rest of the system. when you swap out your django protobufoverhttp payment processing backend for a rust process taking grpc calls over redis queues you change your interface file accordingly and literally no one else has to know.it also means that your deployment times are faster your unit testing is faster your cicd is faster and your application startup time is faster when you do have to do a service restart.i'm not sure why this is so hard for people to understand.;0
29581868;HackerNews;2021-12-16;its really nice to be able to add a column and deploy in minutes without having to rebuild and deploy a giant monoliththis is orthogonal to monolith vs microservices. i've worked on monoliths that could easily be and were deployed very frequently.;0
29581844;HackerNews;2021-12-16;refactor to separate microservices when either 1 the team is growing and needs to split into multiple teamsi've heard this before and i just don't get it. i've worked on multiple monoliths where hundreds of engineers contribute and it's fine. you have to invest a bit in tooling and recommended patterns to keep things from going crazy but you kind of need to do that either way. at 3550 people a common limiting factor is coordination between engineersso don't coordinate? if engineers working on different aspects of the codebase need to coordinate that feels like something is wrong architecturally.;0
29581680;HackerNews;2021-12-16;you bring up an excellent point. as of now it is impossible for me to run my company's backend ecosystem on my machine locally. what we do could easily be done by one simple monolith but our eng. lead is obsessed with overengineered microservice architecture so nobody can actually develop locally. everything on the backend is done by a bunch of lambdas behind an api gateway.i got so burnt out developing in that environment that i asked to become a pure frontend dev so that i wouldn't have to deal with it anymore.;0
29581373;HackerNews;2021-12-16;this is exactly how i feel. great to hear it from someone with netflix experience. so so many organizations jump headfirst into microservices before they even realize what that entails just because they heard it's the trendy new thing netflix is doing.if you make your code and architecture simple from the getgo then you can refactor to microservices when you know you really need it.;0
29581189;HackerNews;2021-12-16;i explicitly claim to use a citadel archicture 0 when talking about breaking off services for very similar reasons. having a single microservice split out from a monolith is a totally valid application of microservices but i've had better results in conversation when i market it properly.i've found this to go so far as to have monolith understood to mean single instance of a system with state held in memory.0;0
29581131;HackerNews;2021-12-16;to be fair modular monoliths weren't talked about much before microservices. i'm thinking about the heyday of rails where there were bitter debates over whether you should even move critical business logic out of rails. i got the impression that most devs didn't even care. that was sort of the point where i saw that i was a bit of an odd duck as far as developers go if i cared about this stuff and pivoted my career. i really enjoy contexts where i can make modular monoliths however. i'm thinking of mobiledesktop apps here mostly.software design is something of a lost art currently. this is partially due to the current zeitgeist believing that anything that automated tools cannot createenforce can't be that important in the first place. of course there's a whole swath of concerns that cannot be addressed with static or dynamic analysis or even different languages.microservices is a response to the fact that a monolith without any real design moves quickly but can easily converge on spaghetti due to the fact that everything is within reach. it enables teams to create an island of code that talks to other islands only via narrowly defined channels. additionally they support larger dev teams naturally due to their isolationist take and reinforce the belief that more developers always better in the process. in other words they mesh perfectly with the business context that a lot of software is being built in.factor in the fact that coolcompany uses them and you have a winner.;0
29581104;HackerNews;2021-12-16;it's usually not obvious where to put the seams ahead of time so you can cut them when you need to split into microservices.plus keeping the api boundaries clean costs time and resources and it's tempting to violate them just to launch this one feature. this extra discipline doesn't have any payoff in the short term and it has unknown payoff in the long term because you're not sure you drew the boundaries ahead of time anyway.so i think in practice what happens is you create a monolith and just eat the cost of untangling it when the team gets too big or whatever.;0
29581003;HackerNews;2021-12-16;but i've worked on teams that advocated for microservices needlessly and it was 100 cargo cult behavior netflix does it so we should too.i've seen this too and in fact i got laid off because i pushed back against this silliness for what should have been a simple lift and shift.;0
29580929;HackerNews;2021-12-16;it's a big tradeoff for maintenance complexity and cognitive load though and people often don't realize how big that tradeoff is. chasing bugs and maintaining the spiderweb of network connections between all your services can quickly become a nightmare. a distributed ball of mud instead of a monolithic ball of mud but a ball of mud nonetheless.personally i lean towards building a monolith first then breaking out features into separate services if you need it. but i've worked on teams that advocated for microservices needlessly and it was 100 cargo cult behavior netflix does it so we should too.another anecdote my current company a startup could've launched its product a year earlier than it did but our engineering lead insisted on preengineering a rube goldberg machine of a microservices backend before we even had any prospective customers. took months of engineering time and headaches to grok all of it when in reality one monolith and a basic database could've done the job for years before we'd ever have to scale past that.but microservices architecture looks great on a resume so shrug;0
29580906;HackerNews;2021-12-16;the interesting thing about microservices is not that it lets you split up your code on module boundaries. obviously you can and should! do that inside any codebase.the thing about microservices is that it breaks up your idatai and ideploymenti on module boundaries.monoliths are monoliths not because they lack separation of concerns in code something which lacks that is not a monolith it is whats called a big ball of mudmonoliths are monoliths because they have one set of shared dependencies one shared database one shared build pipeline one shared deployment process one shared test suite one shared entrypointas organizations and applications get larger these start to become liabilities.microservices are part of one solution to that not a whole solution not the only one.;0
29580870;HackerNews;2021-12-16;these days devops is used as a bludgeon to fire sysadmins and make devs pretend to manage infrastructure. the idea from the corporate viewpoint is to save money by not having anyone to handle systems stuff just shove into the cloudtm as serverless microservices then just restart it when it falls over instead of troubleshooting.yes i'm cynical. having to use javalike stuff to do what should be a simple shell script will do that to you.;0
29580841;HackerNews;2021-12-16;it seems to me that the ratio of hateformicroservicescompaniesactuallyusingmicroservices is way out of wack. i know that there are some highprofile cases like uber but in nearly every conversation i see online or in person we're all in agreement that going all in on microservices is hypedriven nonsense. maybe i'm wrong though.;0
29580753;HackerNews;2021-12-16;imo the big advantage of microservices over monoliths if they're done right is reducing iteration times. it's just a lot quicker to buildrunetc. i think monoliths are a fine starting point but once your iteration times get slow that's when it's time to break it up.;0
29580682;HackerNews;2021-12-16;someone please write an article don't start with architecture some dude suggested because of their ego. there are cases when monolith is bad and when microservice is the must. take the healthy approach.the article is garbage with no real understanding how real microservices worksthe deployment modern microservices are working using templates. you deploy it using that directly from you gitlabgithub. you copy paste your artifact and it's there. the builds are taking 2 minutes to build sometimes less means you can quickly react on some issue as opposed to 30 minutes old school java monolith. deployments are build in the same cluster you use for everything else. ci job runner is just another application in your cluster. so if your cluster is down everything is down.the culture partwe use templates where you have all the libraries tracing in place. in fact when this request is coming we have some similar functionality written so we reply to product oh this feature is very similar to feature x we'll copy it while we discuss some schedule thing our developer renamed similar project did commit and it's already deployed automatically to the dev cluster the rest of the team joined to development. there is a bad pattern when you need to update your templates. this is tradeoff of approach you don't libraries as a concept. hence that you can have half services migrated half services don't that's a bonus. the cons is that you need scripts to push everything immediately.better fault isolationyes you might have settings down and core functionality working means you have less sla breaking events. saves you money and customers. same thing with error handling. if it's just tooling you copy paste a different set of tooling. if the error logging is not implemented in a proper way in the code... it's no different from monolith it's just errors in code. but things like tracing are already part of the template so for basic evens handlers are traced from deploy 1.;0
29580638;HackerNews;2021-12-16;well there are distributed transaction systems you could use but usually it's a good idea to ensure things happen inside one transaction in one microservice also leads to better code in general imo keep your transaction scope as small as possible;0
29580484;HackerNews;2021-12-16;well it quickly can become a mess because of people having different ideas about what microservice is and also decrying things as for microservices only when for example i just want to offload auth and monitoring to a specialized service.it's also a common trope when i'm dealing with k8s decriers yes you might have one application that you can easily deploy but suddenly there are 15 other mediumweight applications that solve different important problems and you want them all p.s. recently a common thing in my own architectures is separate keycloak deployment that all services either know how to use or have it handled at separate request router service mesh or ingress or loadbalancer;0
29580465;HackerNews;2021-12-16;the problem with monoliths is that they're written fast and chock full of business logic that isn't reusable anywhere else. with microservices if done correctly a la hasura your business logic is abstracted to config or to the highest level of abstraction your business allows.;0
29580380;HackerNews;2021-12-16;we've been following this modular monolith approach as well for 3 years now bounded contexts and all but our architectural end goal is still mostly microservices. maybe it's specific to php and the frameworks we use what the modulith is written in but the startup time of the monolith is just unacceptable for our processing rates for every request the framework has to be reinitialized again with all the 9000 services via di and what not. microservices tend to be much more lightweight you don't even need di frameworks and monolith also encourages synchronous calls calling a bounded context's api in memory is so simple which has been detrimental to our performance and stability because microservices at least in our architecture encourage eventbased communication which is more scalable and allows clean retries on failure etc. but again your mileage may vary maybe it's specific to our tools.;0
29580260;HackerNews;2021-12-16;former netflix engineer and manager here. my advicestart a greenfield project using what you know unless your main goal is learning keeping things as simple as possible.microservices is more often an organization hack than a scaling hack.refactor to separate microservices when either 1 the team is growing and needs to split into multiple teams or 2 high traffic forces you to scale horizontally.1 is more likely to happen first. at 3550 people a common limiting factor is coordination between engineers. a set of teams with each team developing 1 or more services is a great way to keep all teams unblocked because each team can deploy separately. you can also partition the business complexity into those separate teams to further reduce the coordination burden.;0
29580248;HackerNews;2021-12-16;i always think of microservices as a product an organization offers to itself. if you don't have the team including managers and even marketing to run an internal product then you probably shouldn't be doing the microservice thing.;0
29580118;HackerNews;2021-12-16;the point here for me is team dynamics maturity and skill level.if you have a team that can't competently write and maintain a monolith that is modular and builttested via automation then that team has no business trying to build and maintain microservices.;0
29579910;HackerNews;2021-12-16;i tend to build monoliths because i've got a subtwopizza team to work with. if i could throw dozens of people at the problem and moreover needed to invent things to keep that many people busy then i think microservices would be more interesting.;0
29579900;HackerNews;2021-12-16;microservices are just a way to implement a distributed system.the problem seems to be that quite a number of teams don't have any formation about system design monodistributedmixed.most teams go for microservices because of hype and because they see an spagheti monolith and believe the problem is the monolith and not the rotten badly modularized code.;0
29579876;HackerNews;2021-12-16;what i think nobody talks about is 1 the legitimate reason for breaking up services into multiple address spaces and 2 that using different versions of the runtime different build systems and different tools for logging orm etc. in different microservices is slavery not freedom.1 is that some parts of a system have radically different performance requirements than other parts of the system. for instance 98 of a web backend might be perfectly fine written in ruby or php but 2 of it really wants everything in ram with packed data structures and is better off done in java go or rust.2 the run of the mill engineering manager seems to get absolutely ecstatic when they find microservices means they can run jdk 7 in one vm run jdk 8 in another vm run jdk 13 in another vm. even more so when they realize they are 'free' to use a different build system in different areas of the code when they are 'free' to use log4j in one place use slf4j someplace etc use guava 13 here guava 17 there etc.the rank and file person who has to actually do the work is going to be driven batty by all the importantbutnotfashionable things being different each and every time they do some 'simple' task such as compiling the software and deploying it.if you standardize all of the little things across a set of microservices you probably get better development velocity than with a monolith because developers can build e.g. make mvn install smaller services more quickly.if on the other hand the devs need to learn a new way to do everything for each microservice they are going to pay back everything they gained and then some with having to figure out different practices used in different areas.throw docker into the mix where you might need to wrangle 2g of files to deploy 2k worth of changes in development 100 times to fix a ticket you can really wreck your productivity yet people really account for where does the time go when they are building and rebuilding their software over and over and over and over again.;0
29579845;HackerNews;2021-12-16;good points but i want to point out some caveats to a few of them. i overall disagree with your conclusion of once you have business running you need to dismantle it asap. i think it's a casebycase thing and you're ignoring the significant complexity costs of a microservices approach. deployment times will be longernot necessarily. i'd say that when you have multiple changes across boundaries that need to go out together monolith deployments can actually be faster as you only need to do a rolling update of 1 container instead of n. but if by deployment time you mean the time between deploys i agree. but also...so what? as long as your deployment times are good enough it doesn't really need to be faster. requirements for hosts where you deploy it will be biggertrue you will end up with huge instancesnot necessarily. depends on the tech stack framework etc. i've seen .net and even rails monoliths that are huge and only use hundreds of mba gb or two of ram. but i've also seen java monoliths using 12gb to handle small amounts of traffic so ymmv. you'll have to scale more than you really need to because some parts of your monolith are more scalable than anothera problem often easily fixed with throwing a bit of at the problem depending on your scale and perrequest profitability.;0
29579660;HackerNews;2021-12-16;at the same time you have to be at a pretty huge scale before resource overprovisioning really hurts the bottom line. you can buy a lot of compute for the price of a single engineer's salary and it usually takes more than one engineer to support a microservice architecture. most applications hit problems scaling the database vertically long before they exhaust resources at the application level.;0
29579543;HackerNews;2021-12-16;this is a pretty critical point. the drum i tend to beat is that the positive read of microservices is that ithey make your code reflect your org charti.if they don't do this and that usually resolves into developers each owning a bunch of microservices that are related concepts but distinct and are contextswitching all the livelong day you've created the reverse of a big ball of mud you've created a tar pit. companies used to brag to me when they had 250 microservices with 100 developers and i don't think any of those companies are going concerns.;0
29579386;HackerNews;2021-12-16;actually monoliths maybe faster than microservices.consider monolith cpu l1 cache end usermicroservice account servive foo service l1 cache end userie monolith goes directly to cou cachemicroservice goes to network calls which are mich slower than cpu cache.also with microservices you will need distributed application performance metric for call tracing. distributed central logging. container orchestration platform to run all the services.;0
29579313;HackerNews;2021-12-16;microservices mean that different parts of your code are now communicating via e.g. http instead of function calls.it changes the situation regarding deployment but it does not miraculously absolve you from changing code when data formats change. how could it?;0
29579219;HackerNews;2021-12-16;no one had to invent the monolith or define how far it should go it was the default.microservices came about because companies kept falling into the same trap that because the code base was shared and because organizational pressures mean features tech debt always there was always pressure to write spaghetti code rather than to refactor and properly encapsulate. that doesn't mean it couldn't be done it just meant it was always a matter of time before the business needs meant spaghetti.microservices on the other hand promises enforced separation which sounds like a good idea once you've been bitten by the pressures of the former. you can't fall into spaghetti. what it fails to account for of course is the increased operational overhead of deploying all those services and keeping them playing nicely with each other. that's not to say there aren't some actual benefits to them too language agnostic faults can sometimes be isolated but the purported benefits tend to be exaggerated especially compared to a monolith if we just had proper business controls to prevent engineers from feeling like they had to write kluges to deliver features in time.;0
29579078;HackerNews;2021-12-16;why not... branch from whatever branch is in prod implement change on that branch in this case adding a column test deploy to prodi realize the build and deployment process may be more complex than that making it hard... but it doesn't have to be.i agree that a microservice or even another system a collection of services is a good solution if you need to make quick iterative changes and you can't do so with your current system.;0
29579063;HackerNews;2021-12-16;monolith was always supposed to be modular from the startwell that certainly iisi sensible but i wasn't aware that someone had to invent the monolith and define how far it should go.alas my impression is that the term monolith doesn't really refer to a pattern or format someone is deliberately aiming for in most cases but instead refers to one big execution of a lot of code that is doing far more than it should have the responsibility to handle or is reasonable for one repository to manage.i wish these sorts of battles would just go away though because it's not like micro services are actually bad or even monoliths depending on the situation. they're just different sides of the same coin. a monolith results from not a lot of care for the future of the code and how it's going to be scaled or reused and micro services are often written because of too much premature optimization.most things should be a modular monolith. in fact i think most things should start out as modular monoliths inside imonoreposi and then anything that needs to be split out into its own separate library or microservice can be made so later on.;0
29578944;HackerNews;2021-12-16;deploy in minutes without having to rebuild and deploy a giant monoliththat's a tooling issue not a monolith vs microservice issue.tooling can allow the exact same speed of deployment for tiny background processing without the need to completely segment your code base.;0
29578738;HackerNews;2021-12-16;on the tdd argument you should know what a return for a function f should be when given an argument b. ideally you have a set of arguments b to which b belongs and a set of results c to which the return belongs. your tests codifies mapping examples from b to c so that you can discover an f that produces the mapping. take another step and generate random valid inputs and you can have propertybased testing. add a sufficient type system and a lot of your properties can be covered by the type system itself and input generators can be derived from the types automatically. so your tests can be very strong evidence but not proof that your function under test works as expected. there's always a risk that you modeled the input or output incorrectly especially if you are not the intended user of the function. but that's why you need user validation prior to final deployment to production.likewise with a microservice architecture you have requirements that define a set of data c that must be available for an application that provides getpostputdeleteevents in a set b to your service over a transport protocol. you need to provide access to this data via the same transport protocol transform the input protocol to a specified output protocol.you also have operational concerns like logging that takes messages in a set c and stores them. and monitoring and authorization etc. these are present in every requestresponse cycle.so you now split the application into requestresponse services across the routing boundary 1 route 1 backing model. that service can call other apis as needed. and that's it. it's not hard. it's not even modulelevel split depolyment. it's functionlevel deployment in most serverless architectures that is recommended because it offers the most isolation while combining services makes deployment easier that's mostly a case of splitting deployment across several deployment templates that are all alike and can be managed as sets by deployment technologies like cloudformation and terraform 1.you can also think of boundaries like this services in any soa are just like software modules in any program they should obey openclosed and have strong cohesion 2 to belong in a singular deployment service.then you measure and monitor. if two services always scale together and mutually call each other it's likely that they are actually one module and you won't effect cohesion by deploying them as a single service to replace the two existing ones. easing ops overhead.not deploying and running as a monolith doesn't mean not putting the code to be run into the same scmmultiproject build as a monorepo for easy shared crossservice message schema refactoring dependency management and version ingredient. that comes with its own set of problems service projects within the repo that do not change or use new portions of the comm message message schema shouldn't redeploy with new shared artifact dependencies basically everything should still deploy incrementally and independently scaling it is hard see alphabetgoogle's or twitter's monorepo management practices for example but there seems to be an extra scale rank beyond enterprise size that applies to it's very unlikely you are in that category and if you are you'll know it immediately.we like to market microservice architecture as an engineering concern. but it's really about ops costs in the end. lambdas for services that aren't constantly active tend to cost less than containersvpscompute instances.1 2;0
29578697;HackerNews;2021-12-16;many of these points you're mentioning is exactly why k8s was developed. yes it makes deploying simple applications unnecessary hard but it make deploying more complicated applications way more manageable.so in the k8s world auth service meshes network policies ... monitoring tons of tooling there to streamline that deploy this at scale is trickier than you'd think many seem to assume k8s on it's own here is the magic dust they need. but gitops with argocd helm has worked pretty well at scale in my experience. security is a ci problem and you have that with every single language not just go. see log4j.kubernetes is my bread amp butter but i do realise this has way too much overhead for small applications. however once you reach a certain scale it solves many of the really really hard problems by streamlining how you look at applications from an infrastructure and deployment side of things. but yes you need dedicated people who understand k8s and know what the hell they're doing and that's in my experience a challenge on it's own.let's also dispel a myth that k8s is only suitable for microservices. i have clients that are running completely separate monolith applications on k8s but enough of those that managing them 'the old way' became very challenging and moving these to k8s in the end simplified thing. but getting there was a very painful process.;0
29578681;HackerNews;2021-12-16;on the point about technology lock i've thought that the move to microservices would mean allowing different programming languages but whenever i've asked existing companies if they would be open to other languages it's usually a no. part of it seems to be decent enough reasons but i usually think they could be overcome with a reasonable amount of work where the tradeoff may be worth it. i usually suspect it's more social reasons. my company also made the move to microservices and i was able to use another programming language but there was strong social pressure to conform.;0
29578564;HackerNews;2021-12-16;one strong operational reason i have seen recently is resource management.the monolith where most api endpoints are instant and use constant memory but some use much more memory and can be slower... is tough.like if you just give a bunch of memory to each process now you're overprovisioning and if you try to be strict you run into quality of service issues.if you split out homogenous api endpoints into various groups you now have well behaved processes that are each acting similarly. one process could be very small another could be much larger but handle only one kind of request etc...of course the problem with standard microservicey stuff is now you gotta have n different applications be able to speak your stack. the idea of a monolith with feature sets is tempting... but also can negate chunks of microservice advantages.ultimately the microservicey everything is an api can work well even as a monolith and you would then have the flexibility to improve things operationally later.;0
29578533;HackerNews;2021-12-16;first you publish the next version of your service with the new data then ithe disparate teams in charge of 12 clientsi not you update the rest of the application then the old version is retired and every team has coordinated properly. microservices allow lean coordination basically just asking every team when they think they'll be ready without anyone messing with someone else's code.;0
29578524;HackerNews;2021-12-16;if your developers are writing crap code in a monolith they're going to continue writing crap code in microservices but now you have new problems of deployment observability performance debugging etc etc.anecdotally i witnessed this once. there was this huge ball of mud we had that worked okayish. then the architects decided hey microservices could solve this so we started building out microservices that became a distributed ball of mud. every microservice shared and passed a singular data model across 30 microservices which made things interesting when we needed to change that model. also we took mediocre developers and asked them to apply rigor they didn't have in developing these services to that they were prepared for the failures that happen with distributed systems.the big upside to management though was that we could farm out parts of the system to different teams on different sides of the planet and have each of them build out the microservices with each team having different standards as to what is acceptable what response messages look like what coding standards should be ect. all of this was less of a technical problem and more of a managment one but we felt the pain of it as it was made into a technical problem.;0
29578433;HackerNews;2021-12-16;this feels very fudy. it gives a bunch of examples of ways in which microservices can go wrong without empirically examining those claims. it also excludes the middle you can have milliservices really just serviceoriented architecture which do more than route a single endpoint but still give flexibility and scaling.we are a young startup in the mlservice space with about a dozen engineers data scientists. our stack is based on all docker containerized python. we have 6 microservices not sure at which point they become micro but each plays their own role with 430 rest endpoints each. it's been fantastic and none of us are particularly experienced with microservices. we run on aws east but you can spin most of the stack up locally with dockercompose. i don't even need k8s if we wanted we could probably deploy a local cluster with docker swarm. fault isolationi can't talk in depth but we were able to handle the recent east1 outage with only parts of the stack degraded others stayed functional.also rollout is most likely when something will fail. rolling back a services is way easier than disrupting the whole stack. eliminating the technology lockthe ml container is a massive beast with all the usual heavy ml dependencies. none of the other containers need any of that. easier understandingyep definitely true in my experience. the api surface area is much smaller than the code under the hood so it's easier to reason about the data flow inout. faster deploymentwe can easily patch one service and roll it out rolling out hotfixes to prod with no disruption in the time to run through the ci pipeline or roll back a task spec which is nearinstant. scalabilityemphatically so. the difference in scale between our least and most used service is over 100x.we could probably get away with making the userfacing backend a monolith and in fact it's the most monolithic has the most endpoints but for data pipelining micromilliservices has been a dream. i don't even know ihowi it would work as a monolith.as with everything in this field it all depends on usecase and tradeoffs. if your services each handle roughly the same load the independent scaling argument weakens. if your business logic is complex tightly coupled and fits on a single box you'll waste a ton of cycles just communicating.;0
29578424;HackerNews;2021-12-16;your microservices pains are legitimate. that's why we built the control plane platform. our customers deploy microservices in seconds and get unbreakable endpoints even when aws gcp or azure go completely down.they get free logging metrics secrets management load balancing autoscaling mtls between services service discovery tls intelligent dns routing to the nearest healthy cluster and much more.multi region and multi cloud used to be hard. now they are as natural as clicking a button.before you write part two of your article give the platform a try. one you've tried it i'm 100 convinced you'll make a 180. i'm happy to personally demo it for you.;0
29578385;HackerNews;2021-12-16;yeah i think this is right.microservices is an iorganizationali optimization. it can allow one team to manage and deploy their own subsystem with minimal coordination with other teams. this is a useful thing but be aware what it's useful for.if each of your developers manages a microservice that probably reflects that you do no actual teamwork.;0
29578383;HackerNews;2021-12-16;microservices solve pretty much one problem you have a larger organization 10 devs certainly 100 and as a result the coordination overhead between those devs and their respective managers and stakeholders is significantly limiting overall forward progress. this will manifest in various concrete ways such as microservices allow independent component release and deployment cycles and microservices allow fine grain scaling and microservices allow components written in different languages but really it's all conway.;0
29578367;HackerNews;2021-12-16;i agree. started with a simple react for frontend and nestjs for backend. now i am running microservices for distributing thirdparty widgets my search engine and the analytics.works well and it actually simplifies things a lot each service has its repository pipeline and permissions developers don't need to understand the whole application to code.you also don't have to start with kubernetes to make microservices work many tools can act as inbetweens. i am using app engine from gcloud yes it's a lot of abstraction over kubernetes and it is overpriced but i don't care. it works perfectly for these use cases and even if overpriced it stays a low absolute value.the caveat is that you really need to start off with a stateless mindset.;0
29578265;HackerNews;2021-12-16;i've started doing microservices 56 years ago and i don't want to go ever writing monoliths. i don't understand why these articles keep popping up.;0
29578254;HackerNews;2021-12-16;i agree with your position i'm a big fan of the modular monolith approach. i took a look at your post. this is one thing that jumped out to me because the people who design programming languages have decided that implementing logic to deal with distributed systems at the language construct level... isn't worth iti'm not sure if this is just a dead end or something really interesting. the only language i really know that does this is erlang though it's done at the vm library level and not technically at the language level meaning no special syntax for it. what goes into a language is tricky because languages tend to hide many operational characteristics.threads are a good example of that not many languages have a ton of syntax related to threads. often it's just a library. or even if there is syntax it's only related to a subset of threading functionality i.e. java's synchronized.so there might not be much devotion of language to architectural concerns because that is changing so much over time. no one was talking about microservices in the 90s. plus the ideal case is a compiler that's smart enough to abstract that stuff from you.;0
29578220;HackerNews;2021-12-16;if ive got a microservice collecting events off a queue and writing a csv out to s3 on a schedulei call this a worker.;0
29578102;HackerNews;2021-12-16;in my experience with enterprise software one of the things that cause most trouble is premature modularization sibling to the famous premature optimization.just like i can't understand how people can come up with the right tests before the code in tdd i can't understand how people can come up with the right microservices before they start developing the solution.;0
29578047;HackerNews;2021-12-16;yes microservices are a bad idea. but modern oses are built using them. e.g. linux runs as a bunch of services.;0
29577988;HackerNews;2021-12-16;bad idea 10 teams jointly maintaining a monolith.good idea 10 teams each with responsibility for a separate microservice.it always goes back to conways law.;0
29577974;HackerNews;2021-12-16;i agree more or less with 1 and 4 mostly. but for monitoring either you would have to monitor the service calling this microservice or need to have a way to detect error. if it does have memory leaks anyways just basic cpumem usage monitoring on your hostswho keeps on monitoring like this? how frequently would you do it? in a startup there are somewhere in the range of 5 microservice of that scale per programmer and daily monitoring of each service by doing top is not feasible. 3. deployment? if its a go service literally a bash script to scp over the binary and an upstart daemon to monitorrestart the binary.your solution literally is more complex than simple jenkins or ansible script for build then kubectl rollout restart yet is lot more fragile. anyways the point stands that you need to have a way for deployment;0
29577889;HackerNews;2021-12-16;choose your architecture.worked with a huge monoliths business critical predictable usage easy debugging deployment simple onboarding quick even with less documentation.worked with microservices business critical predictable usage less documentation here onboarding took long time spent on how it works hard to debug never needed to scale up. why microservices ? lessons learnt problem is never with the architecture. why you choose one over the other is the question to ask when you start on.;0
29577869;HackerNews;2021-12-16;microservices are supposed to be autonomous. independent services with an own lifecycle. what this article is describing sounds more like what is called a distributed monolith. too many horizontal dependencies will create problems no matter where they are located.i worked on monoliths where the shortest theoretical amount of time from a commit to running in production is several hours. the way you in a controlled way can change small parts of system with microservices is incredibly useful.what i do see though is people making microservices too small. like one table in a monolith database becomes one microservice. microservices is not about having everything loosely coupled. cohesion rules for modules still applies.;0
29577844;HackerNews;2021-12-16;yup. this is why i think that microservices require a stronger operational plattform but then it enables new and more effective ways of developing new tunctionality.our internal software plattform is getting to a point so it can answer most of these things auth via the central oidc providers basic monitoring via annotations of the job's services deployments via the orchestration and some infrastructure around it including optional checks and automated rollbacks and automated vulnerability scanning on buildservers and for the running systems. it wouldn't be 15 lines of go more like 15 lines plus about 100200 lines of terraform andor yaml to get everything configured and a ticket do register the service in the platform. it's pretty nice and our solution consultants like it very much.the thing is this took a team about a year to build and it'll take another half a year to get everything we currently want to do right. and it takes a nontrivial time to maintain and support all of this. this kind of infrastructure only makes business sense because we have enough developers and consultants moving a lot faster with this.back when we were a lot smaller it made a lot more sense to just push a single java monolith on vms with chef or ansible because that was a lot easier and quicker to get working correctly for one thing.;0
29577792;HackerNews;2021-12-16;the cost of starting with microservice is higher than starting witht monothlics.but the cost of splitting a monothlic into a microservice is x10 in some case impossible.;0
29577782;HackerNews;2021-12-16;for the life of me i never understood nor will ever understand why people think making rpcs is easier or leads to better design than making normal function calls split your code into microservices it will make your code modular smaller and easier to understand!.there are legitimate reasons to put a network between one piece of code and another but modularity is not one of them.;0
29577761;HackerNews;2021-12-16;managed microservices monoliths microservices;0
29577753;HackerNews;2021-12-16;if a team is not disciplinedskilled enough to build a well structured monolith the chances they can build and support a microservices solution which is a distributed system with orders of magnitude more failure modes and requires an order of magnitude more tooling and testing is pretty much 0.;0
29577727;HackerNews;2021-12-16;it is not a binary flip between monolith and modular monolith it is on a gradual scale and i saw teams moving toward modularity with a various degree of success. they may not even use the term of distributed monolith to name their approach. sometimes they do it to keep the monolith maintainable sometimes as the first steps towards microservices defining boundaries simplifying dependencies certainly help against the antipattern of distributed monolith.ideally the decision to build modular monolith should be made and implemented from the very start of the project. some frameworks like django help with keeping separation.i found that fitness functions help with policies and contracts. you run then in your cicd and they raise alarm when they detect contract access violation across the boundaries.;0
29577722;HackerNews;2021-12-16;well that's the thing isn't it. as soon as you move away from the atomicity of a relational database you can't guarantee anything. and then we like you do to resort to cleanup jobs everywhere trying to rectify problems.i think that's one of the things people rarely think of when moving to microservices. just how much effort needs to be made to rectify errors.;0
29577707;HackerNews;2021-12-16;splitting code into modules has the same downsides as splitting it into microservices.not to be pedantic but it has isomei of the same downsides. microservices have other major downsides in that they bring in all the fallacies of network computing. even if you manage to stabilize these in the end they just waste so much time in development and debugging.;0
29577706;HackerNews;2021-12-16;over 15 years though...correct. that is why the advice not to start with microservices. perhaps later may make sense but not in the beginning.;0
29577692;HackerNews;2021-12-16;but the problem with this is it's a technical solution to a social problem.if your developers are writing crap code in a monolith they're going to continue writing crap code in microservices but now you have new problems of deployment observability performance debugging etc etc.as an aside i have a sneaking probably ahistorical suspicion microservices hype happened because people realised ruby or similar trendy dynamic languages often ended up being a write only framework and rather than try and recover some codebase sanity people would rather abandon the code entirely and chase the new codebase high.;0
29577683;HackerNews;2021-12-16;a microservice runs as some somewhat privileged user you may want some auth.auth can be a very broad term in the case of services especially in the cloud. iam could only allow access from certain other machines etc...;0
29577670;HackerNews;2021-12-16;did someone say microservices?;0
29577647;HackerNews;2021-12-16;i've argued for a long time that microservices should grow out of a monolith like an amoeba. the monolith grows until there is a clear section that can be carved off. often the first section is securityauth but from there it's going to be application specific. a modulith could be just another step in the carve up process.but there is no right answer here. application domain team size team experience etc... all matter and mean a solution for one team may not work for another and vice versa.;0
29577644;HackerNews;2021-12-16;splitting code into modules has the same downsides as splitting it into microservices. you can still end up making the wrong splits and needing to back track on things you once thought were modular but no longer are.the logistics of microservices are rarely the hard part. it's the long term maintenance. everyone who's ever maintained a core library knows the same pain at some point you just end up making sacrifices just to get things to work.;0
29577584;HackerNews;2021-12-16;ime it's the drive for microservices that encourage the modular monolith. that is to say the monolith is typically loosely modular but still with many rulebreakages until the push for microservices starts then the big refactor to modularity begins.;0
29577556;HackerNews;2021-12-16;exactly it doesn't have to be one or the other. so far i've been using a monolith for core functionality and microservices for independent processing tasks.that way i can attach as much functionality as i want without bloating the main app and processing scales with demand.;0
29577535;HackerNews;2021-12-16;while it is easy to start with monolith it's not easy to just go from monolith to microservices in case it is determined that's the best path forward. often organizations don't have the luxury to learn by doing a monolith first and then determining the boundaries. in most cases market pressures limited budgets keep monoliths monoliths. otoh my experience is that it is easier to combine overly granular microservices into just right size microservices on an ongoing basis. and yes infra requirements are bigger for microservices but often it is highly automateable.i think one of the reasons besides all the usual reasons that keeps microservices in vogue is the ability to align with organizational structure and enabling independentish teams.;0
29577505;HackerNews;2021-12-16;well in my eyes equating microservices with kubernetes is a problem in of itself. i actually wrote about docker swarm as a simpler and more usable alternative to it for smallersimpler deployments though some other folks also enjoy hashicorp nomad which is also nice another article on my blog won't link here not to be spammy myself.if you evaluate your circumstances and find that microservices could be good for you then there are certainly options to do them more easily. in my eyes some of the ideas that have popped up like 12 factor apps can be immensely useful for both microservices and even monoliths.so i guess it's all very situational and a lot of the effort is finding out what's suitable for your particular circumstances. for example i made the page over at when the app was released and the page was getting hundreds of thousands of views due to all of the news coverage scaling out to something like 8 instances was a really simple and adequate fix to not break under the load.;0
29577503;HackerNews;2021-12-16;i would say this is another problem. if an external call to a web service is involved then you can never have an atomic call in the first place. one always needs to just have a state machine to navigate these cases.even with a monolith what if you have a poweroff at the wrong moment?what you are describing here is to me pretty much the job description of a backend programmer to me think through and prepare for what happens if power disappears between code line n and code line n1 in all situations.in your specific example one would probably use a reservecapture flow with the payment services provider first get a reservation for the amount then do the external webservice call then finally to a capture call.in our code we pretty much always write i am about to call external webservice to our database in one db transaction as an event then call the external webservice and finally if we get a response write i am done calling external webservice as an event. and then there's a background worker that sits and monitors for cases of abouttocall events without matching completedevents within 5 minutes and does according required actions to clean up.if a monolith solves this problem then i would say the monolith is buggy. a monolith should also be able to always have a sudden poweroff without misbehaving.a poweroff between line n and n1 in a monolith is pretty much the same as a call between two microservices failing at the wrong moment. not a qualitative difference only a quantitive one in that poweroff may be more rare than network errors.where the difference is is in the things that an acid database allows you to commit atomically changes to your internal data either all happening or none happening.;0
29577434;HackerNews;2021-12-16;thank you for sharing and i agree with youin my humble opinion microservices are hot because in theory you can scale a lot with them if you are able to do cloud provisioning. microservices needs devopsorchestration service.a good example of microservices architecture is how k8s is designed i think it is an overkill for most average needs so think twice before entering in microservice trip tunnel.;0
29577430;HackerNews;2021-12-16;don't forget serdes costs for microservices. they kill runtime speeds even with nice toys like flatbuffers.;0
29577424;HackerNews;2021-12-16;yes a view would be exactly how i would address the problem i described in my other answer above what happens if i need to change zip code representation in a data source that is read by multiple microservices?.but this also means that we are now back into yessql territory and specifically that we have to use a rdbms which allows us to create views. goodbye nosql goodbye keyvalus datastore. or maybe you will just create an extra newzipcode and mantain it in parallel with zipcode allowing every other consumer to adapt at their leisure...?.so it is another step back to more traditional ways to design a system... or a recipe for a disaster as soon as you start dealing with significant quantities of state.;0
29577415;HackerNews;2021-12-16;dont end with microservices either. monoliths are your friend.;0
29577404;HackerNews;2021-12-16;i agree.the only addition often it is useful to design with microservices because it means you don't have to create and maintain them yourself. even a database is a microservice. phpmyadmin and similar is a microservice so are other open source projects i like celery sentry mailhog jupyter nextcloud even caddy or nginx. all could be considered microservices. integrating them into your platform often makes a lot of sense.;0
29577383;HackerNews;2021-12-16;caveat i am really not qualified to discuss the nuances because i have never used microservices so the little i know is based on reading a bit on those here and on other online forums.single writer multiple readers yes this is what i would probably use but yet again wasn't the promise of microservices being able to work in total isolation?if i have one table e.g. customer which is written by one specific microservice and read by a dozen or more... what happens when i decide that i have to change the schema because the current representation of zip code is not adequate anymore because i dunno we started dealing with uk customers now?lo and behold i have to change code in 13 microservices the one actually writing to it and the 12 more that only need to get the data to show or print or convert to json or whatever... Â¯ãƒ„Â¯;0
29577366;HackerNews;2021-12-16;it's a lot of code but it's not a lot of logic.the exact reason why i compare microservices to oop;0
29577355;HackerNews;2021-12-16;that's a fallicy. you've optimized for one use case but you've made everything else more complicated as a consequence.deploying a single monolith is faster than deploying 10 microservices especially if you find yourself in the model where your microservices share code you've ended up with a distributed monolith instead of microservices.;0
29577350;HackerNews;2021-12-16;however i still wouldnt recommend microservices to a new team org starting from scratch. imho microservices only make sense when the system grows so vast it cannot be understood in its entirety by a single person.i wouldn't go that far. the problem is prescribing a stock design solution to every problem without even considering the problem domain or what benefits it will bring.there are domains where this style of programming is an absolute benefit even at smaller scales and it's really nothing new either. a lot of the patterns in microservice design rhyme rather well with what erlang has done for decades.;0
29577336;HackerNews;2021-12-16;i wonder why no one ever talks about architectures in the middle between those two modular monoliths.the point in time where you're splitting your codebase up in modules or maybe are a proponent of hexagonal architecture and have designed it that way from the beginning leading to being able to put functionality behind feature flags. that way you can still run it either as a single instance monolith or a set of horizontally scaled instances with a few particular feature flags enabled e.g. multiple web api instances and maybe some others as vertically scaled monoliths e.g. scheduled report instance.i wrote more about that approach on my blog as one of the first articles moduliths because we need to scale but we also cannot afford microservices in my eyes the good part is that you can work with one codebase and do refactoring easily across all of it have better scalability than just a monolith without all of the ops complexity from the outset while also not having to worry as much about shared code or perhaps approach the issue gently by being able to extract code packages at first.the only serious negatives is that this approach is still more limited than microservices for example compilation times in static languages would suffer and depending on how big your project is there will just be a bit of overhead everywhere and not every framework supports that approach easily.;0
29577335;HackerNews;2021-12-16;a microservice runs as some somewhat privileged user you may want some auth. can everyone internally create sales tickets? or can everyone just query them? if a team provides a library to run and you run it you still only run as whatever user you have access to.monitoring it's easier to look at a stack trace including some other team's external library than a http error code 500.deployment is certainly ieasieri when you're just shipping code and a build. you don't have to faff around with the previous instance running maybe having some active connectionstransactionswhatever needing to launch a new one. maybe it's not hard overall but less fun.;0
29577323;HackerNews;2021-12-16;i've felt soa is the easiest to grow because it encourages you to swap out concrete implementations as requirements change. for example iuserservice can start off with a local userservice implementation that makes direct calls to a database. once you signup with an idp this might become userserviceazureadoktaauth0. unlike microservices i keep my compiletime guarantees that iuser continues to have the properties i require without any tooling.given the rhetoric here i worry that i'm the only person who's genuinely swapped out their implementation. the ol' ntier is stupid you're never going to change the database comment couldn't be more wrong.;0
29577303;HackerNews;2021-12-16;going for microservices without a central director role is indeed madness and leads to inefficiency.my employer has a landscape like that hundreds of microservices each managed by a different team some teams manage multiple. however we have an enterprise architecture group whose job it is to keep an overview and make sure every microservice is meaningful and fulfills a clear role for the organization. every project presents their architecture to this group as well as a group of peers and this often results in changes that increase cohesion and avoid redundant work. we had a few semiinterconnected monoliths before and from what im told i joined after the microservice transition the new way is better.however i still wouldnt recommend microservices to a new team org starting from scratch. imho microservices only make sense when the system grows so vast it cannot be understood in its entirety by a single person.;0
29577260;HackerNews;2021-12-16;microservices are such a bad idea for most companies out there. specially for companies doing onprem sw that suddenly want to go to the cloud with microservices without realising that micorservices is the end destination of a long journey involving serious devops and a mentality radically different from onprem.it is just so easy to get it or implement it plainly wrong that it is a disservice to most company to suggest ms without a huge warning sign.but...it the cv zeitgeist as design patterns and solid were a decade ago. these days if you don't do ms and don't deploy to k8s you're not worth your salt as a dev. and if you're a company doing monolith you're not worth the time and money of worthy investors. our field is pop culture. it's all about belonging and plain averse for history. which is why we go in endless cycles of dogmadisillusionment.i'm sorry if i sound cynic but you get some cynicism when you see the same movie about the great silver bullet the 3rd or 4th time around.;0
29577248;HackerNews;2021-12-16;no good reasonhow about deployment speed? if ive got a microservice collecting events off a queue and writing a csv out to s3 on a schedule its really nice to be able to add a column and deploy in minutes without having to rebuild and deploy a giant monolith. it also allows for fine grained permissions that service can only read from that specific queue and write to that specific bucket.people throw around distributed monolith like its a dirty phrase but ive found it actually a very pleasant environment to work in.;0
29577230;HackerNews;2021-12-16;this sounds dreadful. i dont think microservices are with talking about with these basics figured out.;0
29577211;HackerNews;2021-12-16;most people give up and do orchestration instead at some point.fortunately there are not that many things in the world that need to be 100 atomic so you can get away with a lot.for your own microservices you generally have at least the ioptioni of fixing the problem properly even if it's at great expense.but then you hit external systems and the problem resurfaces.you can go crazy thinking about this stuff at a certain point most business logic starts to look like connectors keeping different weird databases in sync often poorly.pure crud api? oh that's a database where client is responsible for orchestration create folder upload document... and isomei operations might be atomic but there are no transactions for you. also the atomicity of any particular operation is not actually iguaranteedi so it could change next week.sending an email or an sms? you're committing to a far away database but actually you never know if the commit was successful or not.payments are a weird one. you can do this perfectly good distributed transaction and then it fails months after it succeeded!travel booking? iruns away screamingi so many databases.etc.;0
29577207;HackerNews;2021-12-16;the need to do a crossservice atomic operation indicates that you chose the wrong service boundaries in your architecture.and since it's microservices it's near impossible to refactor it while it could have been a simple thing to reorganize some code in a monolith where it is also a good idea to make sure that db transactions don't span wildly different parts of the source code but the refactor to make that happen is easier.this is the big downside of microservices not the difficulty of doing atomic operations but the difficulty of changing the architecture once you realize you drew the wrong service boundaries.microservices is great as long as you choose the perfect service boundaries when you start. to me that's like saying you always write bugfree code the first time it's not doable in practice for large complex projects hence i'm not a fan of microservices...;0
29577124;HackerNews;2021-12-16;in some companies teams are not divided in a way that follow technical faultlines but rather after product owners so that the only valid divison lines are exteral facing superficial aspects.e.g. think a car company where you are not organized as engine team and transmission team but rather sedan team and suv team and the engine and transmission just need to happen somehow.the microservices fad and every team own their own services fad combined can really get performance to a halt in such a setting.product owners are suddenly the unwilling and unwitting chief architects.at least with a monolith everything is reasonably standardized and people from different teams can be expected to contribute to larger parts of it..;0
29577096;HackerNews;2021-12-16;except when the team division in the company does not map to any natural service api boundaries yet it is insisted that each team own their services.then microservices increase organizational complexity too.suddenly product owners and middle management are chief architects without even knowing it.;0
29577087;HackerNews;2021-12-16;monorepomonolithmicroservicesetc is just the way you organize your codei don't think this is true.i think at least as far as i've observed microservices in practice means replacing various functions calls with slow and errorprone network requests.this is a big and meaningful difference.;0
29577082;HackerNews;2021-12-16;example of decoupling things in goblins framework nodejsone domain give one packagemodule domains are now dependenciesactors models can act as services one actor in a domain is a service with an api communicating with other trought event loops or tcpip microservice?we can develop and debug the whole system in a monorepo lt the monolith is the repository of code.;0
29577066;HackerNews;2021-12-16;i've seen organizations that have hundreds of developers organized in 510 man teams each managing their microservice. i think it tends to happen when a large organization decides to get down with the kids and start to do microservices.conway's law enters into it in a lot of ways. because of the way the people are organized into tiny isolated teams the code shares that shape too. there is an event horizon one teamservice away beyond which nobody knows what happens or who wrote the code.what you get is that the services actually don't do that much except take a request from one service translate it to an internal format perform some trivial operation then translate it to another external format and pass it on to another service. it's a lot of code but it's not a lot of logic. add to that maintaining the test and prod environments as code and suddenly it looks like this is a lot of work but you've essentially gotten a hundred people to do work that three people could probably accomplish if it wasn't for this pathological misapplication of an architectural pattern.;0
29577057;HackerNews;2021-12-16;the only issue i have with microservices is when you're dealing with atomic things. like in a monolith you'd probably just stick it all in a database transaction. but i can't find any good reads about how to deal with this in a distributed fashion. there's always caveats and ultimately the advice just try not to do it but at some point you will probably have an atomic action and you don't want to break your existing architecture.distributed transactions? two stage commits? just do it and rely on the fact you have 99.9 uptime and it's probably not going to fail?anyone else dealt with this headache?;0
29577033;HackerNews;2021-12-16;no why?the task of the microservice is to convert the pdf to stardust and to return it to its sender. so no auth. furthermore its most likely only reachable through the local network or at least should be if you want some stranger not to be able to also make stardust from pdfs.monitoring are you trying to say that its a lot esaier to pick up one logfile thant lets say 15? because they should be aggregated somewhere anyway no?deployment depending on anything you listed how do i do anything? of course if have to define it but if you want a fancy example k8s argocd canary deployments done. i literally set it up once.security? really? please dont get this wrong but this feels to me like whataboutism but well here i goi implement security just the same way as i would in the monorepo. the thingpersonentity just has to look into more repositories it comes down do one sentence i think state is not shared state is communicated.;0
29577023;HackerNews;2021-12-16;nice parts of microservice decouplingif you require microservices to enforce decoupling you're doing it rong;0
29577019;HackerNews;2021-12-16;when microservices were new they brought a whole slew of new technologies and architecture patterns with them spas jwt authentication micro frameworks restgraphql containerization. things that solved problems people were having with the previous monolithic approach all above the lack of maintainability and composability. so i see the term microservice today not as something that's measured in lines of code but above all by embracing the new technology landscape that came from it.;0
29577013;HackerNews;2021-12-16;microservices is kind of a superpower that allows you to choose where you want your complexity to be. you are supposed to start with something simple so the microservices decision needs to come in later.not starting full in with microservices is a good pattern.;0
29577007;HackerNews;2021-12-16;if theres no organizational barrier e.g. microservices architecture separate repos with strict permissions that will prevent devs from leaking abstractions across technical boundaries those welldefined modules and interfaces will devolve into a big ball of mud.i say this with the assumption that the team is large and members regularly come and go.;0
29577005;HackerNews;2021-12-16;what if the product department doesnt give a damn about the underlying system architecture? i mean shall they?they should not. either it works correctly or it doesn't. even buildings need to be useful even though people might admire the architecture. no nontechnical person will admire your microservice or whatever architecture.;0
29577002;HackerNews;2021-12-16;i find with microservices they are a fake separation of concerns. when i have to work on something and it covers two or three services i'm actually working on a mono app. i've found smaller service classes that do one job meet the same need. one or two public methods perform and valid seem to work perfectly.;0
29576992;HackerNews;2021-12-16;all ideas that are good in principle become absurd the moment they are elevated to a kind of dogma applied to every problem no matter if it makes sense to do so or no.microservices are no exception from that rule and often repeat the same mistake as oop did with its promise of reusable code.does it sometimes make sense to break some larger services up in smaller ones? yes.does it make sense to factor out every minor thing of the implementation into something that can individually be manhandled into a docker container because at some point in the far future someone may save a few minutes of typing by talking to that service? no.why not? because on the 11000 chance that what the service does is actually exactly what that other thing requires it will probably take more time to implement an interface than it would to simply implement a clone of the functionality.;0
29576990;HackerNews;2021-12-16;one or more relational databases depending on whether youre gonna go with single database per service or notthis imho is where serious complications can come in. a single database for all services is a good trade off if you want the nice parts of microservice decoupling but not the headaches of a distributed system. just perhaps dont call it microservices to avoid having to deal with arguments from purists who want to explain why this is not true microservices etc.;0
29576954;HackerNews;2021-12-16;i'd sum up with simplicity is your friend...recently i am getting more and more thoughtful about accidental complexity we add to our solutions in form of dependencies on external libsmodule frameworks such as ioc log services anyone and on the architectural side microservices etc.;0
29576953;HackerNews;2021-12-16;more and more i think of oop and services as the same thing at different scales. objects are services dependency injection is your service discoveryorchestration layer. your monolith is already a microservice architecture.in the end extracting a microservice from a monolith built this way is just a matter of moving the implementation of the object to a separate application and making the object a frontend for talking to that application.the single biggest reason oop gets a bad reputation is because lots of languages insist on treating oop as the beall endall of code structure java and ruby are particularly bad examples and insist on trying to shoehorn this sort of logic into tiny dumb pieces of pure data.;0
29576918;HackerNews;2021-12-16;back when i was studying cs in the early 90s it wasn't obvious at all that i am going to work with a db anytime in my career. i loved the subject i passed with a. but i thought i am not going to see it later because i didn't plan to work for a bank or some large enterprise.then in about two years everything changed. suddenly every new web project and web was also novel included a mysql db. that's when the idea about the three tier architecture was born. and since then a few generations of engineers have been raised that can't think of a computer system without a central db.i'm telling this because in microservices i see the opportunity to rethink that concept. i've built and run some microservices based systems and the biggest benefit wasn't technical but organizational. once the system was split into small services each with its own permanent storage when needed of any kind that freed the teams to develop and publish code on their own. as long as they respected communication interfaces between teams everything worked.of course you have to drop or at least weaken some of acid requirements. sometimes that means modifying a business rule. for example you can rely on eventual consistency instead of hard consistency or replenishing the data from external sources instead of durability.otherwise i agree with the author that if you are starting alone or in a small team it's best to start with a monolith. with time as the team gets bigger and the system becomes more complex your initial monolith will become just another microservice.;0
29576911;HackerNews;2021-12-16;imho microservices done well should actually cut a whole vertical through your applications feature space. so not only should it be responsible completely for its own storage of data but it should be responsible for how that data is shown on the front end or as close to that as you can realistically achieve. a microservice should ideally be ireviewsi or ileft navigationi not icustomer authenticationi or iorder processingi.;0
29576901;HackerNews;2021-12-16;developing a montolith for years but now you have written a 15 line golang http api that converts pdfs to stardust and put it into on a dedicted server in your office? welp thats a microservice.but the 15 lines of golang are not just 15 lines of golang in production. you need auth? who can talk to your service? perhaps ip whitelisting? monitoring? how do you know if you service is up and running? if it's down you need alerts as well. what if there is a memory problem because code is not optimal? how do you deploy the service? plain ansible or perhaps k8s? just scp? depending on your solution how do you implement rollbacks? what about security regarding outdated packages the go app is using? you need to monitor it as well.and so on. the moment you need to store data that somehow needs to be in sycn with the monolith's data everything gets more complicated.production stuff is not just about lines of code.;0
29576885;HackerNews;2021-12-16;well it's all about the data responsibility who is the owner of the data how others can access the data. once you have defined these you see that you can share the access with other microservices for example read only mode on a view as long as the ownership and the access rules are preserved.;0
29576874;HackerNews;2021-12-16;except that you do not need microservices to solve organisational problems. you need as has always been done to have welldefined modules with welldefined interfaces.;0
29576873;HackerNews;2021-12-16;i don't even think the deployment pipelines are the problem. if you have 1000 microservices you have 21000 possible states of your application based on any of those services being up or down reality is much more complex. it is genuinely hard to keep that number of services up and running so you then need to be extraordinarily diligent about how you handle failures.;0
29576871;HackerNews;2021-12-16;clarify the microservice architecture concept with how you are going to deploy your system as per your example is exactly what i'm trying to explain to my teams since the microservice architecture inception. there are too many concepts conflating into the microservice term code architectureseparation of concerns source code organization deployment etc. this is very confusing which is the reason why it's now common to say that microservices are hard.;0
29576857;HackerNews;2021-12-16;maybe it is just me but i always understood that properly designed microservices have itheir own specific datastorei which is inoti shared with other microservices even if these all collaborate to the same process.if this is actually still true that means that the way you organize your code is a bit simplistic. your example of an http api that converts pdfs to ... is surely a valid example of a microservice but most business products have to handle much more state than those and this will create further complications which go far beyond how to organize your code and make monoliths more appealing.;0
29576854;HackerNews;2021-12-16;unless you have a strong technical or organizational reason to use microservices using microservices is just more work to achieve the same results.organizational reason would be multiple peopleteams who don't want or can't talk much to each other so they develop pieces of a larger system as relatively independent projects with clear api and responsibility boundaries. frontendbackend style web development is an example of such approach even though we don't typically call these parts microservices.a technical reason i can see is some component of a system actually having to be written in a different stack or to be run in a separate location for business reasons separate physical computer separate vms or containers don't count. like a firmware running on an iot system. or most of the system uses python but there's a really good library in java for solving some very specific problem so let's use it.if neither of these reasons stands you don't have a microservice architecture you have a distributed monolith. you just replaced some function calls with rpc. rpc call which takes a much a longer time than a local one and can randomly fail. most of your microservices are written in a single stack so you refactor common parts into a library but then different services are stuck to use different versions of this library. you end up with a much slower and a much more fragile system which is harder to work on for no good reason.;0
29576849;HackerNews;2021-12-16;no wonder you have a bad time if you associate microservices with k8s.;0
29576842;HackerNews;2021-12-16;monorepomonolithmicroservicesetc is just the way you organize your code.its also about how you deploy your code. if you have 1000 micro services do you have 1000 deployment pipelines? if so how do you manage those pipelines? if not you sacrifice independent deployment of each micro service.;0
29576841;HackerNews;2021-12-16;i feel like microservices are a solution for magpie developers. it's hard to keep a hundred engineers excited about working in an aging java stack when there's all these shiny new tools out there. but maybe that's just my perspective coming from a consultancy firm whose devs wanted to stay on the cutting edge.;0
29576836;HackerNews;2021-12-16;maybe i'm too old but i don't even want to have to worry about all that. i think in terms of functions and i don't care if they are being called remotely or local.that was the promise back in the day of j2ee and it seems to me microservices are just a rehash of that same promise.which never really worked out with j2ee it was mostly invented to sell big servers and expensive consultants which is how sun made money?these days i sometimes don't even bother to make extra interface classes for everything. if i need it i can still insert that but no need to do it up front.and devops is just a ploy to make developers do more work that was formerly done by admins.writing every microservice in a new language also seems like a huge headache. the only bonus is that you can attract developers by being able to promise them that they can work with some shiny new technology. maybe that is actually the main reason for doing that?otherwise again perhaps it is my age but i prefer to minimize the dependencies. do i really want to have to learn a whole new programming language just so that i can fix a bug in some microservice. i personally don't want to.;0
29576833;HackerNews;2021-12-16;well not git but modularity was invented for that.you can have a modular monolith that works just as well with 100 people as something serviceoriented would. the difference lies in the level of discipline needed. it's much easier to just go in and make that field public because it makes my implementation easier when you have a modular monolith. with microservices you are more explicitly changing an external api by doing that.yes it's the same thing. but somehow psychologically people feel worse about changing a networked api than making an identifier public instead of private.edit i forgot there's one more thing with service orientation you can deploy in finer grains. you shouldn't have heavily stateful services but if you do and you always do! it can be cumbersome to redeploy them. at that point it's nice to be able to deploy only the parts that changed and avoid touching the stateful stuff.;0
29576832;HackerNews;2021-12-16;i originally had my search engine running on a kubernetesstyle setup off mk8s.the code is a microserviceesque architecture. some of the services are a bit chonky but overall it's roughly along those lines besides the search engine i've got a lot of random small services doing a lot of things for personal use scraping weather forecasts and aggregating podcasts and running a reddit frontend i built.i'd gone for kubernetes mostly because i wanted to dick around with the technology. i'm exposed to it at work and couldn't get along with it so i figured we may get on better terms if i got to set it up myself. turns out no i still don't get along with it.long story short it's such a resource hog i ended up getting rid of it. now i run everything on bare metal debian no containers no nothing. systemd for service management logrotategrep instead of kibana i do run prometheus but i've gotten rid of grafana which was just eating resources and not doing anything useful. git hooks instead of jenkins.i think i got something like 30 gb of additional free ram doing this. not that any of these things use a lot of resources but all of them combined do. everything works a lot more reliably. no more mysterious containerrestarts nothing ever stuck in weird docker sync limbo no waiting 2 minutes for an idle kubernetes to decide to create a container. it's great. it's 100 times easier to figure out what goes wrong when things go wrong.i do think monoliths are underrated in a lot of cases but sometimes it's nice to be able to restart ipartsi of your application. a search engine is a great example of this. if i restart the index it takes some 5 minutes to boot up because it needs to chew through hundreds of gigabytes of data to do so. but the way it's built i can for example just restart the query parser that takes just a few seconds. if my entire application was like the query parser it would probably make much more sense as a monolith.;0
29576828;HackerNews;2021-12-16;org complexity is a valid point. sure you can solve it using microservices. but in this particular case solving org complexity such microservice is akin to a library with some rpc. you might as well have each team developing their microservice as a shared statically linkable lib. same thing in this context.;0
29576815;HackerNews;2021-12-16;this is the right take on this. all tech people here that rave on that microservices really make their life easier even though they are working in a small team for an entire product are looking through rose colored glasses while chucking down the koolaid and also not the intended audience. the tech complexity is hardly ever worth it unless you are a large corp.;0
29576809;HackerNews;2021-12-16;monoliths and microservices are two bad ways to develop software. monoliths are rife with hidden dependencies and microservices tend to collapse from even simple faultsneed to rightsize the modules. more than one but just a few with boundaries chosen around recovering from faults;0
29576805;HackerNews;2021-12-16;wasn't git invented for that?in what way do microservices even help? it seems to me you still have to synchronize to be sure that the microservice from team b does exactly the things that are specified in the new version?is it not easier to have a pull request that says this will do thing x you merge it into your monolith and then you can see in the git log that this version will indeed to x?how do microservice organizations even manage that? is it the reason that atlassian has a billion dollar evaluation because people need it to keep track?;0
29576762;HackerNews;2021-12-16;jenkins is not necessary you can still deploy stuff with a local bash script and you need containerization whether you are on microservices or monolyth architecturethis is what i do. single bash script when ran on bare os can install and configure all dependencies create database from backup build and start said monolith. all steps are optional and depend on command line parameters.since i deploy on dedicated servers i have no real need for containers. so my maintenance tasks are ssh to dedicated server and run that script when needed. every once in a while run the same thing on fresh local vm to make sure everything installs configures builds and works from the scratch.;0
29576759;HackerNews;2021-12-16;db isn't needed. our microservices pipeline either uses mq efs or s3 for the destination for another pipeline to pick up. unless you count those 3 as dbs;0
29576747;HackerNews;2021-12-16;microservices aren't implemented to solve technical problemsrather they are used to solve organizational problems. having 10 developers working on a single monolith? probably fine. 100? good luck managing that.yes they add technical complexity. but they reduce organizational complexity.;0
29576743;HackerNews;2021-12-16;there is a lot of talk about monoliths vs microservices lately.. i just want to throw into the ring that you can do both at the same time. easily. and noone is going to kill you for it either.maybe we are getting caught up in sematics because its christmas but monorepomonolithmicroservicesetc is just the way you organize your code.developing a montolith for years but now you have written a 15 line golang http api that converts pdfs to stardust and put it into on a dedicted server in your office? welp thats a microservice.did you write a 150 repo application that can not be deployed seperatly anyway? welp thats a monolith.you can also build a microservice ecosystem without kubernetes on your local network. we have done it for years with virtual machines. software defined networking just makes things more elegant.so dont stop using microservices because its hard or start writing monoliths because its easy because none of that is true in the long run.what is true is that you have a group of people trying to code for a common goal. the way you reach that goal together defines how you organize your code.;0
29576736;HackerNews;2021-12-16;you misunderstand their point. not all microservices need persistence at any level. very often microservices are just processing things.;0
29576643;HackerNews;2021-12-16;db is not an obligatory part of microservices.if the microservices don't have their own store but are all mucking around in a shared data store everything will be much harder. i wouldn't even call that a microservice it's a distributed something. it can work sure.;0
29576476;HackerNews;2021-12-16;nice article! although i think you are overdramatizing microservices complexity a little. kubernetes is rather a harder way to build microservices. db is not an obligatory part of microservices. kafka isn't as well. it's a specific solution for specific cases when you need part of your system to be based on an events stream. jenkins is not necessary you can still deploy stuff with a local bash script and you need containerization whether you are on microservices or monolyth architecture kibana prometheus zipkin are not required. but i think you need both logs aggregation and monitoring even if you have just a monolith with horizontal scalability.also all this is assuming you are not using out of the box cloud solutions.;0
