ID;Source;Creation Date;Content;Sentiment
29379926;HackerNews;2021-11-29;Title:Some thoughts on microservices, Content: https://filipnikolovski.com/posts/thoughts-on-microservices/;0

29450820;HackerNews;2021-12-05;i can guarantee you that most systems out there could serve production traffic on an old laptop with wellwritten code and lean database queries. i have done things in mysql v3 in 2006 that should not be done with a modern database even today a taxonomy search engine 3 levels deep. never again.in the age when database trips and network trips are treated as free we somehow arrived at more complicated solutions like microservices.a hello world problem in 99 of the cases is a hello world problem. at google it is not. it's a scale problem. everything is a scale problem at google first and a business logic problem second. the faang alumni has convinced the new generation of developers that everything is a scale problem.;0
29422776;HackerNews;2021-12-02;fundamentally i don't really see much difference between monoliths and microservices. in a monolith you just call another functionclass but in microservices that function is a http call.that right there is the fundamental difference.for one thing calling a function in the same process is going to be orders of magnitude faster than a network connection call and all that it entails. even if performance doesn't matter at all in some use case it's also additional cost to be running all these additional instances.and then complexity went up since a network call can fail in all kinds of additional ways that a jump to a function address in the local process cannot. so the code has to deal with all those. the complexity of correlating your logs and diagnostics also just went up. your deployment automation and versioning complexity also now went up.all these are solvable problems of course. it just takes more people time and budget. if the company is large enough sometimes it's worth it for the dev team decoupling aspects. if the company is tiny it's approximately never worth taking on all this extra work and cost.;0
29414049;HackerNews;2021-12-02;publishing to maven definitely works.updating sql drivers etc is not trivial because you don't have control over the code but if you have enough integration tests or at least proper failure handling for your separate library then you can update with the same frequency as microservices.i think it's fine to do this thought exercise but you're massively discounting the difficulties of microservices while making up obstacles and mocking frankenmonolith every other suggestion. any company that doesn't already use microservices and doesn't also have people with experience building iinfrastructurei for them rather than just using is gonna have a harder time with a microservice solution than you currently do. it is perfectly fine to extrapolate from your own experience but you're discount things without any research whatsoever and saying nobody knows about it or nobody uses it in a very disrespectful way. another post of this discussion about code ownership is exactly the same it takes literally seconds to write a simple icodeownersi file in github while you make it seem like it would be an sisyphean task an uphill battle compared with microservices just because you're not aware of it. some things are not hard maybe you just didn't heard of them yet.;0
29413444;HackerNews;2021-12-02;microservices is a psyop by big tech to make deploying amp maintaining software so insanely difficult that future potential competitors are too tied up trying to keep the cloud equivalent of hello world afloat to present any real threat;0
29412192;HackerNews;2021-12-02;i wouldn't underrate the technical issues. to really make it work you've gotta get the tooling right so you're not writing and maintaining plumbing logging tracing runtime config networking deployment api layer repository etc etc for every single microservice all in their little bespoke ways. i once decommissioned a microservice after noting that the loc of all its plumbing and config outweighed the actual logic 51. pushing that plumbing to the background so it can be managed as a crosscutting concern isn't so easy.;0
29411940;HackerNews;2021-12-02;if you deploy same binary under different roles it's same issue with complexity.with modern tooling deployment and managed storages is not a problem at all you use templates or buildbacks or even lambda combined with gitlab github ci abilities. recent progress allows you to embrace zeroops and microservices. in my team we don't have a dedicated ops person and deployment from dev to prod is running via git by developer.node itself has a very bad profiling tooling compares to more adult languages. if you run a microservice it's much easier to spot a problem in cpu or especially memory leak. and vise versa if you doing something in scala or java microservices benefits are minor. it's also so much easier later to rewrite some of the services in a more performant language.;0
29411069;HackerNews;2021-12-02;you don't get to change the constraints i already know how to setup x after an answer just to say the answer is wrongworse and expect not to be called out on it...i don't see it as being called out it's a constructive discussion. the purpose of my example is to see how practical it would be for me to set up a monolithbased cicd that could support multilingual multirepo teams. i have a better idea now maybe have them publish to a local maven style server and kick off a monolith build when there is a new library version? the monolith can then bind them together and rebuild. i'm not sure how the host interfaces would get regenerated still.good examples re libcurl imagemagick etc. how would we deal with very frequent changes there? i know that upgrading a sql driver is not a task we take lightly and i would love to see how we could make this easy to do on a daily or hourly basis. mainly we'd need autogenerated strong types somewhere on the interface again like openapi but for libraries. you seem to be under the impression that what i'm suggesting is a replacement for real microservices.this discussion started with several suggestions that monoliths could do just as well as most microservice setups and i wanted to do an exercise to see how practical this would be. i don't understand what's the issue here.there is no issue. who said there is an issue? so far so good. sure but you can't use yourself as a benchmark for the industry if you're that unfamiliar with something that basic.i know andor interview enough people across the webdev and gamedev industry that i feel i have a sizable sample of data points to form an opinion that is not purely a guess of a single person. again there is a humongous difference between we're doing microservices or even we have a service oriented architecture and your i need two things to interoperate.sure. the two things example was just a distilled example for the purpose of a thought experiment. we can easily extrapolate to an org with tens of services where maybe most people like to use the default environment like javaspring but a few teams maybe prefer or their use case calls for something different like python or c or whatever. if anything it would be even more difficult to stand up a monolith there with more and more varied components.;0
29410340;HackerNews;2021-12-02;i that's maybe a bit unfair. there are a lot of microservice shops but i haven't heard many who do this frankenmonolith thing. remember that infamous microservice dependency graph from uber? i guess facebook was famous for doing a monolith but i don't know if it was purely php or not.iyour original example was that you needed to let a remote team add some functionality to my say spring backend but they really prefer to write c and have their own cicd system. i am telling you the classical way of solving ithisi problem. you don't get to change the constraints i already know how to setup x after an answer just to say the answer is wrongworse and expect not to be called out on it...also it's not a frankenmonolith dude... it's just a library. have you ever used imagemagick to resize images from your microservices? maybe made a request using libcurl? maybe had to use a sql driver that was native maybe redis? a npm package with native code? that's exactly the same thing... i literally don't know of a single language that doesn't use those things...plus there is a huge difference between what you asked and a uberfacebook scenario. you seem to be under the impression that what i'm suggesting is a replacement for ireali microservices. no it is simply a solution for the problem iyoui described.you described a problem and said you don't know how to solve other than with x. i'm giving you y. i don't understand what's the issue here.i i can if the metric is availabilityfamiliarity in the industry but ok.isure but you can't use yourself as a benchmark for the industry if you're that unfamiliar with something that basic.i i don't know my experience is people like to say they use microservices but they just have a serviceoriented architecture. meanwhile i never ran across an organization that does something like npm modules and goes way crazy with granular services. i don't know maybe they are out there.iagain there is a humongous difference between we're doing microservices or even we have a service oriented architecture and your i need two things to interoperate.;0
29410176;HackerNews;2021-12-01;you don't need a library for that it's is part of the language. java can call code from native libraries c can export native functions. it can also be another process.having never done this i believe you. i am still skeptical of how quicklyeffectively you could set up a cicd system and the module repos to deploy to a monolith. i wonder how the type interop works there equivalent of openapibased code generation. the problem is that you moved the goalposts. i need to interoperate with c code is very different from i need to interoperate with c code and my company uses microservices and that's the only thing i know.that's maybe a bit unfair. there are a lot of microservice shops but i haven't heard many who do this frankenmonolith thing. remember that infamous microservice dependency graph from uber? i guess facebook was famous for doing a monolith but i don't know if it was purely php or not. you can't claim something is automatically worse just because you're ignorant about it.i can if the metric is availabilityfamiliarity in the industry but ok. nope. there are exactly zero companies claiming to use microservices when they have exact two services. and it's not about size by the way it's about different architectural patterns.i don't know my experience is people like to say they use microservices but they just have a serviceoriented architecture. meanwhile i never ran across an organization that does something like npm modules and goes way crazy with granular services. i don't know maybe they are out there.;0
29409897;HackerNews;2021-12-01;i i said i don't know which library would let me make c method calls from a java spring runtime presumably in the same process. do you? feel free to share a link.iyou don't need a library for that it's is part of the language. java can call code from native libraries c can export native functions. it can also be another process. 1i yes the whole point was to come up with a concrete example for the sake of argument and see how we can accomplish it in practice. we're not writing academic papers here the fact that this functionality is widely available is a good thing.ithe problem is that you moved the goalposts. i need to interoperate with c code is very different from i need to interoperate with c code and my company uses microservices and that's the only thing i know.you can't claim something is automatically worse just because you're ignorant about it.i yes me and 95 of the industry. again it's unfortunate but here we are.inope. there are exactly zero companies claiming to use microservices when they have exact two services. and it's not about size by the way it's about different architectural patterns.1;0
29409635;HackerNews;2021-12-01;i i don't know what that library is right nowiare you serious? in which language do you program that you don't have to use multiple libraries daily? you just talked about npm.in your example the c could output dlls that have functions that can be called by the java code. this can give the same encapsulation you get with your multiple services example including separate deployments different repo different language etc.you could also use different processes. please tell me you know what an executable is...i meanwhile i could set up the separate reposmicroservices by the end of the dayithat's because someone set it up for you not because it's faster.in your hypothetical scenario of ii needed to let a remote team add some functionality to my say spring backend but they really prefer to write c and have their own cicd systemi you didn't mention that ibut we already have a fast way of setting up micro services.i it is unfortunate that the micro in microservice is often misunderstoodit's not you're using the term loosely. two services do not make a micro service architecture.sorry to be blunt but i'm getting the feeling you're not talking out of experience but rather repeating popular talking points.;0
29409320;HackerNews;2021-12-01;microservices as a philosophy is encoding your org design at the networking layer.not always. one of the things where i desperately wish people iwouldi adopt the microservices philosophy is in applications which provide a scripting language.for example if i want to script openoffice i am stuck with the iexacti incarnation of python shipped with openoffice. nothing newer nothing older iexactlyi binary compatible. this is a really irritating limitation.if however they simply provided a microservice interface that anyone could talk to rather than just the anointed python then you could run your own python or script using a completely different language.i'm picking on openoffice here but this is not specific to them. nobody who has a scripting extension language as part of their application has demonstrated anything better.;0
29409116;HackerNews;2021-12-01;start with a monolith and only break it up if you are actually forced to by the computer i.e. the process won't fit in ram anymore or eats all the cpuio. the second you break up your monolith you lose its most powerful feature the direct method invocation. the amount of time i see developers spending on json wire protocols cors problems api endpoint designs et. al. really is starting to concern me. i sometimes wonder if anyone wants to do any actual work or if this is just a big game to some people.i did the full trip on this microservices rollercoaster. monolith uservices monolith.i used to vehemently advocate for using microservices because of ihow easyi it would be to segment all the concerns into happy little buckets individuals could own. we used to sell our product to our customers as having a microservices oriented architecture as if that was magically going to solve all of our problems or was otherwise some inherent feature that our customers would be expected to care about. all this stuff really did for us is cause all of our current customers to walk away and force a reevaluation of our desire to do business in this market. all the funshiny technology conversations and ideas instantly evaporated into a cloud of reality.we are back on the right track. hardcore monorepomonolith design zealotry has recovered our ship. we are focused on the business and customers again. the sense of relief as we deprecated our final servicetoservice json apicontrollers was immense. no more checking 10 different piles of logs or pulling out wireshark to figure out what the fuck is happening inbetween 2 different code piles at arbitrary versions.;0
29408850;HackerNews;2021-12-01;with a library.i don't know what that library is right now. meanwhile i could set up the separate reposmicroservices by the end of the day. that sounds like you need at most two different services not microservicesit is unfortunate that the micro in microservice is often misunderstood to expect that these are very small and granular components. in practice by and large it ends up being separate services with separate repo code review ownership deploy or cicd etc. pipelines. it doesn't have to mean they are actually very small. i know people like to joke about npm components and the leftpad thing but in my experience microservices have not turned out like that.;0
29408762;HackerNews;2021-12-01;i i'm not sure how i would accomplish this in a monolith.iwith a library.depending on what youre doing process ran a few times a day? maybe even spawning a process is enough.i what options would i have if i say needed to let a remote team add some functionality to my say spring backend but they really prefer to write c and have their own cicd system.ithat sounds like you need at most two different services not microservices.;0
29408677;HackerNews;2021-12-01;if you are already doing code reviews it is trivial to setup.if youre using microservices monorepo you need exactly the same thing otherwise people will just commit in your service.if youre relying on multiple repositories you can just split things within libraries and have the exact same effect. you can even have separate deployments with this arrangement.not to mention it is also an uphill battle to get things set up properly with microservices so theres really no advantage in using them for enforcing encapsulation.but most important a team unable to enforce encapsulation and code ownership is not ready for microservices iat alli.;0
29408431;HackerNews;2021-12-01;microservices as a philosophy is encoding your org design at the networking layerdef the bestworst reason to use it but it does practically make sense. anyone who has had crossteammonoliths will welcome this.;0
29408267;HackerNews;2021-12-01;at a previous company. i had a team that chose to rebuild a feature from the monolith as a microservice to contain the complexity. they built the service off to the side had automated tests validating its inputs and outputs and they were quite proud of it. then came integration and it became clear they had not put any thought into how to migrate the data what would happen if the service was unavailable when the monolith called it how to generate reports across the monolith and microservice etc etc.in this case using microservices was like getting drunk a way to briefly push all your problems out of your mind and just focus on what's in front of you. but your problems didn't really go away and in fact you just made them worse.;0
29408112;HackerNews;2021-12-01;assuming people will need reports that cut across teammicroservice boundaries all that data has to end up in one common place possibly a data warehouse. at which point other teams can still add and remove columns and break your reports.is there another way to do things?;0
29408041;HackerNews;2021-12-01;this is the flavor of reductio ad absurdum example i always give when people hype up the micro part of microservices. only meant to be illustrative i had no idea that any org was iactually doingi that sort of nonsense yikes.;0
29407873;HackerNews;2021-12-01;indeed. i did simple calculation for myself. we kind of split a service in 5 microservices. now if i look at e.g 5 integration related issues between 2 services which would obviously not exist in monolith we are actually looking 20 chances of error in an endtoend transaction.to me this is pretty high chance of error on day to day basis. and in our case some errors are convoluted so possibly getting missed and causing slow data corruption.;0
29407412;HackerNews;2021-12-01;node can run multiprocess with the cluster module. node being written as a monolith but running it in 100 instances is also an option. roles can be implemented in software. there's much less orchestrating complexity when you're deploying a single service.so node being singlethreaded is not itself a reason to use microservices.i tend toward writing a monolith for the core api of a service but then break out microservices for tasks that need to scale independently or that need to run on highmemoryhighperformance instances for example. so i'm not totally against using microservices. but we should choose to use them when they're to our advantage to use them not just because they're already written that way.;0
29407248;HackerNews;2021-12-01;the major difference is whether the small projects are independent applications that use some shared libraries what i think you mean by existing generalized components or whether the small projects all talk to each other to create a single large application.if it's the former then you're just talking about refactoring functionality into a shared library but at the end of the day you're still just building little monoliths. you don't have to worry about most of the problems that come up with microservices.;0
29407243;HackerNews;2021-12-01;yet another based on my experience opinion. based on my experience our service would fail due to performance because well nodejs is still single thread. given this we should either duplicate deployment of big service by roles that gives you same level of orchestrating complexity or rewrite in different languages means hello microservices again ps our product was initially written by non tech cofounders that used heroku and microservices from day one. they used a swarm of small services to stay on free tier. so microservices in this use case are cheaper. and yes it's simpler for non experience developer to get up to speed with your backend if it's a simple service.;0
29407193;HackerNews;2021-12-01;if i was cto of a company microservices would give me nightmares. how do you do due diligence on used free software licenses and security updates? how do you plan the resource usage of your whole setup if every developer can add a new autoscaling service? who is actually keeping track on deployments so we don't accidentally overload the system? how do you refactor a crossservice feature consistently? and the worst part who keeps track of the nn contracts between the services?i mean yes i know that each of these problems can be solved sometimes in a relatively straightforward manner. but who really has all these aspects covered and doesn't run some services that started to smell weirdly a couple of months ago?;0
29406255;HackerNews;2021-12-01;a coworker at a previous four person startup was always advocating microservices.having to push back on that over and over was frustrating.we didnt even have a real devops guy or a vpc with properly partitioned cidr blocks to segregate our databases from the public web and were going to start adding the complexity of a microservice architecture?for what! we didnt even have users yet.but try to get folk to dogfood our application since we had no actual users besides the founder and it was like pulling teeth.totally backwards to me.;0
29405863;HackerNews;2021-12-01;my thoughts on microservices...they're fine. but what's not fine are inanoiservices. i did security on a project once where it seemed that every function was its own microservice. user registration user login and password resetting were each a separate microservice. it was an utter nightmare.;0
29405477;HackerNews;2021-12-01;i couldnt tell if you were serious or joking or a mix of both. i think in part because i had the same reaction when i heard about microservices. i thoughtuh... we had that back in the early 2000s at least they called it soa back then.and yes we learned back then how painful and complex that kind of architecture was to reason about and support compared to a simple monolith.monolith is truly king unless obviously you're at faang scales. 99 of shops are many orders of magnitude below that scale.;0
29405372;HackerNews;2021-12-01;another phrase i like to use is 'vertically integrated service'. you need to be vertically integrated to scale horizontally. that is the whole point of microservices after all.;0
29405189;HackerNews;2021-12-01;i agree but perhaps i didn't word it the right way in my original comment. with microservices there is a big overhead in development and managing failures but functionally it doesn't offer much more than a function call within a monolith.;0
29405020;HackerNews;2021-12-01;i haven't had experience with well isolated modules in a monolith so i'm likely not giving monolith enough credit here. it's possible a microservice organization may still have an advantage by having more of this isolation by default instead of an uphill battle to get things set up properly.;0
29404984;HackerNews;2021-12-01;in the real world poorly designed microservices make the ball of mud problem much much worsei can see that. i am trying to reflect on why i have such negative experience with a monolith and positive with microservices. it's possible that in the monolith setups i had poor design was easy by default. no linting no crossmodule ownership interlocks very slow and costly production deploys. likewise the microservice setups tended to make poor design harder since code is isolated by default both at compile and runtime.can you make a monolith with all the good benefits of modularity but without the complications of network rpc etc.? maybe but i haven't seen it yet. excluding trivial singleteam apps talking about at least 3 teams and 50 headcount orgs. asynchronous? doesn't save you when an upstream service changes event definitions and emits events with unexpected structure and a downstream service starts failingsure shit happens. again my experience may be colored but when costly mistakes happen in monoliths it tended to take longer to roll back because of how deploys are structured both technically and on an organizational level. i think i would still prefer smaller units in this case.;0
29404979;HackerNews;2021-12-01;fundamentally i don't really see much difference between monoliths and microservices. in a monolith you just call another functionclass but in microservices that function is a http call.in j2ee that difference is a configurable technical detail. you have 1 service that calls another and the protocol they use can be a normal function call rmi soap or i think rest nowadays depending on dynamic configuration.;0
29404829;HackerNews;2021-12-01;first of all we called these distributed systems. we reserved those for rare cases where scale was the requirement and you jumped into it fully expecting to have no life.the world did not finally crack distributed systems. most companies created multiple microservices putting their small dev team underwater because this is the way at the faang.all of your dry principles are out the window and now you have to debug in production the new word for ithati is observability.not to mention that the actual reason for distributed systems is to scale multiple parts of the system independently but you need to know what has to scale individually before you do it. what i see is that the topology really reflects the company structure of course. it's not what has to scale separately it's team y is working on x and team y does not want to talk to team z so they will create a service to make sure they don't have to talk to people.except that this is a giant selfown. we all still have to talk to each other like a lot because things just keep breaking all the time and no one knows why.dropbox instagram stackoverflow these companies are largely monoliths to this day. you thinking that your small outfit needs to be like google is highly arrogant.and don't get me started on the amount of money people cpu cycles and co2 emissions wasted on this solving of the problem most people don't have.;0
29404714;HackerNews;2021-12-01;i find peoples reactions to microservices to be fascinating. i have always looked at them with the same framing as unix userland tools many small focused apps that do something really well coupled with a super generic ipc mechanism in unixs case using pipes or message queues.but unix isnt all small tools. we have servers for the heavy work like databases.the challenge then becomes how do you design that ipc mechanism? maybe it exists! i dont know the answer yet. but its something i think about a lot and i havent seen compelling evidence for microservices are always bad no exceptions;0
29404670;HackerNews;2021-12-01;this. microservices are introduced because it seems like they'll be able to decouple and scale well and then they make mistakes that make everything even harder than if it'd stayed a monolith.usually they don't plan for how they'll coordinate their work and that leaves gaps in the design and puts more risk on the business. on top of that they don't even make a true microservice. they start directly calling into each others' data rather than interface at an api layer they make assumptions about how each other works they don't do load testing or set limits or as... and because none of them understand the rest of the system they don't see that their mutual lack of understanding is the cause of their problems.even with multiple teams if they're forced to work inside a monolith there's a much better chance they will iby accidenti come to understand the rest of the system.;0
29404669;HackerNews;2021-12-01;op makes a really good point in that dev teams also need to own their infrastructure when everything is a microservice. asking devops to change an infra component prior to a release just shifts the monolith under the rug while also completely defeating the point of devops.lots of devs don't know infrastructure that well though this is changing with the adoption of kubernetes. additionally most devs don't want to go oncall when their app crashes unexpectedly.;0
29404256;HackerNews;2021-12-01;i with a monolith any random developer can go and flip some private method to public import it way across the modules and presto you are now building a ball of mud.iif any developer can do it then the problem is not with monoliths but rather with your pull request reviews process and lack of code ownership. this can even be helped by github and other platforms with a icodeownersi file.microservices by themselves doesn't solve this problem. if anyone has commit access to all micro services then they can make an even bigger mess the same way.;0
29404247;HackerNews;2021-12-01;i know microservices have passed the excitement phase of the hype cycle but they're not useless. one of the most enjoyable systems i've worked on was a microservice architecture.that said i'm going make some wild inferences about what you were getting at in ordet to say that i agree that a microservice architecture is probably a solution in search of a problem in most cases. and even in the cases where it is a good option i can see all sorts of ways to mess up the implementation. the article is right the trickiest things to get right about microservices are actually organizational issues not technical ones. my hot take is that dev teams who are considering adopting microservices should take a serious look at how much ability they have to influence the org chart and interteam and interdepartmental communication. if management is strictly something that happens to them i would not give them stellar odds of achieving sustainable success with microservices. perhaps some other form of soa but not actual microservices.;0
29404097;HackerNews;2021-12-01;your first question in a job interview should be do you use microservices? if the answer is yes you can save yourself a lot of time.;0
29404028;HackerNews;2021-12-01;hey! i enjoyed this post a lot. i agree with almost all your points raised except for singleteam no microservices. your prose makes your points easy to understand.i have a couple layout commentsfirst i love that you have a high contract texttobackground. that is really helpful for me. there wasis a trend to have light gray on white backgrounds for blogs this is absolutely a terrible pattern. i appreciate that you did not go this route.second serif fonts are difficult to read when the font size is relatively small. something like jura or similar could maintain the terminal feel without getting bogged down in serifs.third i have a really hard time reading content when it uses smaller fonts and uses a minor fraction of the screen. this is what i see i am getting older and reading smaller fonts is increasingly difficult for me. i tend to keep my zoom at 150 something about this page forced it back to 100. i am not well versed in responsive design so i don't know the technical details for it but having zoom maintain or using a larger font would save some cognitive cost to older users like myself needing to zoom in.thanks for your thoughts on microservices!;0
29404010;HackerNews;2021-12-01;yes that is the marketing brochure pitch for microservices.in the real world poorly designed microservices make the ball of mud problem much much worse and whatever pain you had in deployments in a monolith are now magnified tenfold. i have not been fortunate enough to see welldesigned microservices so i suspect the ball of mud is the default. can this be rectified through discipline? probably but i haven't seen it.asynchronous? doesn't save you when an upstream service changes event definitions and emits events with unexpected structure and a downstream service starts failing. can this be rectified through async openapi and rigorous contract testing? probably but i haven't seen this happen in a way that helps.i have seen large companies survive perfectly well on a monolithic ball of mud and small companies get lost in a mud pit of microservices.my point is not that microservices are bad they're not they're just a tool but they are a tool that is a poor fit for most companies in my opinion. i can't speak to the few giant companies that need them and use them effectively there is a good reason the tool exists.;0
29403927;HackerNews;2021-12-01;if you don't even have cicd yet i'll argue that your team has not reached the operational sophistication required for microservices yet. there are many ways in which microservicesalso if individual devs can reach out across the codebase and turn private methods public it is the pull request review procedure that you need to improve not the architecture.;0
29403752;HackerNews;2021-12-01;i don't think the number of users nor number of developers is really the deciding factor. instagram prefacebook acquisition was a very simple application. it was literally just a chronological feed of strictly square photos with captions you followed your friends could explore hashtags and not much more. videos wouldn't even come for a few more years let alone all the crazy stuff facebook has hamfisted in there since.for the scope of that app it would have been absurd to use microservices. and i think most people who are in favor of microservices would say the same thing. to me what microservices help with is when you're building an entire platform rather than a single product. not even necessarily on the scope of facebook or google but i've worked at companies where one team might work on an app for managing social media accounts and another app helps you optimize the seo of your website. neither of those things really want to own the concept of a user they both share or deal with account creation and whatnot. so that's handled by a dedicated microservice.now when you get to a size where you're building a platform you're likely going to have lots of developers and users but i don't think whether you use microservices is a function of either of those numbers and they're just a side effect of the thing you've built.;0
29403691;HackerNews;2021-12-01;the longer im in tech the more im convinced microservices were a technical solution to an organizational problem.carnage4life on twitter now ive not had the pleasure of working in an organisation using microservices and so im only informed anecdotally. but i always assumed they where best used as an api boundary between teams rather than adding more complexity to a teams work.;0
29403664;HackerNews;2021-12-01;splitting a system into microservices can help individual teams be better stewards of their part of the system.iteami being the keyword here. if you have 35 developers per microservice you're absolutely okay. if you have 35 microservices per developer that's when it gets ugly.;0
29403563;HackerNews;2021-12-01;to be fair you can build a monolith in a way that is very similar to microservice architecture.you can have a single function that handles all data base writes. a single function that monitors for failures. a single function that sends outbound notifications... etcif these functions are call in a way that allows for ab testing super high latency or no response failure notifications sent to the code owner automatic retries of failures independent code deploysthen congratulations you have a monolith made up of microservices!;0
29403523;HackerNews;2021-12-01;splitting a system into microservices can help individual teams be better stewards of their part of the system. they can release on their own schedule they can use their own linting rules heck even a different language and they can have better control of incoming code changes. with a monolith any random developer can go and flip some private method to public import it way across the modules and presto you are now building a ball of mud. need an out of cycle release? hopefully you have cicd or now you have to beg the sre in charge to do it for you.;0
29403517;HackerNews;2021-12-01;you just call another functionclass but in microservices that function is a http callthe difference is enormous.;0
29403503;HackerNews;2021-12-01;and you add latency issues and overhead. with a function call you pass two int and get a string of length 120 how much memory is this? little very little with microservices you make an api call using http with it headers and get a json and maybe you could need 2 api calls. for me it's easy just create a monolith when you become facebook or netflix split symfony services into microservices just an example. oh and don't forget the developers who translate a specific function into an endpoint you need a change in the caller and you must change the api!;0
29403438;HackerNews;2021-12-01;microservices means just that tiny single purpose services that deploy and scale on their own.i often see appeals to conway's law when discussing microservices but teams don't organize themselves this way. instead teams work on a imacroi services the email delivery team or the monitoring team or whatever. in most cases these macroservices would be best implemented and deployed as a monolith and then presented to the outside world over a reasonable api.;0
29403426;HackerNews;2021-12-01;microservices are not a solution they're a capability. it's powerful for a team to be able to deploy a tiny service with the absolute minimum amount of explicit plumbing to meet operational requirements. whether they ishouldi break their system up this way is a case by case judgment.every place i've been the costs of microservices get overlooked in favor of the illusion of decoupling. microservices will absolutely make simple features fully contained within a service easier but as soon as a feature spans services or even impacts the contract of a service you're in for more pain than in a monolithic architecture. microservices sieze local simplicity at the cost of integration complexity.microservices as a philosophy is encoding your org design at the networking layer. i hope you get it the factoring right the first time because it's going to be painful to change.i'm all for small services where they make sense. but just like the advice that all functions should be small microservices has been myopically adopted as a design principle rather than a debatable decision.;0
29403400;HackerNews;2021-12-01;there is a huge amount of truth to this. i've been thinking of these as microliths large monolithic codebases surrounded by service workers lambda style or queue style.the biggest problem i've seen is that early applications are not built in a modular fashion. more as a maze of twisty little functions calling each other where you quickly end up with circular dependancies and other challenges. if your base monolithic architecture mimics the world of microservices modular single purpose functions and event busses to pass around information.good design is good design.;0
29403384;HackerNews;2021-12-01;a single team can break down their domain into sensible layers and abstractions within a monolith.similarly a microservicessoa architecture can fail to break down their domain into good boundaries and abstractions. i've seen this happen a lot.it's a lot harder to fix bad microservices than to fix a bad monolith;0
29403357;HackerNews;2021-12-01;well a serviceoriented architecture is a more general category then microservices and has been around much longer. in many cases it is much more justifiable on technical grounds. just to give one example. you have an api that is not the most stable thing in the world and when it misbehaves you do not want it to take the whole application down with it. so you put it in a separate service that can easily be restarted. that is a good technical reason for a separation of executables. problems arise when people introduce these separations for no good reason. then one gets all of the problems of rpc and none of the benefits. i.e. one is making things more complicated for no good reason.;0
29403323;HackerNews;2021-12-01;fundamentally i don't really see much difference between monoliths and microservices. but in microservices that function is a http calli think that maybe you're understating the complexity that distributed systems may involve.for example see all of the following plus in the current day and age we still don't have that many convenient ways to make two systems interact over a network. rest and things like graphql don't map well to actions whereas rpc solutions like grpc also involve a certain amount of boilerplate code and you still need to think about how the concerns above.;0
29403293;HackerNews;2021-12-01;the whole problem starts with calling them microservices. just call it a service oriented architecture please. the whole micro thing is already an indication of the kind of trouble you are getting yourself into. more respect to the monolith please.;0
29403289;HackerNews;2021-12-01;fundamentally i don't really see much difference between monoliths and microservices.in a monolith you just call another functionclass but in microservices that function is a http call. i guess the benefit of microservices is the ability to independently scale different microservices being able to choose different languages for different microservices and less conflicts in the repo as more people work on it but you still have to deal with backwards compatibility and versioning of endpoints.i think lambdas are interesting when you look at it this way. a microservice is essentially a set of functions which is constantly deployed as one unit. but with lambdas each function is a single unit that can scale independently.;0
29403285;HackerNews;2021-12-01;never start with a microservice architecture if you have a single team.this is probably a good point however isn't the entirety of the story.personally i agree that most teams shouldn't start out with microservices monoliths can be entirely sufficient and are easier to run and reason about. otherwise you might end up with so much operational complexity that you don't have much capacity left to actually develop the software and make sure that it's actually good.however you also need to think about the coupling within your monolith so that if the need arises it can be broken up easily. i actually wrote more about this in my blog in an article called moduliths because we need to scale but we also cannot afford microservices where this goes wrong is that no one actually thinks about this because their code works at that point in time so they make their pdf report generation logic be tightly coupled to the rest of the codebase same as with their file upload and handling logic same with serving the static assets etc. so when suddenly you need to separate the front end from the back end or extract one of the components because it's blocking updating to newer tech for example java 8 to java 11 everything else works that one component breaks so it would be more logical to keep it on the oldstable version for a bit instead for it to block everything else you just can't.sooner or later containers also have to be brought up since they can be a way to do a multitude of applications in a manageable way but at the same time it's easy to do them wrong perhaps due to not understanding the tech or some of the potential concerns.many out there think that doing containers involves taking their legacy monolith putting it inside of a container and calling it a day. it isn't so and you'll still have plenty of operational challenges if you do that. to do containers properly you'd need to actually look into how the application is configured how it handles logging external services and how it handles persistent data. and it's not the no true scotsman fallacy either there are attempts to collect some of the more useful suggestions in actionable steps for example though those suggestions aren't related directly to containers alone they can work wonderfully on their own outside of container deploymentslastly i've also seen kubernetes be used as almost something synonymous to containers in some environments you can't have a conversation about containers without it being mentioned. i've also seen projects essentially fail because people chose it due to its popularity and couldn't cope with the complexity it introduced oh hey now we also need istio kiali helm oh and a nexus instance to store helm charts in and we'll need to write them all and then also have a service mesh and some key value store for the services when something simpler like docker swarm or hashicorp nomad would have sufficed. i actually have yet another blog topic on the subject docker swarm over kubernetes honestly this also applies outside of the context of containers for example picking something like apache kafka over rabbitmq and then being stuck dealing with its complexityin conclusion lots of consideration should be given when choosing both the architecture for any piece of software as well as the tech to use to get it right. in some ways this is slower and more cumbersome than just pushing some files to an ftp server that has php running there but it can also be safer and more productive in the long term configuration drift and environment rot. sadly if the wrong choices are made early the bad design decisions will compound with time.;0
29403247;HackerNews;2021-12-01;an interesting list but is this specific to microservices or just service oriented architecture in general?for me other than the obvious size difference the difference between microservices and large ? services is that a single team breaks down their domain into sensible layers abstractions etc.;0
29403189;HackerNews;2021-12-01;to me microservices should not be an architecture.you can have pieces of functionality in a monolith that make sense to scale independently and those should not be micro they should be meaningful pieces of functionality that justify the overhead of spinning them out.in a way your comment reflects this a lot of the places that justified microservices were at a scale where their microservice was serving more requests than the average company's entire codebase.it's big data with 10 gbs of logs all over again.;0
29403092;HackerNews;2021-12-01;one should probably not even think of microservices if one employs fewer than 100 programmers. in many cases microservices are introduced because of fashion andor resume driven design not because it actually makes sense. i prefer refactoring a poorly structured monolith to refactoring poorly structured microservices in every case.;0
29403073;HackerNews;2021-12-01;i watch the other day the lex fridman podcast with kevin systrom founder of instagram.he talks about the scaling issue they were using django at that time and scale up to 50 millions users with a small team of developers.i do not think a majority of companies have more than 50 millions users and absolutely need to go full microservices.;0
