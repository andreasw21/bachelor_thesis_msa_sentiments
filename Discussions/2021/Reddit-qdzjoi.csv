ID;Source;Creation Date;Content;Sentiment
qdzjoi;Reddit;2021-10-23;"Title:Unpopular opinion: Database per service is just one of the microservices patterns. You could very well have a shared database as long as it delivers a feature efficiently., Content: I'm an enterprise application developer with 12 years of experience in developing enterprise software for multinational corporations. Right now, I work as an architect for a fintech unicorn. My role is to design and develop a scalable payment gateway system that could support 3000+ transactions per second. I have been working with microservices since 2014 and I have seen the strength and pitfalls of microservices in the last 6 years.  &#x200B;  From interacting with different people of the same expertise, I realize that there is a common misconception that a shared database is an anti-pattern. Whenever I talk to an engineer, especially someone with < 8 years of experience, their idea about microservice is a stripped-down version of REST API with a single database per service. However, I wholeheartedly disagree with this idea. A microservice doesn't need to have a REST interface and it could very well use a shared database as long as it solves your business problem efficiently. What are your thoughts?  Edit: Just realized that the post is leading to an assumption that the current design I'm working on has a shared database design. The only scenario where we have a shared DB is when we have a CQRS implemented. Even then, the queries are connected to a read replica rather than the master database itself. The opinion is just a thought I came across while interacting with multiple senior engineers.";0

hhpv81v;Reddit;2021-10-23 09:09:58;just about all these arguments and discussions come down to one thing focus on micro in microservices. it's a horrible name and people talk past each other about it all the time. the ddd concept of bounded context is much more appropriate. that then is a service or collection of services with an interface or interfaces of some kind and it is completely agnostic about the form they take. it can be huge it depends on the domain. it's not micro so much as it is not everything. the purpose of it is to put a wrapper around it and allow the inside of it to be its own thing growing or shrinking in scope as needs demand. at that point a db specific to that service is appropriate and necessary and it is so for the same reasons. it is not constrained by its need to support anything other than itself. if it needs to grow in one direction or another it can. a very small service with a simple api slapped on it is a micro service to me. microservices as a term is basically useless.;0
hhq6iii;Reddit;2021-10-23 12:00:23;depends. shared database ! shared objects in that database. if you do shared objects like multiple clients accessing the same tables views sequences you need a database access abstraction library shared between all contributors as db migrations are inevitable over the course of a project and coordinating those onebyone across possible different solution stacks from java to javascript on nodejs is impossible to do while meeting milestones in a timely manner unless your org runs like clockwork which i believe it doesn't. if you have implemented aaa on the api layer between microservices you need to maintain database object acls because obvbiously one service requiring aaa on the front side api while exposing all its data on the back side to any random service does not make much sense. essentially if you share objects between services in a schemaful database you end up with a distributed monolith because database access protocol object names object contents columns ... etc need to be coordinated. and the db access control with finegrained permissions between clients and data objects can actually be complicated as well to implement audit and maintain. you'll end up having at least one guy playing dba which is not an easy sell in an environment where noone wants to play dba.;0
hhq78xe;Reddit;2021-10-23 12:11:15;i see it differently. the reason microservices commonly do not share a database are not entirely of technical nature but also of an organizational one. there are two major reasons to use microservices scalability self sufficiency of teams now for the first part you can scale a central database pretty far depending on your system. though it might become a performance bottleneck at some point. if the services really use the same database not just the same rdbms with their own databases it might become hard to separate them later if you need to. a central database is always harder to scale than the services in the application layer. secondly the point about self sufficiency of teams. a major point is that a teams own the entire service front to back. thus being able to not only unilateraly change their services code but also the database schema if needed. having a central database that is shared by all services introduces another point of interaction and necessary coordination between teams. microservices already suffer from an increased need of communication. with a shared database you not only have the potential rest or whatever interfaces to version and worry about but also the database. doing schema migrations is already annoying for a single service e.g. this whole introduce new fields migrate data remove old fields over multiple versions and deployments while keeping the software capable of dealing with the old and new format at the same time. doing this in coordination with 10 to 50 other teams all working on the same database and potentially relying on the same table and fields sounds like a nightmare of communication. so while you can technically do this i do believe there are good reasons why it is normally considered an antipattern. this of course depends on the size of your operation. with 23 teams and no thought about expanding in the future you might as well go the route of having a shared database. but in that case you might be coming closer to a distributed monolith rather than a microservice architecture. which might be fine. you should just be aware of the potential pitfalls. edit talking about an operation that has only 23 teams you might as well consider building a monolith especially if you want to share the database. you can still care about internal separation by domains in your codebase and take care of some separation on the database layer. though having a small number of developers it might actually increase your efficiency to not do microservices as it would reduce that communication and coordination overhead. though you might want to consider how your operation will be growing if there will be the need of splitting up the monolith in the future and then design for that possibility up front.;0
hhq6321;Reddit;2021-10-23 11:53:40;microservices separate databases etc. are 99 about how your teams are structured 1 about scaling. i am seeing a trend back towards monoliths as companies see that the benefits of microservices are a lot of the time not worth the overhead.;0
hhqfr0d;Reddit;2021-10-23 14:04:35;really were talking about shared usage of tables in the db. if everyone only uses their own tables who cares if theyre in the same db. shared tables monorepo win. if you need to migrate your schema you can easily migrate all the usages. no more calling 15 microservices to validate your domain model. shared tables many repos or poor source control trouble. like others have said way too hard to find and coordinate any changes. you end up with tables users groups core entities that can never be changed bc theyre used by legacy repos nobody can run code that was never checked in tableau dashboards etc.;0
hhq6ja5;Reddit;2021-10-23 12:00:42;my take on this is the following the goal of breaking down your architecture into something like microservices is to decouple parts of the project from each other. teams should be able to do their work independently without getting into each others way. as long as your architecture achieves this you follow the spirit of the pattern. it does not make sense to me to blindly apply best practices without thinking about why. in the particular case of a shared database you do introduce an interface between services and hence coupling teams need to synchronize about the data model and the way that their services access this data. however it could very well be that in your particular case this interface is easier for the teams to manage than services communicatung with each other through rest calls.;0
hhqbdmr;Reddit;2021-10-23 13:09:06;hehehe you are reaching the point in time where you realize life is more complex then patterns so you are starting to mix and match and do middle ground solutions. by definition microservices imply they are independent. that means a different db. at least a different schema maybe its ok to use the same db server although i would say it really should all be independent. oh but now we have a lot of duplication and need to hire more db admins and all of that? thats when you as a very smart and new architect propose this whole new architecture of monoliths and drop microservices. then you do that and realize the problems with that approach and so on. architectures in it really do seem to be cyclical. anyone old enough knows microservices were done in the past but with a few small differences and names. engineers love to engineer and that means architectures patterns etc. i also blame conferences and bookcourses writers for reinventing too much to sell new books personally i try to not follow the trends just because they are trends but use time tested approaches where they work and the issues are livable. no solution is perfect so sometimes its better to use an old one that you already know the problems then just trusting a new it ted talk that it will solve all problems. any purist will hate you for breaking that barrier. personally if im using a pattern i also like to keep it within the rules. but you can do a custom architecture based on x but with this and that change. just dont call it microservices because then words stop having meaningful definitions which is the whole point of having patterns. welcome to real life!;0
hhq8h8g;Reddit;2021-10-23 12:29:22;the interesting part is this opinion of one microserviceone database is very strongly held in java community while other language developers only see it is a useful pattern but are not religiously tied to it. i guess when you never study a system programming language cc you have no idea how powerful modern computers are. java with its vast ecosystem probably seems like solution to everything and any enterprise architect blog posts a gospel. it was shocking to witness how 8 years experienced developers believed an rdbms is slow and how confident they were that they can design a globally distributed system with their microservice choices. of course costs were no factor.;0
hhqhv58;Reddit;2021-10-23 14:28:29;microservices are a way to scale your business not performance that might or might not be a sideeffect. at the size where microservices benefit you you will not want to have a single shared database because it will tightly couple all those services accessing it. there's a good reason to not share databases. this doesn't mean it's a hard rule that applies 100 of the time there can be very specific cases where you need to but in general it's a good rule. what are your thoughts? most of the time you don't want to tightly couple deployable units through a database because you lose the ability to release separately. that's all there's to it. it's not rocket surgery the 'rule' has a very good reason you don't seem to want to acknowledge. p.s. the way you refer to people with less than 7 years of experience is rather distasteful. it seems you want to disqualify their opinion based on another opinion of theirs and that is imho rather unprofessional.;0
hhr532p;Reddit;2021-10-23 18:15:16;do you have firsthand experience with microservices with a shared central database? i have inthetrenches experience with this and it's definitely a headache. microservices can no longer be thought of as wellencapsulated units of behavior and state with a simple welldefined interface. performance issues in one service can now impact another service. coordination needs to happen across teams at the database layer now too as well as the other interfaces the microservice uses rest api or asynchronous message passing. business logic can easily end up encoded in the database i.e. in views stored procedures or schema constraints which makes changing it later harder with crossteam coordination. depending on your particular rdbms and database schema some of the database's builtin data integrity and performance functionality e.g. foreignkey constraints and indexes may be lost. development becomes biased towards the expedient sharing data through the database. this compounds all the above problems for delivering features efficiently in the short term. other teams will start reading the data without your team's knowledge. for example they may need the data to generate reports or do other business analytics. other teams or applications may write to the same tables.;0
hhpuidj;Reddit;2021-10-23 08:59:51;it would be fine to have specific tables dedicated to specific microservices ala domain driven designs idea of aggregate roots. in this way each microservice is solely responsible for its own data. however theres no reason why they cant all share a database lets be honest your data simply isnt that big youre splitting for code maintenance reasons only. once you reach this level of enlightenment youll ask why your microservices even need a service broker network protocol or separate cpu processes at all. an aggregate root is a totally tangential idea to a microservice. the former has value on its own the latter is situational. imagine a scenario where you want to run complex reporting metric queries from one of the replica databases. much easier when the data is all in one place right?;0
hhq615r;Reddit;2021-10-23 11:52:48;its anti pattern because i might change the schema drop a collection or even migrate to a different db technology. if i do that for a service i am responsible for and another service is dependent on it that service breaks. microservices isnt just about performance its about high availability.;0
hhqn3kl;Reddit;2021-10-23 15:19:57;their idea about microservice is a strippeddown version of rest api with a single database per service. just here to say that one of our microservices is a ui with no database and no exposed rest services. and some others are lambdas which also have no database and no exposed rest services.;0
hhqp26d;Reddit;2021-10-23 15:37:05;i think part of the reason people think 1 db per microservice is because they want the independence of each microservice being as isolated as possible from each other microservice. however i'd argue in service to your point that if the microservices are acting on the same data then their usecases inherently connect them at a data level and efforts to isolate them begin to divorce the architecture from the usecase. if they are not acting on the same data thoughmicroservice a only cares about table 1 and microservice b only cares about table 2 then using the same db doesn't make a lot of sense unless there are additional reasons to stick to a single db.;0
hhqq5qp;Reddit;2021-10-23 15:46:33;are we talking database or database server? i think if i were to share a database across services that were split across teams id have a serious dba build a plsql interface to the db. i mean id do that anyway but i like databases. youd then not need to rebuild db logic in each microservice the same could be achieved with a library wrapping your db logic that maybe used an orm but not if services are in different languages.;0
hhqw5ya;Reddit;2021-10-23 16:53:02;im newer to working with microservices have been an engineer for the last 9 years or so. i have been having this debate with my boss about just this fact. i believe the database to be a separate layer from the services. i understand the idea of shared data dependency being a potential problem when using microservices but i feel like with proper design you can avoid interdependence of data. to me managing the microservices with a good db design is no different then having a database per services or as we are doing having a nosql table per service. we have to sacrifice some of sqls strength to deal with the no sql implementation too;0
hhr1n3w;Reddit;2021-10-23 17:48:40;i work in that space i.e. databases at scale for microservices. i've seen 1 database per service work and scale extremely well especially when teams change and services have to be transferred to other owners. shared databases also work well but tend to break down when more than 3 teams use them i have seen that work well with 2 teams though one owning the data model one more of a consumer. x200b the actual can the database scale with the data and load is secondary to the organizational problem of stewarding and editing the database schema. most rdbmses can support most growthstage businesses comfortably provided you have decent infrastructure practices stay up to date don't run them on your own hardware and have a modicum of db administration skills. that said even then you will come to a stage where your 4to10terabyte monolith is a constraint around the architecture of your entire tech stack. usually people will have shards before then but that's kind of predicated on having a dedicated database group that has the skill and authority to keep said monolith manageable.;0
hhr4fx2;Reddit;2021-10-23 18:10:15;well then it's not really a microservice and defeats the goal of microservices which is to have services that can be independently maintained without intimate knowledge of each other. if i decide to rework the database schema and it's going to break another service someone else maintains... well maybe that can work if you're a small enough org. past a certain size it definitely does not unless you're just going to tightly lock down the schema forever which is going to encourage people to abuse it.;0
hhrnw32;Reddit;2021-10-23 20:35:32;shared database is a known pattern and it is an alternative to db per service httpsmicroservices.iopatternsdatashareddatabase.html if it suits better the purpose our your app use it.;0
hhqsior;Reddit;2021-10-23 16:17:35;true the main idea behind microservices are just separating the concern. if it makes life harder dont do it. if the business team still talking like one monolith dont do it. they are not ready yet. the way our service described probably define how the business goes and communication between team.;0
hhqy083;Reddit;2021-10-23 17:14:41;yeah my experience has been that microservices are most useful for bureaucratic reasons. a microservice can have its own team with its own release process and its own oncall rotation.;0
hhq77x9;Reddit;2021-10-23 12:10:49;agreed in the same way companies are being agile i believe some companies are doing microservices by separating each service out to its own database when multiple may be in the same bounded context though i think the larger tendency may be to microservice by just separating a monolith out to a bunch of separate codebases that use the same db modeling many bounded contexts maybe you have a couple services interacting with the same db i think the more important factor is whether they're working within the same context and are both owned deployable by the same relatively small team.;0
hhqbnbg;Reddit;2021-10-23 13:12:43;exactly this. you don't have two microservices sharing a database. they can not scale independently. if i refactor one to use a new primary key in the table i have broken the other ones not exactly decoupled. they are all in the same bounded context and should be treated as a single entity two services and a table. then that unit is decoupled from the rest of the services and the insideoutside boundary is clear. fundamentally it doesn't really matter what your opinions are as long as you can recognize when you are dividing the responsibility correctly or not and what is allowing you to deploy and scale without causing debt or friction. the less you need to care about what the other parts are doing the easier everything becomes. if your architecture isn't built to deliver that it is built incorrectly. edited typo and clarity from response below;0
hhq7lij;Reddit;2021-10-23 12:16:34;i always regarded microservices not as being micro but as having such a bounded context in which they operated and fulfill their tasks. but i hadn't thought about it closer in those terms. i like the concrete association of the term bounded context with such a service. seems fitting.;0
hhq7y2j;Reddit;2021-10-23 12:21:39;i think you're focusing too much on the semantics. like you said x200b it can be huge it depends on the domain. it's not micro so much as it is not everything. x200b i believe most engineers understand this implicitly. i've never seen anyone argue that a microservice should be arbitrarily sizerestricted nor about the exact definition of micro. services can be as large or small as you want and you can have as many or as few as you want. so long as you can support those decisions both in principle and in practice of course. it depends on your business needs your technical challenges the size of your organization and so forth.;0
hhstam7;Reddit;2021-10-24 01:50:02;id say probably 90 of all the organizations who implement microservices dont need that granular level of scalability. you can scale up a monolith and pay for a few hundred wasted megabytes of ram or whatever with little consequence if youre not dealing with netflixlevel scale. self sufficiency of teams is the real benefit but its always scalability being talked about. as a result most organizations miss the selfsufficiency target because theyre not paying attention to it. i get the sense that there are a lot of people who have never successfully implemented microservices who perpetuate this scalability talking point because its easy to wrap your head around and makes for neat textbook examples. people going into it with this mindset are primed for failure from the outset because theyre optimizing for the wrong things hardware resources. the valuable resources they should be conserving are development time and engineer brain cycles but its much harder to explain how to architect your system with those parameters in mind.;0
hhrg9xb;Reddit;2021-10-23 19:38:26;eh teams are part of it i guess but one team can own multiple services. i can't think of a single team i've been on that didn't. i think of it more in terms of code organisation. with distributed systems at a certain level of seniority you're less concerned with lines of code class structures and the like and more concerned with what the pieces of your system are and how they all fit together. it's engineering at the level of boxes on your architecture diagram. microservices are basically do one thing and do it well but for rpc servers. plus there are definite advantages in terms of load balancing and capacity planning it's easier to forecast the resources needed by a server when it only does one thing. it certainly makes team ownership easier because you can pass off ownership of components between teams but i don't see it as the only reason for doing it.;0
hhr4d4z;Reddit;2021-10-23 18:09:40;the issue here is that the microservices places artificial boundaries aound areas that are coupled from a business perspective. i may have a products service customers service and inventory service and an orders service and then when i have to notify customers that a product they ordered from after a certain data is out of stock until next week i'm going to have to pull the data from all those services together. if all of that data resides in separate databases i'll no doubt need another service to do so and that's when the distributed monolith starts ..;0
hhqckui;Reddit;2021-10-23 13:25:22;sure you can but at least be nice and dont call it the pattern name then... thats when the confusion starts. microservices have a definition if you use separate services with shared db then call it something else. the main goal of patterns is to have a common language between people if we start calling things randomly then that is lost;0
hhqi67j;Reddit;2021-10-23 14:31:49;no idea why you're being downvoted. this is the whole point of this 'rule' to decouple parts of your organization. which in itself is literally the biggest benefit of microservices and kinda their point really.;0
hhqb2eh;Reddit;2021-10-23 13:05:02;once laid down schemas change far less frequently than people think. and when they do it's because there's been a significant business change which would require refactoring services as well. swapping out a db for another in a production application? i've never seen that happen. and if it did it would be a major undertaking that would touch all of your microservices. and the minute you're out there replicating redundant data between services your high availability is a pipe dream.;0
hhrofan;Reddit;2021-10-23 20:39:29;here's a review of distributed transaction patternshttpsdevelopers.redhat.comarticles20210921distributedtransactionpatternsmicroservicescompared for those who cannot share the db and has to deal with multiple data sources.;0
hhqdu07;Reddit;2021-10-23 13:41:15;ive seen this at two large scale companies transitioning to microservices and it was a complete disaster each time. there was no schema governance so people were just chucking new tables and columns in willy nilly until no one understood any of the tables. migrations become a mess and at some point break entirely so that people cant even reproduce the prod schema in their dev environment without dumping it and restoring from someone who has a working setup on their machine. the database inevitably becomes an integration layer. since no one understands the schema data types are used in a somewhat arbitrary way. the meaning of certain properties become lost to time making it extremely difficult to reason about the business logic. a simple operation of adding a new field to a public api now involves four separate teams and takes a whole quarter to coordinate because no one understands the implications or the semantics of what the data represents. and then you end up with stupid shit like two name columns with slightly different naming schemes because some idiot needs a new validation constraint for their invoices or whatever and then they start to diverge and now no one can agree on which name to use. you and your colleague spend three days talking past each other because youre referencing the same client but under two different names without realizing. then some other idiot introduces a foreign key constraint on some pointless metadata making it so you cant delete entities anymore complete breaking some critical cleanup flow leading to data congestion. now your prod database is 9 tb and takes two weeks to restore if it crashes and you have an astronomic aws bill. diffusion of responsibility because of unclear ownership means no one addresses the issue. its not that you cant have a monolithic database its just that its really easy to fuck up and if you do you screw over the entire engineering department instead of just yourself. dont do it. if youre already dealing with microservices theres no reason to share a database unless you have very specific reasons to in which case you would know about it.;0
hhpyxe3;Reddit;2021-10-23 10:04:55;microservices is a paradigm for managing an engineering team that consists of thousands of developers. stack exchange can probably seat all of its engineers on a single floor. so yeah they dont really need multiple databases that end up doing the same thing.;0
hhrh4tu;Reddit;2021-10-23 19:44:48;single databases scale really well up to a certain point single powerful machine with a warm standby then begin to scale ok but very expensively cluster of beefy machines and then just scale very poorly and ridiculously costly past that as synchronization between nodes eats up the benefit of adding more nodes. where those lines are changes with hardware capabilities thanks ssds! but the formula hasn't really changed. you can often add a readonly cache on it to get a lot more scaling but that depends on the use case. honestly you can get really really far with a traditional db setup and nonmicroservices soa. real microservices tm are a solution for places like netflix that have immense scale both in actual customer load and engineering team count. they're as much of an organizational response to conway's law as they are a technical solution.;0
hhqd6di;Reddit;2021-10-23 13:33:21;so i want to disagree with this one here. you can have depending on database up to a couple of million operations per second until you stop finding a big enough database. i think the pattern of minimizing internal state to a service has a completely different reason persistent state is harder to migrate than refactoring code. read outage migration time persistent state is cheap. x200b sharing state between services and teams through for instance a database is fine as long as the following rule applies. changing the underlying architecture between two teams is cheaper than the more complicated architecture if they were separated. also consider the fact that some databases scale better and are distributed themselves and you can easily have two services sharing them for a very high scale think cassandra big table dynamo etc x200b also consider that if you use kafka it is persistent state that is potentially shared one to many and it is considered a microservice pattern to use it between services and it comes with the same headaches as a shared database.;0
hhq1ibf;Reddit;2021-10-23 10:43:26;i agree its really a shame this happened because the original concept was good. the same thing is happening with microservices minus the xml and add json.;0
hhsfh03;Reddit;2021-10-24 00:01:59;i did a yearlong placement at a company that argued many of those things. they'd gone allin on the idea of microservices and while there was some logic behind it the aim was ultimately that a few different teams would each maintain a data source service that could then feed into a central aggregate system in practice the result was chaos. people kept on repeating the mantra that it was better to split a service prematurely than have to untangle it later which meant that there were services for some tiny things. i don't remember people talking about a specific size exactly but the micro part of the name was definitely taken very seriously.;0
hhqb1vp;Reddit;2021-10-23 13:04:51;yes and you need 1 guys who do all that on which all the teams depend to coordinate. if the projects grow big enough this kind of thing will turn into the ultimate dependency of every team's releases. on microservice teams i was on rarely somebody there had a deep enough understanding or the willingness to manage 5 teams' rdbms dependency all day.;0
hhqhzrs;Reddit;2021-10-23 14:29:53;this imo shared db is fine as long as the services which shares the database will not touch other services table with shared databases people mean shared schemas. you can have multiple services use the same database service just fine as long as they don't use the same schema what's called a database in most relation databases. no one is saying two microservices can't use the same postgres instance.;0
hhsbymm;Reddit;2021-10-23 23:35:12;honestly you can get really really far with a traditional db setup and nonmicroservices soa this. to all the devs out there if all of stackoverflow was able to run with just a couple db servers plus standbys then your super special startuptm can pull it off up to quite a large size. what it takes is proper isolation between schemas for different purposes otherwise you end up with one monstrous ballofmud db schema that is impossible to manage good db table and indexing design if you have queries that trigger a full table scan then you're going to have a bad time when that's hitting a 100m row table multipled by many users. effective use of caching layers most of the reads should hit redis or elasticsearch etc not your db. the queries that need to read large numbers of rows to generate aggregates or stats? you can't afford to run that often the result needs to be cached or stored in a materialized view and only updated with new data. splitting up databases is about making components easier to manage and align with specific teams and about reducing some infrastructure risk. it can also save a bit of money if you're able to isolate and scaledown less performancesensitive portions to run on more limited hardware. but it's by no means obligatory for a welldesigned app.;0
hhu5p3q;Reddit;2021-10-24 09:33:29;so what you're saying if i understood correctly i need to access customer and product data inside my orders service microservices store data locally from en event sourced bus which is receives a new message every time customers and products change. i listen for these events and store a copy of that information locally. naturally this implies that we must set up an event bus with monitoring message replays and consistency checks. data is only eventually consistent so i can't be 100 sure i have all the customer or product data that matches the orders i received .. shared database i perform a join to get the data i need. i know it's consistent because the rdbms engine guarantees it .. where did i go off the rails here?;0
hhqsmxl;Reddit;2021-10-23 16:18:45;yes that comment is somewhat misguided. when we're designing a system sure i'll think about who's going to be building it but i would rarely say we have thousands of people on the same projectproduct. yet we're still building microservices.;0
hhr5hzg;Reddit;2021-10-23 18:18:33;well size does factor into it though. a smaller engineering organization means microservices are a lot of overhead when you can just get up and talk to everyone who might be affected by some change you want to make in a few minutes so you might choose to go with a more monolithic design. for a large organization it becomes more and more impractical.;0
hhqr2z4;Reddit;2021-10-23 16:03:16;wait really? my company has a single dev team so we don't have the need for microservices from the perspective of each team owning a different service. however we do have a 10 year old .net monolith codebase of dozens if not hundreds of .net projects. we've started going the microservice architecture route little by little so that we can deploy and scale different services more efficiently. is this pointless for us since we're a single team?;0
hhrh5f9;Reddit;2021-10-23 19:44:55;every celebrity engineer that advocates microservices do so with two common factors start with a monolith conway's lawhttpsen.m.wikipedia.orgwikiconway'slaw;0
hhrhg61;Reddit;2021-10-23 19:47:08;that is a distributed monolith. microservices demand true separation of concerns. for situations that demand breaking changes these should be 1. extremely rare. 2. managed over several releases.;0
hhr7inb;Reddit;2021-10-23 18:33:42;think of domain driven design as single process microservices with a super efficient inmemory service api.;0
hhue67o;Reddit;2021-10-24 11:32:59;no you pretty much nailed it. you get the initial overhead of setting up the messaging infrastructure but that is shared across the entire company. if you only have two services this doesnt make sense but if you have two hundred its not a big deal. also you dont get to skip setting up the db or monitoring on that either. in my company we're going to have less than a dozen. i'm sure some places need that many but i ssuspect that's pretty rare the consistency and added technical complexity is a bit of a problem granted. however in practice its probably highly unlikely that a customer changes his email address and then places and order within such a short amount of time that the order comes through before you can process the email change. if youre falling behind on processing those events you can disable processing the notification events as well until you catch up. if an outoforder processing type problem does happen its likely the customer will be understanding of the issue and its not the end of the world. this is more of a problem on paper than something that will likely cause issues in practice most of the time. if you need higher guarantees for consistency then sure dont go for this approach. if it was only about an email change i might agree. but it could be a delivery address change a payment method change a cancellation. all of these require immediate consistency. not to mention new customers who might not be appearing in your cache nor in the message queue. i doubt anybody is going to be very understanding in these cases. youre trading these imo rather small and unlikely problems against all the problems that come with a shared database schema. theres a huge amount of issues there that arent covered in your happy path. what you gain basically is independence for your service and your team which is a very valuable thing if you ask me. that's the crux right there. i've seen it many times. it's this idea that problems like these are samll and so rare we don't need to worry about consistency. i keep hearing about the huge amount of issues one has with a consistent rdbms but nobody seems to be able to articulate a scenario that makes any sense. and once again if you have to cache data coming from other services and you have to keep them consistent with code your independence is just an illusion. i don't believe this is the fault of microservices. in our example the data is coupled from a business perspective already. to deliver orders service customers and check the state of inventory you need to have a way of capuring the state of the data right now and not eventually. that data has a relationship in time that can only be trusted if there is a guarantee that it can't exist in an inconsistent state. if you had a weather reporting service for example i'd fully undertsand the value of keeping the process and the data separate from the rest of the system provided this data needed to be ingested by many different processes. so the service exists to keep pumping weather information for anyone who is interested. it can scale change whatever as long as the weather alerts keep coming in it doesn't matter. how that paradigm came to be seen useful in all business applications is beyond me.;0
hhqtejx;Reddit;2021-10-23 16:26:20;pointless? maybe. potentially heading into increased complexity just because it looks better than the alternative? definitely. my org just recently demicroserviced our entire platform and wrote a monolith to replace it simply because actually dealing with dependency hell and deploying multiple services that needed small changes at the same time was a pain in the ass with such a small team. for a small team making a handful of changes to a tested monolith and deploying that is much much easier.;0
hhuetbq;Reddit;2021-10-24 11:42:09;the issue isnt with a rbdms the issue is with a monolithic schema of hundreds of tables shared by dozens of teams. these tables work in conjunction in esoteric ways that no one in the company understands or dares change. pretty soon this puts you in a position where hidden dependencies and lack of faith in your deployment processes means youre unable to modify the schema in any meaningful way leading to drift between your business rules and your underlying data. soon no one can reason about the system at all and you cant do any refactoring. your system is now snowballing towards legacy hell in a handbasket. lots of people have described those issues at length in other comments in this post. if you only have a handful of devs and a dozen tables and you also need all that consistency between your data then this is maybe a sign that its all in one big bounded context and youve split your services up in the wrong way. microservices and eda of this kind is a solution to scale an organization and if youre not encountering any systemic issues like this in the development process then theres no reason to reach for the microservice solution at all. if you need to separate your services and still need strong consistency guarantees you can simply opt to retrieve the data on demand from the other service. this isnt as catastrophic as the big ball of mud you might be imagining unless every use case involves this kind of coupling. some dependencies here and there are unavoidable in real life.;0
hhqu2ch;Reddit;2021-10-23 16:32:53;ah gotcha that makes sense. our codebase is so old that a lot of projects are vb.net and no one on the team feels comfortable working there. it's as legacy as it gets. however i suppose the microservice pattern is decoupled from the concern of rewriting and modernizing it. as you pointed out we could just rewrite it as a monolith in .net core. another person pointed out that microservice isn't that accurate of a term in that each microservice needn't be small just bounded by context. since we're just a single small team it makes sense to create as few microservices as possible even if they are relatively big. that's what we've done and it's working fine so far.;0
hhs7r2d;Reddit;2021-10-23 23:02:44;i meant it is an improper comparison. if you are using microservices and have lots of interservice dependencies all you have done is distribute the monolith. otherwise yes i completely agree.;0
hhytt93;Reddit;2021-10-25 11:36:06;the issue isnt with a rbdms the issue is with a monolithic schema of hundreds of tables shared by dozens of teams. these tables work in conjunction in esoteric ways that no one in the company understands or dares change. yes in a poorly implemented database system. i'd bet good money that a poorly implemented microservices architecture is no less horrific;0
hhrf872;Reddit;2021-10-23 19:30:43;imho starting with a monolith with low coupling is the best option for most smaller orgs. ask yourself what business needs you are solving by adding the complexity of all the services. do you currently need to scale independently? does your company want to release independently? if the answer to either is no then there is no reason to go the microservice route for now. you can always split it up later when the needs arise if you build it right. keep the separations up in terms of dependencies namespaces etc. being disciplined now will give you the same flexibility with none of the weight of the services.;0
hhyyvvn;Reddit;2021-10-25 12:47:58;for sure its not great. at the core of the microservice premise is team autonomy and independence. if you have a monolithic database schema then all teams are coupled to each other and there can be no true autonomy or independence of teams. you get a spof for the entire organization and a bunch of constraints on deployments. you can still manage it but its difficult to scale in this way because you need centralized governance for it not to degrade into utter chaos and the larger the organization gets the more difficult that is to coordinate. with microservices you get increased team autonomy and independence but you trade it for technical complexity. its really that simple. if you wanna use your database as an integration layer then you can and there are some benefits to it but it comes with a cost to scaling the organization.;0
