ID;Source;Creation Date;Content;Sentiment
q8p4su;Reddit;2021-10-15;Title:Stop Using Microservices. Build Monoliths Instead., Content: https://betterprogramming.pub/stop-using-microservices-build-monoliths-instead-9eac180ac908;0

hgqpp29;Reddit;2021-10-15 16:22:49;microservices primarily allow developer scale in my experience. when you have a small dev team focus on modular components run as a monolith and you will save yourself time money and many headaches. if it's built modular enough you'll be able to microservice it later as needed. it really is that simple. people just think complicated is mandatory.;0
hgrdmxq;Reddit;2021-10-15 19:07:59;microservices vs monolith is a false dichotomy. the optimum is usually in the middle. and in the middle you have macroservices. also known as serviceorientedarchitecture. you can implement unrelated parts of your app as separate services. they don't need to be 'micro' or anything.;0
hgs6zn9;Reddit;2021-10-15 22:31:59;i agree that most companies don't need microservices but that's because most companies are small. a large portion of developers on the other hand do because large companies hire a ton of people.;0
hgs5ewd;Reddit;2021-10-15 22:20:37;take a fortune 500 company. should every single service be in one big monolith? no. should every single rest call be in its own distinct containerwebservermicroservice? no. somewhere between these extremes is a good situation. honestly i think it comes down to the datastore. most services accessing a medium sized database should probably be colocated in the same semimonolith. but then why intermix administration data mininganalysis and primiary crudbusiness purpose calls?;0
hgs8c5k;Reddit;2021-10-15 22:41:48;more like why my startup with single digits users doesn't need microservices well actually it won't matter either way since it'll fail like most startups;0
hgrbb7o;Reddit;2021-10-15 18:52:06;currently in the middle of a multi year migration from monolith to microservices and everything everything about the microservices solution is better. slightly more complexity in terms of deployment but being able to upgrade dependencies in isolation is a huge win.;0
hgtgs4d;Reddit;2021-10-16 04:55:26;controversial opinion nearly every foray into microservices i've seen has been a disaster. i find developers hugely underestimate 1. the complexity of scaling many different services 2. the challenge of making many services reliable 3. the complexity of managing state across many services 4. the complexity of reliably deploying many services 5. the complexity of monitoring many services 6. the complexity of interservice communication 7. the complexity of atomicity across may services 8. the intricate and complicated ways in which a microservice architecture can fail 9. the complexity of managing security among many services 10. the complexity of debugging an application with many services 11. ...and so forth. here's a simple question to determine if an engineering department is ready for microservices can we reliably scale deploy monitor and manage a monolith? if the team can't manage a single service well it is utterly foolish to think managing many services is a good idea. i'm currently dealing with an unmitigated disaster of a codebase my company now owns via acquisition that codebase has a dozen or so microservices that don't scale with load aren't reliable make debugging a nightmare make nearly every deploy miserable fail all the time and so forth. that codebase is the product of developers taking these silly fads at face value instead of being skeptical and discerning. stop. mindlessly. making. microservices. pretty please.;0
hgr0i35;Reddit;2021-10-15 17:38:35;i'd say it depends on the company. if it is a new project in a large company that will be hit a lot. id probably start by making microservices. but only the bare minimum. so an orders service but not internal orders and external order services. and in those i would try to silo the data into those internal and external ideas. i like doing this with packages myself. since you can see when someone adds a dependency on another package pretty easily java or node haven't worked in other frameworks however i think it is possible. i wrote a monolith that was essentially a couple loosely coupled internal microservices of different domains. worked quite well.;0
hgsjlxt;Reddit;2021-10-16 00:08:05;the problem is teams aren't actually building microservices. they're just building hundreds of tiny monoliths. a microservice should be small enough that if it needs to be changed you can just delete it and rebuild it. any bigger than that it's no longer a microservice and you're better served just building a single monolith.;0
hgrra2i;Reddit;2021-10-15 20:41:00;i prefer monolithic design but when i see a system using python functions to send individual commands by opening ssh connections to another device's command line for each microservices sound like a huge improvement nevertheless.;0
hgt83g3;Reddit;2021-10-16 03:36:34;first it was monoliths are bad and everyone should use microservices. now it's the opposite lol. i say just do what makes sense for your application. monoliths has its place and microservices has its place.;0
hgu8ia5;Reddit;2021-10-16 10:27:05;i can't take the we have many developers so we need microservices nonsense anymore. your workflow is shit? you don't understand what modularity is? you think you have to enforce that through a grpc framework? maybe pick a different career.;0
hguo6yh;Reddit;2021-10-16 14:05:26;i've got a better idea. stop propagating martin fowler's bullshit business and do programming motherfucker. not microservices but programming motherfucker. not monoliths but programming motherfucker.;0
hgsw3yw;Reddit;2021-10-16 01:51:12;i swear to god people need to shut the fuck up about monoliths and microservices and just build their shit with some foresight. fuck off;0
hgst8fc;Reddit;2021-10-16 01:27:12;i disagree with many commenters that microservices are mainly good for scale. i think robustness is a more valid reason to use microservices. i believe all programmers should know how to program in erlang just to learn the basics of good concurrency programming.;0
hgt22er;Reddit;2021-10-16 02:42:26;building monoliths is dumb. you change one thing and you have to extensively test the entire monolith. microservices coupled with domain driven design produces software that is appropriately decoupled and modular to allow for independent development and innovation at the microservice level. ive have many clients do it and are thrilled with the results.;0
hgt4hl4;Reddit;2021-10-16 03:03:56;so what might facebook be using to cause them to lose billions in revenue? i'm hearing a few of you say that you can always go microservices later but that seems to defeat the purpose to me. i've always been partial to microservices frameworks and don't even get me started about separation of concerns problems. the original author blaming their misuse of the framework for their mistakes. https;0
hgtav1k;Reddit;2021-10-16 04:01:14;i use a pattern called remote model to debug microservice data say i have currency codes as a microservice it's an isolated data domain perfect for a microservice. i publish to a json endpoint. next i might build a shipping estimation service based on currency codes. one of the endpoints will be a cache of the currency code data the remote model will poll the currency code endpoint for changes once an hour and update it's internal model. if i really need to i can flush the model by restarting the estimation server or pushing a update models command. either way i can check the internal state of the estimation server by just asking what do you think the list of currency codes is? cache invalidation is one of the two hardest problems in computer science along with naming things and off by one errors which for me justifies the extra investment in tooling to make cache invalidation work well. a monolith has the same caching issues but you have slower build times longer test cycles and a slower cadence of release. my advice check your whole value delivery pipeline from idea to pr merge to feedback from user to figure out where your development bottlenecks are and then decide whether you want to continue a monolithic code base or build lots of small domain driven microservices.;0
hgttjj3;Reddit;2021-10-16 07:06:56;the biggest annoyance regarding microservices is that everyone builds their own. with no controls over who is building what you end up with 20 getorder services all slightly different perpetuating the problem because a newcomer doesnt trust any of them.;0
hgty4ad;Reddit;2021-10-16 08:02:39;i dont think microservice is superior to monolith. its a different approach to a problem. if the a project needs microservice approach it has to be done that way. problem is lot of startups going microservice for every project just because all big tech companies like uber netflix doing it. often they think oh it just 3 or 4 microservices that will communicate over a rest api. after 2 years of development they like 20 of microservices plus devops maintained by 3 developers. imo if you cant design a good monolith system you definitely can't design a good microservice system. modular monolith is a good option. it will allow to go microservice as needed. ps sorry for my english;0
hgu5zmd;Reddit;2021-10-16 09:50:04;i have seen way too many microservices that are coupled so tightly that if one of the services go down it takes down the entire application with it. that's not how it's supposed to work tho. if it's that tightly coupled why use microservices to build it?;0
hgvqtry;Reddit;2021-10-16 19:24:33;before the arrival of microservices monolithic used to refer to applications that were designed with no modularity a bad practice no matter how you cut it. calling an application a monolith was akin to saying it was poorly designed. now all of the sudden anything that isn't a microservice is a monolith.;0
hgxnmwh;Reddit;2021-10-17 04:01:26;microservices suck. they leave you with 47 different repos and it's an impossible amount of work to maintain them and fix bs tech debt. they sound good in principle because you can write your new thing in some other programming language and pile it on top of the jenga pile. but you better get a new job before the tower collapses and you're stuck maintaining the mess.;0
hgrxkjc;Reddit;2021-10-15 21:24:42;if it's built modular enough you'll be able to microservice it later as needed. this. the reason microservices are a hit is because they force modularity and separation of concerns. generally i think that program should split out in phases that could eventually lead to microservices if the need arises 1. modularization code is separated into libraries with separate concerns. all shared concerns are thrown into a third shared library so neither library should depend on each other or one should be a clear dependent on the other. 1. semantic decoupling. basically the modules begin to have separate languages that are completely enclosed. this will require building new types and such. you may want to redundantly reimplement types and utility functions and have them share a single implementation from the third library. basically you should be able to describe the terms and semantics of each module independent of the others. the one exception when you have a module that is a explicit dependency on another module that exposes this dependency honestly and transparently ie the api of the dependent module is clearly just an extensionexplicit user of the other depended api and it doesn't make sense to describe it otherwise like a data layer that is clear about it talking to a database behind the scenes. 1. contract enforcement. libraries are further separated visibility is strongly limited and strong api contracts are done. this is mostly adding tests and documentation on that. at this point the technical debt should be managed. the issue comes when you want to scale move things around or rewrite modules into entirely different things. a solution is to move it outside. 1. stubout expose the library in a way that is separate of its implementation. change a doers into interfaces etc. 1. lamprey out. this isn't making the module into a dynamic library that's the easy step you could do above but it has little benefits in a tightly controlled environment as a server. it's making it a separate binary that talks through a rpc system. you'd still keep them as a single service the main binary would start the subbinary as part of startup. it would all look exactly the same from the outside it's still a monolith but a single containervm that now contains multiple processes instead of the one. 1. here you can do rewrites into other languages or shift things out. you get most of the flexibility of microservices from the point of view of a developer. you can also release binaries in separate cadences as separate packages that are then deployed together. 1. spinout separate service. this is where you actually get the scalability and support benefits. lets you scale different services at different rates and if you get a catastrophic disaster like running out of resources you can prioritize only the services needed to have a gracefully degraded experience and drop the others. very few would have a need for it. the key part that most people would be fine with is the lamprey. there's relatively few cases outside of faang that benefit of the full microservization of this. but 80 of the steps benefit almost everyone the modularization and clear contracts and even the next 10 gives almost all the advantages that people tout.;0
hgr6bzm;Reddit;2021-10-15 18:18:11;i think it's a balance. in one way i prefer a monolith. we have a few microservices and all they've done is slow down development from having to start 4 microservices locally pulling down the latest versions deploying 4 different applications keeping a test suite running that connects all 4... i haven't seen the benefits. i think to benefit from them you need to be in a larger team where you have individuals responsible for making ci and testing etc easier and more automated otherwise it just ends up being a huge time sap.;0
hgr4sij;Reddit;2021-10-15 18:07:34;great summary. but i hope we can stop arguing again and again what are the advantagesdisadvantages of microservices as imo those are pretty much obvious now that we have so much collective experience with them and the alternatives.;0
hgrmzri;Reddit;2021-10-15 20:11:41;well said. microservices are just libraries with a slow unreliable function call abi. the only real advantage i've heard for them is that they allow you to scale different parts of your system independently.;0
hgsdx3t;Reddit;2021-10-15 23:23:42;ive always been of the mind that microservice architectures are an expression of conways law. thats not a value judgement on microservices they arent good or bad they just are and they have trade offs.;0
hgr5tf3;Reddit;2021-10-15 18:14:39;microservices primarily allow developer scale in my experience you omitted word complexity. microservices scale process complexity upwards. the moment you opt to do them you fall for all network fallacies.;0
hguw7qj;Reddit;2021-10-16 15:26:08;if it's built modular enough has anyone built a framework that moves in and out of going from monolith to microservice?;0
hh3x2q6;Reddit;2021-10-18 15:55:41;how small of a team? microservices do a good job of formalizing service boundaries in code rather than having to go through that with each code review and making sure that the boundaries remain intact. a single repo and one hasty prreview can allow coupling and risk to creep back in. separate servicesrepos create implicit friction that make it harder to accidentally introduce those types of regressions.;0
hgrwq5v;Reddit;2021-10-15 21:18:51;this is what we're working on moving towards from monolith. the article talks about how keeping data insync across microservices can be challenging. and well i mean don't? if the data is sensitive to timing and that tightly coupled it shouldn't be separated by the network. that's why it's so challenging. macroservices keep all the coupled data together while letting you separate the uncoupled data.;0
hgtfwbw;Reddit;2021-10-16 04:47:11;also you can have a monolith that runs the bulk of your stuff and bunch of microservices that do the lessused things.;0
hgt8l0i;Reddit;2021-10-16 03:40:55;large companies also buy many smaller ones in a sense collecting selfcontained services once they've matured and teams already silo'd off from the rest of the developers and thus predisposed to microservices by conway's law.;0
hgs66lo;Reddit;2021-10-15 22:26:12;well i'm happy to share you this piece of knowledge about the microservices from googlehttpscloud.google.comarchitecturemicroservicesarchitectureintroduction they explain the benefits of monolith and microservices the problems you might end up with how to make them communicate etc. the kind of thing i wish i knew before migrating a monolith into microservices for the first time it didn't end well i must emphasize that google does consider that your microservices are talking over rpc and not rest and i agree with them don't try to make rest apis if you're only getting called by an internal service of your team.;0
hgrtkxw;Reddit;2021-10-15 20:56:58;geographically dispersed teams nothing wrong with accessing your alm and the rest from anywhere on the planet though... differences in security and auditing requirements across services so two libraries do that differently what's the big deal? differences in technology certain domains have better tooling in particular languages ffi is a thing and when it doesn't work ipc or rpc isn't hard. differences in the pace of release cycles interface compatibility must be preserved and at that point it doesn't matter what part of the program is taken from what build. and dig this it is absolutely the same with microservices. if there is a client for v1 of the service v2 can exist but v1 must stay. heck even c libraries go through multiple versions without affecting existing older clients. in other words all of the above purported benefits of microservices have been available by various tech way before a word microservice even existed. benefits exist but they are elsewhere they are e.g in the supporting software that helps with deployment scaling and the like.;0
hgrstbe;Reddit;2021-10-15 20:51:28;i've dealt with both monoliths and microservices in corps somewhere between start up and enterprise not really either and i'd take the monolith any day of the week. every single time i've been on a project that started as microservices it's been a big fucking mess with mud and shit smeared across queues network calls and weird shared databases both monolithic and nonmonolithic. and the one time i've watched from a distance a monolith get decomposed into microservices there was a glimmer of hope in my eyes until the architects feel asleep at the wheel and some jackass got things so mucky mucky again. and being outside the project my opinion was immediately discarded because what do i know because how could anyone know that putting another service in as a submodule and treating it like a package would end in suffering and pain truly a mystery.;0
hgygp8w;Reddit;2021-10-17 08:48:36;i feel like the scale of monolith and micro service isn't great. to me it's too monolithic if deployment takes too long or if there's too many unrelated services in it. it's too much of a microservice when you start to have to call too many apis to accomplish something simple.;0
hgru0ow;Reddit;2021-10-15 21:00:06;people have been updating dependencies decades before the word microservice existed. tell me what was your problem and i tell you how it was solved.;0
hgv47mm;Reddit;2021-10-16 16:35:22;exactly. an operating system is by the microservice fanbois' definition a monolith. and yet it's so modular that a separate team can develop the disk io subsystem without involving the folks who schedule threads because their part is modular and separate from the rest of the system such as the ui and so on .. somehow they manage huge teams without needing a rest api between each of the modules;0
hgv3l4j;Reddit;2021-10-16 16:30:17;that's what's happening where i work. new managers came in and declared we're going to use microservices. i'm powerless to stop them and for the reasons you mentioned we're going to be in a world of hurt soon.;0
hgrt9qq;Reddit;2021-10-15 20:54:43;sounds like your putting innovation ahead of business value. there is nothing about using php that forbids you from using ml. of course you don't write it in php but that's not what a monolith is. even monoliths have external services. the difference is that a monolith is a unified source of all business logic. a microservice splits things into different applications. sometimes the business is so complex that it's warranted.;0
hh2np7q;Reddit;2021-10-18 06:42:00;i agree with you but just to be fair you can apply those ideas to a monolith. if your monolith requires extensive testing there is no reason your suite of microservices wouldn't also need that.;0
hguadpv;Reddit;2021-10-16 10:55:06;yep. design for microserviceability not microservices.;0
janggea;Reddit;2023-03-02 19:10:58;do you have an example of a module converted to microservice?;0
hgr5735;Reddit;2021-10-15 18:10:21;you say that but with lots of people adding things in different places and styles the project becomes difficult to reason about very quickly so microservices with clear boundaries mean smaller parts are easier to understand and replace if needed as a solo or small team none of that applies because it is easier to coordinate and the each dev knows a much larger portion of the codebase;0
hgs2nhz;Reddit;2021-10-15 22:00:41;are a hit is because they force modularity and separation of concerns. the real disaster comes when teams learn that's not true and they've scattered concerns across many microservices.;0
hguy45l;Reddit;2021-10-16 15:43:20;this. the reason microservices are a hit is because they force modularity and separation of concerns. they are hit for usual reasons few big companies did it coz it fit their architecture and now everyone wanting to feel modern copies it. lamprey out. this isn't making the module into a dynamic library that's the easy step you could do above but it has little benefits in a tightly controlled environment as a server. it's making it a separate binary that talks through a rpc system. you'd still keep them as a single service the main binary would start the subbinary as part of startup. it would all look exactly the same from the outside it's still a monolith but a single containervm that now contains multiple processes instead of the one. that is entirely terrible solution. you don't get any benefits of microservices with all the drawbacks each of those would still have to have healthchecks and all the other crap related to having something run separate reconnect logic more complex deploy etc.;0
hgsstpn;Reddit;2021-10-16 01:23:44;they are a hit because they hide problems that monoliths would reveal almost instantly. so they seem good because its essentially a form of obfuscation. basically people seperated concerns so they didn't even have to care about anything. they created an abstraction where every problem was another teams problem. issue is every other team is thinking the same thing. what microservices offer is a blameless pile of spaghetti where everyone can pretend it's not their problem. it's literally perfect for modern software development.;0
hgrs780;Reddit;2021-10-15 20:47:07;that's what he said yeah. i worked at amazon and it was all microservices and it was awesome. because each one was owned by an entire team so we weren't compiling their code we were just hitting their api. they also had multiple customers and they could scale up and down for each independently. if your a small team working on a single unified project though? monolith all the way.;0
hgua8t3;Reddit;2021-10-16 10:53:01;from having to start 4 microservices locally pulling down the latest versions deploying 4 different applications keeping a test suite running that connects all 4... i haven't seen the benefits. based on this i'd say the problem is that you're not building microservices you're building a distributed monolith.;0
hgzruig;Reddit;2021-10-17 17:24:15;you can use smaller web apis instead of microservices if you just need to scale independently. my hot take on microservices is that it helps when your staff are themselves disorganized similarly as small independent teams who dont agree on the same platforms packages or tooling.;0
hh3zilf;Reddit;2021-10-18 16:14:54;it likely depends on the scope. but if you have one person managing more than one microservice then you've made a mistake.;0
hgu39zi;Reddit;2021-10-16 09:11:35;microservices is poorly defined.https it's hard to know what's needed to achieve microservice status.;0
hgtxg2k;Reddit;2021-10-16 07:54:02;yeah i like this one better in my previous company we joked about one of the microservices being a macroservice due to its massive size compared to other codebases that we had.;0
hguaevq;Reddit;2021-10-16 10:55:36;we have a few monolithic microservices in our platform;0
hgsoocj;Reddit;2021-10-16 00:49:10;if you develop a monolith even with soa you almost certainly will never have the opportunity to do the parting things out. it's almost impossible to make the business case for it you'll have to develop brand new communication layers unless you did that already but if you did that already why did you make a monolith you just made the worst of both worlds in reality 99 of the time when you approach a nontrivial project like this all the monolith is is hour 0 tech debt. legacy software is one thing but for new projects your use case either calls for microservices or it doesn't and you should design appropriately instead of having a massive albatross around your neck from day 1.;0
hgt8bmu;Reddit;2021-10-16 03:38:32;i must emphasize that google does consider that your microservices are talking over rpc and not rest and i agree with them don't try to make rest apis if you're only getting called by an internal service of your team. and yet more and more people continue to build microservices talking with and or layering over rest. which becomes a large hassle really quickly.;0
hgrzzko;Reddit;2021-10-15 21:41:46;for geographically dispersed teams i was thinking more about the difficulties of meeting around different time zones. a team in australia isn't going to talk as often with a team in the us. for differences in release cycles having separate services allows you to redeploy only the service that changed rather than redeploy the entire system. this can save time depending on the infrastructure involved. i could talk about the other two points too but my point wasn't to say that microservices are the only solution to these problems there are other ways to establish boundaries around software components and teams but that microservices are appropriate for more than just large teams and companies with deep pockets.;0
hgsj7dj;Reddit;2021-10-16 00:04:53;security is a crosscutting concern and if you have two vastly different noninteroperable levels of security in the same app that sounds like madness. as for paces of release cycles it's less about compatibility and mainly about it's going to take seven weeks for our next release cycle for a minor bugfix. there are also more manageable concerns like how can i accidentally fuck the server during deployment and how much downtime will it take to deploy this tiny fix which are much easier to work on with more lightly coupled microservices.;0
hgsuqg6;Reddit;2021-10-16 01:39:44;microservices don't really solve anything. the hard part of systems is the strong coupling and the constraints that accrue over time that make them harder and harder to comprehend and add to. the guy who came up with microservices was like how do we just pretend that never happens and everyone just started writing their own apps and stringing them together. that means you never have to care what everyone else is doing! they must have been comediens. the problem is all the coupling is still there. all the constraints are still there. it's just now been splattered all over the place in 300 different programs. now it is impossible to tell what is going on. anyay yeah i feel your pain.;0
hgs6ppj;Reddit;2021-10-15 22:29:59;you can't compare greenfield to alreadyenterprise sized. monolith does not equal spaghetti. you can make spaghetti in a monolith and you can make it in microservices. if you think you can't that complacency will end up being painful. but problems and difficulties that end up leading to spaghetti come with size. the larger things get the more difficult it is to keep the code clean. and the problems increase exponentially. thus the everrenewing churn of people going of to make the wheel again but this time not make a mess. starts out great. ends up a mess. thinking because you can start great must mean you are great and won't end up making a mess is a mistake.;0
hgtq5l0;Reddit;2021-10-16 06:29:18;i don't think this is really lava flow unless they have internal shared libraries between different parts of the code base which is doing microservices wrong imho. if we are talking about external dependencies that don't show up in the apis between microservices maintained by different teams team 1 on version 2.2 and team 2 on version 4.0 is better than a monolith where everyone is stuck on version 2.1. it is only lava flow antipattern if you have accumulated code as an accident of history from failing to refactor this can happen internally to a monolith or a microservice but an oversized monolith is harder to recover from vs a microservice where worst case you rewrite the bad microservice.;0
hgvt07c;Reddit;2021-10-16 19:39:45;microservice architecture doesn't mean not monorepo so its rather easy to enforce version consistency if you do it that way. we only allow one version of any dependency.;0
hgvq7df;Reddit;2021-10-16 19:20:22;microservices don't have to suck. but the approach many so called experts push especially concerning the database side is a recipe for pain unless you really know what you are doing and need that degree of separation. now if you are coming from completely separate data silos yeah that makes sense. but to plan for that is kind of ass backwards imo.;0
hh61mm3;Reddit;2021-10-19 01:09:44;usually monoliths require extensive testing because of tight coupling. if microservices are designed correctly they are loosely coupled and you can modify a microservice and test it without having to test the entire application. thats why using domain driven design is so important. most monolithic applications in service today were built over years with capabilities added as needed and perhaps the design over time got too tightly coupled. i consult in application modernization and see this kind of legacy code all the time.;0
hgyq8xe;Reddit;2021-10-17 10:56:55;that is entirely terrible solution. i disagree. i think it's a solution that makes sense under very specific situations. sometimes it makes sense while full microservices won't. you don't get any benefits of microservices with all the drawbacks i disagree in some levels. first you do get some of the benefits. you're able to get separate languages and have them interacting separately. you are also able to isolate failure areas. that is services that are not critical can have the failure handled at os level instead of at binary. the main binary which is still the same critical binary for the job could decide to reboot services or simply fail. ultimately there's a reason why we still simply start subprocesses for many things. it's not that bad. each of those would still have to have healthchecks and all the other crap related to having something run separate reconnect logic more complex deploy etc. yes and no. the advantage is that a lot of these problems are way easier when you are running on the same machine. it's easier to know the binary is working well also with ipc it's a lot less trouble to imagine what could happen inbetween. you still could have problems but these are already handled by the libraries meant to access services on external machines pretty well already simply reuse that logic. startup is also much faster and trivial since the space was already allocated locally you don't need to start a new paxos routine to decide where to shove the next job at so a lot of things become faster. this also is a great solution to having thick clients when you have a service that is separate but a lot of logic needs to exist in the client. if you have everything in one language that's great. if you have two languages that means you need two copies this can keep growing. by having the services running as separate things you can simply reuse the same library for the thick client. and you could use dynamic linking swig and what not to get a similar thing but that's its own pain and it's very much a deadend also disadvantaged that it's different from how everything else in serverland communicates with. though of course this wouldn't be something i recommend outside of server software i think it's a pretty reasonable solution. the hard thing is keeping the binaries under controlled in a larger space but containers already solve that problem and you probably though about moving to containers way before you consider having to split your job though it doesn't have to be kubernetes there's great middleoftheroad solutions for containers too. that said i do agree there is a real cost both in terms of runtime costs and development costs to doing this. every phase has it. the whole point is you can choose when to stop or when to go on. you can also choose to skip when it makes sense and i do think this is one were the cost of skipping is minimal so many do so. that's how large companies did it they just kept gradually moving towards this as their needs scaled and justified more complex systems. they built great tooling to define a large solution and built it entirely so. the whole point is that it's a continuous thing it's not all or nothing but something were you can go improving it as needed.;0
hgt1haf;Reddit;2021-10-16 02:37:19;they are a hit because they hide problems that monoliths would reveal all most instantly. so they seem good because its essentially a form of obfuscation. i mean you have to be clearer and more specific than that. i could switch it up. monoliths are a hit because they hide problems that microservices would reveal almost instantly. so they seem good because it's essentially a form of obfuscation. examples would data and services coupling shared functionality that isn't related wasteful inefficient pieces of code that are hidden over the huge resources other functionality requires but the inefficiency still costs you cpuhr. basically people seperated concerns so they didn't even have to care about. they created an abstraction where every problem was another teams problem. issue is every other team is thinking the same thing. clear responsibilities among teams is an important concern and management. and there should be work to find out orphans and manage them. monoliths don't fix these issues they can also hide it. you'd be surprised at how many times projects fail because of concerns on a piece of code everyone had forgotten because no one owned it. but because it all compiled nicely into the binary no one noticed. until its broken and someone else should. this is partially why people talk about blameless audits and postpostmortems. when people aren't scared about being blamed for something and understand they will be responsible for orphans and problems even if they weren't owners of the core cause means this has a lower chance of happening. people are more eager to take ownership. you are right though this is a big problem on software. microservices doesn't make it better or worse. what microservices offer is a blameless pile of spaghetti where everyone can pretend it's not their problem. it's literally perfect for modern software development. this is an issue. microservices is many times used as an excuse for cowboy programming. adding a new service no matter the size should not be trivial and have a solid justification. but i've seem as much spaghetti with everyone blaming others. in monoliths it can be even worse because it's easy to no have contracts. it's easy to go in fix someone else's code and then break half the uses because you switched the semantics to what made sense for you but wasn't the original intent. microbenchmarks force you to set this rpcqueue border that makes it clear you should work with the way anything on the other side works. it doesn't matter if you have a monolith your code should be heavily modularized you should avoid changing functionality of other modules and instead work around it and if it's an issue later fix it as a separate thing and clear ownership should exist. here this is one of those areas were microservices work. not because they magically fix it but because they make the painful decisions obvious and upfront. instead of something you realize when you are reading a 10 wtfs piece of code at 3am trying to understand how an outage corrupted data in order to undo it of course there should be a backup but in places with these issues sometimes backups are not done often enough.;0
hgu4u3m;Reddit;2021-10-16 09:33:45;what microservices offer is a blameless pile of spaghetti where everyone can pretend it's not their problem. cloudified blame brilliant! that's worthy of a dilbertorientedprogramming award.https 🏆;0
hgsyvn4;Reddit;2021-10-16 02:14:57;exactly what i thought about microservices concept i mean sure it is easy to scale but mostly this is concept for rapid development where poor code optimalization isn't an issue. proper microservices can work fine but now this concept is used on every project without thinking if it is needed.;0
hgsmvkz;Reddit;2021-10-16 00:34:33;in what way would this make you run out of memory? it's no worse than a monolith memorywise at least. there's a tiny performance overhead but the ability to use highly efficient c code in performance sensitive code more than makes up for it. and if you have individual boxes running out of memory splitting them into microservices is trivial from a functional point of view though there may be logistical challenges in making sure the availability of the microservice is good enough to ensure the larger service runs.;0
hgs2g0e;Reddit;2021-10-15 21:59:13;you mean you didn't have teams of 2 devs making a dozen microservices each?;0
hgs4vll;Reddit;2021-10-15 22:16:46;this is the way i've seen microservices done best even at smaller companies although still large enough to have multiple teams. each team can broadly structure their system as they like and release as they like as long as they don't break an api promise to another team and the teams interact via explicitly describes web interfaces. even within a single team splitting things like frontend and backend can be helpful if you've got different release schedules or processes. it makes crosscutting work more complicated because you end up negotiating across different teams and services but that can also be a question of business organisation rather than technical organisation.;0
hgrseq2;Reddit;2021-10-15 20:48:36;so selectively choose when to make it a microservice? sounds great assuming you haven't chosen some framework that makes that a massive uphill battle.;0
hgskqlt;Reddit;2021-10-16 00:17:12;this can happen outside of microservices too. my org has a shared lib and then a dozen or so apps. someone writes something in their app and it never makes it into the library because why would it. except now 8 people have written the same function. it's getting better with less of that but it's still not perfect.;0
hgtj04w;Reddit;2021-10-16 05:16:50;as for paces of release cycles it's less about compatibility and mainly about it's going to take seven weeks for our next release cycle for a minor bugfix. there are also more manageable concerns like how can i accidentally fuck the server during deployment and how much downtime will it take to deploy this tiny fix which are much easier to work on with more lightly coupled microservices. i disagree. it doesn't have to take several weeks. update a dependency with a fix deploy what's the problem!? about how can i accidentally fuck the server during deployment this is a consideration with a microservice just the same why wouldn't it be!? and regardless 1. deploy on a reduced set of servers say one out of two you have and test 2. surely backups and rollback are available!? about how much downtime will it take to deploy this tiny fix but that is completely unrelated to microservices. depending on your tech stack it can be e.g old asp.net copy a new module to your bin directory watch old app domain dry out ongoing requests and new one run with the new module. or it can be 'take one server out of load balancer again lbs support drying out ongoing requests update put it back rinse repeat 0 downtime'. and seriously all of what i am saying has been possible and done decades before the word microservice existed.;0
hgsvutt;Reddit;2021-10-16 01:49:04;microservices don't really solve anything. that feels like swinging too far in the other direction. i've definitely seen instances where splitting something off into it's own corner drastically improved things. for example my last job has its own bespoke auth tokening service why i don't know but it was there whether or not this was wise is different conversation so we were able to stuff a little thing between it and everyone else they allowed us to generate fake auth tokens for testing got a story that says only people in the customer servicing group can do x just generate a fake token for cs and a fake token for other groups rather than asking for new ad accounts it had to create and teardown and w engineering had to jump through hoops to deny access in production. the woman that made that was qa's favorite developer because she saved them literally hours upon hours of work interacting with it to get test accounts. so there's definitely a benefit i just really question the just always do microservices lol approach.;0
hgyh1es;Reddit;2021-10-17 08:52:48;internal shared libraries between different parts of the code base which is doing microservices wrong imho. the fabled distributed monolith;0
hgz1yki;Reddit;2021-10-17 13:32:53;ah yes.. microservices solving dependencies... by splitting everything into 50 deployments so you can just update the dependencies on the one thing you care about this week and 4050 of the things just code rot.;0
hgr4fr2;Reddit;2021-10-15 18:05:09;there's a talk on youtube called majestic monolithshttps it locks you in one language but it is what microservices should have been.;0
hgwknr1;Reddit;2021-10-16 22:58:32;they especially suck when the data is coupled for business reasons but because the microservices call for data separation we lose enginelevel guarantees that an rdbms could provide and instead we're developing clumsy handrolled integrity checks while we replicate data to each others' services. not because any of this makes any technical sense we're just going to implement full microservices hell or high water no matter the cost for the sake of microservices;0
hh62c2b;Reddit;2021-10-19 01:15:20;you can use interfaces and have loose coupling in monoliths though. microservices should have as much testing as monoliths have. we just call those tests contract tests instead.;0
hgvd23n;Reddit;2021-10-16 17:44:45;except when you changed 100 lines in xyz a and b and something bad happens that you can only find if you examine the changes across all the services. but microservices are independent! well only if you do them right . we don't do monoliths right and they're fucking simple. people think they're going to get microservices right? lol.;0
hguv6u0;Reddit;2021-10-16 15:16:35;that was my point. too many microservice advocates think their architecture prevents intermixing of concerns.;0
hgv9nur;Reddit;2021-10-16 17:18:57;you're right. it's funny that both monoliths and microservices hide the same problem opaque hardtorecognize coupling and incorrect mixing of concerns. monoliths hide it by making it so easy you don't notice the problem this is like git and branches making branching so easy you don't notice the problems they create. you suffer from the problems but seeing the real cause is difficult. microservices hide the same problem by hiding collaboration in a sea of unchecked json data. semantic dependencies are difficult to recognize until an ugly problem develops. the real problem of mixing of concerns is being shuffled back and forth between different ways of hiding the problem rather than solving the problem which mostly involves discipline and staying vigilant.;0
hgu6pfo;Reddit;2021-10-16 10:00:31;monoliths are almost always bad. microservices are almost always worse. i think the cause as to why monoliths fails is the same reason microservices exist. it's a serious lack of big picture thinking and reasoning about how everything should fit together. it's a holistic problem and people make an assumption there is technoligical solution which is already a step in the wrong direction.;0
hgucbta;Reddit;2021-10-16 11:24:30;the whole point of microservices is they can be built tested and deployed separately. each microservice should be a self contained unit functionally independent of each other. if you need to build and run multiple services as part of you dev process then those services aren't microservices they're just one big service you've split into separate code bases.;0
hgrsk5r;Reddit;2021-10-15 20:49:42;i don't know that i would ever agree with someone that 2 webservices constitutes a microservices architecture but you do you boo.;0
hgsni22;Reddit;2021-10-16 00:39:33;ok there's a lot of uncertainly especially with new software but if you know your goal is to migrate to a microservices model just start there instead of accruing tech debt from hour 0. unless you have a very junior team or something who needs room to grow into it. any speed gains you make in your initial product are going to be wiped out and then some when you migrate your services over.;0
hgtmj1s;Reddit;2021-10-16 05:51:24;i'm not saying it can't be done in fact i thought about addressing the server set deployment which vs microservices also has to maintain database compatibility for its own previous versions and also its public api to work. as for deploying things at large scale releases get screwey. it's absolutely stupid that some devs can't deploy what's the problem? but it is in fact the case and microservices can make that a team level decision instead of some sort of corporate hellhole in enterprise anyway. i'm sure a lot of dedicated tech companies are way better about it.. really microservices are just a way to buzzword some granularity into deployment models and dev teams. if they can't do that then their implementation has been worse than useless i know at least one enterprise team where this has been the case. to me the theoretical scalability of microservices is absolutely worthless in comparison to what they offer in terms of team and mental independence. monoliths can be scaled in the same way as microservices unless you have a crap architecture but being able to have totally separate codebases and by extension repositories and teams is much more useful.;0
hgswa9v;Reddit;2021-10-16 01:52:41;i wouldn't call that a microservice. microservice encompasses not only splitting stuff off but the ideological mindset that comes with it. you need the full package for it to be a microservice imho. it's always the mindset and culture that tends to be the problem because it's incapable of thinking about anything outside of itself.;0
hh62ly0;Reddit;2021-10-19 01:17:31;true but by using microservices and containerizing them you can scale more efficiently. there are a lot of benefits to microservices.;0
hgstq2o;Reddit;2021-10-16 01:31:18;microservices are essentially impossible to reason about by design. it is seperation of concerns taken to the extreme. you aren't supposed to be able to reason about other services because that means you havent seperated concerns enough.;0
hgvdqsh;Reddit;2021-10-16 17:49:50;functionally independent of each other so they don't ever have to call each other? then who is calling a microservices api endpoints?;0
hgruosp;Reddit;2021-10-15 21:04:43;well there is a difference between a microservice architecture and a microservice. if something is a small isolated system with its own stack logging repository and url than it's a microservice. i do agree i'd prefer a monolith with the occasional microservice where it makes sense but you can't blindly create a monolith without considering the possibility that you might need to split it up at some point.;0
hgveruq;Reddit;2021-10-16 17:57:17;why would microservices ever be the goal? my goal is to make money. create a product that offers a useful service and do it as cheaply as possible. microservices might be a solution but it's never a goal. we're always chasing solutions and forgetting they need problems or we're wasting time and energy. and we forget to measure costs properly when a solution is the goal. it actually becomes our goal to incur the costs! terrible.;0
hgsylcm;Reddit;2021-10-16 02:12:29;ok there's a lot of uncertainly especially with new software but if you know your goal is to migrate to a microservices model just start there instead of accruing tech debt from hour 0. why would you start any project with the intention of microservices? i understand building a modular code base that's not just all clumped together but starting with microservices introduces all kinds of complexity and overhead and work that's not likely to pay off for years if ever. why do you need a message queue and a service to do little bits of logic that result in calling another service when you could just use an in process broadcast? when the overhead gets too much there's several ways i can think of that can address that without breaking parts into a separate service use the database as a work queue use redis as a work queue write the message to kafka or something and read them back in on a separate thread if you're feeling really spicy use an in memory queue and block shutdown on it emptying out crashes will still fuck you though and to be clear i don't mean a company starting a microservices project to decompose an existing code base because you have an the scars and learning hopefully to know how systems should be divided. i mean starting a new project from day 1 with the intent of microservices.;0
hgtnzma;Reddit;2021-10-16 06:06:34;to me the theoretical scalability of microservices is absolutely worthless in comparison to what they offer in terms of team and mental independence. monoliths can be scaled in the same way as microservices unless you have a crap architecture but being able to have totally separate codebases and by extension repositories and teams is much more useful. that too is something that existed way before the word microservice existed. since forever people compose programs using say libraries that come from different sources including different companies or oss repositories. it rather looks like you are just hoping that sprinkling the word microservice will alleviate various organizational problems we encounter. in some of my experiences the opposite has been the case problems were compounded by microservices.;0
hgwzb4n;Reddit;2021-10-17 00:49:07;i meant independent as in not dependent. as in service a doesn't need to care how service b works it's just making a service call and getting a response. effectively independent might have been a better phrase. that said you can use event driven architecture for connecting your microservices which is often the preferred pattern in which case they don't need to know about each other at all.;0
hgrxbe4;Reddit;2021-10-15 21:22:56;well fuck then that 500k loc webservice is also a microservice. it too has it's own stack logging repository and url. here's a crazy thought ... lets not fucking play the semantic game.;0
hgsv22z;Reddit;2021-10-16 01:42:24;designs can certainly evolve from a simple system's concept. you don't have to have actually implemented that system especially with experienced engineers. also the jump in complexity from a monolith to microservices isn't as vast as it used to be. we have so much tooling around the concept now that neutralizes a lot of the complexities into simply gluing api's together;0
hgsz3vr;Reddit;2021-10-16 02:16:57;work that's not likely to pay off for years if ever. because i can either do all of this stuff now or i can do it later and i'd rather just do it now if i'm expecting any number of things that microservices will solve. this sounds like a problem that a small or new team would have but at a certain level of maturity an organization should have a pretty decent idea on if the upfront effort which is becoming less and less every day as the tooling continues to mature is going to be worth it or not. if you're not sure if it'll pay off then yeah starting with it is a bad idea but that's also a whole other problem with your organization.;0
hgtq3jm;Reddit;2021-10-16 06:28:42;i think all buzzwords are equally idiotic and that it is unfortunate that they have been tainted by bad applications and incorrect reasoning because there can be some good general architecture ideas hiding under layers of crap. the enterprise i know that added microservices to their new project did so for illdefined reasons with overzealous implementors and it seems to be going very poorly. however a lot of the ideas in microservices can be used in legitimate architectures to decrease burden. function as a service is still just madness without a use case and excessive cost though. another commenter was right in that it's still going to be a spaghetti mess of crap because if your architecture and designers are crap it's going to be crap regardless.;0
hgsw2ch;Reddit;2021-10-16 01:50:49;no one intended it to be that. that's just what they turn out to be because no one is self critical enough to realise that microservices don't solve anything.;0
hgtb1qy;Reddit;2021-10-16 04:02:55;because i can either do all of this stuff now or i can do it later and i'd rather just do it now if i'm expecting any number of things that microservices will solve. and how exactly do you know that you're going to need any of this? why not invest in building the simplest thing that could possibly work cultivate so it doesn't turn into a mess and then split off the chunks when they need to be split off?;0
hh08xfu;Reddit;2021-10-17 19:26:06;to be frank your definition seems tied to a 90's way of looking at things. modern servers distribute loads in a virtual way such that defining service but how it's being run on the machine is antiquated. the stored procedure doesn't have an api how are you defining api? why define service by whether it uses json or some other syntax? it shouldn't be about syntax that's too arbitrary and swappable. same result different syntax. if it's the same result why define it by call syntax? defining service or process based on command syntax or machine configuration is not useful in terms of application usage. there are dozens of ways to achieve the same result send a command get data back scgdb. if there is something special or particular about the way microservices does scgdb what is that key ingredient or difference? stored procedure doesn't exist separate of the database why does this matter?;0
hgsovaz;Reddit;2021-10-16 00:50:44;i didn't define a microservice in that manner salbris did. that their definition also includes a 500k loc webservice is exactly the problem with their definition.;0
hgsoqww;Reddit;2021-10-16 00:49:44;a monolith is actually far more complicated than a set of microservices snip. you are wrong. what you mean is that you do not see the complexity because other people wrap you in swaddling. if you had to actually deal with the ops side of that equation you would not have this opinion.;0
hgvgarf;Reddit;2021-10-16 18:08:20;experience should enable to you build something without things you don't need and yet still be easy to change to microservices in the future if the need arises. that's what real experience enables.;0
hh2q1gw;Reddit;2021-10-18 07:08:31;sorry didn't mean it to sound so condescending. the point i was trying to get across is that when sliced properly changes in other services that don't affect their api should not have any affect on other services. if that isn't the case it's a strong sign that you haven't sliced your microservices optimally. most commonly there's some third service that should exist on it its own but ended up being split across two other services.;0
hgveawp;Reddit;2021-10-16 17:53:51;i think salty's point is that there's a conceptual difference between identifying a need to pull out 1 or 2 specific pieces to run separately and be scaled separately and microservices which as an architectural concept involves separating all the domains into separate services that are supposedly independently developable and deployable. i think it's a good point even if salty is being a bit salty about it.;0
hgvm7ky;Reddit;2021-10-16 18:52:04;l be easy to change to microservices it's never easy. this is the point. if it was easy to change to microservices it'd been easy to develop to start with. without things you don't need why does everyone keep assuming we don't know what we need as a team... wtf kind of teams are y'all working with? again not every development project is some forge into the unknown.;0
hgsy96m;Reddit;2021-10-16 02:09:33;yeah because microservices are such a new idea. sheesh. there's this concept called thought you probably don't like it though because it's too old fashioned.;0
hgvghnb;Reddit;2021-10-16 18:09:46;it's definitely a step towards microservices though. maybe everything's not quite micro enough yet but i feel like that is arguing semantics.;0
hgy4aoc;Reddit;2021-10-17 06:27:39;sounds like a problem with compiled languages because dynamic languages are generally deployable at a file level. does that make php automatically microservices?;0
hh3fijo;Reddit;2021-10-18 13:05:15;but changes that do affect apis happen all the time another sign that your microservices aren't sliced well. that or your apis aren't designed well. plus anytime someone argues that x has zero problems so long as you don't make any mistakes ... well.. thats not a very interesting proposition. ah maybe this is the issue. if you don't find the idea of doing a good job appealing i doubt it makes a difference what patterns you use. with services that depend on each other tests across services are needed. they're really not. the company i work for manages quite well with no such tests. so have all the other companies i've worked for in the last 4 years. you just need to test the service and maybe some sort of contract test on the api. mocking doesn't protect against mistakes made in that other service. why would you be worrying about testing for bugs unrelated to your changes? sounds like defensive programming.;0
hh3hpt3;Reddit;2021-10-18 13:31:12;if you are making a change and you are changing any of the inputsoutputs of your service then what are you doing? uh building new features? you just can't help being this way huh? i mean i can't really interpret your comment any other way. if you're only interested in way of programming that involve allowing mistakes in your code advanced techniques like microservices aren't going to work. microservices effectively allow you to increase speed by allowing you to make and deploy changes independently. if you don't trust your code base enough to deploy your changes without verifying that other services work they they're supposed to then you're not going to realise any of the benefits of microservices. the answer should be to increase the quality of your code base not move back to monoliths.;0
