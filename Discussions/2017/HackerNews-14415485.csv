ID;Source;Creation Date;Content;Sentiment
14415485;HackerNews;2017-05-25;Title:Enough with the microservices, Content: https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html;0

14422375;HackerNews;2017-05-26;if you have people that are experienced with microservices i think it can even benefit a 2 person team.the anecdote that comes with thati joined a startup as the second developer. the first developer built everything in a microservices architecture with the background that we were supposed to grow as a devteam significantly in the next 6 months. one of my first tasks was setting up cicd for the microservices so we can launch the product which is a pretty routine setup for me since i've done the same thing 5 times before. then startup things happened and we stayed a 2 person team for a long long time.in the beginning i was skeptical if the microservice architecture was really the right choice there but overall i think we came out ahead. there were a lot of instances where we needed to upgrade libraries to fix some bugs or get some newer features and only had to upgrade very little of the whole codebase allowing us to iterate faster. this would not have been possible in a monolith. we also experienced some of the microservices downsides like slower refactoring and network connections being less reliable than inprocess function calls but with the right approach and tools they were not much of a problem.microservices are not a free lunch but they can be a cheap and tasty one.;0
14421704;HackerNews;2017-05-26;i blame monolithic microservices...;0
14420700;HackerNews;2017-05-26;no apologies needed. you highlighted precisely the issue that is causing us to move to proper microservices at eventbrite. without splitting our monolith into separate processes migrating to newer versions of django or to python 3 simply isn't tractable for us. luckily we've already decoupled much of the monolith by moving functionality into a homegrown service framework that lets you run services either remotely or colocated in the same process without code changes.;0
14420612;HackerNews;2017-05-26;1. refactoring is pretty much anything that you do to improve the system that doesn't change anything to the outside observer in other words your boss can ask you the stupid question so you've been working all this time committing changes like crazy and nothing has changed at all? and your answer is yes but.... extracting scattered logic and encapsulating it into modules classes whatever with clear responsibilities is refactoring for example. extracting your module into separate dependency package is refactoring as well. similarly extracting module to some kind of rpc is also a task that falls into refactoring bag because it doesn't change anything for the outsider.2. mature service is your app after several cycles of release. at the beginning the project is just a dance with the client going in circles changing things all the time until she's happy with at least parts of the system. the thing is that at the beginning you don't know how the system will look like and more importantly she doesn't know as well. the only tool that we have that we know works well is rapid prototyping with quick feedback loop. you want to minimize the friction of changes. she asks you to do something you do it then she changes her mind rearranges things etc often those changes require schema changes shuffling hierarchy or adding some indirection layers etc. you can't do it fast if you have to coordinate several microservices to use new schema. you need to promote all of them to the new version and you need to orchestrate it on live production system. with monolith you don't have this problem everything is in one place you run migrations on deployment to bring the system to the new state and presto you're done. this kind of friction echoes through all environments from your local dev through staging to production. if you're working with more colleagues your changes can easily block others' work.3. so we agree that avoiding friction is important for any kind of project. i'm saying this implying that microservices are adding extra friction to the development. instead of just calling function in your system you now have to maintain separate coordinated interface compatible service. all changes now need to go to two places. they need to be coordinated on migrationdeployment have their own devops setup etc.4. ...and then you introduce discount codes different countries tax information translations connecting users with paypal and what not all spanning across multiple microservices you need to duplicate new communication schema across all of them versioning apis sometimes managing breaking changes which are pain in the ass in microservice world... all that for what? what exactly are you gaining? are you really maxing out on thousands of requests per second on any one of those components? is microservice going to save you because you can scale horizontally? aren't they writing to the same store that's a bottleneck and scaling out the middleware won't improve anything at all? if they are separate then how are your joins doing when you need to match multiple cross database collections? for example to update some kind of aggregate information for every user? or any kind of reporting?ecommerce site with user cart payment and all the rest is trivial in monolith webapp as described in full in beginners book agile web development with rails for example. there's no need to clutter basic app like that with microservices imho.;0
14420026;HackerNews;2017-05-25;this. for languages with a good module system it's almost trivial to use modules either inprocess e.g. monolithically or outofprocess exposed via http or some other network interface as microservices. then the discussion becomes about writing modular code rather than microservices.;0
14419815;HackerNews;2017-05-25;this whole thing is about polyglot development and deployment.micro is a meaningless prefix. this is all soa service oriented architecture. a service can be anything it's a vague definition of whatever is a natural encapsulation of a bit of logic in your application or company. this encapsulation can be easily done with separate classes namespaces or even packages while still running together in the same process.in the end you're putting some binaries on a server. the machine doesn't care how often you do that or how many different binaries you choose to use so the only real reasons are multiple languages that aren't compatible in the same process or massive appsorganizations that need to have completely separate projects to make forward progress.for everything else microservices are a silly solution to no actual problem.;0
14419444;HackerNews;2017-05-25;as of late i've come to a new belief as to the ireali reason for microservices' current popularity. devops deployment and whateverhyperopaquecloudyserviceamazonhavelaunchedthisweek are the cool amp fun things happening at the moment. having loads of microservices to manage simply gives you plenty of toys to play with.personally the microservicey project i'm currently working on makes me want to burn my face off every day.;0
14419233;HackerNews;2017-05-25;very little of this blog post is concerned about performance. we're talking about microservices running on different hosts and ipc takes the form of a network socket and typically http.we're also talking about very very large scale systems like hundreds of api endpoints not ten with multiple oncall rotations each assigned their own section of the microservices surface running in front of customers at all times without the engineering effort to make sure things are close to perfect before exposing to customers.what happens here is a combinatorial explosion. 1 faulty service can end up affecting it and its transitive dependencies but operationally it's hard to distinguish symptom from cause. worse a problem on one team may be cause by an unmonitored problem two teams across the network increasing time to resolution as each oncall is woken up to discover the root cause is another layer up the network.more efficient rpc doesn't solve any of this.;0
14419199;HackerNews;2017-05-25;the separation of concerns inherent to microservices is such a great advantageit is not. not even close.you have to manage separate onboarding processes ensure the standards are completely up to date ensure that training is extremely relevant and covers every single critical component of the system.you have to maintain up to date documentation of integration state data flow testing capabilities etc. you can bring an extra hand into the team without them having to have to understand other parts of the code to do their job.that sounds awful. won't allow you for example to place each service under its own repo which would also provide you with the ability to limit code accesslet me guess you are not paying for engineering talent? the notion of having distributed teams for most of the companies is so ridiculous it's not even funny.what happens if a lead person on team x and y quits? are you going to retain a fulltime person to manage your deployment process now?what happens if your budget is cut in half and you need to fire half of the team? do you expect other engineers to pick up something they have not touched for the duration of their stay without slowing down business? that requires a lot more upfront investment but it's worth it over the long runnone of that is true.;0
14419123;HackerNews;2017-05-25;microservices are just one option of refactoringbreaking down a monolithic platform into different microservices is not something i would call refactoring. microservices are for mature services with crystallized interfaces.you are not making any sense here. what exactly is a 'mature service'? just throwing technical jargon around? the most important part when starting project is avoiding friction at all levels from dev setup contribution deployments database evolution migrations interaction between different parts of the system it's easier to just call a function from a module than to do rpc which involves implementing rpc on the other side managing it's deployment keeping interfaces in sync etc...those things are pretty important for any kind of project. they emerge naturally and the split is obvious at later stage this information is not available at the beginning.most microservices are plain boring and extremely predictable. have an ecommerce site? then you have a user service a cart service payment service etc.;0
14419095;HackerNews;2017-05-25;i've seen monoliths running on 10 year old technology using runtimes and development kits that have been deprecated or are no longer supported by their maintainers. these applications are being used in production today by billion dollar companies. with microservices this never has to be the case. i think it's madness for a company to be running old software with security vulnerabilities and performance liabilities because no one wants to touch what's basically a digital jenga tower. then you have people writing articles like this one. i think we're beyond fads and buzzwords here. there are real world advantages for building software this way. if you're afraid to embrace the future please step aside. you're making my job far more difficult than it should be. these are my observations as a 40 year old developer.;0
14418938;HackerNews;2017-05-25;did you read the section titled dependencies? that was about social as much as technical concerns.i don't think the author disagrees with the goal of reducing dependencies or coupling between dev teams. what they disagree with is whether moving to microservices is necessary to achieve this. they think a a monolith composed of welldefined modules with welldefined interfaces can get you the upside without the downsides.;0
14418929;HackerNews;2017-05-25;i no battle plan survives contact with the enemy and microservices are making decisions early on that are difficult to change later. because you've picked one decomposition and then erected fences around the partsiwhy would merging two or more microservices be any more difficult than turning a monolith into several microservices?i'm not implying one would be harder than the other. i'm really curious to understand the downsides of going each route.;0
14418651;HackerNews;2017-05-25;this is partly a limitation of the mediocre interprocess communication system in the linuxunix world. calling another service is a big deal.i've done a complex robotic system which had about ten processes running on qnx. most of them were running some microservice gps ins lidar mapping logging shortterm vehicle control etc. this worked fine. that's because qnx does interprocess communication well. msgsendmsgreceive is like making a subroutine call on the send side. the receive side is more like an event loop.this sort of thing is common in robotics. ros does something similar although the interprocess communication is slower. usually you have dummy services for simulation purposes so you can run the operational code in a simulated environment. we could run the system for real or run it entirely with simulated inputs and outputs or could put the robot vehicle up on blocks and run the system with fake inputs while operating the real vehicle engine running and wheels spinning but going nowhere. everything could be run on one desktop or on the vehicle's own computers or partially split. there were shell files to launch the various configurations. we could plug in shims between services and watch the data go by.i don't see the fear of multiple intercommunicating processes. even on linux there are decent ways to distribute. they're not as good at hard real time as qnx but they work.;0
14418571;HackerNews;2017-05-25;the separation of concerns inherent to microservices is such a great advantage that in my opinion it's critical even for small teams. you can bring an extra hand into the team without them having to have to understand other parts of the code to do their job. a monolith with clearly delimited packages will give you this too but it won't allow you for example to place each service under its own repo which would also provide you with the ability to limit code access. that requires a lot more upfront investment but it's worth over the long run unless your project has a very limited lifespan which is rare and sometimes really unknown.;0
14418284;HackerNews;2017-05-25;just like agile and vendorbased software solutions of the past it seems like microservices are following the same path. i've seen projects starting off with microservices because someone several pay grades above deemed it so. lots of resumedrivendevelopment done here.;0
14418235;HackerNews;2017-05-25;no iii don't because they are my own at home projects that haven't taken off but i'm able to use the same library and code structure at work for things that absolutely do need microservice because of the power of the framework. and if any of my at home projects take off and i have huge teams and load then i may need microservices. it becomes a deployment question instead of a code question with the right framework.;0
14418170;HackerNews;2017-05-25;found three rather boring very technical concerns to harp upon for what microservices are supposed to deliver and why they're not the bee's knees.what microservices actually work towards is a viable strategy towards the two pizza rule where teams can be kings and queens of their kingdoms amp drive their own agenda forward without needing to consult with everyone else working on the monolith. containerizing your software allows containerizing your culture keeps there from being ancient legacy topdown hierarchical culture and praxis set forth long ago and which will dwell ever on in the monolith your whole company must collectively lurchingly keep trying to push forward. free yourself from the more brutal pieces of conway's law. create an organization that can continue to try new ideas that allows team's freedom to work without always bumping elbows with others.at the end of a somewhat different thread amid these comments gloverkcn happened upon a wonderful synopsisithe problem is that it's easier to grab the people sitting next to design something than scheduling a meeting with groups you rarely see. this is a key driver of conway's law.i microservices amp their platform infrastructure are the answer to make this not a problem to free you from tight organizational grips of conway's law.for small and new companies technical and organizational structuring has not accrued. these are not major problems in early stages because everything is small enough to be changed easily anyways. but as time goes on as software or head count grows maintaining the liberty to ongoingly innovate and pick up new ideas and new technologies is a liberty that has to be fought for. making your way from a 1many service organization comes with a lot of complexity and cost but it is a key step to allowing diversity and innovation and technical growth particularly for multidepartment organizations.;0
14418017;HackerNews;2017-05-25;it's totally possible to write code that's straightforward to port later. i'd say the biggest blockers tend to be database and codeorganization related.if you make a component that is the sole entrypoint to it's concerns gets it's own database and have an orm or database context layer that is capable of dealing with that moving to a microservice is as simple as taking that same code exposing an http layer to it and making your original interface call to the service instead.if other code is joining into the relevant tables skipping said interface and doing it's own thing with the guts of it you'll have issues.this can of course be done in any language really though database tooling can definitely vary in ease of doing it;0
14417834;HackerNews;2017-05-25;you gain nothing by including network communication between those different pieces of code.i consider the network aspect of the communication a bit of a side show here. what's important is the information flow. even if you've got a monolith you've got some components and if you are taking such good advantage of your monolith that the communication flow between modules is inoti something that is clearly specifiable and understandable because of the global variables and shared state and shared everything else what you've got there is a mess not a beautiful shining example of architecture that obviates the need for microservices.or possibly you've just got something too small for the microservices to be relevant. which is totally a thing and i totally agree with the various things that say don't write your startup as microservices.but eventually as your size grows large enough you iwilli either end up with components so nicely separated that putting a network between them doesn't affect them all that much iori you will have a big ball of mud that nobody can move around anymore. if you don't have one of those you just aren't large enough yet. humans can not code the way biology tends to work we ineedi bitesized chunks of a larger system to get our heads around.;0
14417573;HackerNews;2017-05-25;you'll either use microservices or a monolith that contains an adhoc informallyspecified bugridden slow implementation of microservices even strictly de facto in the form of this code belongs to this team that code belongs to that team.that metaphor isn't good here. you gain nothing by including network communication between those different pieces of code. the adhoc solution is often more formally specified less bugridden and faster than the microservices solution.microservices solve some technical problems not social ones.;0
14417519;HackerNews;2017-05-25;what size startup do you think is benefited by a microservices architecture?;0
14417488;HackerNews;2017-05-25;imho ease of development isn't guaranteed with microservices. it's usually a bit more complicated to manage multiple services all coordinating the completion of a single task. where it does help is to define responsibility and allow different teams to work without stepping on each others toes.also there are cases where microservices would make sense even with one person on the tech team. for instance if you want to scale services independently of each other. for example your web app isn't used that much but you get heavy traffic on the mobile api. in that case maybe having the mobile api as a separate service helps.;0
14417485;HackerNews;2017-05-25;but if you make a modeling mistake in a monolith it's a little painful but if you make a modeling mistake with microservices it's excruciating.;0
14417319;HackerNews;2017-05-25;here's on of the sources i see most referred to when talking about microservices. maybe this could help you to understand them.;0
14417249;HackerNews;2017-05-25;could anyone explain what microservices are? i'm still learning as a junior dev and haven't quite understood what this word means. how would you break down an existing monolith into smaller 'microservices'?;0
14417242;HackerNews;2017-05-25;i don't think there is a single starting place. it really depends on the context.as an example we're talking about microservices so one could start looking into things that people brought up like the unix philosophy.the thing developers really need to constantly be aware of is this if you think of it today another developer has already thought of it 30 years ago. go find out what he knows.;0
14417138;HackerNews;2017-05-25;1. nothing promotes the ability to produce quality code like being woken at 3am to troubleshot a problem 3 microservices away from your own.in my anecdotical experience the ability to recover from such incidents degrades with age so nowadays i regard everybody but management does devops as codeword for ageism.;0
14417081;HackerNews;2017-05-25;like many aphorisms it's 95 true or so. almost always when facing a social problem within a company you should be solving it socially. if you don't understand why that's true 95 of the time i.e. trying to argue that it's completely untrue you're not going to be able to identify the 5 of the time that it's false and following the aphorism will likely serve you well. understand the aphorisms before breaking themhowever there is that 5 that matters. in my opinion one of the things that separates a good architect from a really senior engineer with lots of responsibilities is the ability to engage with the social and political implications of code design and convert social concerns into lines of code. this further reinforces the idea that architects imusti code on the grounds that in general this degree of understanding of a situation is inoti transferable. especially to people who don't even believe these issues exist or are relevant to a design which is quite a lot of even quite senior engineers. the 5 is not equally distributed and a lot of it will concentrate on to the architects so for instance i find myself thinking about this stuff a iloti because of my position. but it's still the exception it just happens that i get a lot of that exception.of that 5 the vast majority of it relates to conway's law organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. i first encountered this in a list of funny jokes and such that had been knocking about since the old unix days and at first i figured it was a joke too. then as i grew more experienced i thought it was a lament in the style of the first 90 takes 90 of the time. the remaining 10 takes 90 of the time. now i understand it simply to be a law of software design. like gravity if you intend to defy it you'd better have a ireallyi solid story as to how you intend to avoid it. it is often much better to reorganize teams rather than fix this with code but even optimal organizations of teams will still have a certain amount of conway's law issues because the real world is messier than team structures should be. plus engineers suggesting team reorganizations doesn't always go well if nothing else you will confuse the heck out of your management even proposing it like what are you doing thinking about ithati?. you may be forced as an architect to deal with suboptimal organizations anyhow.and thus we wrap back around to microservices... once an organization hits a certain size you are almost inevitably constrained to use microservices because organizationally it is simply impossible to have 500 people working on the same thing. you'll either use microservices or a monolith that contains an adhoc informallyspecified bugridden slow implementation of microservices even strictly ide factoi in the form of this code belongs to this team that code belongs to that team.the generic form of greenspun's 10th rule is any sufficiently complicated program in a certain domain will inevitably be pushed towards certain solutions based on the domain and if the designers attempt to resist that solution that will simply result in an adhoc informallyspecified bugridden and slow implementation of those solutions. or in short use the right tool for the right job even if you thing you don't like that tool.;0
14417063;HackerNews;2017-05-25;i think the biggest thing most organizations miss is that microservices are just another potential tool in the toolbox. you can have both monolithic and microservices architectures that coexist across different applications. i'd say that there is even a potential mixture of both.i too feel there were good points but i'm not ready to throw the baby out with the bathwater because there have been failures in organizations because they chose to adopt the pattern without a great reason for why.;0
14417056;HackerNews;2017-05-25;as always it depends. personally i have been working for a corporation where we use a microservice approach and it has been great for productivity turn around times on projects and the systemsservices are quite easy to understand. we are full ci. our microservices maybe aren't as micro as others we have a pattern of having monolith 'data services' and micro businessfunctionalapi services. the monolith 'data service' effectively a layer that exposes crud over data in some cases has 10 microservices that interface. i could go on and on but it works very well for us.;0
14416948;HackerNews;2017-05-25;this makes me wonder are there any systems that make it easy to build a modular monolith that can relatively easily be split into microservices in the future?erlang otp? comes to mind though i have very little experience with it so i could be off;0
14416842;HackerNews;2017-05-25;that's what i am thinking too. how are people who can't write decent libraries suddenly able to define microservices and their boundaries?;0
14416821;HackerNews;2017-05-25;yes that's why i said it's a tooling problem. but not everyone has log aggregators set up or set up in a sanetotally adequate way and even with log aggregators it takes a little more care to make sure you're exposing the right information and exposing it in a way where it's easy to trace the important stuff that's happening chronologically.i'm not saying that it's an unsolvable or even unusually difficult problem i'm just saying that it's very possible to do wrong. if an organization can fill a monolith with tech debt they can probably find a way to do the same with microservices.;0
14416612;HackerNews;2017-05-25;in my experience if you slice your microservice boundaries with the philosophy that each of them should be able to be sold as a white label product or more realistically be reused for a completely different product internally microservices can survive pretty large pivots of the startupproject with little changes.once you're at the point of having multiple products you've already made it past the valley of death. in my experience you only understand the system well enough to be able to decompose it correctly if it's already working endtoend.;0
14416586;HackerNews;2017-05-25;also refer to the handy flowchart i created in my post for judging whether you need microservices;0
14416585;HackerNews;2017-05-25;it seems to me that the answer really depends on application.there are two kinds of scalability requirements. some applications scale almost linearly with number of users for example google maps. that happens if users need interact with each other in limited ways. for such horizontal scalability of a monolith is almost always a better answer than microservices and splitting the data before processing is almost always better solution than spark or hadoop.the second kind of scalability requirement is where the users interact and so the processing required scales more than linearly quadratically with number of users. the examples are social networks the more users you have then you need to deliver quadratically more messages to all of them. in this case microservices and spark and hadoop are probably better since you can't solve the problem just by scaling the monolith horizontally.;0
14416575;HackerNews;2017-05-25;i agree with your first point but i find microservices which almost always means json in practice tend to lead to less well designed interfaces than monoliths in a welltyped i.e. mlfamily language.;0
14416529;HackerNews;2017-05-25;lots of problems can benefit from well defined interfaces security complexity maintenance hrproject matching need for parallelized or decoupled development eg. multiteamtimezone use of existing codebases etc. as always the devil is in the details.it is an old maxim in programming that correctly modeling the data is a huge percentage of the design. for exampleipike's 5th rule data dominates. if you've chosen the right data structures and organized things well the algorithms will almost always be selfevident. data structures not algorithms are central to programming.i rob pike notes on c programming 1989in that sense in nontrivial problem spaces if forced to generalize then i am generally more for spending time carefully developing interfaces ie. a paradigm potentially more closely aligned in a network services context with the microservices model older coders with maintenance chops than immediately writing actual code ie. approach of the keyboardhappy iterative tweaker young coder with fireandforget habit.any real world project lies somewhere between these extremes.;0
14416525;HackerNews;2017-05-25;the free microservices vs soa book gives an excellent run down of the difference between microservices and soa. it's really useful to have this in mind when having any conversation about microservices. one of the fundamental concepts to remember is that microservices architecture is a shareaslittleaspossible architecture pattern that places a heavy emphasis on the concept of a bounded context whereas soa is a shareasmuchaspossible architecture pattern that places heavy emphasis on abstraction and business functionality reuse.;0
14416498;HackerNews;2017-05-25;this is an oversimplification. microservices ! soa;0
14416251;HackerNews;2017-05-25;i agree. microservices enable startups to pivot very easily or to implement or diverge into new sales channels quicker than with monolithic solutions.the same applies to larger business. with microservices ie. large banks can easily offer api services enabling new revenue streams that were nearly impossible to offer before.microservices are an excellent way to deal with future changes. the unknown unknowns like some would put it.;0
14416208;HackerNews;2017-05-25;microservices are just one option of refactoring that can be considered at later stage of life of the system.even big guys who are using microservices started with monolith. many people can't seem to catch this important detail they started as monolith that was later refactoredmodularisedsplitmicroserviced. it doesn't mean the moment they did it that humanity found a better way of writing software called microservices. it just means that at that stage of life of the project it made sense. starting with monolith is still in most cases the best way to write projects even if later they evolve into microservices.starting projects with maximum split into microservices is in most cases just a plain stupid idea.the most important part when starting project is avoiding friction at all levels from dev setup contribution deployments database evolution migrations interaction between different parts of the system it's easier to just call a function from a module than to do rpc which involves implementing rpc on the other side managing it's deployment keeping interfaces in sync etc...microservices are for mature services with crystallized interfaces. they emerge naturally and the split is obvious at later stage this information is not available at the beginning.;0
14416196;HackerNews;2017-05-25;i agree overuse of almost everything is bad.one of our customers are developing a service which in turn consist of four minor services. they are completely separate services one provide the core functionality and the rest a supporting tools but the core can run without them. to me that's a completely reasonable seperation and it allows multiple teams to work in parallel.one of the services above however consist of 10 to 15 smaller services all of which are communicating via http. the idea as i understand it is that these are small components that can be reused in other projects if needed. what i don't understand is why these aren't just made into library that can be reused rather than having them as microservices.this project is an example of where microservices is done both right and wrong.;0
14416194;HackerNews;2017-05-25;it doesn't have to be you can use ruby modules classes and namespacing to split the application into logical pieces. then start to enforce encapsulation between these pieces so all access to a given piece of the system goes through a small well defined and documented interface.iifi you are thinking about migrating to microservices at some point it's also beneficial to try to limit the areas of the database schema that each of these pieces accesses. there's no point having lots of microservices running over the top of a single monolithic database schema extracting microservices should imply extracting the relevant part of the database schema and putting it into a private database with operational access only through the microservice. you can make this much easier while still working in a monolithic application by being more disciplined about how much of the schema a piece of the application needs to know about.;0
14416184;HackerNews;2017-05-25;you just reminded me of one i worked on too back before the buzzword existed but still a microservice architecture. it was all c but service1 would call service2 which would call service3 which would call service1. it had all the spaghetti of a monolithic system with 110th the debugability and performance serialization can be relatively expensive.;0
14416181;HackerNews;2017-05-25;and comes at one of 2 costs1 never change data exchange formats between trivially connected parts of the application e.g. splitting billing and delivery address in the payment system no way you can do that easily with microservices2 effectively have 3 versions of every service running essentially constantly and at the same time. this is more work than just running 3 versions they must also be developed so they can run at the same time e.g. they must tolerate the nonexistence of a delivery address in the same example;0
14416176;HackerNews;2017-05-25;the unix philosophy is popularly simplified to do one thing and do it well sure but that simplification is not accurate. many unix programs do much more than one thing. what the unix philosophy actually isthe unix philosophy emphasizes building simple short clear modular and extensible code that can be easily maintained and repurposed by developers other than its creators. the unix philosophy favors composability as opposed to monolithic design.which is a lot more akin to what's now called microservices. unix philosophy has always been about software modularity and do we really need to use 'microservices' these days to describe such an approach? the meaning is not clearly defined anyway what one company describes as a microservice architecture might not be described as such by another. i certainly don't need any buzzwords e.g. reinvented terminology to describe a modular software system and whether your processes ipc mechanism is httpjson pipes or sockets we are talking about exactly the same kind of system.;0
14416109;HackerNews;2017-05-25;and microservices guarantee that every single fad is represented in a hundred different ways in every different microservice and that there is not a single bit of consistency in the code base.the mental overhead of that is ihugei. every new bit of functionality you have to figure out how this microservice was built? opening a microservice and learning what developer x did with developer y's i don't understand functional but i'm damn well going to use it and wouldn't it be great to build this in the zebeedeee framework that trended on hn two weeks ago and then mysteriously disappeared forever.bad programmers are going to muck up microservices even worse than they're going to muck up monoliths.at least with monoliths they might actually reuse some code rather than cut and paste it from the last microservice they worked on.;0
14416103;HackerNews;2017-05-25;i agree overuse of almost everything is bad. currently i am working with one another seasoned architect who is very proponent of microservices and aws lambda on same lines as mentioned in the article. my discussion with whom has always articulated that let's do traditional portionuser management permissions payments etc in a traditional way we are using django so in that and whatever tasks we have lets do them in a microservices way.in a traditional sense we are implementing a system in django that will be deployed to aws lambda via zappa or sam. all the traditional taskqueue tasks will be separate microservices lambda. so we are implementing fusion and i personally see future in that.;0
14416083;HackerNews;2017-05-25;i my i i. sounds like you ireallyi don't need microservices.;0
14416058;HackerNews;2017-05-25;imicroservices were not just concocted by a team at netflixiin the distant past microservices were called loosely coupled architectures and these have been around since the early 80's i believe but probably earlier. there isn't anything new about microservices and they are a great idea in theory. in practice there are all kinds of challenges and these will have to weigh in on the architectural decision to deploy this particular pattern.i am genuinely curious as to why we in information technology have such an astounding capacity for reinventing and relabeling the wheel. i rarely see as much not invented here and not in my backyard as i do in our field.;0
14416037;HackerNews;2017-05-25;just saying that you're using microservices doesn't guarantee that you'll be avoiding or capping tech debt. i've seen some hopelessly entangled microservices that are so full of assumptions about how other parts operate that they're essentially unusable anywhere except for one or two places. you need that discipline whether you are separating components by service boundaries or just by organization of code within a monolith.i agree that microservices tend to make it harder to accrue tech debt past a certain point though. although they can also dramatically complexify the process of figuring out what is going on in an app if log files are spread around a ton of places which is mainly a tooling problem.;0
14416034;HackerNews;2017-05-25;i would love if each micro service article would start by defining what they mean with micro service. wikipedia says in a microservices architecture services should be finegrained and the protocols should be lightweight.1 but that leaves lot of things open especially what does the micro mean size wise.when these kind of things are not defined people may take good advice and apply it wrong way. you read articles how large companies are embracing micro services. however a micro for them might mean very much different thing than what is means for smaller company. just like with big data.1;0
14415991;HackerNews;2017-05-25;the projects i've seen getting to technical bankruptcy have been with no exception monoliths. with microservices you have the ability to take one service and fix it reimplement it or replace it if necessary.the worst kind of technical debt is usually about having the service boundary in the wrong place and crappy apis. with microservices this problem is amplified. it's harder to unpick a service than it is a module.if you've ever tried debugging a problem across a series of microservices as well you'll wish you hadn't...;0
14415990;HackerNews;2017-05-25;in my experience the desire to move to microservices results in people going overboard when decomposing their monoliths. authentication services payment services comments service etc.;0
14415966;HackerNews;2017-05-25;tldr microservices is yet another religion.;0
14415962;HackerNews;2017-05-25;i'd say the microservices fad is newer than the distributed source repositories but disregarding something because deemed 'new' doesn't make a good argument.iand in the java world at least modules aren't real.i the statement shows lack of understanding how modules should be utilized it has very little to do with packages. interfaces can do exactly the same what protocols in microservices do. enforcing that might be harder but facadesproxies ensure there would be no feasible way to bypass. there is no substitute for good data modelsresponsibility.;0
14415948;HackerNews;2017-05-25;i've worked on a codebase where a jsp app would call an api served by a modperl app which would call a remote api to a c app. technical bankruptcy can and does creep up even in services made in the micro style. they may not be as common now because the microservice trend is fairly recent but as years go on i'm betting you're going to see more issues with microservice systems where code done may be using a decade's worth of changing best practices.;0
14415928;HackerNews;2017-05-25;i wish the author discussed microservices in the context of domains and models. if you model your application and find a distinct isolated domains then consider creating separate services for them.;0
14415910;HackerNews;2017-05-25;the issue is when you have multiple teams working on a monolith.i haven't seen a configuration of teams that doesn't screw up the monolith by creating spaghetti dependencies between the pieces. hence making the transition to microservices a multi year journey.;0
14415878;HackerNews;2017-05-25;hi author here. thank you for your feedback and i'll be sure to take it into account in future writing.i don't have any preference for or against microservices as long as the benefits they bring outweigh the drawbacks which come along with such an approach.the goal wasn't so much to rant against cargo culting but to provide some counter points along with a more measured progression for moving towards microservices.i agree that the points at the end should be what such a transition looks like but it's amazing how often companies skip the first two steps and try to immediately break up their monolith as a form of technical bankruptcy which is rarely warranted.thank you again for the comments!;0
14415843;HackerNews;2017-05-25;it seems to me the overhead of microservices in terms of iproductivyi is o1 but i can be wrong. if the overhead is o1 then the question becomes whether or not you already have the framework to do microservices. if you dont so yeah maybe you should do a monolith.edit that even sounds like business opportunity.;0
14415830;HackerNews;2017-05-25;if you divide your project so selfcontained components with scoped set of responsibilities that are not coupled to the rest that's fine as well. i've used that pattern with great success.microservices are a way of achieving this but as you describe it is not the only way. discipline is another way.now as you have more people involved or release deadlines get tighter chances that tech debt gets introduced increase. unless you go back and repay the tech debt situation would worsen.in that sense microservices are some sort of cap on the impact of tech debt from rushed deadlines and lack of discipline.;0
14415829;HackerNews;2017-05-25;i don't see how the size of any individual microservice matters for the scenario hinkley has outlined.;0
14415826;HackerNews;2017-05-25;with microservices you have the ability to take one service and fix it reimplement it or replace it if necessary.you can do that inside a monolith too. microservice as a solution points to architectural problems we try to build systems that are too vertical our architecture should be horizontal. microservices enforce this horizontalness but it's not the only way to achieve it.;0
14415824;HackerNews;2017-05-25;but if you are changing the factoring of the microservices you are necessarily rewriting more than one. sure it can be done but you know what's easier than refactoring microservice boundaries? refactoring service object boundaries in a single app with one coherent test suite.it's time to stop handwaving away the overhead of microservices. the two big reasons to introduce microservices are because you have different workload profiles that need to scale independently or because you have separate teams with bounded areas of responsibility and you want them to operate independently and minimize communication overhead. i'll also give a pass for microservices where the interface is very obvious and stable and there are low crosscutting concerns.but in a lot of cases devs are just complexifying things for their own resume and ego.;0
14415819;HackerNews;2017-05-25;it depends how you do micro services. there are middle grounds. one big gain of microservices is that it guarantees things are separate and can be handled by separate teams if the need arises. that doesn't mean you need to start out that way. for instance in python i use hug to create my microservices then i can just install them to create a monolithic services that consumes all the microservices the great thing is that hug allows you to expose both as a webservices and as a python library so i can consume as a python library with no overhead until the need to split is evident and then can split up the services with very little work. of course the need may never arrive but the modularity that is forced when using microservices pays dividends quickly regardless;0
14415799;HackerNews;2017-05-25;the biggest problem i have with microservice is that they lock you into a particular data flow up front.you say that as if that's an unalterable fact. no battle plan survives contact with the enemy and microservices are making decisions early on that are difficult to change later. because you've picked one decomposition and then erected fences around the parts.if you know about that problem then don't do that! pin my experience if you slice your microservice boundaries with the philosophy that each of them should be able to be sold as a white label product or more realistically be reused for a completely different product internally microservices can survive pretty large pivots of the startupproject with little changes.;0
14415784;HackerNews;2017-05-25;you could also have a monolith in a single or multiple compatible languages c rust c etc and have different featuresmodules separated in different libraries. these libraries could then act as the microservices.developers could be tasked with working on these libraries that would have 0 overhead since they are just a piece of code that can be used in another library instead of creating restsoaprpc apis that come with the httpsoaprpc overhead.this means you can start small with a public restsoaprpc api. less infrastructure less server config etc. and if at some point you need more scalability you can always do an actual microservice ie a separate restsoaprpc api with the library code the day you absolutely need it for horizontal scalability or whatever.i have seen this pattern used in the rust world a lot. projects expose both a library and a binary. and the binary is built on top of the library. this means you have 0 overhead if you want to use the binary's features since you can simply include the library and get going.also i think that having the tools to support deprecation is big advantage when working with a monolith. i think rust has builtin support for compiletime deprecation notices. php for instance doesn't have that particular feature yet as far as i know. symfony tries its best by adding deprecation notices iiwhen you callii a deprecated methodfunction. but you have to call it to realize it's deprecated.i'm not here to promote rust or hurt php i actually love both. the statements above apply to a lot of other languages as well. i just took the examples of rust and php because these are the ones i've worked with the most.xxs's comment is spot on as well.;0
14415781;HackerNews;2017-05-25;i somewhat recently worked on a huge monolith where certain parts were off limits i was told to the effect of noone changes those classes we don't really understand them. that business is not going too well now.i searched the article for domain and bounded contexts found nothing. article is not without merit however sam newman in his book 1 cautions about going too aggressive i.e. splitting down into too many microservices before the domain is fully understood. on the other hand having systems cross obvious domains is a definite warning sign of disaster.so the motto might be use them but in moderation as with a lot of things.1;0
14415774;HackerNews;2017-05-25;typically you solve that through a rewrite followed by migration and depreciation. since the microservice is small you can ideally accomplish the rewrite in under a week.;0
14415759;HackerNews;2017-05-25;and if you find scaling microservices harder than a giant stateful monolith well then clearly you've done something wrong.monoliths don't have to be stateful anymore than a microservice does. stop arguing against strawmen. this is why this topic is maddening.;0
14415746;HackerNews;2017-05-25;monoliths assume that every single developer that will ever touch that codebase will do the right thing. ltltthis is just false there are pull requests reviews and all. morealso there are modules and just because you can deploy the 'monolith' as a single process and use shared memory doesn't mean you can't addremove parts or have to compile all at once.analogy with microservices your login service is borked. the rest of your site is kind of useless even if perfectly operational.;0
14415724;HackerNews;2017-05-25;sometimes the idea of microservices seems like an attempt at taking the unix philosophy of doing one thing and doing it well and adding on the additional requirement of doing it over the net. i dont think its a bad idea but surely its not worth the effort in lots of cases.;0
14415722;HackerNews;2017-05-25;two things jump out at me initially. first the assertion that cargoculting is bad is hardly revelatory regardless of the paradigm. secondly the five point list at the end of the diatribe is exactly what any transition from legacy monolithic system would follow in order to pursue a microservice infrastructure.i can't decide if the author actually has a problem with an appropriately deployed microservice architecture and no you do not need 100 engineers to support such a thing... i replaced a legacy backend system for a 100myr revenue company with such an architecture using 4 devs or if this is just a misapplied generic rant about cargo culting that has been applied to thingireadabouttoday.;0
14415710;HackerNews;2017-05-25;additionally if you're actually having issues with scaling microservices or using them reliably for some reason it's usually pretty easy to integrate two of them into a bigger piece. virtually always easier than extracting a new microservice from an existing monolith.;0
14415708;HackerNews;2017-05-25;i keep forgetting the old axiom don't use technology to solve a social problem.the biggest problem i have with microservice is that they lock you into a particular data flow up front. and the only times i've worked on a project where the data flow didn't change substantially from first implementation to having a rich set of features and many customers? those were the projects that never got anywhere.no battle plan survives contact with the enemy and microservices are making decisions early on that are difficult to change later. because you've picked one decomposition and then erected fences around the parts.;0
14415700;HackerNews;2017-05-25;the projects i've seen getting to technical bankruptcy have been with no exception monoliths.with microservices you have the ability to take one service and fix it reimplement it or replace it if necessary. also use whatever technology makes more sense for that project as long as it speaks the same protocols and sticks to the same interfaces.with monoliths there's always the analysis paralysis related to the possible ramifications of a change which slows down everything.;0
14415682;HackerNews;2017-05-25;there are good points in there but i disliked some of the scare es.microservices were not just concocted by a team at netflix and everyone then followed. instead microservices emerged across many different companies and teams concurrently. the architectural style was a natural reaction to many simultaneous forces that were being applied across the broader development ecosystem.of course i'm biased because i built two similar architectures at the same time that micro service was becoming a buzz word and i only knew that the type of architecture had a name much later. but me and my team just did it that way because we were trying to find the architecture that worked best for us our tools and our environment. that is the form followed the function. and this was the type of design that naturally turned out.;0
14415679;HackerNews;2017-05-25;microservices have their place but as often happens they were overhyped to be a solution to everything and for everybody... now the cooldown period begins...;0
14415669;HackerNews;2017-05-25;this frankly adds nothing new to the conversation.and if you find scaling microservices harder than a giant stateful monolith well then clearly you've done something wrong.likewise local development should be far easier if you define your apis and contract boundaries properly.;0
