ID;Source;Creation Date;Content;Sentiment
13426896;HackerNews;2017-01-18;"Title:Ask HN: Are we overcomplicating software development?, Content: I have recently been involved in the overhaul of an established business with poor output into a functioning early&#x2F;mid stage startup (long story). We are back on track but, honestly, my lessons learned fly in the face of a lot of currently accepted wisdom:<p>1) Choose languages that developers are familiar with, not the best tool for the job<p>2) Avoid microservices where possible, the operational cost considering devops is just immense<p>3) Advanced reliability &#x2F; redundancy even in critical systems ironically seems to causes more downtime than it prevents due to the introduction of complexity to dev &amp; devops.<p>4) Continuous integration seems to be a plaster on the problem of complex devops introduced by microservices.<p>5) Agile &quot;methodology&quot; when used as anything but a tool to solve specific, discrete, communications issues is really problematic<p>I think overall we seem to be over-complicating software development. We look to architecture and process for flexibility when in reality its acting as a crutch for lack of communication and proper analysis of how we should be architecting the actual software.<p>Is it just me?";0

13513400;HackerNews;2017-01-29;1 yes except that you should try some languages sometimes. e.g. if you use spark in production as a critical part of your system... take the time to learn scala.2 is a pet peeve of mine. theoretically microservices are good but we don't have a way to orchestrate them. what's lacking in programming languages terms is a runtime and debugger and of course a widelytested amp reliable set of libraries for most common tasks. i think it's possible to do something like that as long as you start imposing some restrictions on what a microservice is and how it talks to the outside world. also in this frame of thinking it becomes apparent that deployment is actually programming the system at a high level. it's not just configuration configuration is code if you moved the complexity from your code to your configuration you just moved the complexity into a language that has very poor tools to work with.3 my rule of thumb for most systems is avoid redundancy in the control plane you can and should have redundancy in the datadata processing plane don't plan for 100 uptime in the control plane plan for very short downtimes for fast recovery when something goes wrong4 my experience is that continuous integration is good for all but the very small teams. for multiple reasons not just microservices5 agile is horrendously misused the cargo cult is in full force. it should be about prioritising amp doing the important things reducing overhead to the minimum necessary. it has become an overhead in itself with sprints reduced to ridiculously low periods meeting over meeting at each sprint etc.;0
13446731;HackerNews;2017-01-20;1 choosing javascript for a math heavy project would likely be a mistake. there are plenty of other examples of picking the wrong language for the wrong job. that's where this statement falls apart.2 depending on how you bring them all together yes this can be true. if you have something like aws api gateway then microservices may be manageable. if you're rolling your own custom solution with something like nginx or haproxy you're probably wasting a ton of cycles.3 again i tend to agree with this. premature optimization seems to be the norm these days. especially when you get devops people involved. do we need every single layer in our stack to be highly available if we have zero users? the answer is no.4 well this sounds clever but i'm not sure it really means anything. setting up something like jenkins to watch your github repos and build the branch and run the tests can alert you to issues early and really isn't that difficult to setup.5 nothing wrong with tdd as long as you don't go overboard. nothing wrong with standups planning or retros. nothing wrong with short sprints.;0
13436623;HackerNews;2017-01-19;as everyone is saying do what is reasonable and useful.e.g let's make an online shop.it has browsing purchasing and admin sections.browsing is simple. query db and show html. it's probably the most used as well and needs to be reliable. having as different service means admin section could break while users are still able to browse. same for payments. sometimes it's crazy complicated. i think of microservices as big product feature boundaries that can work independently. a failure in one doesn't affect the other.continuous integration once you have your tests and some auto deploy scripts you have an engine. you push code tests auto run a live staging is created for latest code you play with it. looks good? merge with master. it's deployed to production. the idea is deployment is effortless and you can do it multiple times a day just like git push. tests just don't only have to be unit. we run integration testing features on dummy accounts periodically from different regions in the world on production. this means you are alerted as soon as something breaks. fast deployment and great telemetry mean you can always revert to last known good state easily.investing in tests is a pain but it pays off in the long run. especially if you have other developers working on same code base.just don't over do it. i believe these ideas came from pain developers actually faced and they used then to solve it. if you're not feeling the pain or won't feel it then you don't need the remedy.;0
13434844;HackerNews;2017-01-19;no not at all.the only difference i noticed with respect to rube goldberg what you call microservices systems and coupling is that tight coupling between components of rube goldberg systems was much more painful particularly debugging across multiple service boundaries.;0
13434577;HackerNews;2017-01-19;you're right of course but it can also go the other way. if you break something then it seldom brings the service down and often the breakage is very visible and can be seen by queues backing up. you can restore the broken service without having to redeploy the system as a whole.like most things in life there is no right answer with tools like terraform you can build a very complicated microservices system with not much effort but only if someone on your team is experienced enough. if you're in a small team it's probably not worth the effort of learning the techniques and putting them in practice. we hate premature optimisation after all.;0
13434456;HackerNews;2017-01-19;it can go both ways. if you mess up modification of the microservice such that it breaks other services that relied upon it you quickly get into ceremony that a small team might struggle with. a monolith might have had the problem solved faster.;0
13433990;HackerNews;2017-01-19;better you can do it without a restart is you can serialise current state. that also enforces discipline in defining such state.microservices are only a step ahead.that said in many cases the cost of a full restart can be accepted.;0
13433638;HackerNews;2017-01-19;having loosely coupled microservices has benefits for maintenance as well as scaleability. if you are quickly iterating on a product and have it up in a rough state then you can easily work on seperate parts without having to worry about effecting the whole.;0
13433119;HackerNews;2017-01-19;tbh microservices do a good job of making you much more dependent on your tools and selecting the wrong tool for the job won't become clear until you've used that tool for years.;0
13432579;HackerNews;2017-01-19;i have seen microservices be the death of a lot of startups corporations. proceed with caution.;0
13432530;HackerNews;2017-01-19;choose languages iandi frameworks that developers are familiar with.microservices are fine if you can rely on shared cicd infrastructure and automate execution properly maintaining rapid buildtest cycle times. they start to suck if people aren't familiar and everyone's laptop has to hold their own parallel multitopology service prom regression test releases every time you change a line of code... developer focus flow and efficacy will be reduced.i agree that redundant ha systems are usually not required. in the past it was expensive to get. however tooling is now so good that with reasonable developers and reasonable infrastructure design you can get it very very cheaply if your services are packaged reasonably cdcapable with basically sane architecture and your infrastructure is halfway modern. this truly is excellent because gone are the 1990s of everyonereliesongrizzledsysadminandtwooverpricedboxeswithfailover.i don't think ci is a plaster it is a great way to work but like any tool or workflow is not appropriate in all situations.we do overcomplicate. methodologies are too meta programmers are already operating at max concurrent levels of abstraction. better to incrementally adjust workflow cicd on the workflow for the cicd of the workflow!. that's not to say that there's no value to some people thinking at this level some of the time but yoda told me desk with agile literature much sign of untidy mind be. i think he was right.;0
13432411;HackerNews;2017-01-19;logic is vague and there a several layers you can implement this before even thinking about microservices.it can be as simple as a simple class or maybe a larger class as a singlefile service or an entire namespace with a several classes or a separate library easily referenced. all the logic split benefits without the ridiculous hassle of microservices.;0
13432203;HackerNews;2017-01-19;honestly it is probably just you and your peers.quite frankly chances are the team you have sucks at operations lacks the necessary experience to design complex systems and probably doesn't do the fundamental engineering to make a reliable software product.1 false dichotomy the best tool is one you have mastered your team has individuals with 20 years of development experience on it right? probably not2 micro services are supposed to have small areas of concern and small functional domains to minimize operational complexity. your services are programs that fit on a couple screens right? doesn't sound like it3 redundancy's goal is to remove single points of failure you should be able to kill any process and the system keeps working. the word critical suggests you have spfs4 ci is a dev tool to avoid merge hell by always be merging. ci is often used by orgs with massive monoliths because of the cost of testing small changes and too many cook trying to share a pot. ultimately if you don't have well defined interfaces ci won't save you. you had well defined published interfaces with versions right?5 agile is a marketing term for consulting services to teach large orgs how to act like small effective teams of experts. hint you need a team of selfdirected experts with a common vision and freedom to execute it you got that right?most problems in tech are related to pop culture. because we discount experience because experienced developers are expensive we get to watch people reinvent existing things poorly. microservices soa agile ci these things are older than many devs working today. the industry fads are largely just rebranding of old concepts to sell them to another clueless generation.computers are complex systems networks of computers are complex systems. complex systems are complex. some complexity is irreducible and complex system behavior is more than just a mere aggregation of the parts. people tend to over complicate their solutions when they don't understand their actual problem. they see things they are unfamiliar with as costly and overly complicated as in your examples above.your problem is a culture that doesn't value experience and deep understanding. you and your team will over complicate things because you don't know better yet.;0
13431967;HackerNews;2017-01-19;a certain amount of complexity or complication is required to solve problems. sometimes you will undershoot the mark and not fully solve the problem. other times you will overshoot the mark and create problems in the form of overcomplicated answers. 1 choose languages that developers are familiar with not the best tool for the jobit's a tradeoff rampup time vs efficacy once ramped up. it's probably okay to let your devs rock it old school with vanilla javascript for your website frontend it's probably inoti okay for them to try and write your website frontend in cobol even if cobolscript is apparently a thing just because they don't know javascript. 4 continuous integration seems to be a plaster on the problem of complex devops introduced by microservices.ci is great plaster for all kinds of problems not all of which you'll be able to solve in a reasonable fashion. of course you may have problems which would be better to solve that you're using ci as a crutch to avoid solving or to simply deal with the fact that you haven't gotten around to solving those problems iyeti.in game development i use ci to help 'solve' the problem of my coworkers not thoroughly testing all combinations of build configurations and platforms for each change. 5 configs and 6 platforms? that's already 30 combinations to test so it's no wonder... 5 agile methodology when used as anything but a tool to solve specific discrete communications issues is really problematicon the other hand other companies rock flat management well past the point it's effective and may lack any kind of methodology to keep progress on track which is also problematic.;0
13431774;HackerNews;2017-01-19;i did not mean microservice as in just make it many apps!. i meant as do not share databases and expose everything as apis.it helps cognitive load because such apps can be reasoned about without reading code elsewhere.;0
13431753;HackerNews;2017-01-19;i tend to try to write monolithic services in such a way that they icouldi be broken up into microservices if that were ever desired.i don't go too far with this just avoid things like shared static state and other antipatterns.;0
13431045;HackerNews;2017-01-18;hi i'm happy to be posting anon right now. can someone eli5 the difference between libraries and packages and a microservice?;0
13430980;HackerNews;2017-01-18;the rule is there are no rules. the answer is it depends.if the only language your developers are familiar with is ruby and you're developing a realtime highperformance system then you shouldn't write it in ruby.if you need the kind of availabilityscalabilityencapsulation that microservices provide in your applicationusecase then you should use them. don't break you application into microservices just because everyone says it's a good idea. an angry birds app on an iphone doesn't need to be split up into microservices running on said iphone.if you don't have redundancy and you lose your server then you're hard down. if you're ok with that fine. if you want to continue operation with one server down then you need redundancy. redundancy doesn't necessarily add as much complexity as you seem to imply.continuous integration is usually a good idea regardless of all other variables. if you have more than a single developer working on a system it's a good idea to keep buildingtesting this system with every change so you can catch issues earlier. you start very lightweight though with a small team. even a single dev can do ci it's not that hard.agile is just a buzzword but it doesn't hurt to familiarize yourself with the agile manifesto while making sure you're aware of the context in which it arose. it's really mostly about understanding that requirements often change and that we're dealing with humans. again different projects team sizes situations will require somewhat different approaches. sometimes the requirements are well understood and will change very little. sometimes you know nothing about what the software will do when you're done.;0
13430576;HackerNews;2017-01-18;avoid microservices where possible the operational cost considering devops is just immense is it though? there's more complexity due to more moving parts sure. but being able to solve issues by just issuing a scale kubernetes command in the cli is priceless. as is killing pods with no drama. however what are we talking about here? small business ecommerce? your monolithic app is probably going to work just fine.maybe i just haven't seen enough projects but every significant criticism of microservices i've seen assumes that microservices effectively means each team does their own thing in a way that greatly increases complexity and maintenance costs of our monolith app.of course it's not going to pay off if you're maintaining all your own hardware servers and each team is using their own stacks languages and frameworks... especially if they're all bottlenecked to the same database instance anyway. that's basically magnifying the potential downsides and minimizing the benefits.our industry definitely has some use the new stuff because it's cooler sentiment but i think we also have another distinct mentality that shows up a lot. i'm most familiar with hammers. we tried a cordless drill once a few years ago but its battery died and we had to wait for it to charge! the hammer still worked though. so we stick to hammers and i recommend others stay away from drills.;0
13430061;HackerNews;2017-01-18;you've thrown together a bunch of buzzwords and asked if we are over complicating things.buzzwords can mean freaking anything. i've seen great agile teams that don't look anything like textbook agile teams. microservices can be a total clusterfuck unless you know what the hell you're doing and manage complexity. sound familiar? cicddevops can be anything from a lifesaver to the end of all life in the known universe.so yes we are over complicating software development but the way we do it isn't through slapping around a few marketing terms. the way we do it is not understanding what our jobs are. instead we pick up some term that somebody somewhere used and run with it.then we confuse effort with value. hey if devops is good the more we do devops the better we'll be right? well no. if agile is good the more agile stuff we do the better we'll be right? hell no. we love to deep dive in the technical details. if there aren't any technical details we'll add some!software development is too complicated because individual developers veer off the rails and make it too complicated. that's it. that's all there is to it. throw a complex library at a good dev and they'll ask if we need the entire thing to only use 2 methods. throw a complex library at a mediocre dev and they'll spend the next three weeks writing 15 kloc creating the ultimate system for x iwhich we don't need right now and may never needi.it has nothing to do with the buzzwords the tech or software development in general. it's us.;0
13430037;HackerNews;2017-01-18;if you need to change your microservice's api in a nonbackwards compatible way you have the exact same problem plus significant operational complexity.;0
13429792;HackerNews;2017-01-18;i've used microservices but on qnx where you have msgsend and msgreceive which make message passing not much harder than a subroutine call and not much slower. unixlinux was never designed for interprocess communication. you have to build several more layers before you can talk and the result is clunky.if you're crossing a language boundary it's often better to use interprocess communication than to try to get two languages to play together in the same address space. that tends to create technical debt because now two disparate systems have to be kept in sync.;0
13429761;HackerNews;2017-01-18;at the last company i was at our search microservice was fast average response was well under 100ms and it didn't crash once while i was there. at a larger company this may not be an accomplishment. at a startup this is the bees knees.meanwhile the rest of our codebase a monolith crashed every few days for one reason or another. we had an oncall rotation not because that's what you're supposed to do but because we actually needed it.now i'm not saying that microservices make sense for everyone. in general i agree that they are used incorrectly. microservices are hot and software developers generally speaking like to use hot technologies. yes moving to a microservice was costly. we had to rewrite a lot of code we had to set up our own servers and we had to get permission from the guardians that be to do all of this. but for our use case and i assume there are other use cases too the benefits of detaching ourselves from the company's monolithic codebase far outweighed the costs for doing so.tldr no argument is the end to every conversation. few things are so black and white.;0
13429644;HackerNews;2017-01-18;i feel like all of this just comes back to judgement calls. you can't pick technologies in a vacuum and you can't generalize technology choices.it's not very fair to make these claims without knowing all of the details around the situation. microservices can be a pain but it might offset a greater pain of trying to coordinate a monolithic deployment. it depends on things like team size budget and technology available to you.this is where i see the disconnect between employers and most developers. programming isn't a job. your employer doesn't pay you to write code. they pay you to solve problems. the good employers don't care what tools you use to solve the problem just that you solved it. the bad employers will force you to use technologies and buzzwords that probably don't apply to your situation. you should be able to defend all of your decisions and have good reasons for them.on the flip side not everything you try will work that doesn't mean that it's a bad option just that it didn't work for your situation. you don't need to have a redundant lowpriority memo system because you don't get enough value out of it to justify the overhead of maintaining it.;0
13429502;HackerNews;2017-01-18;nothing about splitting your app into microservices forces a good design. i've never seen microservices with welldefined seams. every time knowledge leaked between the apps and any nontrivial change to the app required updating multiple repos deployment synchronization etc. microservices are a tremendous burden that the vast majority of companies will not benefit from.;0
13429476;HackerNews;2017-01-18;one caveat is that if you need to fix a bug in your library in an apicompatible way you can't reach into all the codebases that are using your library. you can deploy a new version of the microservice though.;0
13429417;HackerNews;2017-01-18;from my perspective the problem is that others ibelievei everyone else is caught up in the same trends they are. if someone starts to prosthelytize something whether that's build management microservices or even pairing react with redux by default individuals start to think it's the new thing and adopt rather than critically think about it.personally i tend to shy away from tools unless they seem to do something of significant value for me that outweighs their cost on my development process. the best tool for the job is the one that allows me to finish a project in a timely manner not one whose memory footprint is 10 lower.;0
13429279;HackerNews;2017-01-18;figuring out how to do things simply is remarkably hard. after twenty years of this i feel like i'm beginning to be able to design simple systems some of the time.the problem with much currently accepted wisdom is that it doesn't explain exactly what is being balanced. works for my organization is the equivalent of works on my machine. for example1 best tool for the job when applied to languages nearly never is a question of the intrinsic merits of a language design. there have been quite a few discussions recently on hacker news on the virtues of a boring stack that is one that everyone else has already beaten on so much that you can expect to hit fewer issues.2 microservices are a tradeoff. if you have an engineering team of five hundred shipping a single software as a service product one of your biggest issues is coordinating releases among all those people without having your services pingponging up and down all the time. microservices are an answer to that. at that scale you've already had to automate your operational troubles so it doesn't impose that much additional operational cost. if you have an engineering team of ten then none of this applies to you.3 high availability like all concurrency is hard. try to write your own code so that it scales horizontally by simple replication and depends on stock components such as kafka zookeeper etcd or cassandra to handle orchestration. in many cases your reliability budget may be such that you can run a single system automate some operations around it and be just fine. it's only when your reliability budget doesn't allow that or your workload forces you to orchestrate parallel work that you have to go this route.4 yes. nearly all discussion of agile software development that i've seen focuses on rituals without the applied behavior analysis underlying them. for example a standup meeting has a small set of goals establish a human connection between everyone on the team on a regular basis air things that are blocking individuals in a forum where they are likely to find someone who can unblock them quickly have everyone stand up and take responsibility for what they are doing in front of their team and serve as a high bandwidth channel of communication of important information the build is going to break this afternoon for an hour etc.. if those outcomes are being achieved in other ways by your group then there's no reason to have a standup. if you're doing a standup and it's not accomplishing one or more you need to revise how you do it. human behavior and interaction is something to be designed and shaped in an organization. what works in a team of three with excellent communication may not work in a team of ten or fifty or five hundred.;0
13429276;HackerNews;2017-01-18;you can get that benefit by dividing your system up into libraries with defined documented tested apis. there's no need to introduce all the complexity and failure modes of distributed systems just to force good design.when you need to scale itheni you can easily throw your libraries behind an rpc framework and call it microservices but there's no need to pay that cost until you actually face that problem.;0
13429272;HackerNews;2017-01-18;definitely agree the polyglot aspect can also be useful for companies where different parts of their problem fit different tools.however exercising proper software discipline and using languages with goodexistent module systems like ocaml or go can lead to the same modular results without the fixed overhead. if you don't have a fulltime ops person or team you almost always have no business running microservices.;0
13429225;HackerNews;2017-01-18;forces good design and reduces cognitive loadexcept splitting into microservices is an unnecessarily complex design choice. that's almost always worse and the cognitive load comes in when you now need to figure out how to get this stuff right. the scaling benefits also require that you get it right small flaws in your system become massive issues.;0
13428941;HackerNews;2017-01-18;i believe for small shops the real benefit of microservices is the logic split that forces good design and reduces cognitive load.you reap the scaling benefits way later if ever.;0
13428909;HackerNews;2017-01-18;i put good in es for a reason. i never said hire the best that isn't a requirement for anything that was stated.there shouldn't really be a measurable overhead of running a distributed system at least in the context of microservices. i strongly disagree with the sentiment that a distributed system isn't worth it at smaller organizations. i'm part of one and it helps keep things flexible while increasing reliability of the overall systems.but that's neither here nor there. one shoe size won't fit everyone but op ran down a gambit of things and seemed to have issue with each one. it is exceedingly unlikely they are doing anything eccentric enough to the point of proclaiming ci is just a bandaid on the broken concept of microservices. i will contend that the source of op's insights are... misappointed and by breaking down efficiencies and flexibility they're merely masking certain underlying problems.what's more probable? an organization hired some wrong people or a generic list of strongly supported practices over the course of two to three decades are to blame for an organization's failings? i guess that's my take on it.;0
13428890;HackerNews;2017-01-18;i find that the boundary creates operational headaches. a function call won't time out deliver a 502 error have authenticationauthorization issues require load balancing etc. etc.a rest api will.plus once you've debugged a problem that involves crossing 5 microservice boundaries you'll start to wonder if it was all worth it.monolith is also a wrong and somewhat derogatory word to describe a nonmicroservice architecture. there's nothing monolithic about loosely coupled code running on the same machine.i really think that microservices are a hack to deal with conway's law in large corporations. operationally it's inefficient but it fixes a nexus of technical and political problems when the correct boundary is picked.;0
13428602;HackerNews;2017-01-18;yeah. if you're going to use languages methodologies and architectures without understanding and without evaluating them for how well they fit your situation many things will be painful. don't follow the fads whether methodologies agile architecture microservices languages or frameworks. iuse what's appropriate for what you need to do.i;0
13428435;HackerNews;2017-01-18;imicroservices probably reduces the asymptotic cost of scaling but add a huge constant factor.iif this were imediumi i'd highlight the hell out of that.that's so true and so nicely succinctly put it ought to be the reply to end every argument about whether microservices are good or bad.;0
13428318;HackerNews;2017-01-18;1. what problem are you optimizing for? the job encompasses code but it also encompasses staffing. it's a lot easier to hire java developers than scala developers. in a leadership role your responsibility isn't just the daytoday code it's the whole project.2. microservices vs monoliths is a seesaw. you build a monolith find it's a brittle incomprehensible hairball and you break out microservices. you build microservices find that operational headaches are killing you and start consolidating them into monoliths. which kneecap do you want the bullet in?3. fix what breaks.4. continuous integration is ivitali. but it needs to be evolved along with the system. there's this thing i say... have computers do what computers do well have humans do what humans do well. handling complex and irepeatablei behavior i.e. builds and test suites should absolutely be automated as much as possible. think continuous integration sucks? try handing it off to humans for a while! you'll learn whole new levels of pain.5. all process is about or should be about specific discrete communications issues.;0
13428268;HackerNews;2017-01-18;avoid microservices where possible the operational cost considering devops is just immenseis it though? there's more complexity due to more moving parts sure. but being able to solve issues by just issuing a scale kubernetes command in the cli is priceless. as is killing pods with no drama.however what are we talking about here? small business ecommerce? your monolithic app is probably going to work just fine. advanced reliability redundancy even in critical systems ironically seems to causes more downtime than it prevents due to the introduction of complexity to dev amp devops.systems can and will fail. if you can eat the downtime by all means forget about that. continuous integration seems to be a plaster on the problem of complex devops introduced by microservices.could you stop singlingout microservices? we have deployed continuous integration with old school rails apps before and it was extremely valuable.agree about agile.;0
13428211;HackerNews;2017-01-18;yes we are over complicating it but that it primarily about trying to take what is essentially an artistic process and turning it into a regimented process a known hard problem.rob gingell at sun stated it as a form of uncertainty principal. he said you can know what features are in a release or when the release will ship but not both. it captured the challenge of aspirational feature development where someone says we have to have feature x and so you send a bunch of smart engineers off to build it but there is no process by which you can start with an empty main function and build it step by step into feature x.that said it got worse when we separated the user interface from the product browser webserver. and you're rants about microservices and continuous integration are really about releases delivery and qa. the 'delivery time' of gingell's law above.these are complexities introduced by delivery capabilities that enable different constructions. the story on hn a few days about about the js graphics library is a good example of that. instead of linking against a library on your computer to deliver your application with graphics we have the capability of attaching to a web service with a browser and assembling ion demandi the set of apis and functions needed for that combination of client browser os. its a great capability but to pull it off requires more moving parts.;0
13428145;HackerNews;2017-01-18;there is a lot of bs in software development. always has been probably always will. everything is a tradeoff. understand the tradeoffs that you are taking listen for the principles and you can ignore most of the noise.on to your questions.i1 choose languages that developers are familiar with not the best tool for the jobihow familiar developers are with the language is part of what determines what is best for the job at hand in a real organization.it isn't the only factor. for example if you're doing something new to you doing it in the language that you find wherever you are learning it from makes sense because you'll be more likely to get help through complex issues.that said do not underestimate the support advantage of using a consistent toolset that everyone understands.i2 avoid microservices where possible the operational cost considering devops is just immenseisee for emphatic support.if you go the microservices route think ahead about predictable challenges with debugging failures 3 calls deep and plan in advance for monitoring etc tooling to solve it.i3 advanced reliability redundancy even in critical systems ironically seems to causes more downtime than it prevents due to the introduction of complexity to dev amp devops.ias the old saying goes dbas are the primary cause of databases going down. reliability is not something that you just plaster on top blindly. an systems are good at finding failure modes that you never thought of.i4 continuous integration seems to be a plaster on the problem of complex devops introduced by microservices.ino. continuous integration is actually a fix for developers checking in clearly broken code and then nobody discovering it later. that said it does little good without a number of other good practices that are easy to ignore.i5 agile methodology when used as anything but a tool to solve specific discrete communications issues is really problematicithis one generated the most discussion. i would say sort of but you went too far.any set of poorly understood principles dogmatically applied is going to work out badly. agile is actually a set of good principles that addressed a major problem in the common wisdom back in the day. but the pendulum has swung and it is often applied poorly.that said there are other problems in organizations which are prone to poorly understood principles dogmatically applied...;0
13428082;HackerNews;2017-01-18;well i think there are 6 points to answer here 0 are we over complicating software development?yes in many cases we are over complicating software development. i think a large part of oop too complex to produce reliable services easily still possible though. simplicity is not as popular among developers as it should be. i often run into complex code that can be replaced by 10x smaller code base that is much clearer than the original.1 sure2 i am not sure why you think that you need services that can few things well and individually scalable units. this used to be soa service oriented architecture and microservices lately. there are cloud vendors out there who make it super easy for you to run such services for reasonable price on their platforms without a devops team.3 see point 0. complex systems fail more than simple ones. failure isolation and graceful degradation should be properties at design time. the best is to have stateless no master slave service or registry that is required for correct operations clusters where you can scale the capacity with the number of nodes.4 continuous integration is way older than the term microservices. it contains patterns that a company figured out by shipping code that had to be reliable and it is optimised for frequent changes aka when you developing a new service or product. it is just a way of giving instant feedback to developers.5 there are so many talks and videos about agile used bluntly is harmful on the web that i think this is a well understood question. use a method that works for the team it provides the insight to the business what they are doing and you are good. i use kanban for almost 10 years with distributed teams software and systems engineering and it works perfectly for us.1 for simpler code and simpler software;0
13428055;HackerNews;2017-01-18;some good practices aren't a good fit for a particular organization. moving the discussion to whether your engineers are good rather than whether they understand the organization's needs is reductive.if you want to develop better practices in an industry saying the practitioner should be good isn't very helpful. of course they should be good! but unfortunately despite the trope we can't all hire the best and part of the reason we have best practices is to work well without only hiring the top 1 of engineers.an example from my experience mentioned in another comment microservices are a good practice in many larger orgs because a big piece of what they solve is political but the overhead of running a distributed system at a small org often isn't worth it.;0
13427830;HackerNews;2017-01-18;continuous integration is with a reasonable test suite one of few elements of software development that i would consider almost essential for any long running project. it's just too useful to have continual feedback on the quality of the system under construction. and this is before bringing in microservices or any other complicating architectural pattern.where i might agree with you more are on points 3 and 4 'advanced reliability' and 'microservices'. while i have no doubt that these are useful to solve specific problems i think as a profession we tend to overestimate the need for these things and underestimate the costs for having them. to me this implies that there needs to be a very clear empirical case that they support a requirement that actually exists. i'd also make the argument that the drive for microservices within an organization has to come from a person or team that has the wherewithal to commit resources over the longterm to actually make it happen and keep it maintained. ie probably not an individual development team.;0
13427777;HackerNews;2017-01-18;i think these problems are not about software development but are infrastructural and architectural. lack of good people to handle those things is certainly a problem. but you do need quite a bit of infrastructure for microservices for resilience for continuous integration and all of that paired with some good architectural decisions. resilience is probably the hardest thing among them as it requires some expertise in distributed systems operations infrastructure so you wouldn't do something that has almost no impact but requires a lot of engineering effort.;0
13427761;HackerNews;2017-01-18;i don't do anything approaching microservices but a good ci setup combined with a good test suite is an absolute blessing that verges on a 'must have'.;0
13427652;HackerNews;2017-01-18;many of these practices are popularized by googlefacebookamazon but don't make sense for a company with 100 or even 1000 people. i try to focus on whether a practice will solve a concrete problem we're facing.switching from hadoop to spark was clearly a good idea for our team even though it required learning a new stack but there isn't a strong reason to switch to flink or start using haskell.agile makes sense when your main risk is finegrained details of user requirements but not when you have other substantial risks such as making sure a statistical algorithm is accurate enough.microservices probably reduces the asymptotic cost of scaling but add a huge constant factor.relational databases are the right choice 95 of the time nonrelational stores require a really specific use case.tdd is good for fast feedback in some domains but for others manually investigating the output or putting your logic into types is better. e.g. a lot of my time comes from scaling jobs that work on 10gb of data but crash on 1tb tdd is not that helpful here.continuous integration mostly makes sense when you're making a lot of small changes and can reliably expect a test suite to catch issues.in short ask the question when is practice x useful? instead of is practice x a good idea?;0
13427587;HackerNews;2017-01-18;i think you wanted to say are we simplifying things in software development? all of the points you have made are actually simplifications of what might be the optimal solution.imagine the solution space as some multidimensional space where there is somewhere an optimal solution. the dimensions include the habits of your programmers the problem you are trying to solve and the phase of the moon. microservices a special form of redundancy continuous integration agile development are all extreme solutions to specific problems. solutions which are extreme in that they are somewhere in the corner of your multidimensional solution space.they are popular because they are radical in the way they conceptualize the shape of the problem and attempt to solve it. therefore they seem like optimal solutions at first glance when really they only apply really well to specific toy models.take e.g. microservices. yes it's really nice if you can split up your big problem into small problems and define nice and clean interfaces. but it becomes a liability if you need too much communication between the services up until the point where you merge your microservices back together in order to take advantage of using shared memory.don't believe any claims that there is a categorically better way to do everything. most often when you see an article about something like that it is proved by showing it solves a toy model very well. but actual problems are rarely like toy models. therefore the optimal solution to an actual problem is never a definite answer from one of the simplified corner case scenarios but it is actually just as complex as the problem you are trying to solve.;0
13427556;HackerNews;2017-01-18;1 the best tool is useless if people can't avail of its power2 true. microservices are usually premature optimization3 true4 ci is a good idea regardless of using microservices or not5 you might elaborate this item;0
13427503;HackerNews;2017-01-18;i find microservices can help in just keep everything small and focused. i know you can do this with a monolith. but having a process boundary really enforces it.;0
13427445;HackerNews;2017-01-18;1 choose languages that developers are familiar with not the best tool for the job95 of the time a language that your developers are familiar with is the correct tool for the job simply for that reason! there are cases where it is not the case but those involve special case languages and special case systems. if you don't know what special case means then you're situation is almost certainly on that list. 2 avoid microservices where possible the operational cost considering devops is just immenseif your data fits on one machine then you don't need hadoop ... same thing applies here. microservices have place and putting them in the wrong one will bite you bad. 3 advanced reliability redundancy even in critical systems ironically seems to causes more downtime than it prevents due to the introduction of complexity to dev amp devops.then there's probably something wrong or limited with the deployment that needs to be reviewed 2 node when you need a 3 node cluster bad networking environments etc. if you have a reasonable setup with solid tech under it ideployed per specsi then this should not be true. if on the other hand something is out of whack say running a 2 node cluster with linux ha and only a single communication path between them you're going to have problems and the only way to fix them is to get it done right. 4 continuous integration seems to be a plaster on the problem of complex devops introduced by microservices.i'm not sure about this but if your deployment system requires ci you have a problem. an individual given hardware and assetscode should be able to spin up a complete system on a fresh box cleanly and in a reasonable timeframe. fresh data restores can take longer of course but the system should be runnable barring that. if this irequiresi i.e. it can't reasonably be done manually something like an ci script or ansiblechefetc. script then you're deployment process is probably too complex and needs to be reevaluated. 5 agile methodology when used as anything but a tool to solve specific discrete communications issues is really problematicagile is commonly used to gloss over a complete lack of structured process or a broken. even with agile there should be some clean process and design work that goes into things or you're hosed.;0
13427415;HackerNews;2017-01-18;from what you are describing it seems like there is more a problem associated with your team than with anything else. maybe you don't have the right set of expertise in the team and people tend to work better with what they are comfortable with. microservicesredundancy supportci at a fundamental level increase the complexity of how you go about things but they do have benefits. they require a way of thinking and developing that should be a cultural fit for the team for it not to feel like you are constantly fighting the system. one way to get there is to incrementally add these after the primary project is done. when tackling one thing at a time things end up being simpler and and the need for these things gets into the working habits of everyone better and they are no longer fighting the system.;0
13427380;HackerNews;2017-01-18;you are right. agile languages ci devops are all tools not solutions to problems. blindly applied they will not get the results promised.first focus on identifying the primary job to be done build a valuable piece of software with as little effort as possible given your current team and existing technology.second consider how valuable the existing software is and whether it really needs to be rewritten at all. prefer a course that retains the most existing value. it is work you won't have to repeat.third choose tools that maximize the value produced per hour of your team. ci devops microservices languages all promise productivity and reliability benefits but will incur complexity and time costs. choosing the right mix is part of the art of software management.;0
13427372;HackerNews;2017-01-18;1 no way. absolutely not. not if what you're building is intended to last. any languageecosystem you choose has costs and benefits. you will continue to pay the costs and reap the benefits long after your developers could have become fluent in a language.certainly the language your developers already know is better than one they don't all things being equal. but your rule is way too simplistic.2 of course. avoid every complex thing where possible.3 this means the costbenefit ratio was not considered closely enough when planning these features. again avoid every complex thing where possible.4 this is a strange one. most people doing ci are not building microservices. ci is really more about whether you have different independently moving pieces that need to by integrated. could be microservices could be libraries could be hardware vs software. if you only have a single active branch everyone's merging into regularly you're doing ci implicitly. you just might not need it automated.5 take what you can from the wisdom of agile and then use your own brain to think. and don't confuse agile with scrum.;0
13427339;HackerNews;2017-01-18;many of the programmers i have worked with actually love complexity despite trying to convince others and most likely themselves that they hate it.advice tends to be cherrypicked to suit an agenda they already have with your example on microservices the vast amount of resources saying they're very difficult should be driven by a monolith first approach and solve a specific set of problems is largely brushed under the rug.i think because our industry moves so fast there's a fear of becoming irrelevant. ironically companies are so scared of not being able to employ developers that they're also onboard with complicating their platform in the name of hiring and retention. i think this is down to the sad truth that most developer roles offer very little challenge outside of learning a new stack.;0
13427314;HackerNews;2017-01-18;no it's not just you and yes we often do overcomplicate software development.it's been that way long before agile methodology or microservices though. complexityforthesakeofcomplexity everthinghastobeanabstractclass frameworks have been plaguing the software development business since at least the 1990s and i'm sure there are similar stories from the 80s and 70s.it's hard to find a onesizefitsall easy method for not falling into that overengineering overmanagement trap. i try to focus on simple principles to identify needless complexity there is no silver bullet see microservices if the same design pattern is used to solve each and every problem there probably is something amiss. less code is better. favour disposable code over reusable code avoid the trap of premature optimisation both in terms of performance and in terms of software architecture. also known as you aren't gonna need it. code means communication by writing code youre entering a conversation with other developers including your future self. if code isn't easily comprehensible again there's likely something wrong.;0
13427306;HackerNews;2017-01-18;1 false dichotomy. developer familiarity is one of the most important metrics for choosing the best tool for the job.2 conway's law applies in reverse here if your organization consists of a lot of rather disjoint teams then microservices can be quite beneficial because each team can deploy independently. if you're one cohesive team there is not much benefit only cost.3 depends. if you have a welldesigned distributed system it can be amazingly resilient and reliable without introducing much administrative overhead. from my experience openstack swift is such a system. parts may fail but the system never fails. there are two main problems with distributed systems a designing and implementing them correctly is really hard. b many people use distributed systems when a single vm would do just fine and get all the pain without cashing out on the benefits. see also 4 continuous integration was not meant to help with complexity. its purpose is to reduce turnaround time for bugfixes and new features. if your release process is long and complicated the increased number of releases will indeed be painful for you. our team sees value in bringing the pain forward in this way. your team obviously puts emphasis on different issues and that's okay.;0
13427244;HackerNews;2017-01-18;you're right though you should end most of your comments with for us.we've been burned by the microservice hype and it took a while for us to realize that most of the touted benefits are for larger organizations. these best practices rarely include organizational context.;0
13427206;HackerNews;2017-01-18;1. i think this is rather obvious work with what you have. maybe think about hiring specifically for areas your team is in lacking in as long as the team as a whole will see decent benefit from it.2. i hate to say you're doing microservices wrong but i'd really question project structure and practices being the culprit behind the cost of doing devops with microservices.3. this seems like an engineering fault rather than some implicit principle behind those concepts causing more downtime.4. how is ci a plaster on the problem of microservices? ci is useful with or without microservices.5. agile was always meant to be a iguidelinei not an end all and be all. it's meant to get your team to figure out how it wants to work and write code before process. see the problems you are describing seem like big problems with your team engineering and management. no amount of process and technology is ever going to fix a dysfunctional sorry if that's too blunt team. what i get from this instead of having processes in place that make it easy to move code out you're removing tooling to slow things down intentionally with the superficial result of stabilizing the entire development effort. the solution appears to be to get your team to write less code and force management to bow down to the new reality of these stabilizing changes. both of which can and sometimes should be done regardless of processes and tooling in place.the best code is the code you don't write. but don't blame the tooling on making it easy for a team to be lazy and remove the all important characteristic of a team selfcritiquing i.e do we really need this feature that'd be nice to have but right now we're managing to get things done. did i actually test my code was it reviewed or am i just counting on the fact that i can shove something else out later while our redundancy systems pick up the slack?;0
13427187;HackerNews;2017-01-18;as someone working at a scrum company transitioning from php monoliths to ddd microservices shielded by nodejs gateways and apis and even cqrses on the horizon i will answer yes.but i guess that'll look cool in our resumes.i must say sometimes i envy our mobile developers that are a bit immune from all that.;0
13427171;HackerNews;2017-01-18;the only way to have any sense of a good or solid development platform or lifecycle is to me to look at your specific situation and tailor everything to your deliverables and needs. doing anything because of industry trends or academic pontificating will lead you towards the solution someone else had success with in a different circumstance.microservices work fine in some situations agile works fine in some situations but until you find that you are in one of those situations trying to bend your deliverables to meet a sprintcycle or some other nauseating jargon will cause as you put it overcomplication or just poorly targeted effort. it can also cause enough stress to dramatically affect your health i know better than mostthose moments of solidarity between product and effort are real gems that i've only recognized in hindsight.;0
13427168;HackerNews;2017-01-18;much of the problem in the things you mention is that those things are specific solutions that have been confused with goals. i.e. we're supposed to build microservices is a horrible idea as opposed to given this particular situation a microservice is a great fit.understanding the ipossiblei benefits and drawbacks of any solution is important. it's important in whether or not that solution is selected but also to make sure that the implementation actually delivers those benefits.it's very common in our industry to use best practices without understanding them and therefore misapplying the solutions.;0
13427121;HackerNews;2017-01-18;no. you are correct. honestly i think you can solve a lot of that by following on from one of deijkstra's core priniciples seperation of concerns.when you practice good seperationof concerns specific choice in different areas can be more easily fixed later. it requires having decent apis and being thoughtful on the interaction of different components but it helps immensely in the long run.microservices are one way to practice seperation of concerns but it can also be practiced in monolithic software as well by having strong modular systems different languages are stronger at this than others.;0
13427102;HackerNews;2017-01-18;all development teams or products are not the same. sometimes microservices can improve the quality and sometimes the opposite.it is important to know why you do some things instead of applying hypedrivendevelopment.do what is best for iyou and your teami instead of what is best for isomeone elsei with a different product problem and team.;0
