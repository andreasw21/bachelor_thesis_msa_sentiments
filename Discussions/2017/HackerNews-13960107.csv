ID;Source;Creation Date;Content;Sentiment
13960107;HackerNews;2017-03-26;Title:Modules vs Microservices, Content: https://www.oreilly.com/ideas/modules-vs-microservices;0

13968709;HackerNews;2017-03-27;i think that microservices may be an actual optimization when the application flow has several clearly separable tasks that have varying requirements and you need to divide the load over several machines. for example one task may be mostly io heavy another will use a lot of ram and a third may mostly be cpu bound. when you distribute the load over multiple servers microservices can make it easier to tailor each server to the needs of the services it runs. the io bound workload doesn't need 100gb ram and the cpu bound workload may not need several gigabit interfaces.that said i haven't personally worked with a microservicebased architecture where this ever became a useful optimization. often it is exactly as you say a technological workaround for an organizational problem.;0
13968510;HackerNews;2017-03-27;imo microservices from day one aren't necessarily a premature optimization or an optimization at all. it is sometimes just the natural way to model a solution.for example at my last job we developed several services that constantly generated reports for our clients to run. instead of embedding the functionality to move these files to other machines in each service we developed a separate service that monitored a directory to do only that. this meant that the reporting services were more open ended clients could decide how to handle the files but were still left with a very convenient option. it also meant that we could hand off new versions of the transfer service on its own for customers to install without interrupting reporting services and only having to deal with the documentation of the transfer service itself.in terms of scalability or performance it added absolutely nothing but it simplified deployment documentation and development from day 1.;0
13966513;HackerNews;2017-03-27;those are good and important questions.our old 1.0 store architecture did in fact decompose things into multiple services. it has a separate acl microservice that every microservice had to consult in order to perform permission checks. that was a really bad stupid bottleneck.for our new architecture we decided to move things into a single integrated opinionated package that's operationally simpler to deploy and run and reason about. it's also highly focused and intended for composition the permission system for example is intentionally kept simple to avoid it blooming into some kind of allencompassing rule engine it only cares about data access and doesn't even have things like ip acls or predicatebased conditionals. the idea is that if you need to build something complicated you would generate acls programmatically and use callbacks to implement policies outside of the store the comments only editable for 5 minutes is an example of this and maybe someday we'll move the entire permission system into a plugin so you can replace it with something else.it's also important to note that the store isn't the data store to end all data stores. it covers a fairly broad range of use cases documents entity graphs configuration analytics but it's not ideal for ialli use cases. there are plenty of use cases where you'll want some kind of sql database.;0
13965577;HackerNews;2017-03-27;re rule enginesi know exactly what you mean having suffered through jrules projects but don't consider ruleforwardchaining languages part of a soa stack per se i especially loved the idea that rule bases unlike services don't need testing because they're enduser configuration parts and because like sql they're kindof declarative.reading through the answers i still don't know how microservices are any different from soa;0
13965558;HackerNews;2017-03-27;we used microservices at my last job and initially everyone used the same maven archetype to create a basic java application of similar structure property files environment variables filters etc. it wasn't as sexy as say scala or node or haskell. otoh there were absolutely no developers who didn't already know java or could learn our framework in a few months at least enough to follow and be productive.this came in handy because everyone could easily jump from one service to another and figure things out pretty easily since not only was it all in the same language but also the configurations and bootstrap classes were the same. once someone figured out something clever it was easily added to the base classes for everyone else to inherit.eventually some of the newer hires got bored of java and wanted to use things like node python etc.at the time i left it was a pure clusterfuck. it was impossible to write once and easily change the whole filter stack e.g. an auth filter since we were now up against at least 5 different languages frameworks. developers couldn't easily jump from project to project as needed either.anyway most of our microservices were just glorified db json crud apps. microservices themselves were probably not needed for our customer size we would have been fine with a 2008style multiwar project on jboss.and yes even java is pretty damn good at spitting out crud json data to frontends. absolutely no need for the complexity introduced by the half dozen other frameworks.;0
13965103;HackerNews;2017-03-27;yeah that's a good point. when the system is too big there's no way you can run it all locally. the angle i'm coming from is an application that's fairly new and still small and is changing rapidly with lots of crosscutting changes. we're paying some heavy microservices taxes with development testing deployment and performance but not at a point where we see benefits yet imho.;0
13964494;HackerNews;2017-03-27;let's say the app is a comment system that allows editing your comment but only within 5 minutes. acls cannot express this so to accomplish this we have the store invoke a callback to the owner microservice which can then accept or reject the change.i think these kinds of access control rules can be expressed within an entitlement solution. these systems are often called rbacabac role based access control attribute based access control. the caller calls a pdp policy decision point. policy decision point is a rules engine that can take in the callers application context which in your case will include current time and the time of the initial post pdp is often implemented as a microservice or even as a cacheenabled rules engine that as api resides with the context of every caller for faster lower latency more resilient solutionthese components are part of xacml;0
13964316;HackerNews;2017-03-27;watching a discussion like this really make me wonder this what is a module anyway? there are obviously varying aspects of modularity such as different code locations e.g. functions different namespaces e.g. libraries python modules different release cycles distribution models e.g. es6java modules in this sense? different oses languages security models e.g. microservices?seems like people including myself are confused by putting these in a onedimensional spectrum. the reality is probably never that simple.;0
13964270;HackerNews;2017-03-27;i agree but i don't think microservices are properly classed as an optimization of any sort premature or not. microservices arise because a company can't communicatemanage itself internally.this does not mean that you must have one giant 50mb executable to run your whole company but it probably does mean most companies shouldn't have 60 200line microservices.;0
13964104;HackerNews;2017-03-27;i've worked on both types of projects and i would never choose microservices over monolith if presented the option.rather i agree with the author that proper separation into documented modules gives most of the benefits from microservices without any of the numerous drawbacks.microservices seriously increase the operational overhead. they increase the hardware expenses. they increase service latency through round trip times and unnecessary work. they increase the code complexity through unneeded serializationdeserialization and rest calls vs plain old function calls. they make debugging a lot harder. they give you all the pain of distributed systems and networking when all you previously needed was a function call.with go and many other statically typed languages you get proper modules that can't reach into the private implementation of other modules even with reflection. they can't have import cycles. the compiler will take care of alerting you when an api changes in an incompatible way. likely all your modules will share a backend databases so you need to take care to use the public interface of the responsible module rather than reach around behind its back with direct queries but that's a solvable organizational problem.i wonder sometimes if the microservices craze isn't trying to find a technical solution to human problems that would be better dealt with via communication and creating solid organizational practices. like team a doesn't trust team b and rather than work out a common set of norms and rules they just start using microservices to bypass dealing with the problem all together.;0
13964038;HackerNews;2017-03-27;those are organizational concerns that you're conflating with microservices vs monolith. they're tangential. i see no reason why you can't assign team responsibility to individual modules vs microservices. you can collect metrics for both modules and microservices and publish them in a dashboard. alarms and monitoring are probably unnecessary at the module level in most cases you'd just do it once for the whole monolith.;0
13964001;HackerNews;2017-03-27;for those of you happy with your use of micrsoservices how many microservices does your team handle?i don't mind microservices but i definitely think my company has taken it too far for my team of 5 we have 25 separate componentsdeployments which make up 12 microservices. it makes it impossible to keep track of each service and be familiar with idiosyncrasies in each project.;0
13963886;HackerNews;2017-03-27;all fair points but i think people ignore the challenges associated with microservices much more complex to debug which service is failing interservice latency things run much faster on a single box vminstance sprawl because every service should run on its own host x redundancy x multiple environments increased costs see vm sprawl. i still think the advantages outweigh the disadvantages but they definitely come at a cost.;0
13963803;HackerNews;2017-03-27;i think the article is missing a key value of microservices or at least smaller services service ownership. with a monolith who is on call for the service when something goes wrong? how does that person find an appropriate person to diagnose the issue in one of the 100 libraries included in the monolith? what does the monolith dashboard look like?the great thing about small services is that a team developing a service can own it from top to bottom including and of course there are other socialorganizational problems with a monolith another example being deployments. i want to deploy my new feature but i'm blocked because someone introduced a bug in some unrelated library that's clogging the entire pipeline. or i have to release my feature according to the deployment schedule of the monolith which may not make sense for my team. with smaller services a team can own its own deployment pipeline and decide when it wants to deploy.a third organizational benefit of smaller services comes process separation. gc'ed languages work really hard to help developers pretend that memory is free but memory is still a finite shared resource and it only takes one misbehaving module to cause the whole process to start stalling in large gc pauses. with smaller services you get process separation which makes the problem much more tenable. and of course there are other exhaustible shared resources like threads and file descriptors.at the end of the day i prefer smaller services because i like the social organization where a company consists of agile autonomous teams owning their own services. i feel a monolith service actively discourages that and leads to social organizations that are less productive and successful.;0
13963763;HackerNews;2017-03-27;nobody arrives at microservices unaware of their complexity and complications.i think the opposite is often true. there are developers that buy into microservice architecture without a full understanding of the complexities involved.;0
13963713;HackerNews;2017-03-27;it's not impossible. as a sibling comment says it usually just requires a bunch of adhoc scripts to make sure everything is running. this does get increasingly complex especially as microservices are written with different stacks but that's part of the tradeoff.;0
13963703;HackerNews;2017-03-27;one more point is that in your monolith you actually have the option of crossing module boundaries. you don't have that luxury with microservices unless you want to introduce xa god bless you. so you better get your boundaries right.;0
13963668;HackerNews;2017-03-27;actually i've worked on a great many monolith projects over the past 20 years including a j2ee server weblogic. and yes that was a huge monolith that had technical debt that needed addressing. when i left there was this future modularity project that i'm certain didn't involve introducing network boundaries between the servlet ejb jca containers etc. to achieve that modularity. and i can tell you that there was a definite effort to enforce interfacepackage boundaries between the various server components. if you introduced an illegal dependency you were going to be talked to about removing it. i want to say that we actually had the build breaking on such infractions after i'd moved to product management.the point i was making is exactly what you're talking about. that sometimes deadlines force bad architectural choices and that's called technical debt. the laziness and lack of discipline comes with failing to acknowledge and address that debt in the future. as best i can tell people think that microservices are going to solve that problem and i'm saying they won't and that there's not enough thought going into the price of network.just like in real life when it comes to being in shape. diet and exercise. there's no silver bullet there either and it seems to me as though microservices are the fad diet of the current tech cycle.i realize this stuff isn't cut and dried and easy. if it were then none of us would have well paying jobs to figure out when to use what tool for what job. there's a time and a place for all solutions but i'm seeing the same groupthink i saw back when everyone was purchasing sun oracle and weblogic for sites that didn't and would never need those tools. this is ejb all over again as best i can tell.as far as your shared libraries comment goes you wouldn't consider having any shared libraries ever? what you're describing are permutations of a shared library that either need to be addressed by the shared library's design by adapting or splitting into multiple libraries. i'd be interested in learning what you do instead of sharing components? duplicating everywhere?;0
13963460;HackerNews;2017-03-26;sure but they are tangled at the macro level.what happens with monoliths is they tangle at all levels. how many times have you seen a giant utils module which initially contained stateless stringutils and similar classes then devolved into a dumping ground for stateful business logic.or especially with jvm applications how many times do library dependencies for one of part of the codebase end up causing issues with another. that's a big bonus with microservices i.e. being able to manage thirdparty dependencies better.;0
13963449;HackerNews;2017-03-26;for my employer the iwhole pointi of microservices is separate deploys. when we had hundreds of engineers committing on the monolith a bad change in one out of the few dozen commits in a given day's upgrade could require rolling the whole thing back.now each service deploys usually one or two commits at a time completely understood by the person who clicks the upgrade' button. people working on unrelated code don't need to block each other's release velocity.more disciplined interfaces could have solved the spaghetti problem but lots of small services that a few people have absolute power over can move a lot faster than an integrationrelease process shared by thousands.;0
13963448;HackerNews;2017-03-26;i take it you've never worked on a monolith project before. there are always reasons often deadline related always legitimate never as a result of laziness or lack of discipline where developers have been forced to cross module boundaries.nobody arrives at microservices unaware of their complexity and complications. developers are forced to choose the approach between monoliths have their own issues.also common shared libraries are a disastrous idea imho. they always become riddled with stateful business logic and the difference in requirements between their consumers means they end up brittle inelegant and full of hacks.;0
13963327;HackerNews;2017-03-26;i think microservices place a greater emphasis on dataencapsulation amp isolation wheres soa focused more on the rpcapi surface. i think this is just an emphasis difference though and not a hard separation;0
13963315;HackerNews;2017-03-26;i've heard this exact argument at work in favor of microservices. i honestly think it's a lazy man's cop out to say it makes sense to insert a network boundary because it's just assumed somebody's going to violate a module boundary. that's a huge tax to pay for being lazy. if you lack discipline it's going to show up no matter how you decide to distribute your complexity. from what i'm seeing the idea that devops is going to offset the increased complexity of network boundaries as interfaces is going to be the downfall of a great many of microservice based implementations that simply didn't need to take that burden and risk. i suspect that a hybrid approach is going to end up being the right solution for a great many companies. one or more well factored monoliths with common shared libraries and orthogonal services that each of them use that make sense being a service vs. a shared library.;0
13963299;HackerNews;2017-03-26;it doesn't just eliminate ithati app. it generally means no app needs ianyi crud except to encapsulate business logic.secondly all data operations can now be expressed using the ione canonical data store apii with its rich support for queries joins finegrained patching changefeeds permissions etc. every little microservice doesn't need to reinvent its own rest api.for example the usersorg app has a way to list all users list all organizations list all memberships in an organization etc. every app needs to provide all the necessary routes into the data in a restful way a client that wants to query this app must first pick which silo to access then invoke these apis individually. the iwayi that the querying is done is silospecific and the verbs only provide the access patterns the app thinks you want. what if you want to filter invites not just by status but also by time? every app must reinvent every permutation of possible access patterns. rest is pretty exhausting that way. graphql is a huge improvement but doesn't really fix the silo problem.with our new store a client just invokes yes we did invent our own query language. we think it was necessary and not too crazy.or indeed now the client gets a stream of newupdateddeleted organizations as they happen.;0
13963198;HackerNews;2017-03-26;since you seem to have it figured out... i'm a monolith guy in a microservices world. friday i had a question asked of me that in our old system was a simple query and i could answer in 5 minutes. this question however was split across three separate microservices in the new system and the information had never been captured in a convenient way in hadoop. running two separate queries in two separate systems and writing a program to collate the results takes significantly more developer time. while not insurmountable it's no longer a trivial task.did you run into these problems? what did you build to solve them?;0
13963050;HackerNews;2017-03-26;cool story. our startup 8 engineers is built on microservices as well. right now after 1 year live 4 hours downtime until then we have 43 microservices running. we have a rabbitmq broker for fireandforget communications. we use consul for service discovery. jenkins is used for automatic testing and deployment. i have to say that i love our setup. while there are some things that are a bit more complicated the increased efficiency is worth it all. on some days we deploy 10 or more times to production.i have to say. the startup is very well funded and we have a dedicated sysops guy who helps us with devops. he does all the nitty gritty ansible stuff.i think the ibesti thing about microservices is that it ienforcesi service boundaries around aggregates. you just can't leak responsibility if you have to traverse the network. this enforces loose coupling.its also much easier to do code review if changes are localized to a small codebase of maybe max 500 lines.;0
13963023;HackerNews;2017-03-26;i don't have a specific definition of microservices nor do i think anyone does.the central data store pattern arguably makes apps even more micro albeit at the expense of adding a dependency on the store. but the opposite pattern is to let each microservice have its own datastore so you ialreadyi have a dependency there.it's just moving it out and inverting the api in the process for many apps the data store becomes the api. for example we have an older microservice that manages users organizations think github orgs but hierarchical and users' membership in those orgs. it has its own little postgres database and every api call is some very basic crud operation. we haven't rewritten this app to use our new data store yet but when we do the entire app goes away because it turns out it was just a glorified gateway to sql. a verb such as create an organization or add member to organization now becomes a mere data store call that other apps can perform directly without needing a microservice to go through.;0
13963003;HackerNews;2017-03-26;be interested in if anyone has much experience in using an actor type model instead of microservices. things like akka.net orleans erlangs otp etc;0
13962940;HackerNews;2017-03-26;isolated internal state is part of the definition of microservices. it is not hard to find articles that assert this. taking that away may yield a better result but you no longer have microservices you have something else;0
13962857;HackerNews;2017-03-26;genserverstartlink3the original microservice;0
13962724;HackerNews;2017-03-26;idempotency would be nice but it is often impossible to have at all layers. eventually at some point you deal with stateful microservices and distributed transactions. depending on how long the transactions take either twophase commits or compensation transactions are needed to rollback or restore states when failures happen. and that is not trivial to implement and complicates your system further.stable and welldefined interfaces between microservices are another luxury hard to have in reality especially when business and application logics constantly evolve. more often than not it's inevitable to juggle multiple services to fulfill the need which takes much more time effort and risk than monolith.;0
13962645;HackerNews;2017-03-26;hmm my ideology doesn't say whether microservices are better than monoliths. but it does roll its eyes when it sees people mistake the encapsulating things into modules for some particular technology helping you do that.i mean when oop was new people talked as if a no one had been trying to seperate out modules before oop and b the class was the natural boundary between modules. both are false.btw what does that article mean about that in java 9 a native module system is added... presumably this is something distinct from the package system it always had. what are the differences?;0
13962561;HackerNews;2017-03-26;and how that central 'data store service' is different than a single 'database service' rdbms or nosql crud that all microservices connect to and run there selectinsertupdatedeletecrud ops?other than api rest vs whatever binary rpc protocol it sounds very much like a standard database...;0
13962425;HackerNews;2017-03-26;microservices do not feel like a premature optimization. it does not feel premature to make architectural decisions around scaling based on the entirely realistic proposition that you will have more customers in the future than you do today. architecture is exactly the area you want to get right since it's a pain to optimize when you have a weak architecture.;0
13962377;HackerNews;2017-03-26;we've used microservices for around 67 years now. one thing we realized quite early was that letting each microservice store state silos independently was a bad idea. you run into the synchronization issue you describe.instead we've moved the state to a central distributed store that everyone talks to. this allows you to do atomic transactions. our store also handles finegrained permissions so your auth token decides what you're allowed to read and write.one nonobvious consequence is that some microservices now can be eliminated entirely because their api was previously entirely about crud. or they can be reduced to a mere policy callback for example let's say the app is a comment system that allows editing your comment but only within 5 minutes. acls cannot express this so to accomplish this we have the store invoke a callback to the owner microservice which can then accept or reject the change.another consequence is that by turning the data store into a firstclass service many apis can be expressed as data similar to the command pattern. for example imagine a job system. clients request work to be done by creating jobs. this would previously be done by posting a job to something like apijobs. instead in the new scheme a client just creates a job in the data store. then the job system simply watches the store for new job objects.of course this way of doing things comes with its own challenges. for example how do you query the data and how do you enforce schemas? we solved some of these things in a rather ad hoc way that we were not entirely happy with. for example we didn't have joins or a schema language.so about a year ago we went back to the drawing board and started building our nextgeneration data store which builds in and codifies a bunch of the patterns we have figured out while using our previous store. it has schemas optionalgradual typing joins permissions changefeeds and lots of other goodies. it's looking extremely promising and already forms the foundation of a commercial saas product.this new store will be open source. please feel free to drop me an email if you're interested in being notified when it's generally available.;0
13962199;HackerNews;2017-03-26;this is why i tend to build microservices that implement a bounded context. then compose those different apis as necessary to implement the public facing api.i don't need granular level services it places too much burden on operations but i still get the separation of context concerns and 'anticorruption' layers that i'm looking for in my design.;0
13962180;HackerNews;2017-03-26;isn't a microservice just a small application behind a network boundary? moving what might be a big ball of mud into smaller ones?;0
13962177;HackerNews;2017-03-26;i'd estimate that you can run at least 50 jvm python and node.js processes on a typical single machineunless someone has convinced you that spring is the right way to build microservices in which case you're going to need a gigabyte per instance and most people won't be able to run 50 on a typical machine. i worked on a project like that and our beefy imacs really laboured to bring up ten services.;0
13961828;HackerNews;2017-03-26;at the startup i currently work for i designed the system to be composed of microservices with swaggeropenapi even when it might've been easier to write modules for scalability reasons. before i was brought on as the first engineer we had a series of contractors build a poorly architected monolith that had issues scaling. microservices have enabled us to independently scale different parts of the service as load changes. it's also forced a very strong separation of concerns.my main complaints are that we've run into various instances where we need to access some data in a different service so we stuff it into some object so that the next service can pull it from the db. however this is a solvable implementation issue.the other complaints i have are that monitoring and profiling are much more involved. additionally setting up a new service can be painful if you don't have a template.overall we've had a good experience with microservices and it's enabled us to deploy faster and scale simpler.;0
13961827;HackerNews;2017-03-26;in my own projects you can start up every microservice with a single command script.yes having sufficient tooling for microservices does consume resources.;0
13961821;HackerNews;2017-03-26;splitting a single process into n processes with no shared memory multiples startup memory by n. it takes a much beefier system to run 8 jvms than one. the same goes for 8 python processes.i agree but i haven't seen the amount of memory ever being a limiting factor when running multiple microservices on a local developer machine. i'd estimate that you can run at least 50 jvm python and node.js processes on a typical single machine and most applications consisting of microservices have 50 or less microservices.;0
13961820;HackerNews;2017-03-26;his comments with regards to the lack of compile time checking of the interfaces between microservices couldn't help me but think of graphql. using graphql as the layer between microservices could alleviate this issue. specially if the usual deprecate don't version approach of graphql is followed.normally graphql is talked about within the context of user facing applications interacting with servers but it could be quite useful for strongly typed machine to machine communication.we already use graphql for our client facing api. we're going to start rolling out microservices at our startup and i think we'll use it for communication between microservices as well.;0
13961807;HackerNews;2017-03-26;why does technical overhead take a backseat whenever a microservices vs monolith discussion comes up?i don't think it does but that's kind of off topic.in the real world setting up and maintaining microservices has huge technical overhead i'd estimate double that of the equivalent monolithic architecture.i agree.;0
13961765;HackerNews;2017-03-26;come on you can have million lines of code and still get binaries of few megabytes. if that counts as microservice then everything does.this is a frequent problem when discussing microservices nobody defines how large they actually are.;0
13961737;HackerNews;2017-03-26;microservices is to soa as json over http apis are to rest apis. fundamentally the same goals but with a focus more on being a general description of a style rather than a specification for how it should be implemented.this is a doubleedged sword of course...;0
13961493;HackerNews;2017-03-26;just a sign of weak tooling.why does technical overhead take a backseat whenever a microservices vs monolith discussion comes up?yes in a perfect world every org would have sufficient time and engineering resources to implement microservices for better scalability and code quality. in the real world setting up and maintaining microservices has huge technical overhead i'd estimate double that of the equivalent monolithic architecture.if your company isn't flush with cash and the product you're building will never need massive scaling then it makes no sense to use microservices at least from a business perspective.;0
13961487;HackerNews;2017-03-26;few advantages for microservices over modules is performance of one module impacting other modules. 1. say one module is running slow that will impact entire application. 2. if we want to push code for one module we need to push code for entire application. so there is no deployment isolation. 3. we have to have all the modules written in same programming language and same version of the programming language. hence there is no clear path for upgrading version of programming language.micro services addresses all these assuming we deploy micro services separating the services including data. but the tradeoff is a bit of complexity and latency for the benefit of complete isolation and independence.;0
13961391;HackerNews;2017-03-26;beginning in 2003 and until the height of the soa craze around 2010 the service component architecture sca was seen as the holy grail of service integration. it encompassed both localinprocess or injvm as well as networked services soap and rest was polyglot in that it defined api bindings for native java and even php and cobol could access external services and was still quite practical. for those needing it it also supported authorization and transaction policies and protocols.when commercial interest in soa middleware products dropped sharply further standardization of version 1.1 slowed down and oracle sitting on the sca board voted down all specs that had been worked on without further explanation.to this day i still haven't understood what makes microservices different from soa in a technical sense. i can get that the term soa was probably burnt at some point but if there's a real lesson to be learned from soa failures i'd really like to know. maybe soa was seen as too complex because it addressed some of the harder problems such as transaction and authorization protocolsboundaries bpm etc. upfront?;0
13961379;HackerNews;2017-03-26;have you considered what will happen when you're application has reached a mutigig deployment? where you have static resources commingled with business logic? where you have rendering blended with db access?modular systems are theoretically as good as soa or microservices but in practice they are not.failure can not be isolataed as easily when there is a problem in the system the entire thing crashes.also to your point is that a single repo or multirepo source control system? in a single repo system your build and testing cycle becomes longer and longer for the entire service regardless he size of changes you have to deploy the entire thing. every successful business with a monolithic deployment regardless of repo structure ends up in the same place based on my experience a large unwieldy beast maintained by dozens or hundreds or thousands of engineers who each have limited knowledge of the runtime. it becomes slow hard to deploy hard to test hard to make changes.microservicessoa does not alleviate the need to good design but it doesn't allow for the above to be true on a perservice basis shortening turnaround for response to issues and deploying new features it is better.;0
13961359;HackerNews;2017-03-26;i don't have much ideology behind going with microservices vs. monolith but what we've done on some recent projects is organize our code into modules that only communicate with each other through a narrow and well defined boundary layer. if we need to split a module out into a separate service then it isn't nearly as much work to split it out later.one of the practical issues we've had with microservices that need to interact with each other in real time is ensuring a consistent state across systems. for example let's say i need to change the status of an object and afterwards call a separate service to change state there as well. what happens if the call fails in some way? you can't just run all of this inside a single database transaction anymore. now you have to design your code to deal with several potential failure points and edge cases which adds complexity. the other consideration is all calls to a service should be idempotent if possible. it makes coding from the client side a lot easier if you can just fire off a call multiple times in case of local or remote failure and not have to worry about state.just some of my thoughts since this stuff has been on my plate recently.;0
13961347;HackerNews;2017-03-26;if the alternative to microservices is a monolith and you can run the monolith locally then logically microservices can also be run locally. if it's difficult to run all the microservices locally then that's just a sign of weak tooling.;0
13961338;HackerNews;2017-03-26;i'm sure it happens my point is that it isn't relevant to microservices. microservices allow multiple technology stacks if dont properly but it doesn't force it on anyone. if your developers are pushing code using a different programming language with no oversight there's an organizational issue.that said it's iawesomei that microservices let you use different tech stacks to solve different problems.;0
13961330;HackerNews;2017-03-26;polyglot programming isn't a fad it's something that microservices enable. that does inoti mean that developers make technical decisions in isolation.if i were to introduce haskell to my company there would have to be at least one other person interested in it and at least a few people who would be interested in learning it. i would never commit code using a new technology without discussing that with my manager.;0
13961320;HackerNews;2017-03-26;in my experience the biggest obstructions to modularity are the unknown unknowns. i can't tell you how many times i've been trying to set up some software where it turns out the installation was looking for file abc in directory xyz even though the documentation wasn't up to date and listed directory efg or nothing at all. also environment variables i.e. global variables are a pain and should be eliminated altogether. what would replace them? i'm not sure but ianyi random idea has got to be an improvement of some sort over the current system.docker alleviates the environment hell problem somewhat so it's easy to set up a bunch of contained microservices that aren't going to fall apart when the global environment changes.we need more research into the complexity of programming patterns. the same patterns and antipatterns keep popping up under different names in slightly different forms.;0
13961248;HackerNews;2017-03-26;this is a totally nutty scenario. microservices are not do whatever you want! they give you the freedom to choose your stack. it is iobviously still a business decisioni to choose haskell and you've got other problems if developers are building things in random languages that they feel like using without a larger discussion.the issue here isn't haskell it's ownership and process.;0
13961219;HackerNews;2017-03-26;i know microservices are successful in many organizations but one downside i've experienced from the microservices hype is starting an application with microservices.it's very difficult to get the system boundaries correct while you're still iterating on core functionality and if you get it wrong you're in a world of pain. refactoring becomes very hard and performance suffers from unnecessary network overhead. deployment is harder. coordination is harder. developers can't run the whole system locally. testing is harder. basically if you don't have a very well defined interface between components it's going to hurt.i would not recommend starting with a microservices architecture. build a modular wellfactored application and split out pieces if they need to be scaled separately or there are other compelling benefits of a microservice.to e kris jenkinsthis is your return type intthis is your return type on microservices io logger either httperror intmicroservices know the risks.;0
13961199;HackerNews;2017-03-26;shouldn't the goal be to do whatever provides the most value and builds your product or business the fastest? if you waste time with a microservice architecture where you could've done more faster with a monolithic app that seems like a poor use of time.;0
13961117;HackerNews;2017-03-26;for us scaling was never an issue we did the stateless scaleout thing. even solving statefull is relatively easy at least in java with solutions like hazelcast. the main drawback is there are usually only a few services in your monolith that are required to scale out. but you have to deploy the entire thing when scaling out.as for osgi osgi is complex i dare to say that the complexity of osgi rivals that of a microservice setup. if i had a nickle for every classloader issue i debugged... orm was especially fun for example wrote this piece way back . but i must admit that i don't think we could have created and maintained such a large modular application without osgi. debugging itself is also way more complex. when an issue arises you spent a lot more time tracking down which module is misbehaving. even though we had inserted lot's of probes which ended up in graphite and log statements which ended up in graylog to counter that.in my experience writing smaller simpler applications which i acknowledge also have their own complexity with distributed debugging are still easier to understand then an modularized application.;0
13961053;HackerNews;2017-03-26;i cofounded startup 6 months ago since day 1 we use microservices. for us the biggest benefit was that at the begin we could hire people knowing different programming languages we managed to build a team of 5 in 34 weeks and they could build a small parts of the system communicating via httprabbitmq. downside is that we had to have a ciampcd from day one and it costs us some resources.i am not saying microservices are cure for everything and of course there is a place for well maintained monoliths but i find that even for smaller teams microservices can be just easier than monolith.;0
13960971;HackerNews;2017-03-26;i used to make this argument. i'm not so convinced anymore. much of this modularity can be achieved now split you libraries into two one for apis and the other for implementations. then in your build only include the api libraries as dependencies and include both at runtime. it doesn't enforce runtime modularity but it's generally good enough.why this isn't great it encourages monolithic mindset. a huge benefit to microservices is that they are small! this means means that you have releases that are faster per service build times that are faster per service code that can be more easily reasoned about.the author is correct that it introduces expensive cross service calls so you do need to be thoughtful on your boundaries but what you end up getting is simpler on a per instance basis. you don't need to become devops experts there are plenty of options for deployment that handles a lot of this heroku gae beanstalk. hell there's even still available to you for your own d.c. though i'd argue that if you're running in your own d.c. then you should think very hard on why that's important to your business even if it's very large.the earlier you have microservice architecture built into your stack the easier it is to continue on that path once you're monolithic it's a huge amount of work to go back the other way.;0
13960855;HackerNews;2017-03-26;to get high availability every system need to be able to hand over processing to another instance of itself in some way.modular or microservice make no real difference here except that a bigger collection of modules in a single jvm will take a bit longer to startup but if you really can't periodically restart your service to reclaim lost resources due to 247 requirements you will need to have several jvm instances serving the same service anyway.this makes startup times mostly irrelevant since any decent load balancer will handle seamless handover almost trivially.microservices is a rather resource expensive solution to modules bringing the jvm down for whatever reason.usually the right thing to do is to decrease amount of state in the application think in microservices without http and within the jvm and finally run a a bunch of small jvm's instead of one large.the upside of this approach is that whenif you need to migrate some modules to actual microservices you have already made part of the work already tested that you can run multiple instances of the same service and all without the significantly increased operational and development complexity of microservices. microservices is good where it really is the only option eg. heterogeneous technology stacks and subsystems with different release schedules.simulating the gridweb of microservices including network errors like timeouts latency and dropped connections in a petrinet or similar simulation tool can be a rather eye opening experience if the set of services isn't trivial. the set of weird behaviours a network of services can exhibit is staggering even without a single line of code.;0
13960429;HackerNews;2017-03-26;we build a modular system based on java with osgi. it served us well but now we feel we have reached the limits of such a system and are looking at a more microservice based approach.for example a modular system is not going to help you when a module is misbehaving since the whole thing still runs in the same process jvm in our case. if someone introduces a resource leak in some trivial module the whole thing still comes down.;0
