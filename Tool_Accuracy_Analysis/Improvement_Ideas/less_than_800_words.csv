ID;Source;Creation Date;Content;Sentiment
23453676;HackerNews;2020-06-08;still don't need microservices. what you're referring to is just soa which has been around for a couple of decades. microservices typically outnumber engineers or aren't too far off.;-1
23453639;HackerNews;2020-06-08;i think he is skipping a couple of points.for example the deployment aspect monolith single deployable unit. microservice multiple independently deployable units.multiple teams on a monolith you have to coordinate releases and rolebacks... code base grows and dependencies between modules that have shouldn't have dependencies on each other as well unless you have a good code review culture. deployment get slower and slower over time. db migrations also need to coordinates over multiple teams.these problems go away when you go microservices. of course you get other problems.my point is in the discussion microservices vs monolith you need to consider a whole bunch of dimensions to figure our what is the best fit for your org.;0
23453562;HackerNews;2020-06-08;in my experience microservices grew to prominence not because of their technical merit but because it allowed engineering leadership to not have to make decisions. every developer or group of developers could create their own fiefdoms and management didn't have to worry about fostering consensus or team efforts all that had to be agreed on was service contracts.we end up with way too many developers on a given product an explosion of systems that are only the least bit architected but thankfully the vp of engineering didn't have to worry themselves with actually understanding anything about the technology and could do the bare minimum of people management.individual minor wins collectively massive loss. there are reasons for microservices at big scales if everyone is still fitting in the same roomauditorium for an allhands i would seriously doubt that they're needed.;-1
23453068;HackerNews;2020-06-08;my point is that microservice architecture is not just the singular pattern of code talking over the internet but a collection of patterns and techniques focusing on when and where to split up code and to focusing on the communication strategy you use.you can 'get around' microservice architecture by not doing it. the point is that if you're familiar with it it's a lot easier to 'accidentally' be successful or at least that's the proposition.;1
23452837;HackerNews;2020-06-08;heh i have a masters degree focused on distributed systems. my thesis was about tracing and debugging in microservicestyle systems. i generally write monoliths on purpose. the massive overheads and debugging nightmares are not worth it most of the time.global state still gets pushed out into backend services redis postgres and i can still scale horizontally all day but theres no crazy chain of backend interservice http requests to cause no end of chaos;-1
23452626;HackerNews;2020-06-08;i agree 99.9 of products do not need a micro service architecture because 1. they will never see scaling to the extent that you need to isolate services 2. they dont have zero downtime requirements 3. they dont have enough feature velocity to warrant breaking a monolith 4. they can be maintained by a smaller teami also agree that the way to build new software is to build a monolith and when it becomes really necessary introduce new smaller services that take away functionality from the monolith little by little.microservices do have a good usecase even for smaller teams in some cases where functionality is independent of existing service. think of something like linkedin front end making calls directly to multiple microservices in the backend one that returns your contacts one that shows people similar to you one that shows who viewed your profiles one that shows job ads etc. none of these is central to the functionality of the site and you dont want to introduce delay by having one service compute and send all data back to the front end. you dont want failure in one to cause the page to break etc.unfortunately like many new tech junior engineers are chasing the shiniest objects and senior engineers fail to guide junior devs or foresee these issues. part of the problem is that there is so much tech junk out there on medium or the next cool blog platform that anyone can read learn to regurgitate and sound like an expert that its hard to distinguish between junior and senior engineers anymore. so if leaders are not hands on they might end up making decisions based on whoever sounds like an expert and results will be seen a few years later. but hey every damn company has the same problem at this point.. so its normal.;-1
23452097;HackerNews;2020-06-08;teams of ten. each service is owned by exactly one team.that rules out every monolith i've seen at companies that still did that.but unfortunately microservices becomes a religion a cargo cult and companies have hundreds of tiny little services.my services are not monoliths. but are they microservices? don't care. they work. certainly they are just a couple of services within a network of several hundred but i work at a large company. and every one of those services has one team responsible for them.;-1
23451680;HackerNews;2020-06-08;microservices have some inherent advantages mainly that you can manage modify and deploy one service at a time without taking downredeploying the rest of your applications. this is arguably the big thing that is missing from monoliths. it's hard to only change a single api endpoint in a monolith but easier to do a change across the entire monolith when you have to change something about how the whole system works. the best compromise that i've come up with would be to have something that can keep your entire app in one place but allow individual portions of it to be hotswapped in the running application and is built to be run in a distributed horizontally scalable fashion in addition there's a lot to be said for the old way of putting business logic in stored procedures despite the poor abstraction capabilities of sql relative to something like lisp but with modern distributed databases we can conceivably run code in stored procedures written in something like clojure keeping code close to the database or rather data close to the code allowing hotswapping modification introspection replay of events and all other manner of things all while managing the whole thing like a monolith with a single application configuration etc. to deploy and a more manageable and obvious attack surface to secure.this is my solution called dataworks if anyone's interested some of those things like introspection and replayofevents are in the road map but the core aspects of hotswapping and modification of codeindb work.;1
23451147;HackerNews;2020-06-07;in my experience the benefits of microservices are primarily better delineated responsibilities and narrower scope and secondary benefits tend to fall out from these. there are downsides but the harmful effects do not reflect my experience. i fully grant more things on a network invite lower availability higher latency but i contend that you already need to handle these issues. microservices do not tend to grossly exacerbate the problem in my experience anyway.the other callout is clean apis over a network can just be clean apis internally. this is true in theory but hardly in practice from what i've seen. microservices tend to create boundaries that are more strictly enforced. the code data and resources are inaccessible except through what is exposed through public apis. there is real friction to exposing additional data or models from one service and then consuming it in another service even if both services are owned by the same team and moreso if a different team is involved. at least in my experience spaghetti was still primarily the domain of the internal code rather than the service apis.there's also a number of benefits as far as nontechnical management of microservices. knowledge transfer is easier since again the scope is narrower and the service does less. this is a great benefit as people rotate in and out of the team and also simplifies shifting the service to another team if it becomes clear the service better aligns with another team's responsibilities.;1
23450591;HackerNews;2020-06-07;i see microservices as a peopleteam architecture. it's a way to scale up people and define boundaries around who is responsible for what without having to standardize how everyone implements what they are responsible for. just expose it as a rest api. problem solved. and problems created. this isn't all bad it just isn't a everyone should do this and all your problems will go away architecture. that architecture doesn't exist.;0
23450438;HackerNews;2020-06-07;microservices are the actor model erlang or akka except they require lots of devops work being on call for x services every night and a container management system like kubernetes to be manageable.actors are a simple solution to the same problems microservices solve and have existed since the 1970s. actor implementations address the problem foundationally by making hot deployment fault tolerance message passing and scaling fundamental to both the language and vm. this is the layer at which the problem should be solved but it rules out a lot of languages or tools we are used to.so in my opinion microservices are a symptom of an abusive relationship with languages and tools that don't love us grow with us or care about what we care about.but i also think they're pretty much the same thing as ejbs which makes kubernetes google jboss.;-1
23450342;HackerNews;2020-06-07;i read the explanation and i think the answer is still it depends. think about it this way in your kitchen you dont just have 1 kind of knife. you probably have 2 or 3 different kinds of knives if you're doing basic stuff and maybe 5 to 10 different knives if you're a top chef.the same applies to systems architecture. microservices isn't the only solution or the best solution.case in point i've worked on highfrequency trading systems for much of my career. the early systems circa 20002005 were built on top of pubsub systems like tibco rv or 29west this was effectively microservices before the term was used popularly.what happened around 2006 was that the latency required to be profitable in highfrequency came down drastically. strategies that were profitable before needed to run much faster. the result was to move to more monolithic architectures where much of the tick to trade process happened in a single thread.point is use the right tool for the job. sometimes requirements change and the tools needed change as well.;0
23450266;HackerNews;2020-06-07;if you have ten people working fulltime on it it is not a microservice it is just a service.i think the discussion about microservices has suffered more than anyone realises from a lack of shared understanding about what a microservice actually is.;-1
23450259;HackerNews;2020-06-07;microservices are useful but not for the reasons listed here or the reasons often assumedpersonally i'm more a fan of realm of responsibility scoped services to decouple technologiesdatastores of parts of a system that do not interact by design for instance your user account credentials handling from literally anything else and then use a system like kafka with producerowned format to have a common data bus that can tolerate services that process data asyncronously or even things that keep users in the typical refresh loop dying for a bit.;1
23450219;HackerNews;2020-06-07;microservice testing come with version combination hell.if you have 10 microservices each of which can be on one of two versions that's 1024 combinations. how do you test that?;-1
23450158;HackerNews;2020-06-07;a major benefit to microservices over monoliths that i havent seen mentioned yet is testability. i find it hard or improbable to achieve a healthy pyramid of tests on a large monolith.for example a high level black box test of a service endpoint requires mocking external dependencies like other services queues and data stores. with a large monolith a single process might touch a staggering number of the aforementioned dependencies whereas something constrained to be smaller in scope a microservice will have a manageable number.i enjoy writing integration and api tests of a microservice. the ones that we manage have amazing coverage and any refactor on the inside can be made with confidence.our monoliths tend to only support unit tests. automated endtoend tests exist but due to the number of dependencies these things rely on theyre executed in a live environment which makes them hardly deterministic.microservices allow for a healthy pyramid of tests.;1
23450116;HackerNews;2020-06-07;stop off! drop a bunch microservices into the same network without any access control and you don't have a physical barrier at all! in fact it becomes even harder to have a clue as to what's interfacing with what unless you can observe your inter process traffic.;-1
23449910;HackerNews;2020-06-07;at a goto talk an uber engineer said they had so many microservices it was impossible to really count how many they had;-1
23449884;HackerNews;2020-06-07;microservices make the boundary between units defined and forces api design on those boundaries no it doesn't. google distributed monolith to read some horror stories.bad architecture or good architecture without enough quality control over time will cause these issues one way or another.there's no silver bullet for this.;0
23449768;HackerNews;2020-06-07;this misses some of the main reason microservices are nice its much easier to change code that isnt woven throughout a code base. microservices make the boundary between units defined and forces api design on those boundaries. yes you can properly design these abstractions without a service boundary but having the forcing function makes it required.;1
23449762;HackerNews;2020-06-07;like almost anything when not used for the correct application. say a hammer to insert a screw. it is not a good idea. one of my favorite things about using microservice is that you can use multiple languages. this can grant you the ability to use a language which is better for the task or for other programmers to contribute in their favorite language.;1
23449744;HackerNews;2020-06-07;a recent blog post by neobank monzo explains that they have reached the crazy amount of 1500 microservices a ratio of 10 microservices per engineer thats wild. microservices are mostly beneficial organizationally a small team can own a service and be able to communicate with the services of other small teams.if anything i think a 101 software engineers services is probably not far off from the ideal.;1
23449738;HackerNews;2020-06-07;microservices are middleware. that's they way i treat them anyway. i build them as the glue between the backend and frontend. they handle things like authentication business logic data aggregation caching persistence and generally act as an api gateway. i really only ever use microservices to handle crosscutting concerns that are not directly implemented by the backend but have a frontend requirement. the only way that is harmful is if you write bad code. bad code is always harmful.;1
23449672;HackerNews;2020-06-07;microservices were never about code architecture they were an organisational pattern to enable teams to own different services. most microservices don't actually look micro to those implementing them because it's really just a lot of services.for my personal projects i just have a frontend service http server and a backend service api server. anything more is overkill.;0
38174497;HackerNews;2023-11-07;it's not like microservices don't also give you chances to mess your data up. it's hard to do transactions across boundaries you have to deal with eventual consistency sometimes there is no single source of truth.i struggle to see how microservices fix this for people having worked primarily with them for the past 6 years.;-1
38130050;HackerNews;2023-11-03;with proper devops tooling and a half decent design even a junior engineer can manage several microservices without issues. since microservices are about scaling people as much as they are about scaling tech 10 people in one service is a lot to me in that world.the best company i worked at had about 510 deployable per engineers on average and it worked really well. they were small deployed almost instantly dependencies were straightforward etc.monoliths work fine too it's just different tradeoffs.;1
38088383;HackerNews;2023-10-31;testing hugely via expensive integration tests or e2e is needed no matter which software you have. and you could easily fall into doing that for microservice architectures. however a common way is rather having contract tests. google fowler's article for it;-1
38086139;HackerNews;2023-10-31;i ended up getting into a few arguments at work with the over excited engineer in my last place. he wanted microservices. i said it was just going to add complexity. the app was already a mess adding network calls rather than function calls wasn't going to help. we had a small teas 3 backend devs one of them doing mostly devops and two frontend.;-1
38084540;HackerNews;2023-10-31;the theory is that microservices are supposed to be independent and selfcontained but such a wonderful implementation of ddd is a theoretical fantasy that rarely plays out in practice. it's not just a technical difficulty but an organisational problem where communication between teams also throws a spanner in the works.if your typical microservice setup is simply distributing your call stack over a network and oftentimes that's all it is then you might as well use a language designed to operate in such a manner and reap the benefits of it. that kind of microservice architecture only really exists as a function of the organisation's structure such that teams can work more autonomously.;-1
38082191;HackerNews;2023-10-31;maybe logging should be a microservice....;0
38082454;HackerNews;2023-10-31;team size is probably the most important factor that should influence the choice about microservices. unfortunately there was a period when it looked like every project and every team had to adopt them or be declared a dinosaur.;-1
38083263;HackerNews;2023-10-31;absolutely true but also usually your business transactions happen in a business context which happens to be in a microservice. it can be a sign of bad design if you happen to have a lot of those transactional problems.you will have distributed transactions with a distributed microservice setup but most transactions will still be be contained within a single microservice and thus be atomic and not distributed.;0
38083186;HackerNews;2023-10-31;there are many valid reasons and many wrong reasons. i would say if you have multiple stakeholders evoling business needs and many 10 developers there might be a good reason to have independent deployable testable and releaseable units. having few developers with a well defined context working on multiple microservices is a pain though.regarding everything else is just shifting complexity from software development to system maintenance. this sounds reasonable if your software is actively developed. development is expensive. it may very well be that the costs of maintaining a distributed system is lower then the cost of developing a very large monolith with a large team. in the end it depends.;0
38082898;HackerNews;2023-10-31;actually you are wrong. microservices are surely not about defaulting to new microservices but to capture a specific context into one service. there is no rule about how big a context is. a context can contain other context's. there can be technical reasons to split deployments into different microservices but that's not the norm. what you describe is what happens when people get microservices wrong.in the end i like the viewpoint that microservices are a deployment pattern not so much an architecture pattern. usually you can draw a component diagram containing an orderservice and a deliveryservice etc. and without technical details execution environment protocols you couldn't tell if it's describing multiple microservices or multiple components in one service.;0
38079931;HackerNews;2023-10-31;no. a number of startups don't either. i hazard to say that even giants like tinder or uber likely can have a 30 min outage and lose some revenue and goodwill but not be hit by some exorbitant liabilities.also microservices add both resilience by running many copies and fragility many loosely coupled moving parts. which effect prevails depends on many factors.;0
38077876;HackerNews;2023-10-31;in the department i work there's a lot of microservices about 56 so 56 teams. but everything is quarkusspring java and nothing else.;0
38075700;HackerNews;2023-10-30;really doesn't make sense to me that people jump to microservices rather than creating module boundaries in their monolith.;-1
38076765;HackerNews;2023-10-30;ymmv but i think you can only do that if you have a monorepo with the shared library and all the microservices;0
38076540;HackerNews;2023-10-30;microservices are necessary and the best way to architect something new that is going to be used at scale. in my experience working with monolithic architecture with 20 teams at a large tech company i have found it takes multiple years to convert to microservices. rebuilding generally is possible in half as much and gives you the opportunity to hire good talent motivate existing employees and use the latest tech. thoughts?;1
38076411;HackerNews;2023-10-30;microservices don't cost as much if you deploy them everywhere so you get both vertical and horizontal scaling without lookup cost.of course then you need the same stack which allows multiple apps deployed everywhere.;1
38077939;HackerNews;2023-10-31;i look forward to 2030 when microservices are all the rage. anyone who avoids the temptation to tear down and rebuild their entire org as a monolith will be way ahead of the curve.;1
38074617;HackerNews;2023-10-30;microservices not being able to talk to each other the network basically never comes up.what you are saying is outright ridiculous.;-1
38072897;HackerNews;2023-10-30;can you point to a comment on hn saying microservices are never justified?;0
38073768;HackerNews;2023-10-30;open source projects rarely involve live services or providing saas. in those situations i think microservices are much more helpful;1
38071736;HackerNews;2023-10-30;microservices is a newer term than soa.;0
38070872;HackerNews;2023-10-30;if your company has a microservice architecture but doesn't have proper knowledge on how should they communicate how should they share code etc then it is the worst thing possible.;-1
hgs6zn9;Reddit;2021-10-15 22:31:59;i agree that most companies don't need microservices but that's because most companies are small. a large portion of developers on the other hand do because large companies hire a ton of people.;0
hgs5ewd;Reddit;2021-10-15 22:20:37;take a fortune 500 company. should every single service be in one big monolith? no. should every single rest call be in its own distinct containerwebservermicroservice? no. somewhere between these extremes is a good situation. honestly i think it comes down to the datastore. most services accessing a medium sized database should probably be colocated in the same semimonolith. but then why intermix administration data mininganalysis and primiary crudbusiness purpose calls?;0
hgrbb7o;Reddit;2021-10-15 18:52:06;currently in the middle of a multi year migration from monolith to microservices and everything everything about the microservices solution is better. slightly more complexity in terms of deployment but being able to upgrade dependencies in isolation is a huge win.;1
hgtgs4d;Reddit;2021-10-16 04:55:26;controversial opinion nearly every foray into microservices i've seen has been a disaster. i find developers hugely underestimate 1. the complexity of scaling many different services 2. the challenge of making many services reliable 3. the complexity of managing state across many services 4. the complexity of reliably deploying many services 5. the complexity of monitoring many services 6. the complexity of interservice communication 7. the complexity of atomicity across may services 8. the intricate and complicated ways in which a microservice architecture can fail 9. the complexity of managing security among many services 10. the complexity of debugging an application with many services 11. ...and so forth. here's a simple question to determine if an engineering department is ready for microservices can we reliably scale deploy monitor and manage a monolith? if the team can't manage a single service well it is utterly foolish to think managing many services is a good idea. i'm currently dealing with an unmitigated disaster of a codebase my company now owns via acquisition that codebase has a dozen or so microservices that don't scale with load aren't reliable make debugging a nightmare make nearly every deploy miserable fail all the time and so forth. that codebase is the product of developers taking these silly fads at face value instead of being skeptical and discerning. stop. mindlessly. making. microservices. pretty please.;-1
hgr0i35;Reddit;2021-10-15 17:38:35;i'd say it depends on the company. if it is a new project in a large company that will be hit a lot. id probably start by making microservices. but only the bare minimum. so an orders service but not internal orders and external order services. and in those i would try to silo the data into those internal and external ideas. i like doing this with packages myself. since you can see when someone adds a dependency on another package pretty easily java or node haven't worked in other frameworks however i think it is possible. i wrote a monolith that was essentially a couple loosely coupled internal microservices of different domains. worked quite well.;0
hgrra2i;Reddit;2021-10-15 20:41:00;i prefer monolithic design but when i see a system using python functions to send individual commands by opening ssh connections to another device's command line for each microservices sound like a huge improvement nevertheless.;1
hgt83g3;Reddit;2021-10-16 03:36:34;first it was monoliths are bad and everyone should use microservices. now it's the opposite lol. i say just do what makes sense for your application. monoliths has its place and microservices has its place.;0
hgu8ia5;Reddit;2021-10-16 10:27:05;i can't take the we have many developers so we need microservices nonsense anymore. your workflow is shit? you don't understand what modularity is? you think you have to enforce that through a grpc framework? maybe pick a different career.;-1
hgsw3yw;Reddit;2021-10-16 01:51:12;i swear to god people need to shut the fuck up about monoliths and microservices and just build their shit with some foresight. fuck off;-1
hgst8fc;Reddit;2021-10-16 01:27:12;i disagree with many commenters that microservices are mainly good for scale. i think robustness is a more valid reason to use microservices. i believe all programmers should know how to program in erlang just to learn the basics of good concurrency programming.;1
hgttjj3;Reddit;2021-10-16 07:06:56;the biggest annoyance regarding microservices is that everyone builds their own. with no controls over who is building what you end up with 20 getorder services all slightly different perpetuating the problem because a newcomer doesnt trust any of them.;-1
hgty4ad;Reddit;2021-10-16 08:02:39;i dont think microservice is superior to monolith. its a different approach to a problem. if the a project needs microservice approach it has to be done that way. problem is lot of startups going microservice for every project just because all big tech companies like uber netflix doing it. often they think oh it just 3 or 4 microservices that will communicate over a rest api. after 2 years of development they like 20 of microservices plus devops maintained by 3 developers. imo if you cant design a good monolith system you definitely can't design a good microservice system. modular monolith is a good option. it will allow to go microservice as needed. ps sorry for my english;0
hgxnmwh;Reddit;2021-10-17 04:01:26;microservices suck. they leave you with 47 different repos and it's an impossible amount of work to maintain them and fix bs tech debt. they sound good in principle because you can write your new thing in some other programming language and pile it on top of the jenga pile. but you better get a new job before the tower collapses and you're stuck maintaining the mess.;-1
hgrxkjc;Reddit;2021-10-15 21:24:42;if it's built modular enough you'll be able to microservice it later as needed. this. the reason microservices are a hit is because they force modularity and separation of concerns. generally i think that program should split out in phases that could eventually lead to microservices if the need arises 1. modularization code is separated into libraries with separate concerns. all shared concerns are thrown into a third shared library so neither library should depend on each other or one should be a clear dependent on the other. 1. semantic decoupling. basically the modules begin to have separate languages that are completely enclosed. this will require building new types and such. you may want to redundantly reimplement types and utility functions and have them share a single implementation from the third library. basically you should be able to describe the terms and semantics of each module independent of the others. the one exception when you have a module that is a explicit dependency on another module that exposes this dependency honestly and transparently ie the api of the dependent module is clearly just an extensionexplicit user of the other depended api and it doesn't make sense to describe it otherwise like a data layer that is clear about it talking to a database behind the scenes. 1. contract enforcement. libraries are further separated visibility is strongly limited and strong api contracts are done. this is mostly adding tests and documentation on that. at this point the technical debt should be managed. the issue comes when you want to scale move things around or rewrite modules into entirely different things. a solution is to move it outside. 1. stubout expose the library in a way that is separate of its implementation. change a doers into interfaces etc. 1. lamprey out. this isn't making the module into a dynamic library that's the easy step you could do above but it has little benefits in a tightly controlled environment as a server. it's making it a separate binary that talks through a rpc system. you'd still keep them as a single service the main binary would start the subbinary as part of startup. it would all look exactly the same from the outside it's still a monolith but a single containervm that now contains multiple processes instead of the one. 1. here you can do rewrites into other languages or shift things out. you get most of the flexibility of microservices from the point of view of a developer. you can also release binaries in separate cadences as separate packages that are then deployed together. 1. spinout separate service. this is where you actually get the scalability and support benefits. lets you scale different services at different rates and if you get a catastrophic disaster like running out of resources you can prioritize only the services needed to have a gracefully degraded experience and drop the others. very few would have a need for it. the key part that most people would be fine with is the lamprey. there's relatively few cases outside of faang that benefit of the full microservization of this. but 80 of the steps benefit almost everyone the modularization and clear contracts and even the next 10 gives almost all the advantages that people tout.;1
hgr6bzm;Reddit;2021-10-15 18:18:11;i think it's a balance. in one way i prefer a monolith. we have a few microservices and all they've done is slow down development from having to start 4 microservices locally pulling down the latest versions deploying 4 different applications keeping a test suite running that connects all 4... i haven't seen the benefits. i think to benefit from them you need to be in a larger team where you have individuals responsible for making ci and testing etc easier and more automated otherwise it just ends up being a huge time sap.;0
hgsdx3t;Reddit;2021-10-15 23:23:42;ive always been of the mind that microservice architectures are an expression of conways law. thats not a value judgement on microservices they arent good or bad they just are and they have trade offs.;0
hgr5tf3;Reddit;2021-10-15 18:14:39;microservices primarily allow developer scale in my experience you omitted word complexity. microservices scale process complexity upwards. the moment you opt to do them you fall for all network fallacies.;-1
hh3x2q6;Reddit;2021-10-18 15:55:41;how small of a team? microservices do a good job of formalizing service boundaries in code rather than having to go through that with each code review and making sure that the boundaries remain intact. a single repo and one hasty prreview can allow coupling and risk to creep back in. separate servicesrepos create implicit friction that make it harder to accidentally introduce those types of regressions.;1
hgt8l0i;Reddit;2021-10-16 03:40:55;large companies also buy many smaller ones in a sense collecting selfcontained services once they've matured and teams already silo'd off from the rest of the developers and thus predisposed to microservices by conway's law.;1
hgygp8w;Reddit;2021-10-17 08:48:36;i feel like the scale of monolith and micro service isn't great. to me it's too monolithic if deployment takes too long or if there's too many unrelated services in it. it's too much of a microservice when you start to have to call too many apis to accomplish something simple.;-1
hgv3l4j;Reddit;2021-10-16 16:30:17;that's what's happening where i work. new managers came in and declared we're going to use microservices. i'm powerless to stop them and for the reasons you mentioned we're going to be in a world of hurt soon.;-1
hgr5735;Reddit;2021-10-15 18:10:21;you say that but with lots of people adding things in different places and styles the project becomes difficult to reason about very quickly so microservices with clear boundaries mean smaller parts are easier to understand and replace if needed as a solo or small team none of that applies because it is easier to coordinate and the each dev knows a much larger portion of the codebase;1
hgt8bmu;Reddit;2021-10-16 03:38:32;i must emphasize that google does consider that your microservices are talking over rpc and not rest and i agree with them don't try to make rest apis if you're only getting called by an internal service of your team. and yet more and more people continue to build microservices talking with and or layering over rest. which becomes a large hassle really quickly.;-1
hgsuqg6;Reddit;2021-10-16 01:39:44;microservices don't really solve anything. the hard part of systems is the strong coupling and the constraints that accrue over time that make them harder and harder to comprehend and add to. the guy who came up with microservices was like how do we just pretend that never happens and everyone just started writing their own apps and stringing them together. that means you never have to care what everyone else is doing! they must have been comediens. the problem is all the coupling is still there. all the constraints are still there. it's just now been splattered all over the place in 300 different programs. now it is impossible to tell what is going on. anyay yeah i feel your pain.;-1
hgvq7df;Reddit;2021-10-16 19:20:22;microservices don't have to suck. but the approach many so called experts push especially concerning the database side is a recipe for pain unless you really know what you are doing and need that degree of separation. now if you are coming from completely separate data silos yeah that makes sense. but to plan for that is kind of ass backwards imo.;1
hgt1haf;Reddit;2021-10-16 02:37:19;they are a hit because they hide problems that monoliths would reveal all most instantly. so they seem good because its essentially a form of obfuscation. i mean you have to be clearer and more specific than that. i could switch it up. monoliths are a hit because they hide problems that microservices would reveal almost instantly. so they seem good because it's essentially a form of obfuscation. examples would data and services coupling shared functionality that isn't related wasteful inefficient pieces of code that are hidden over the huge resources other functionality requires but the inefficiency still costs you cpuhr. basically people seperated concerns so they didn't even have to care about. they created an abstraction where every problem was another teams problem. issue is every other team is thinking the same thing. clear responsibilities among teams is an important concern and management. and there should be work to find out orphans and manage them. monoliths don't fix these issues they can also hide it. you'd be surprised at how many times projects fail because of concerns on a piece of code everyone had forgotten because no one owned it. but because it all compiled nicely into the binary no one noticed. until its broken and someone else should. this is partially why people talk about blameless audits and postpostmortems. when people aren't scared about being blamed for something and understand they will be responsible for orphans and problems even if they weren't owners of the core cause means this has a lower chance of happening. people are more eager to take ownership. you are right though this is a big problem on software. microservices doesn't make it better or worse. what microservices offer is a blameless pile of spaghetti where everyone can pretend it's not their problem. it's literally perfect for modern software development. this is an issue. microservices is many times used as an excuse for cowboy programming. adding a new service no matter the size should not be trivial and have a solid justification. but i've seem as much spaghetti with everyone blaming others. in monoliths it can be even worse because it's easy to no have contracts. it's easy to go in fix someone else's code and then break half the uses because you switched the semantics to what made sense for you but wasn't the original intent. microbenchmarks force you to set this rpcqueue border that makes it clear you should work with the way anything on the other side works. it doesn't matter if you have a monolith your code should be heavily modularized you should avoid changing functionality of other modules and instead work around it and if it's an issue later fix it as a separate thing and clear ownership should exist. here this is one of those areas were microservices work. not because they magically fix it but because they make the painful decisions obvious and upfront. instead of something you realize when you are reading a 10 wtfs piece of code at 3am trying to understand how an outage corrupted data in order to undo it of course there should be a backup but in places with these issues sometimes backups are not done often enough.;-1
hgsyvn4;Reddit;2021-10-16 02:14:57;exactly what i thought about microservices concept i mean sure it is easy to scale but mostly this is concept for rapid development where poor code optimalization isn't an issue. proper microservices can work fine but now this concept is used on every project without thinking if it is needed.;-1
hgs4vll;Reddit;2021-10-15 22:16:46;this is the way i've seen microservices done best even at smaller companies although still large enough to have multiple teams. each team can broadly structure their system as they like and release as they like as long as they don't break an api promise to another team and the teams interact via explicitly describes web interfaces. even within a single team splitting things like frontend and backend can be helpful if you've got different release schedules or processes. it makes crosscutting work more complicated because you end up negotiating across different teams and services but that can also be a question of business organisation rather than technical organisation.;1
hgsvutt;Reddit;2021-10-16 01:49:04;microservices don't really solve anything. that feels like swinging too far in the other direction. i've definitely seen instances where splitting something off into it's own corner drastically improved things. for example my last job has its own bespoke auth tokening service why i don't know but it was there whether or not this was wise is different conversation so we were able to stuff a little thing between it and everyone else they allowed us to generate fake auth tokens for testing got a story that says only people in the customer servicing group can do x just generate a fake token for cs and a fake token for other groups rather than asking for new ad accounts it had to create and teardown and w engineering had to jump through hoops to deny access in production. the woman that made that was qa's favorite developer because she saved them literally hours upon hours of work interacting with it to get test accounts. so there's definitely a benefit i just really question the just always do microservices lol approach.;-1
hgz1yki;Reddit;2021-10-17 13:32:53;ah yes.. microservices solving dependencies... by splitting everything into 50 deployments so you can just update the dependencies on the one thing you care about this week and 4050 of the things just code rot.;1
hguv6u0;Reddit;2021-10-16 15:16:35;that was my point. too many microservice advocates think their architecture prevents intermixing of concerns.;-1
hh62ly0;Reddit;2021-10-19 01:17:31;true but by using microservices and containerizing them you can scale more efficiently. there are a lot of benefits to microservices.;1
hgstq2o;Reddit;2021-10-16 01:31:18;microservices are essentially impossible to reason about by design. it is seperation of concerns taken to the extreme. you aren't supposed to be able to reason about other services because that means you havent seperated concerns enough.;1
hgtq3jm;Reddit;2021-10-16 06:28:42;i think all buzzwords are equally idiotic and that it is unfortunate that they have been tainted by bad applications and incorrect reasoning because there can be some good general architecture ideas hiding under layers of crap. the enterprise i know that added microservices to their new project did so for illdefined reasons with overzealous implementors and it seems to be going very poorly. however a lot of the ideas in microservices can be used in legitimate architectures to decrease burden. function as a service is still just madness without a use case and excessive cost though. another commenter was right in that it's still going to be a spaghetti mess of crap because if your architecture and designers are crap it's going to be crap regardless.;-1
hgsw2ch;Reddit;2021-10-16 01:50:49;no one intended it to be that. that's just what they turn out to be because no one is self critical enough to realise that microservices don't solve anything.;-1
kccjok7;Reddit;2023-12-07 11:02:18;as someone who has worked on both giant monolith and complex microservice structure i can confidently say both suck! in my case the monolith was much worse though. it needed 60 minutes to compile some bugs took days to find. 100 devs working on a single repo constantly caused problems. we eventually fixed it by separating it into a smaller monolith and 10 reasonably sized still large services. working on those services was much better and the monolith only took 40 minutes to compile. i'm not sure if that is a valid architecture. but i personally liked the projects with medium sized services the most. like big repos with severel hundred files that take resposibilty for one logic part of business but also have internal processes and all. not too big to handle but not so small that they constantly need to communicate with 20 others services.;-1
kcckrre;Reddit;2023-12-07 11:17:52;an answer that works is depends on the usecase. our company used to have multiple microservices bundled together for a release. idk why. this meant a bug in another team's code blocked us from high urgency fixes. moving to an actual microservices arch helped speed up releases by a looot. months became days for releases.;0
kcctth1;Reddit;2023-12-07 13:10:03;i'm currently in a system that uses microservices for modern solutions while still maintaining a legacy monolith until we have time to break it out completely. i like developing in our microservices and despise developing in the monolith. we use a fork of netflix's eureka service discovery tool to hook all our microservices together and it's pretty nice.;1
kchnv0u;Reddit;2023-12-08 12:57:48;guys what if all functions had network latencies? guy about to invent microservices;-1
kccnrx1;Reddit;2023-12-07 11:58:46;microservices suck but nothing will sell me on a giant monolith. giant monoliths are a whole level of suck to whatever you will deal in microservices;-1
kcdhzlu;Reddit;2023-12-07 16:26:26;microservices are a valid architecture choice when used correctly. too many will make things as microservices that should remain as monoliths because either the utilization is too low the rate of change is too low or the solutionecosystem has a sunset date for replacement. microservices are more chatty by nature and considerations should be made with network engineering database engineering observability tooling teams such as sres and others to ensure their part of the design will hold up to the increased requirements. while microservices are a popular design pattern theyre not the only modern or performant one. i would discourage implementing microservices in cultures which do not adequately practice agile delivery principles product and platform model team structures and prioritize technical debt repayment with a high degree of maturity. everything dies on the vine if any of those elements is insufficiently present and matured. for a microservices architecture to work properly a core collection of guiding principles separation of responsibilities and clearly defined communication contracts between both the services and the product teams who ownmaintain them.;1
kcfb5t4;Reddit;2023-12-07 23:44:08;microservices are great. problem is between the keyboard and chair. like the bit about not knowing how to do integration tests setup a company wide staging environment otherwise duplicating production except for running integration tests... what was that nearly impossible? lol. oh and btw that solution is something that should be done with monoliths too so it's not something extra for microservices. what about just services? they are just services. micro refers to breaking it down into decoupled modules instead of one massive monolith. that's it it's not restricting the underlying size of the code base. it's based upon scope you make clean breaks as necessary. people don't understand the things they're complaining about anymore. just superficial bs takes. mostly when people complain about microservices it's just complaining about the bad code they have to work with. then they daydream that monoliths would somehow fix it... but reality is that bad code in a monolith would be worse. half the problems in the article are things microservices actually solve and the author just makes up mental map of the entire system? no other microservices are black boxes. however in a monolith you need a mental map! just another article pretending to be smarter than best practices. quality is exactly as expected.;1
kccl2k3;Reddit;2023-12-07 11:22:00;depends on the implementation. i like the idea of trees with small branches as in think of complex services like an os. have a kernel like thing to it have controller services and small branches for unique stuff that can be properly segmented and recover independently. if you are making 15 services and doing it just because microservice you are as bad as monolith people. i usually don't have a branch that is 3 services deep intentionally like if i can't explain it as a manager and architect in 10 seconds without a diagram how will a 10 euro an hour support guy use it.;0
kce6d4s;Reddit;2023-12-07 19:05:48;as an honest counterpoint i like working with microservices because the interface is clear and noone can screw around with it once it's established. it also has testability built in. other aspects do suck for sure and some people go way too micro with their microservices but breaking down a large problem into digestible blocks with clear interfaces has helped me personally deal with larger problems as well as delegate work. not saying that you can't do that with monolithic systems just that the incentives for developers push them in different directions.;1
kcd2xqe;Reddit;2023-12-07 14:35:10;there's only the bullet lodged in your skull after choosing microservices.;-1
kchyx9u;Reddit;2023-12-08 14:40:30;is the bot using microservices?;0
kcjzf86;Reddit;2023-12-08 22:41:30;any synchronous communication between microservices is a recipe for disaster including datastore calls. sorry are you saying that loading data from database should be done in an async manner? genuinely curious about this it's the first time i hear about it.;-1
kcf3mtb;Reddit;2023-12-07 22:56:17;the pendulum just swung back. people started to realize that maybe using microservices and kubernetes for their pizza delivery app that 200 people use was not the best use of their time and energy. but the same thing happens with everything. some faang company does x and it works and everyone just assumes it's the best because it worked for their company. the moment you become a fan of a single tool you are doomed to fail. what you need to know is which tool fits best for each task and just do that. to be successful in software engineering you need a toolbox not a box full of hammers. unless the only thing your company does is hammer nails;-1
kcd6z1x;Reddit;2023-12-07 15:07:35;we still do. this is not a picture of a microservice architecture.;0
kcdm32v;Reddit;2023-12-07 16:53:23;you need good logging practices and distributed tracing to make large microservice deployments work if you dont have those things debugging is a nightmare;-1
kccmrpg;Reddit;2023-12-07 11:45:21;badly designed monoliths are bad. badly designed microservice architectures are worse. the problem is that it's easier to fuck up with microservices and it's way harder to unfuck. microservices have their place. but they're far from silver bullets.;-1
